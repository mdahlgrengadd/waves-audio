(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.wavesAudio = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var AudioContext = window.AudioContext || window.webkitAudioContext;

/**
 * Expose a unique audio context singleton as the default audio
 * context used by the components of the Waves Audio library and
 * applications using the library.
 *
 * @type AudioContext
 * @name audioContext
 * @constant
 * @global
 * @instance
 *
 * @example
 * import * as audio from 'waves-audio';
 * const audioContext = audio.audioContext;
 */
var audioContext = null;

if (AudioContext) {
  audioContext = new AudioContext();

  if (/(iPhone|iPad)/i.test(navigator.userAgent) && audioContext.sampleRate < 44100) {
    var buffer = audioContext.createBuffer(1, 1, 44100);
    var dummy = audioContext.createBufferSource();
    dummy.buffer = buffer;
    dummy.connect(audioContext.destination);
    dummy.start(0);
    dummy.disconnect();
  }
}

exports.default = audioContext;

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _timeEngine = require('./time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _audioContext = require('./audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This is the base class for all audio related time engine components. It is
 * used to handle audio related events such as the playback of a media stream.
 * It extends the TimeEngine class by the standard web audio node methods
 * connect and disconnect.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/audio-time-engine.html}
 *
 * @extends TimeEngine
 * @example
 * import audio from 'waves-audio';
 *
 * class MyEngine extends audio.AudioTimeEngine {
 *   constructor() {
 *     super();
 *     // ...
 *   }
 * }
 */
var AudioTimeEngine = function (_TimeEngine) {
  (0, _inherits3.default)(AudioTimeEngine, _TimeEngine);

  function AudioTimeEngine() {
    var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;
    (0, _classCallCheck3.default)(this, AudioTimeEngine);

    /**
     * Audio context used by the TimeEngine, default to the global audioContext
     *
     * @name audioContext
     * @type AudioContext
     * @memberof AudioTimeEngine
     * @see audioContext
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (AudioTimeEngine.__proto__ || (0, _getPrototypeOf2.default)(AudioTimeEngine)).call(this));

    _this.audioContext = audioContext;

    /**
     * Output audio node. By default the connect method connects a given node
     * to this output node.
     *
     * @name outputNode
     * @type AudioNode
     * @memberof AudioTimeEngine
     * @default null
     */
    _this.outputNode = null;
    return _this;
  }

  /**
   * Connect to an audio node (e.g. audioContext.destination)
   *
   * @param {AudioNode} target - Target audio node
   */


  (0, _createClass3.default)(AudioTimeEngine, [{
    key: 'connect',
    value: function connect(target) {
      this.outputNode.connect(target);
      return this;
    }

    /**
     * Disconnect from an audio node (e.g. audioContext.destination). If undefined
     * disconnect from all target nodes.
     *
     * @param {AudioNode} target - Target audio node.
     */

  }, {
    key: 'disconnect',
    value: function disconnect(connection) {
      this.outputNode.disconnect(connection);
      return this;
    }
  }]);
  return AudioTimeEngine;
}(_timeEngine2.default);

exports.default = AudioTimeEngine;

},{"./audio-context":1,"./time-engine":5,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// works by reference
function swap(arr, i1, i2) {
  var tmp = arr[i1];
  arr[i1] = arr[i2];
  arr[i2] = tmp;
}

// https://jsperf.com/js-for-loop-vs-array-indexof/346
function indexOf(arr, el) {
  var l = arr.length;
  // ignore first element as it can't be a entry
  for (var i = 1; i < l; i++) {
    if (arr[i] === el) {
      return i;
    }
  }

  return -1;
}

/**
 * Define if `time1` should be lower in the topography than `time2`.
 * Is dynamically affected to the priority queue according to handle `min` and `max` heap.
 *
 * @private
 * @param {Number} time1
 * @param {Number} time2
 * @return {Boolean}
 */
var _isLowerMaxHeap = function _isLowerMaxHeap(time1, time2) {
  return time1 < time2;
};

var _isLowerMinHeap = function _isLowerMinHeap(time1, time2) {
  return time1 > time2;
};

/**
 * Define if `time1` should be higher in the topography than `time2`.
 * Is dynamically affected to the priority queue according to handle `min` and `max` heap.
 *
 * @private
 * @param {Number} time1
 * @param {Number} time2
 * @return {Boolean}
 */
var _isHigherMaxHeap = function _isHigherMaxHeap(time1, time2) {
  return time1 > time2;
};

var _isHigherMinHeap = function _isHigherMinHeap(time1, time2) {
  return time1 < time2;
};

var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

/**
 * Priority queue implementing a binary heap.
 * Acts as a min heap by default, can be dynamically changed to a max heap
 * by setting `reverse` to true.
 *
 * _note_: the queue creates and maintains a new property (i.e. `queueTime`)
 * to each object added.
 *
 * @param {Number} [heapLength=100] - Default size of the array used to create the heap.
 */

var PriorityQueue = function () {
  function PriorityQueue() {
    var heapLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
    (0, _classCallCheck3.default)(this, PriorityQueue);

    /**
     * Pointer to the first empty index of the heap.
     * @type {Number}
     * @memberof PriorityQueue
     * @name _currentLength
     * @private
     */
    this._currentLength = 1;

    /**
     * Array of the sorted indexes of the entries, the actual heap. Ignore the index 0.
     * @type {Array}
     * @memberof PriorityQueue
     * @name _heap
     * @private
     */
    this._heap = new Array(heapLength + 1);

    /**
     * Type of the queue: `min` heap if `false`, `max` heap if `true`
     * @type {Boolean}
     * @memberof PriorityQueue
     * @name _reverse
     * @private
     */
    this._reverse = null;

    // initialize compare functions
    this.reverse = false;
  }

  /**
   * Time of the first element in the binary heap.
   * @returns {Number}
   */


  (0, _createClass3.default)(PriorityQueue, [{
    key: "_bubbleUp",


    /**
     * Fix the heap by moving an entry to a new upper position.
     *
     * @private
     * @param {Number} startIndex - The index of the entry to move.
     */
    value: function _bubbleUp(startIndex) {
      var entry = this._heap[startIndex];

      var index = startIndex;
      var parentIndex = Math.floor(index / 2);
      var parent = this._heap[parentIndex];

      while (parent && this._isHigher(entry.queueTime, parent.queueTime)) {
        swap(this._heap, index, parentIndex);

        index = parentIndex;
        parentIndex = Math.floor(index / 2);
        parent = this._heap[parentIndex];
      }
    }

    /**
     * Fix the heap by moving an entry to a new lower position.
     *
     * @private
     * @param {Number} startIndex - The index of the entry to move.
     */

  }, {
    key: "_bubbleDown",
    value: function _bubbleDown(startIndex) {
      var entry = this._heap[startIndex];

      var index = startIndex;
      var c1index = index * 2;
      var c2index = c1index + 1;
      var child1 = this._heap[c1index];
      var child2 = this._heap[c2index];

      while (child1 && this._isLower(entry.queueTime, child1.queueTime) || child2 && this._isLower(entry.queueTime, child2.queueTime)) {
        // swap with the minimum child
        var targetIndex = void 0;

        if (child2) targetIndex = this._isHigher(child1.queueTime, child2.queueTime) ? c1index : c2index;else targetIndex = c1index;

        swap(this._heap, index, targetIndex);

        // update to find next children
        index = targetIndex;
        c1index = index * 2;
        c2index = c1index + 1;
        child1 = this._heap[c1index];
        child2 = this._heap[c2index];
      }
    }

    /**
     * Build the heap (from bottom up).
     */

  }, {
    key: "buildHeap",
    value: function buildHeap() {
      // find the index of the last internal node
      // @todo - make sure that's the right way to do.
      var maxIndex = Math.floor((this._currentLength - 1) / 2);

      for (var i = maxIndex; i > 0; i--) {
        this._bubbleDown(i);
      }
    }

    /**
     * Insert a new object in the binary heap and sort it.
     *
     * @param {Object} entry - Entry to insert.
     * @param {Number} time - Time at which the entry should be orderer.
     * @returns {Number} - Time of the first entry in the heap.
     */

  }, {
    key: "insert",
    value: function insert(entry, time) {
      if (Math.abs(time) !== POSITIVE_INFINITY) {
        entry.queueTime = time;
        // add the new entry at the end of the heap
        this._heap[this._currentLength] = entry;
        // bubble it up
        this._bubbleUp(this._currentLength);
        this._currentLength += 1;

        return this.time;
      }

      entry.queueTime = undefined;
      return this.remove(entry);
    }

    /**
     * Move a given entry to a new position.
     *
     * @param {Object} entry - Entry to move.
     * @param {Number} time - Time at which the entry should be orderer.
     * @return {Number} - Time of first entry in the heap.
     */

  }, {
    key: "move",
    value: function move(entry, time) {
      if (Math.abs(time) !== POSITIVE_INFINITY) {
        var index = indexOf(this._heap, entry);

        if (index !== -1) {
          entry.queueTime = time;
          // define if the entry should be bubbled up or down
          var parent = this._heap[Math.floor(index / 2)];

          if (parent && this._isHigher(time, parent.queueTime)) this._bubbleUp(index);else this._bubbleDown(index);
        }

        return this.time;
      }

      entry.queueTime = undefined;
      return this.remove(entry);
    }

    /**
     * Remove an entry from the heap and fix the heap.
     *
     * @param {Object} entry - Entry to remove.
     * @return {Number} - Time of first entry in the heap.
     */

  }, {
    key: "remove",
    value: function remove(entry) {
      // find the index of the entry
      var index = indexOf(this._heap, entry);

      if (index !== -1) {
        var lastIndex = this._currentLength - 1;

        // if the entry is the last one
        if (index === lastIndex) {
          // remove the element from heap
          this._heap[lastIndex] = undefined;
          // update current length
          this._currentLength = lastIndex;

          return this.time;
        } else {
          // swap with the last element of the heap
          swap(this._heap, index, lastIndex);
          // remove the element from heap
          this._heap[lastIndex] = undefined;

          if (index === 1) {
            this._bubbleDown(1);
          } else {
            // bubble the (ex last) element up or down according to its new context
            var _entry = this._heap[index];
            var parent = this._heap[Math.floor(index / 2)];

            if (parent && this._isHigher(_entry.queueTime, parent.queueTime)) this._bubbleUp(index);else this._bubbleDown(index);
          }
        }

        // update current length
        this._currentLength = lastIndex;
      }

      return this.time;
    }

    /**
     * Clear the queue.
     */

  }, {
    key: "clear",
    value: function clear() {
      this._currentLength = 1;
      this._heap = new Array(this._heap.length);
    }

    /**
     * Defines if the queue contains the given `entry`.
     *
     * @param {Object} entry - Entry to be checked
     * @return {Boolean}
     */

  }, {
    key: "has",
    value: function has(entry) {
      return this._heap.indexOf(entry) !== -1;
    }
  }, {
    key: "time",
    get: function get() {
      if (this._currentLength > 1) return this._heap[1].queueTime;

      return Infinity;
    }

    /**
     * First element in the binary heap.
     * @returns {Number}
     * @readonly
     */

  }, {
    key: "head",
    get: function get() {
      return this._heap[1];
    }

    /**
     * Change the order of the queue (max heap if true, min heap if false),
     * rebuild the heap with the existing entries.
     *
     * @type {Boolean}
     */

  }, {
    key: "reverse",
    set: function set(value) {
      if (value !== this._reverse) {
        this._reverse = value;

        if (this._reverse === true) {
          this._isLower = _isLowerMaxHeap;
          this._isHigher = _isHigherMaxHeap;
        } else {
          this._isLower = _isLowerMinHeap;
          this._isHigher = _isHigherMinHeap;
        }

        this.buildHeap();
      }
    },
    get: function get() {
      return this._reverse;
    }
  }]);
  return PriorityQueue;
}();

exports.default = PriorityQueue;

},{"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _priorityQueue = require('./priority-queue');

var _priorityQueue2 = _interopRequireDefault(_priorityQueue);

var _timeEngine = require('./time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class SchedulingQueue
 * @extends TimeEngine
 */
/**
 * SchedulingQueue base class
 * http://wavesjs.github.io/audio/#audio-scheduling-queue
 *
 * Norbert.Schnell@ircam.fr
 * Copyright 2014, 2015 IRCAM – Centre Pompidou
 */

var SchedulingQueue = function (_TimeEngine) {
  (0, _inherits3.default)(SchedulingQueue, _TimeEngine);

  function SchedulingQueue() {
    (0, _classCallCheck3.default)(this, SchedulingQueue);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(SchedulingQueue)).call(this));

    _this.__queue = new _priorityQueue2.default();
    _this.__engines = new _set2.default();
    return _this;
  }

  // TimeEngine 'scheduled' interface


  (0, _createClass3.default)(SchedulingQueue, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var engine = this.__queue.head;
      var nextEngineTime = engine.advanceTime(time);

      if (!nextEngineTime) {
        engine.master = null;
        this.__engines.delete(engine);
        this.__queue.remove(engine);
      } else {
        this.__queue.move(engine, nextEngineTime);
      }

      return this.__queue.time;
    }

    // TimeEngine master method to be implemented by derived class

  }, {
    key: 'defer',


    // call a function at a given time
    value: function defer(fun) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!(fun instanceof Function)) throw new Error("object cannot be defered by scheduler");

      this.add({
        advanceTime: function advanceTime(time) {
          fun(time);
        } // make sur that the advanceTime method does not returm anything
      }, time);
    }

    // add a time engine to the scheduler

  }, {
    key: 'add',
    value: function add(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!_timeEngine2.default.implementsScheduled(engine)) throw new Error("object cannot be added to scheduler");

      if (engine.master) throw new Error("object has already been added to a master");

      engine.master = this;

      // add to engines and queue
      this.__engines.add(engine);
      var nextTime = this.__queue.insert(engine, time);

      // reschedule queue
      this.resetTime(nextTime);
    }

    // remove a time engine from the queue

  }, {
    key: 'remove',
    value: function remove(engine) {
      if (engine.master !== this) throw new Error("object has not been added to this scheduler");

      engine.master = null;

      // remove from array and queue
      this.__engines.delete(engine);
      var nextTime = this.__queue.remove(engine);

      // reschedule queue
      this.resetTime(nextTime);
    }

    // reset next engine time

  }, {
    key: 'resetEngineTime',
    value: function resetEngineTime(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (engine.master !== this) throw new Error("object has not been added to this scheduler");

      var nextTime = void 0;

      if (this.__queue.has(engine)) nextTime = this.__queue.move(engine, time);else nextTime = this.__queue.insert(engine, time);

      this.resetTime(nextTime);
    }

    // check whether a given engine is scheduled

  }, {
    key: 'has',
    value: function has(engine) {
      return this.__engines.has(engine);
    }

    // clear queue

  }, {
    key: 'clear',
    value: function clear() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.__engines), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var engine = _step.value;

          engine.master = null;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.__queue.clear();
      this.__engines.clear();
      this.resetTime(Infinity);
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return 0;
    }
  }]);
  return SchedulingQueue;
}(_timeEngine2.default);

exports.default = SchedulingQueue;

},{"./priority-queue":3,"./time-engine":5,"babel-runtime/core-js/get-iterator":22,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/core-js/set":29,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Base class for time engines
 *
 * A time engine generates more or less regular events and/or plays back a
 * media stream. It implements one or multiple interfaces to be driven by a
 * master (i.e. a Scheduler, a Transport or a PlayControl) in synchronization
 * with other engines. The provided interfaces are scheduled, transported,
 * and play-controlled.
 *
 *
 * #### The `scheduled` interface
 *
 * The scheduled interface allows for synchronizing an engine to a monotonous time
 * as it is provided by the Scheduler master.
 *
 * ###### `advanceTime(time :Number) -> {Number}`
 *
 * The `advanceTime` method has to be implemented by an `TimeEngine` as part of the
 * scheduled interface. The method is called by the master (e.g. the scheduler).
 * It generates an event and to returns the time of the next event (i.e. the next
 * call of advanceTime). The returned time has to be greater than the time
 * received as argument of the method. In case that a TimeEngine has to generate
 * multiple events at the same time, the engine has to implement its own loop
 * while(event.time <= time) and return the time of the next event (if any).
 *
 * ###### `resetTime(time=undefined :Number)`
 *
 * The `resetTime` method is provided by the `TimeEngine` base class. An engine may
 * call this method to reset its next event time (e.g. when a parameter is
 * changed that influences the engine's temporal behavior). When no argument
 * is given, the time is reset to the current master time. When calling the
 * method with Infinity the engine is suspended without being removed from the
 * master.
 *
 *
 * #### The `transported` interface
 *
 * The transported interface allows for synchronizing an engine to a position
 * (i.e. media playback time) that can run forward and backward and jump as it
 * is provided by the Transport master.
 *
 * ###### `syncPosition(time :Number, position :Number, speed :Number) -> {Number}`
 *
 * The `syncPositon` method has to be implemented by a `TimeEngine` as part of the
 * transported interface. The method syncPositon is called whenever the master
 * of a transported engine has to (re-)synchronize the engine's position. This
 * is for example required when the master (re-)starts playback, jumps to an
 * arbitrary position, and when reversing playback direction. The method returns
 * the next position of the engine in the given playback direction
 * (i.e. `speed < 0` or `speed > 0`).
 *
 * ###### `advancePosition(time :Number, position :Number, speed :Number) -> {Number}`
 *
 * The `advancePosition` method has to be implemented by a `TimeEngine` as part
 * of the transported interface. The master calls the advancePositon method when
 * the engine's event position is reached. The method generates an event and
 * returns the next position in the given playback direction (i.e. speed < 0 or
 * speed > 0). The returned position has to be greater (i.e. when speed > 0)
 * or less (i.e. when speed < 0) than the position received as argument of the
 * method.
 *
 * ###### `resetPosition(position=undefined :Number)`
 *
 * The resetPosition method is provided by the TimeEngine base class. An engine
 * may call this method to reset its next event position. When no argument
 * is given, the time is reset to the current master time. When calling the
 * method with Infinity the engine is suspended without being removed from
 * the master.
 *
 *
 * #### The speed-controlled interface
 *
 * The "speed-controlled" interface allows for syncronizing an engine that is
 * neither driven through the scheduled nor the transported interface. The
 * interface allows in particular to synchronize engines that assure their own
 * scheduling (i.e. audio player or an oscillator) to the event-based scheduled
 * and transported engines.
 *
 * ###### `syncSpeed(time :Number, position :Number, speed :Number, seek=false :Boolean)`
 *
 * The syncSpeed method has to be implemented by a TimeEngine as part of the
 * speed-controlled interface. The method is called by the master whenever the
 * playback speed changes or the position jumps arbitarily (i.e. on a seek).
 *
 *
 * <hr />
 *
 * Example that shows a `TimeEngine` running in a `Scheduler` that counts up
 * at a given frequency:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/time-engine.html}
 *
 * @example
 * import * as audio from 'waves-audio';
 *
 * class MyEngine extends audio.TimeEngine {
 *   constructor() {
 *     super();
 *     // ...
 *   }
 * }
 *
 */
var TimeEngine = function () {
  function TimeEngine() {
    (0, _classCallCheck3.default)(this, TimeEngine);

    /**
     * The engine's master.
     *
     * @type {Mixed}
     * @name master
     * @memberof TimeEngine
     */
    this.master = null;
  }

  /**
   * The time engine's current (master) time.
   *
   * @type {Number}
   * @memberof TimeEngine
   * @readonly
   */


  (0, _createClass3.default)(TimeEngine, [{
    key: "resetTime",
    value: function resetTime() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      if (this.master) this.master.resetEngineTime(this, time);
    }

    /**
     * Transported interface
     *   - syncPosition(time, position, speed), called to reposition TimeEngine, returns next position
     *   - advancePosition(time, position, speed), called to generate next event at given time and position, returns next position
     *
     * @static
     * @memberof TimeEngine
     */

  }, {
    key: "resetPosition",
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      if (this.master) this.master.resetEnginePosition(this, position);
    }

    /**
     * Speed-controlled interface
     *   - syncSpeed(time, position, speed, ), called to
     *
     * @static
     * @memberof TimeEngine
     */

  }, {
    key: "currentTime",
    get: function get() {
      if (this.master) return this.master.currentTime;

      return undefined;
    }

    /**
     * The time engine's current (master) position.
     *
     * @type {Number}
     * @memberof TimeEngine
     * @readonly
     */

  }, {
    key: "currentPosition",
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return undefined;
    }

    /**
     * Scheduled interface
     *   - advanceTime(time), called to generate next event at given time, returns next time
     *
     * @static
     * @memberof TimeEngine
     */

  }], [{
    key: "implementsScheduled",
    value: function implementsScheduled(engine) {
      return engine.advanceTime && engine.advanceTime instanceof Function;
    }
  }, {
    key: "implementsTransported",
    value: function implementsTransported(engine) {
      return engine.syncPosition && engine.syncPosition instanceof Function && engine.advancePosition && engine.advancePosition instanceof Function;
    }
  }, {
    key: "implementsSpeedControlled",
    value: function implementsSpeedControlled(engine) {
      return engine.syncSpeed && engine.syncSpeed instanceof Function;
    }
  }]);
  return TimeEngine;
}();

exports.default = TimeEngine;

},{"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Granular synthesis TimeEngine implementing the scheduled interface.
 * The grain position (grain onset or center time in the audio buffer) is
 * optionally determined by the engine's currentPosition attribute.
 *
 * Example that shows a `GranularEngine` (with a few parameter controls) driven
 * by a `Scheduler` and a `PlayControl`:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/granular-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const granularEngine = new audio.GranularEngine();
 *
 * scheduler.add(granularEngine);
 *
 *
 * @param {Object} options={} - Parameters
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0.01] - Absolute grain period in sec
 * @param {Number} [options.periodRel=0] - Grain period relative to absolute
 *  duration
 * @param {Number} [options.periodVar=0] - Amout of random grain period
 *  variation relative to grain period
 * @param {Number} [options.periodMin=0.001] - Minimum grain period
 * @param {Number} [options.position=0] - Grain position (onset time in audio
 *  buffer) in sec
 * @param {Number} [options.positionVar=0.003] - Amout of random grain position
 *  variation in sec
 * @param {Number} [options.durationAbs=0.1] - Absolute grain duration in sec
 * @param {Number} [options.durationRel=0] - Grain duration relative to grain
 * @param {Number} [options.durationVar=0] - Amout of random grain duration
 *  period (overlap)
 * @param {Number} [options.attackAbs=0] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0.5] - Attack time relative to grain duration
 * @param {String} [options.attackShape='lin'] - Shape of attack
 * @param {Number} [options.releaseAbs=0] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0.5] - Release time relative to grain duration
 * @param {Number} [options.releaseShape='lin'] - Shape of release
 * @param {String} [options.expRampOffset=0.0001] - Offset (start/end value)
 *  for exponential attack/release
 * @param {Number} [options.resampling=0] - Grain resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Boolean} [options.centered=true] - Whether the grain position refers
 *  to the center of the grain (or the beginning)
 * @param {Boolean} [options.cyclic=false] - Whether the audio buffer and grain
 *  position are considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the
 *  audio buffer that has been copied from the beginning to assure cyclic behavior
 */

var GranularEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(GranularEngine, _AudioTimeEngine);

  function GranularEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, GranularEngine);

    /**
     * Audio buffer
     *
     * @type {AudioBuffer}
     * @name buffer
     * @default null
     * @memberof GranularEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (GranularEngine.__proto__ || (0, _getPrototypeOf2.default)(GranularEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute grain period in sec
     *
     * @type {Number}
     * @name periodAbs
     * @default 0.01
     * @memberof GranularEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0.01);

    /**
     * Grain period relative to absolute duration
     *
     * @type {Number}
     * @name periodRel
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 0);

    /**
     * Amout of random grain period variation relative to grain period
     *
     * @type {Number}
     * @name periodVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum grain period
     *
     * @type {Number}
     * @name periodMin
     * @default 0.001
     * @memberof GranularEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Grain position (onset time in audio buffer) in sec
     *
     * @type {Number}
     * @name position
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.position = optOrDef(options.position, 0);

    /**
     * Amout of random grain position variation in sec
     *
     * @type {Number}
     * @name positionVar
     * @default 0.003
     * @memberof GranularEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0.003);

    /**
     * Absolute grain duration in sec
     *
     * @type {Number}
     * @name durationAbs
     * @default 0.1
     * @memberof GranularEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0.1); // absolute grain duration

    /**
     * Grain duration relative to grain period (overlap)
     *
     * @type {Number}
     * @name durationRel
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 0);

    /**
     * Amout of random grain duration variation in sec
     *
     * @type {Number}
     * @name durationVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.durationVar = optOrDef(options.durationVar, 0);

    /**
     * Absolute attack time in sec
     *
     * @type {Number}
     * @name attackAbs
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0);

    /**
     * Attack time relative to grain duration
     *
     * @type {Number}
     * @name attackRel
     * @default 0.5
     * @memberof GranularEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0.5);

    /**
     * Shape of attack ('lin' for linear ramp, 'exp' for exponential ramp)
     *
     * @type {String}
     * @name attackShape
     * @default 'lin'
     * @memberof GranularEngine
     * @instance
     */
    _this.attackShape = optOrDef(options.attackShape, 'lin');

    /**
     * Absolute release time in sec
     *
     * @type {Number}
     * @name releaseAbs
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0);

    /**
     * Release time relative to grain duration
     *
     * @type {Number}
     * @name releaseRel
     * @default 0.5
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0.5);

    /**
     * Shape of release ('lin' for linear ramp, 'exp' for exponential ramp)
     *
     * @type {String}
     * @name releaseShape
     * @default 'lin'
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseShape = optOrDef(options.releaseShape, 'lin');

    /**
     * Offset (start/end value) for exponential attack/release
     *
     * @type {Number}
     * @name expRampOffset
     * @default 0.0001
     * @memberof GranularEngine
     * @instance
     */
    _this.expRampOffset = optOrDef(options.expRampOffset, 0.0001);

    /**
     * Grain resampling in cent
     *
     * @type {Number}
     * @name resampling
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     *
     * @type {Number}
     * @name resamplingVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     *
     * @type {Number}
     * @name gain
     * @default 1
     * @memberof GranularEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Whether the grain position refers to the center of the grain (or the beginning)
     *
     * @type {Boolean}
     * @name centered
     * @default true
     * @memberof GranularEngine
     * @instance
     */
    _this.centered = optOrDef(options.centered, true);

    /**
     * Whether the audio buffer and grain position are considered as cyclic
     *
     * @type {Boolean}
     * @name cyclic
     * @default false
     * @memberof GranularEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);

    /**
     * Portion at the end of the audio buffer that has been copied from the
     * beginning to assure cyclic behavior
     *
     * @type {Number}
     * @name wrapAroundExtension
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();
    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @name bufferDuration
   * @memberof GranularEngine
   * @instance
   * @readonly
   */


  (0, _createClass3.default)(GranularEngine, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    /**
     * Trigger a grain. This function can be called at any time (whether the
     * engine is scheduled or not) to generate a single grain according to the
     * current grain parameters.
     *
     * @param {Number} time - grain synthesis audio time
     * @return {Number} - period to next grain
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var grainTime = time || audioContext.currentTime;
      var grainPeriod = this.periodAbs;
      var grainPosition = this.currentPosition;
      var grainDuration = this.durationAbs;

      if (this.buffer) {
        var resamplingRate = 1.0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        // randomize grain duration
        if (this.durationVar > 0) grainDuration += (2.0 * Math.random() - 1) * this.durationVar;

        grainPeriod += this.periodRel * grainDuration;
        grainDuration += this.durationRel * grainPeriod;

        // grain period randon variation
        if (this.periodVar > 0.0) grainPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

        // center grain
        if (this.centered) grainPosition -= 0.5 * grainDuration;

        // randomize grain position
        if (this.positionVar > 0) grainPosition += (2.0 * Math.random() - 1) * this.positionVar;

        var bufferDuration = this.bufferDuration;

        // wrap or clip grain position and duration into buffer duration
        if (grainPosition < 0 || grainPosition >= bufferDuration) {
          if (this.cyclic) {
            var cycles = grainPosition / bufferDuration;
            grainPosition = (cycles - Math.floor(cycles)) * bufferDuration;

            if (grainPosition + grainDuration > this.buffer.duration) grainDuration = this.buffer.duration - grainPosition;
          } else {
            if (grainPosition < 0) {
              grainTime -= grainPosition;
              grainDuration += grainPosition;
              grainPosition = 0;
            }

            if (grainPosition + grainDuration > bufferDuration) grainDuration = bufferDuration - grainPosition;
          }
        }

        // make grain
        if (this.gain > 0 && grainDuration >= 0.001) {
          // make grain envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * grainDuration;
          var release = this.releaseAbs + this.releaseRel * grainDuration;

          if (attack + release > grainDuration) {
            var factor = grainDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = grainTime + attack;
          var grainEndTime = grainTime + grainDuration / resamplingRate;
          var releaseStartTime = grainEndTime - release;

          envelope.gain.value = 0;

          if (this.attackShape === 'lin') {
            envelope.gain.setValueAtTime(0.0, grainTime);
            envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);
          } else {
            envelope.gain.setValueAtTime(this.expRampOffset, grainTime);
            envelope.gain.exponentialRampToValueAtTime(this.gain, attackEndTime);
          }

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          if (this.releaseShape === 'lin') {
            envelope.gain.linearRampToValueAtTime(0.0, grainEndTime);
          } else {
            envelope.gain.exponentialRampToValueAtTime(this.expRampOffset, grainEndTime);
          }

          envelope.connect(this.outputNode);

          // make source
          var source = audioContext.createBufferSource();

          source.buffer = this.buffer;
          source.playbackRate.value = resamplingRate;
          source.connect(envelope);

          source.start(grainTime, grainPosition);
          source.stop(grainEndTime);
        }
      }

      return Math.max(this.periodMin, grainPeriod);
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }

    /**
     * Current position
     *
     * @type {Number}
     * @name currentPosition
     * @memberof GranularEngine
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return this.position;
    }
  }]);
  return GranularEngine;
}(_audioTimeEngine2.default);

exports.default = GranularEngine;

},{"../core/audio-time-engine":2,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Metronome audio engine. It extends Time Engine as a transported interface.
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/metronome.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const metronome = new audio.Metronome({period: 0.333});
 *
 * scheduler.add(metronome);
 *
 * @param {Object} [options={}] - Default options
 * @param {Number} [options.period=1] - Metronome period
 * @param {Number} [options.clickFreq=600] - Metronome click frequency
 * @param {Number} [options.clickAttack=0.002] - Metronome click attack time
 * @param {Number} [options.clickRelease=0.098] - Metronome click release time
 * @param {Number} [options.gain=1] - Gain
 */

var Metronome = function (_AudioTimeEngine) {
  (0, _inherits3.default)(Metronome, _AudioTimeEngine);

  function Metronome() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Metronome);

    /**
     * Metronome period
     * @type {Number}
     * @private
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (Metronome.__proto__ || (0, _getPrototypeOf2.default)(Metronome)).call(this, options.audioContext));

    _this.__period = optOrDef(options.period, 1);

    /**
     * Metronome click frequency
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickFreq
     * @instance
     */
    _this.clickFreq = optOrDef(options.clickFreq, 600);

    /**
     * Metronome click attack time
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickAttack
     * @instance
     */
    _this.clickAttack = optOrDef(options.clickAttack, 0.002);

    /**
     * Metronome click release time
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickRelease
     * @instance
     */
    _this.clickRelease = optOrDef(options.clickRelease, 0.098);

    _this.__lastTime = 0;
    _this.__phase = 0;

    _this.__gainNode = _this.audioContext.createGain();
    _this.__gainNode.gain.value = optOrDef(options.gain, 1);

    _this.outputNode = _this.__gainNode;
    return _this;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(Metronome, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      this.trigger(time);
      this.__lastTime = time;
      return time + this.__period;
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (this.__period > 0) {
        var nextPosition = (Math.floor(position / this.__period) + this.__phase) * this.__period;

        if (speed > 0 && nextPosition < position) nextPosition += this.__period;else if (speed < 0 && nextPosition > position) nextPosition -= this.__period;

        return nextPosition;
      }

      return Infinity * speed;
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      this.trigger(time);

      if (speed < 0) return position - this.__period;

      return position + this.__period;
    }

    /**
     * Trigger metronome click
     * @param {Number} time metronome click synthesis audio time
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var clickAttack = this.clickAttack;
      var clickRelease = this.clickRelease;

      var env = audioContext.createGain();
      env.gain.value = 0.0;
      env.gain.setValueAtTime(0, time);
      env.gain.linearRampToValueAtTime(1.0, time + clickAttack);
      env.gain.exponentialRampToValueAtTime(0.0000001, time + clickAttack + clickRelease);
      env.gain.setValueAtTime(0, time);
      env.connect(this.outputNode);

      var osc = audioContext.createOscillator();
      osc.frequency.value = this.clickFreq;
      osc.start(time);
      osc.stop(time + clickAttack + clickRelease);
      osc.connect(env);
    }

    /**
     * linear gain factor
     *
     * @type {Number}
     * @name gain
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'gain',
    set: function set(value) {
      this.__gainNode.gain.value = value;
    },
    get: function get() {
      return this.__gainNode.gain.value;
    }

    /**
     * metronome period
     *
     * @type {Number}
     * @name period
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'period',
    set: function set(period) {
      this.__period = period;

      var master = this.master;

      if (master) {
        if (master.resetEngineTime) master.resetEngineTime(this, this.__lastTime + period);else if (master.resetEnginePosition) master.resetEnginePosition(this);
      }
    },
    get: function get() {
      return this.__period;
    }

    /**
     * Set phase parameter (available only when 'transported'), should be
     * between [0, 1[
     *
     * @type {Number}
     * @name phase
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'phase',
    set: function set(phase) {
      this.__phase = phase - Math.floor(phase);

      var master = this.master;

      if (master && master.resetEnginePosition !== undefined) master.resetEnginePosition(this);
    },
    get: function get() {
      return this.__phase;
    }
  }]);
  return Metronome;
}(_audioTimeEngine2.default);

exports.default = Metronome;

},{"../core/audio-time-engine":2,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

var _PV_fast_ = require('../utils/PV_fast_5');

var _PV_fast_2 = _interopRequireDefault(_PV_fast_);

var _bufferedPv = require('../utils/buffered-pv');

var _bufferedPv2 = _interopRequireDefault(_bufferedPv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

function getCurrentOrPreviousIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value < firstVal) index = -1;else if (value >= lastVal) index = size - 1;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] > value) {
        index--;
      }while (sortedArray[index + 1] <= value) {
        index++;
      }
    }
  }

  return index;
}

function getCurrentOrNextIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value <= firstVal) index = 0;else if (value >= lastVal) index = size;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] < value) {
        index++;
      }while (sortedArray[index - 1] >= value) {
        index--;
      }
    }
  }

  return index;
}

/**
 * Used with a buffer to serve audio files via granular synthesis.
 *
 * The engine implements the "scheduled" and "transported" interfaces.
 * When "scheduled", the engine  generates segments more or less periodically
 * (controlled by the periodAbs, periodRel, and perioVar attributes).
 * When "transported", the engine generates segments at the position of their onset time.
 *
 * Example that shows a `PhasevocoderEngine` with a few parameter controls running in a `Scheduler`.
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/phasevocoder-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const PhasevocoderEngine = new audio.PhasevocoderEngine();
 *
 * scheduler.add(PhasevocoderEngine);
 *
 * @param {Object} [options={}] - Default options
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0] - Absolute segment period in sec
 * @param {Number} [options.periodRel=1] - Segment period relative to inter-segment distance
 * @param {Number} [options.periodVar=0] - Amout of random segment period variation relative
 *  to segment period
 * @param {Number} [options.periodMin=0.001] - Minimum segment period
 * @param {Number} [options.positionArray=[0.0]] - Array of segment positions (onset times
 *  in audio buffer) in sec
 * @param {Number} [options.positionVar=0] - Amout of random segment position variation in sec
 * @param {Number} [options.durationArray=[0.0]] - Array of segment durations in sec
 * @param {Number} [options.durationAbs=0] - Absolute segment duration in sec
 * @param {Number} [options.durationRel=1] - Segment duration relative to given segment
 *  duration or inter-segment distance
 * @param {Array} [options.offsetArray=[0.0]] - Array of segment offsets in sec
 * @param {Number} [options.offsetAbs=-0.005] - Absolute segment offset in sec
 * @param {Number} [options.offsetRel=0] - Segment offset relative to segment duration
 * @param {Number} [options.delay=0.005] - Time by which all segments are delayed (especially
 *  to realize segment offsets)
 * @param {Number} [options.attackAbs=0.005] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0] - Attack time relative to segment duration
 * @param {Number} [options.releaseAbs=0.005] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0] - Release time relative to segment duration
 * @param {Number} [options.resampling=0] - Segment resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Number} [options.abortTime=0.005] - fade-out time when aborted
 * @param {Number} [options.segmentIndex=0] - Index of the segment to synthesize (i.e. of
 *  this.positionArray/durationArray/offsetArray)
 * @param {Bool} [options.cyclic=false] - Whether the audio buffer and segment indices are
 *  considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the audio buffer
 *  that has been copied from the beginning to assure cyclic behavior
 */

var PhasevocoderEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(PhasevocoderEngine, _AudioTimeEngine);

  function PhasevocoderEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, PhasevocoderEngine);

    /**
     * Audio buffer
     * @name buffer
     * @type {AudioBuffer}
     * @default null
     * @memberof PhasevocoderEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (PhasevocoderEngine.__proto__ || (0, _getPrototypeOf2.default)(PhasevocoderEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute segment period in sec
     * @name periodAbs
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0);

    /**
     * Segment period relative to inter-segment distance
     * @name periodRel
     * @type {Number}
     * @default 1
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 1);

    /**
     * Amout of random segment period variation relative to segment period
     * @name periodVar
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum segment period
     * @name periodMin
     * @type {Number}
     * @default 0.001
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Array of segment positions (onset times in audio buffer) in sec
     * @name positionArray
     * @type {Number}
     * @default [0.0]
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.positionArray = optOrDef(options.positionArray, [0.0]);

    /**
     * Amout of random segment position variation in sec
     * @name positionVar
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0);

    /**
     * Array of segment durations in sec
     * @name durationArray
     * @type {Number}
     * @default [0.0]
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.durationArray = optOrDef(options.durationArray, [0.0]);

    /**
     * Absolute segment duration in sec
     * @name durationAbs
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0);

    /**
     * Segment duration relative to given segment duration or inter-segment distance
     * @name durationRel
     * @type {Number}
     * @default 1
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 1);

    /**
     * Array of segment offsets in sec
     *
     * offset > 0: the segment's reference position is after the given segment position
     * offset < 0: the given segment position is the segment's reference position
     * and the duration has to be corrected by the offset
     *
     * @name offsetArray
     * @type {Array}
     * @default [0.0]
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.offsetArray = optOrDef(options.offsetArray, [0.0]);

    /**
     * Absolute segment offset in sec
     * @name offsetAbs
     * @type {Number}
     * @default -0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.offsetAbs = optOrDef(options.offsetAbs, 0.000);

    /**
     * Segment offset relative to segment duration
     * @name offsetRel
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.offsetRel = optOrDef(options.offsetRel, 0);

    /**
     * Time by which all segments are delayed (especially to realize segment offsets)
     * @name delay
     * @type {Number}
     * @default 0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.delay = optOrDef(options.delay, 0.0);

    /**
     * Absolute attack time in sec
     * @name attackAbs
     * @type {Number}
     * @default 0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0.0);

    /**
     * Attack time relative to segment duration
     * @name attackRel
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0);

    /**
     * Absolute release time in sec
     * @name releaseAbs
     * @type {Number}
     * @default 0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0.0);

    /**
     * Release time relative to segment duration
     * @name releaseRel
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0);

    /**
     * Segment resampling in cent
     * @name resampling
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     * @name resamplingVar
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     * @name gain
     * @type {Number}
     * @default 1
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Index of the segment to synthesize (i.e. of this.positionArray/durationArray/offsetArray)
     * @name segmentIndex
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.segmentIndex = optOrDef(options.segmentIndex, 0);

    /**
     * Whether the audio buffer and segment indices are considered as cyclic
     * @name cyclic
     * @type {Bool}
     * @default false
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);
    _this.__cyclicOffset = 0;

    /**
     * Whether the last segment is aborted when triggering the next
     * @name monophonic
     * @type {Number}
     * @default false
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.monophonic = optOrDef(options.monophonic, false);
    _this.__currentSrc = null;
    _this.__currentEnv = null;
    _this.__releaseStartTime = 0;
    _this.__currentGain = 0;
    _this.__currentEndTime = 0;

    /**
     * Fade-out time (when aborted)
     * @name abortTime
     * @type {Number}
     * @default 0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.abortTime = optOrDef(options.abortTime, 0.005);

    /**
     * Portion at the end of the audio buffer that has been copied from the beginning to assure cyclic behavior
     * @name wrapAroundExtension
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();

    /**
    * Size of phasevocoder analysis frame
    * @name frameSize
    * @type {Number}
    * @default 4096
    * @memberof PhasevocoderEngine
    * @instance
    */
    _this.frameSize = optOrDef(options.frameSize, 2048);

    // Setup vocoder
    _this._pv = new _bufferedPv2.default(_this.frameSize);
    _this._pv.set_audio_buffer(_this.buffer);
    _this._pv.alpha = 1;

    // FIXME: BUFFER_SIZE not in use yet...
    // Thinking that if user dont provide segments (ie markerbuffer), 
    // then the engine just chops the buffer into chunks whith this size.
    _this.BUFFER_SIZE = 4096;

    /**
    * The amount to stretch the audio segments with
    * @name stretchFactor
    * @type {Number}
    * @default 1
    * @memberof PhasevocoderEngine
    * @instance
    */
    _this.stretchFactor = optOrDef(options.stretchFactor, 1);

    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @default 0
   * @memberof PhasevocoderEngine
   * @instance
   */


  (0, _createClass3.default)(PhasevocoderEngine, [{
    key: 'advanceTime',


    // TimeEngine method (transported interface)
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = 0;
      var bufferDuration = this.bufferDuration;

      if (this.cyclic) {
        var cycles = position / bufferDuration;

        cyclicOffset = Math.floor(cycles) * bufferDuration;
        position -= cyclicOffset;
      }

      if (speed > 0) {
        index = getCurrentOrNextIndex(this.positionArray, position);

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else if (speed < 0) {
        index = getCurrentOrPreviousIndex(this.positionArray, position);

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      } else {
        return Infinity;
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = this.__cyclicOffset;

      this.trigger(time);

      if (speed > 0) {
        index++;

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += this.bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else {
        index--;

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= this.bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    /**
     * Trigger a segment.
     * This function can be called at any time (whether the engine is scheduled/transported or not)
     * to generate a single segment according to the current segment parameters.
     *
     * @param {Number} time segment synthesis audio time
     * @return {Number} period to next segment
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var segmentTime = (time || audioContext.currentTime) + this.delay;
      var segmentPeriod = this.periodAbs;
      var segmentIndex = this.segmentIndex;

      if (this.buffer) {
        var segmentPosition = 0.0;
        var segmentDuration = 0.0;
        var segmentOffset = 0.0;
        var resamplingRate = 1.0;
        var bufferDuration = this.bufferDuration;

        if (this.cyclic) segmentIndex = segmentIndex % this.positionArray.length;else segmentIndex = Math.max(0, Math.min(segmentIndex, this.positionArray.length - 1));

        if (this.positionArray) segmentPosition = this.positionArray[segmentIndex] || 0;

        if (this.durationArray) segmentDuration = this.durationArray[segmentIndex] || 0;

        if (this.offsetArray) segmentOffset = this.offsetArray[segmentIndex] || 0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        // calculate inter-segment distance
        if (segmentDuration === 0 || this.periodRel > 0) {
          var nextSegmentIndex = segmentIndex + 1;
          var nextPosition, nextOffset;

          if (nextSegmentIndex === this.positionArray.length) {
            if (this.cyclic) {
              nextPosition = this.positionArray[0] + bufferDuration;
              nextOffset = this.offsetArray[0];
            } else {
              nextPosition = bufferDuration;
              nextOffset = 0;
            }
          } else {
            nextPosition = this.positionArray[nextSegmentIndex];
            nextOffset = this.offsetArray[nextSegmentIndex];
          }

          var interSegmentDistance = nextPosition - segmentPosition;

          // correct inter-segment distance by offsets
          //   offset > 0: the segment's reference position is after the given segment position
          if (segmentOffset > 0) interSegmentDistance -= segmentOffset;

          if (nextOffset > 0) interSegmentDistance += nextOffset;

          if (interSegmentDistance < 0) interSegmentDistance = 0;

          // use inter-segment distance instead of segment duration
          if (segmentDuration === 0) segmentDuration = interSegmentDistance;

          // calculate period relative to inter marker distance
          segmentPeriod += this.periodRel * interSegmentDistance;
        }

        // add relative and absolute segment duration
        segmentDuration *= this.durationRel;
        segmentDuration += this.durationAbs;

        // add relative and absolute segment offset
        segmentOffset *= this.offsetRel;
        segmentOffset += this.offsetAbs;

        // apply segment offset
        //   offset > 0: the segment's reference position is after the given segment position
        //   offset < 0: the given segment position is the segment's reference position and the duration has to be corrected by the offset
        if (segmentOffset < 0) {
          segmentDuration -= segmentOffset;
          segmentPosition += segmentOffset;
          segmentTime += segmentOffset / resamplingRate;
        } else {
          segmentTime -= segmentOffset / resamplingRate;
        }

        // randomize segment position
        if (this.positionVar > 0) segmentPosition += 2.0 * (Math.random() - 0.5) * this.positionVar;

        // shorten duration of segments over the edges of the buffer
        if (segmentPosition < 0) {
          //segmentTime -= grainPosition; hm, not sure if we want to do this
          segmentDuration += segmentPosition;
          segmentPosition = 0;
        }

        if (segmentPosition + segmentDuration > this.buffer.duration) segmentDuration = this.buffer.duration - segmentPosition;

        segmentDuration /= resamplingRate;

        if (this.monophonic) this.abort(segmentTime);

        // make segment
        if (this.gain > 0 && segmentDuration > 0) {
          // make segment envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * segmentDuration;
          var release = this.releaseAbs + this.releaseRel * segmentDuration;

          if (attack + release > segmentDuration) {
            var factor = segmentDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = segmentTime + attack;
          var segmentEndTime = segmentTime + segmentDuration;
          var releaseStartTime = segmentEndTime - release;

          envelope.gain.value = 0;
          envelope.gain.setValueAtTime(0.0, segmentTime);
          envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          envelope.gain.linearRampToValueAtTime(0.0, segmentEndTime);
          envelope.connect(this.outputNode);

          this.__currentEnv = envelope;

          // make source
          var source = audioContext.createBufferSource();

          // Buffer to save the stretch audio into
          var stretchedBuffer = audioContext.createBuffer(2, segmentDuration * audioContext.sampleRate, audioContext.sampleRate);

          // Set the phasevocoder's position in source buffer (ie this.buffer).
          this._pv.position = segmentPosition * audioContext.sampleRate;
          this._pv.process(stretchedBuffer);
          // FIXME: If phase is not reset, the audio is silenced when looped... dont know why...
          if (this.positionArray) {
            if (segmentIndex == this.positionArray.length - 1) {
              this._pv.resetPhase();
            }
          }

          source.buffer = stretchedBuffer;
          source.playbackRate.value = resamplingRate;
          //source.connect(envelope); //FIXME: Using envelope causes "tremolo" even if all ramping is 0.
          source.connect(audioContext.destination);

          source.start(segmentTime);
          source.stop(segmentTime + segmentDuration);

          this.__currentSrc = source;
          this.__releaseStartTime = releaseStartTime;
          this.__currentGain = this.gain;
          this.__currentEndTime = segmentEndTime;
        }
      }

      // grain period randon variation
      if (this.periodVar > 0.0) segmentPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

      return Math.max(this.periodMin, segmentPeriod);
    }

    /**
     * Abort the current segment at given time, fade out duration
     *
     * @param {Number} time - abort time
     */

  }, {
    key: 'abort',
    value: function abort(time) {
      var audioContext = this.audioContext;
      var endTime = this.__currentEndTime;
      var abortTime = time || audioContext.currentTime;

      if (abortTime < endTime) {
        var segmentEndTime = Math.min(abortTime + this.abortTime, endTime);
        var envelope = this.__currentEnv;
        var currentGainValue = this.__currentGain;

        if (abortTime > this.__releaseStartTime) {
          var releaseStart = this.__releaseStartTime;
          currentGainValue *= (abortTime - releaseStart) / (endTime - releaseStart);
        }

        envelope.gain.cancelScheduledValues(abortTime);
        envelope.gain.setValueAtTime(currentGainValue, abortTime);
        envelope.gain.linearRampToValueAtTime(0, segmentEndTime);

        this.__currentSrc = null;
        this.__currentEnv = null;
        this.__releaseStartTime = 0;
        this.__currentGain = 0;
        this.__currentEndTime = 0;
      }
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }
  }, {
    key: 'stretchFactor',
    set: function set(newAlpha) {
      if (this._pv) this._pv.alpha = newAlpha;
    }
  }]);
  return PhasevocoderEngine;
}(_audioTimeEngine2.default);

exports.default = PhasevocoderEngine;

},{"../core/audio-time-engine":2,"../utils/PV_fast_5":18,"../utils/buffered-pv":19,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Used with a buffer to serve audio files.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/player-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const playerEngine = audio.PlayerEngine();
 * const playControl = new audio.PlayControl(playerEngine);
 *
 * playControl.start();
 *
 * @param {Object} [options={}] - Default options
 * @param {Number} [options.buffer=1] - Audio buffer
 * @param {Number} [options.fadeTime=600] - Fade time for chaining segments
 * @param {Number} [options.cyclic=false] - Loop mode
 * @param {Number} [options.gain=1] - Gain
 */

var PlayerEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(PlayerEngine, _AudioTimeEngine);

  function PlayerEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, PlayerEngine);

    var _this = (0, _possibleConstructorReturn3.default)(this, (PlayerEngine.__proto__ || (0, _getPrototypeOf2.default)(PlayerEngine)).call(this, options.audioContext));

    _this.transport = null; // set when added to transporter

    /**
     * Audio buffer
     *
     * @type {AudioBuffer}
     * @name buffer
     * @memberof PlayerEngine
     * @instance
     * @default null
     */
    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Fade time for chaining segments (e.g. in start, stop, and seek)
     *
     * @type {Number}
     * @name fadeTime
     * @memberof PlayerEngine
     * @instance
     * @default 0.005
     */
    _this.fadeTime = optOrDef(options.fadeTime, 0.005);

    _this.__time = 0;
    _this.__position = 0;
    _this.__speed = 0;

    _this.__bufferSource = null;
    _this.__envNode = null;

    _this.__gainNode = _this.audioContext.createGain();
    _this.__gainNode.gain.value = optOrDef(options.gain, 1);

    _this.__cyclic = optOrDef(options.cyclic, false);

    _this.outputNode = _this.__gainNode;
    return _this;
  }

  (0, _createClass3.default)(PlayerEngine, [{
    key: '__start',
    value: function __start(time, position, speed) {
      var audioContext = this.audioContext;

      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.__cyclic && (position < 0 || position >= bufferDuration)) {
          var phase = position / bufferDuration;
          position = (phase - Math.floor(phase)) * bufferDuration;
        }

        if (position >= 0 && position < bufferDuration && speed > 0) {
          this.__envNode = audioContext.createGain();
          this.__envNode.gain.setValueAtTime(0, time);
          this.__envNode.gain.linearRampToValueAtTime(1, time + this.fadeTime);
          this.__envNode.connect(this.__gainNode);

          this.__bufferSource = audioContext.createBufferSource();
          this.__bufferSource.buffer = this.buffer;
          this.__bufferSource.playbackRate.value = speed;
          this.__bufferSource.loop = this.__cyclic;
          this.__bufferSource.loopStart = 0;
          this.__bufferSource.loopEnd = bufferDuration;
          this.__bufferSource.start(time, position);
          this.__bufferSource.connect(this.__envNode);
        }
      }
    }
  }, {
    key: '__halt',
    value: function __halt(time) {
      if (this.__bufferSource) {
        this.__envNode.gain.cancelScheduledValues(time);
        this.__envNode.gain.setValueAtTime(this.__envNode.gain.value, time);
        this.__envNode.gain.linearRampToValueAtTime(0, time + this.fadeTime);
        this.__bufferSource.stop(time + this.fadeTime);

        this.__bufferSource = null;
        this.__envNode = null;
      }
    }

    // TimeEngine method (speed-controlled interface)

  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      if (speed !== lastSpeed || seek) {
        if (seek || lastSpeed * speed < 0) {
          this.__halt(time);
          this.__start(time, position, speed);
        } else if (lastSpeed === 0 || seek) {
          this.__start(time, position, speed);
        } else if (speed === 0) {
          this.__halt(time);
        } else if (this.__bufferSource) {
          this.__bufferSource.playbackRate.setValueAtTime(speed, time);
        }

        this.__speed = speed;
      }
    }

    /**
     * Set whether the audio buffer is considered as cyclic
     * @type {Bool}
     * @name cyclic
     * @memberof PlayerEngine
     * @instance
     */

  }, {
    key: 'cyclic',
    set: function set(cyclic) {
      if (cyclic !== this.__cyclic) {
        var time = this.currentTime;
        var position = this.currentosition;

        this.__halt(time);
        this.__cyclic = cyclic;

        if (this.__speed !== 0) this.__start(time, position, this.__speed);
      }
    },
    get: function get() {
      return this.__cyclic;
    }

    /**
     * Linear gain factor
     * @type {Number}
     * @name gain
     * @memberof PlayerEngine
     * @instance
     */

  }, {
    key: 'gain',
    set: function set(value) {
      var time = this.currentTime;
      this.__gainNode.cancelScheduledValues(time);
      this.__gainNode.setValueAtTime(this.__gainNode.gain.value, time);
      this.__gainNode.linearRampToValueAtTime(0, time + this.fadeTime);
    },
    get: function get() {
      return this.__gainNode.gain.value;
    }

    /**
     * Get buffer duration
     * @type {Number}
     * @name bufferDuration
     * @memberof PlayerEngine
     * @instance
     * @readonly
     */

  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) return this.buffer.duration;

      return 0;
    }
  }]);
  return PlayerEngine;
}(_audioTimeEngine2.default);

exports.default = PlayerEngine;

},{"../core/audio-time-engine":2,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

function getCurrentOrPreviousIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value < firstVal) index = -1;else if (value >= lastVal) index = size - 1;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] > value) {
        index--;
      }while (sortedArray[index + 1] <= value) {
        index++;
      }
    }
  }

  return index;
}

function getCurrentOrNextIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value <= firstVal) index = 0;else if (value >= lastVal) index = size;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] < value) {
        index++;
      }while (sortedArray[index - 1] >= value) {
        index--;
      }
    }
  }

  return index;
}

/**
 * Used with a buffer to serve audio files via granular synthesis.
 *
 * The engine implements the "scheduled" and "transported" interfaces.
 * When "scheduled", the engine  generates segments more or less periodically
 * (controlled by the periodAbs, periodRel, and perioVar attributes).
 * When "transported", the engine generates segments at the position of their onset time.
 *
 * Example that shows a `SegmentEngine` with a few parameter controls running in a `Scheduler`.
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/segment-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const segmentEngine = new audio.SegmentEngine();
 *
 * scheduler.add(segmentEngine);
 *
 * @param {Object} [options={}] - Default options
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0] - Absolute segment period in sec
 * @param {Number} [options.periodRel=1] - Segment period relative to inter-segment distance
 * @param {Number} [options.periodVar=0] - Amout of random segment period variation relative
 *  to segment period
 * @param {Number} [options.periodMin=0.001] - Minimum segment period
 * @param {Number} [options.positionArray=[0.0]] - Array of segment positions (onset times
 *  in audio buffer) in sec
 * @param {Number} [options.positionVar=0] - Amout of random segment position variation in sec
 * @param {Number} [options.durationArray=[0.0]] - Array of segment durations in sec
 * @param {Number} [options.durationAbs=0] - Absolute segment duration in sec
 * @param {Number} [options.durationRel=1] - Segment duration relative to given segment
 *  duration or inter-segment distance
 * @param {Array} [options.offsetArray=[0.0]] - Array of segment offsets in sec
 * @param {Number} [options.offsetAbs=-0.005] - Absolute segment offset in sec
 * @param {Number} [options.offsetRel=0] - Segment offset relative to segment duration
 * @param {Number} [options.delay=0.005] - Time by which all segments are delayed (especially
 *  to realize segment offsets)
 * @param {Number} [options.attackAbs=0.005] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0] - Attack time relative to segment duration
 * @param {Number} [options.releaseAbs=0.005] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0] - Release time relative to segment duration
 * @param {Number} [options.resampling=0] - Segment resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Number} [options.abortTime=0.005] - fade-out time when aborted
 * @param {Number} [options.segmentIndex=0] - Index of the segment to synthesize (i.e. of
 *  this.positionArray/durationArray/offsetArray)
 * @param {Bool} [options.cyclic=false] - Whether the audio buffer and segment indices are
 *  considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the audio buffer
 *  that has been copied from the beginning to assure cyclic behavior
 */

var SegmentEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(SegmentEngine, _AudioTimeEngine);

  function SegmentEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SegmentEngine);

    /**
     * Audio buffer
     * @name buffer
     * @type {AudioBuffer}
     * @default null
     * @memberof SegmentEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (SegmentEngine.__proto__ || (0, _getPrototypeOf2.default)(SegmentEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute segment period in sec
     * @name periodAbs
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0);

    /**
     * Segment period relative to inter-segment distance
     * @name periodRel
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 1);

    /**
     * Amout of random segment period variation relative to segment period
     * @name periodVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum segment period
     * @name periodMin
     * @type {Number}
     * @default 0.001
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Array of segment positions (onset times in audio buffer) in sec
     * @name positionArray
     * @type {Number}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.positionArray = optOrDef(options.positionArray, [0.0]);

    /**
     * Amout of random segment position variation in sec
     * @name positionVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0);

    /**
     * Array of segment durations in sec
     * @name durationArray
     * @type {Number}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationArray = optOrDef(options.durationArray, [0.0]);

    /**
     * Absolute segment duration in sec
     * @name durationAbs
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0);

    /**
     * Segment duration relative to given segment duration or inter-segment distance
     * @name durationRel
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 1);

    /**
     * Array of segment offsets in sec
     *
     * offset > 0: the segment's reference position is after the given segment position
     * offset < 0: the given segment position is the segment's reference position
     * and the duration has to be corrected by the offset
     *
     * @name offsetArray
     * @type {Array}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetArray = optOrDef(options.offsetArray, [0.0]);

    /**
     * Absolute segment offset in sec
     * @name offsetAbs
     * @type {Number}
     * @default -0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetAbs = optOrDef(options.offsetAbs, -0.005);

    /**
     * Segment offset relative to segment duration
     * @name offsetRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetRel = optOrDef(options.offsetRel, 0);

    /**
     * Time by which all segments are delayed (especially to realize segment offsets)
     * @name delay
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.delay = optOrDef(options.delay, 0.005);

    /**
     * Absolute attack time in sec
     * @name attackAbs
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0.005);

    /**
     * Attack time relative to segment duration
     * @name attackRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0);

    /**
     * Absolute release time in sec
     * @name releaseAbs
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0.005);

    /**
     * Release time relative to segment duration
     * @name releaseRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0);

    /**
     * Segment resampling in cent
     * @name resampling
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     * @name resamplingVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     * @name gain
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Index of the segment to synthesize (i.e. of this.positionArray/durationArray/offsetArray)
     * @name segmentIndex
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.segmentIndex = optOrDef(options.segmentIndex, 0);

    /**
     * Whether the audio buffer and segment indices are considered as cyclic
     * @name cyclic
     * @type {Bool}
     * @default false
     * @memberof SegmentEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);
    _this.__cyclicOffset = 0;

    /**
     * Whether the last segment is aborted when triggering the next
     * @name monophonic
     * @type {Number}
     * @default false
     * @memberof SegmentEngine
     * @instance
     */
    _this.monophonic = optOrDef(options.monophonic, false);
    _this.__currentSrc = null;
    _this.__currentEnv = null;
    _this.__releaseStartTime = 0;
    _this.__currentGain = 0;
    _this.__currentEndTime = 0;

    /**
     * Fade-out time (when aborted)
     * @name abortTime
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.abortTime = optOrDef(options.abortTime, 0.005);

    /**
     * Portion at the end of the audio buffer that has been copied from the beginning to assure cyclic behavior
     * @name wrapAroundExtension
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();
    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @default 0
   * @memberof SegmentEngine
   * @instance
   */


  (0, _createClass3.default)(SegmentEngine, [{
    key: 'advanceTime',


    // TimeEngine method (transported interface)
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = 0;
      var bufferDuration = this.bufferDuration;

      if (this.cyclic) {
        var cycles = position / bufferDuration;

        cyclicOffset = Math.floor(cycles) * bufferDuration;
        position -= cyclicOffset;
      }

      if (speed > 0) {
        index = getCurrentOrNextIndex(this.positionArray, position);

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else if (speed < 0) {
        index = getCurrentOrPreviousIndex(this.positionArray, position);

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      } else {
        return Infinity;
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = this.__cyclicOffset;

      this.trigger(time);

      if (speed > 0) {
        index++;

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += this.bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else {
        index--;

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= this.bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    /**
     * Trigger a segment.
     * This function can be called at any time (whether the engine is scheduled/transported or not)
     * to generate a single segment according to the current segment parameters.
     *
     * @param {Number} time segment synthesis audio time
     * @return {Number} period to next segment
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var segmentTime = (time || audioContext.currentTime) + this.delay;
      var segmentPeriod = this.periodAbs;
      var segmentIndex = this.segmentIndex;

      if (this.buffer) {
        var segmentPosition = 0.0;
        var segmentDuration = 0.0;
        var segmentOffset = 0.0;
        var resamplingRate = 1.0;
        var bufferDuration = this.bufferDuration;

        if (this.cyclic) segmentIndex = segmentIndex % this.positionArray.length;else segmentIndex = Math.max(0, Math.min(segmentIndex, this.positionArray.length - 1));

        if (this.positionArray) segmentPosition = this.positionArray[segmentIndex] || 0;

        if (this.durationArray) segmentDuration = this.durationArray[segmentIndex] || 0;

        if (this.offsetArray) segmentOffset = this.offsetArray[segmentIndex] || 0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        // calculate inter-segment distance
        if (segmentDuration === 0 || this.periodRel > 0) {
          var nextSegmentIndex = segmentIndex + 1;
          var nextPosition, nextOffset;

          if (nextSegmentIndex === this.positionArray.length) {
            if (this.cyclic) {
              nextPosition = this.positionArray[0] + bufferDuration;
              nextOffset = this.offsetArray[0];
            } else {
              nextPosition = bufferDuration;
              nextOffset = 0;
            }
          } else {
            nextPosition = this.positionArray[nextSegmentIndex];
            nextOffset = this.offsetArray[nextSegmentIndex];
          }

          var interSegmentDistance = nextPosition - segmentPosition;

          // correct inter-segment distance by offsets
          //   offset > 0: the segment's reference position is after the given segment position
          if (segmentOffset > 0) interSegmentDistance -= segmentOffset;

          if (nextOffset > 0) interSegmentDistance += nextOffset;

          if (interSegmentDistance < 0) interSegmentDistance = 0;

          // use inter-segment distance instead of segment duration
          if (segmentDuration === 0) segmentDuration = interSegmentDistance;

          // calculate period relative to inter marker distance
          segmentPeriod += this.periodRel * interSegmentDistance;
        }

        // add relative and absolute segment duration
        segmentDuration *= this.durationRel;
        segmentDuration += this.durationAbs;

        // add relative and absolute segment offset
        segmentOffset *= this.offsetRel;
        segmentOffset += this.offsetAbs;

        // apply segment offset
        //   offset > 0: the segment's reference position is after the given segment position
        //   offset < 0: the given segment position is the segment's reference position and the duration has to be corrected by the offset
        if (segmentOffset < 0) {
          segmentDuration -= segmentOffset;
          segmentPosition += segmentOffset;
          segmentTime += segmentOffset / resamplingRate;
        } else {
          segmentTime -= segmentOffset / resamplingRate;
        }

        // randomize segment position
        if (this.positionVar > 0) segmentPosition += 2.0 * (Math.random() - 0.5) * this.positionVar;

        // shorten duration of segments over the edges of the buffer
        if (segmentPosition < 0) {
          //segmentTime -= grainPosition; hm, not sure if we want to do this
          segmentDuration += segmentPosition;
          segmentPosition = 0;
        }

        if (segmentPosition + segmentDuration > this.buffer.duration) segmentDuration = this.buffer.duration - segmentPosition;

        segmentDuration /= resamplingRate;

        if (this.monophonic) this.abort(segmentTime);

        // make segment
        if (this.gain > 0 && segmentDuration > 0) {
          // make segment envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * segmentDuration;
          var release = this.releaseAbs + this.releaseRel * segmentDuration;

          if (attack + release > segmentDuration) {
            var factor = segmentDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = segmentTime + attack;
          var segmentEndTime = segmentTime + segmentDuration;
          var releaseStartTime = segmentEndTime - release;

          envelope.gain.value = 0;
          envelope.gain.setValueAtTime(0.0, segmentTime);
          envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          envelope.gain.linearRampToValueAtTime(0.0, segmentEndTime);
          envelope.connect(this.outputNode);

          this.__currentEnv = envelope;

          // make source
          var source = audioContext.createBufferSource();

          source.buffer = this.buffer;
          source.playbackRate.value = resamplingRate;
          source.connect(envelope);

          source.start(segmentTime, segmentPosition);
          source.stop(segmentTime + segmentDuration);

          this.__currentSrc = source;
          this.__releaseStartTime = releaseStartTime;
          this.__currentGain = this.gain;
          this.__currentEndTime = segmentEndTime;
        }
      }

      // grain period randon variation
      if (this.periodVar > 0.0) segmentPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

      return Math.max(this.periodMin, segmentPeriod);
    }

    /**
     * Abort the current segment at given time, fade out duration
     *
     * @param {Number} time - abort time
     */

  }, {
    key: 'abort',
    value: function abort(time) {
      var audioContext = this.audioContext;
      var endTime = this.__currentEndTime;
      var abortTime = time || audioContext.currentTime;

      if (abortTime < endTime) {
        var segmentEndTime = Math.min(abortTime + this.abortTime, endTime);
        var envelope = this.__currentEnv;
        var currentGainValue = this.__currentGain;

        if (abortTime > this.__releaseStartTime) {
          var releaseStart = this.__releaseStartTime;
          currentGainValue *= (abortTime - releaseStart) / (endTime - releaseStart);
        }

        envelope.gain.cancelScheduledValues(abortTime);
        envelope.gain.setValueAtTime(currentGainValue, abortTime);
        envelope.gain.linearRampToValueAtTime(0, segmentEndTime);

        this.__currentSrc = null;
        this.__currentEnv = null;
        this.__releaseStartTime = 0;
        this.__currentGain = 0;
        this.__currentEndTime = 0;
      }
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }
  }]);
  return SegmentEngine;
}(_audioTimeEngine2.default);

exports.default = SegmentEngine;

},{"../core/audio-time-engine":2,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

var _segmentEngine = require('./segment-engine');

var _segmentEngine2 = _interopRequireDefault(_segmentEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
    if (opt !== undefined) return opt;

    return def;
}

function getCurrentOrPreviousIndex(sortedArray, value) {
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

    var size = sortedArray.length;

    if (size > 0) {
        var firstVal = sortedArray[0];
        var lastVal = sortedArray[size - 1];

        if (value < firstVal) index = -1;else if (value >= lastVal) index = size - 1;else {
            if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

            while (sortedArray[index] > value) {
                index--;
            }while (sortedArray[index + 1] <= value) {
                index++;
            }
        }
    }

    return index;
}

function getCurrentOrNextIndex(sortedArray, value) {
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

    var size = sortedArray.length;

    if (size > 0) {
        var firstVal = sortedArray[0];
        var lastVal = sortedArray[size - 1];

        if (value <= firstVal) index = 0;else if (value >= lastVal) index = size;else {
            if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

            while (sortedArray[index] < value) {
                index++;
            }while (sortedArray[index - 1] >= value) {
                index--;
            }
        }
    }

    return index;
}

/**
 * @class SequencerEngine
 */

var SequencerEngine = function (_SegmentEngine) {
    (0, _inherits3.default)(SequencerEngine, _SegmentEngine);

    /**
     * @constructor
     * @param {AudioBuffer} buffer initial audio buffer for granular synthesis
     *
     * The engine implements the "scheduled" and "transported" interfaces.
     * When "scheduled", the engine  generates segments more or less periodically
     * (controlled by the periodAbs, periodRel, and perioVar attributes).
     * When "transported", the engine generates segments at the position of their onset time.
     */
    function SequencerEngine() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck3.default)(this, SequencerEngine);

        /**
         * A function callback that gets called from trigger().
         * This lets you set up events to be triggered by the sequencer.
         * @type {Function}
         */
        var _this = (0, _possibleConstructorReturn3.default)(this, (SequencerEngine.__proto__ || (0, _getPrototypeOf2.default)(SequencerEngine)).call(this, options));

        _this.callback = optOrDef(options.callback, null);

        return _this;
    }

    /**
     * Trigger a segment
     * @param {Number} time segment synthesis audio time
     * @return {Number} period to next segment
     *
     * This function can be called at any time (whether the engine is scheduled/transported or not)
     * to generate a single segment according to the current segment parameters.
     */


    (0, _createClass3.default)(SequencerEngine, [{
        key: 'trigger',
        value: function trigger(time) {
            var audioContext = this.audioContext;
            var segmentTime = (time || audioContext.currentTime) + this.delay;
            var segmentPeriod = this.periodAbs;
            var segmentIndex = this.segmentIndex;

            // Ignore buffer for now, this is a sequncer... no audio produced.
            if ( /*this.buffer*/true) {
                var segmentPosition = 0.0;
                var segmentDuration = 0.0;
                var segmentOffset = 0.0;
                var resamplingRate = 1.0;
                var bufferDuration = this.bufferDuration;

                if (this.cyclic) segmentIndex = segmentIndex % this.positionArray.length;else segmentIndex = Math.max(0, Math.min(segmentIndex, this.positionArray.length - 1));

                if (this.positionArray) segmentPosition = this.positionArray[segmentIndex] || 0;

                if (this.durationArray) segmentDuration = this.durationArray[segmentIndex] || 0;

                if (this.offsetArray) segmentOffset = this.offsetArray[segmentIndex] || 0;

                // calculate resampling
                if (this.resampling !== 0 || this.resamplingVar > 0) {
                    var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
                    resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
                }

                // calculate inter-segment distance
                if (segmentDuration === 0 || this.periodRel > 0) {
                    var nextSegmentIndex = segmentIndex + 1;
                    var nextPosition, nextOffset;

                    if (nextSegmentIndex === this.positionArray.length) {
                        if (this.cyclic) {
                            nextPosition = this.positionArray[0] + bufferDuration;
                            nextOffset = this.offsetArray[0];
                        } else {
                            nextPosition = bufferDuration;
                            nextOffset = 0;
                        }
                    } else {
                        nextPosition = this.positionArray[nextSegmentIndex];
                        nextOffset = this.offsetArray[nextSegmentIndex];
                    }

                    var interSegmentDistance = nextPosition - segmentPosition;

                    // correct inter-segment distance by offsets
                    //   offset > 0: the segment's reference position is after the given segment position
                    if (segmentOffset > 0) interSegmentDistance -= segmentOffset;

                    if (nextOffset > 0) interSegmentDistance += nextOffset;

                    if (interSegmentDistance < 0) interSegmentDistance = 0;

                    // use inter-segment distance instead of segment duration
                    if (segmentDuration === 0) segmentDuration = interSegmentDistance;

                    // calculate period relative to inter marker distance
                    segmentPeriod += this.periodRel * interSegmentDistance;
                }
                /*
                // add relative and absolute segment duration
                segmentDuration *= this.durationRel;
                segmentDuration += this.durationAbs;
                  // add relative and absolute segment offset
                segmentOffset *= this.offsetRel;
                segmentOffset += this.offsetAbs;
                  // apply segment offset
                //   offset > 0: the segment's reference position is after the given segment position
                //   offset < 0: the given segment position is the segment's reference position and the duration has to be corrected by the offset
                if (segmentOffset < 0) {
                    segmentDuration -= segmentOffset;
                    segmentPosition += segmentOffset;
                    segmentTime += (segmentOffset / resamplingRate);
                } else {
                    segmentTime -= (segmentOffset / resamplingRate);
                }
                  // randomize segment position
                if (this.positionVar > 0)
                    segmentPosition += 2.0 * (Math.random() - 0.5) * this.positionVar;
                  // shorten duration of segments over the edges of the buffer
                if (segmentPosition < 0) {
                    //segmentTime -= grainPosition; hm, not sure if we want to do this
                    segmentDuration += segmentPosition;
                    segmentPosition = 0;
                }
                  if (segmentPosition + segmentDuration > this.buffer.duration)
                    segmentDuration = this.buffer.duration - segmentPosition;
                  segmentDuration /= resamplingRate;
                  // make segment
                if (this.gain > 0 && segmentDuration > 0) {
                  // make segment envelope
                  var envelope = audioContext.createGain();
                  var attack = this.attackAbs + this.attackRel * segmentDuration;
                  var release = this.releaseAbs + this.releaseRel * segmentDuration;
                    if (attack + release > segmentDuration) {
                    var factor = segmentDuration / (attack + release);
                    attack *= factor;
                    release *= factor;
                  }
                    var attackEndTime = segmentTime + attack;
                  var segmentEndTime = segmentTime + segmentDuration;
                  var releaseStartTime = segmentEndTime - release;
                    envelope.gain.value = 0;
                  envelope.gain.setValueAtTime(0.0, segmentTime);
                  envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);
                    if (releaseStartTime > attackEndTime)
                    envelope.gain.setValueAtTime(this.gain, releaseStartTime);
                    envelope.gain.linearRampToValueAtTime(0.0, segmentEndTime);
                  envelope.connect(this.outputNode);
                    // make source
                  var source = audioContext.createBufferSource();
                    source.buffer = this.buffer;
                  source.playbackRate.value = resamplingRate;
                  source.connect(envelope);
                    source.start(segmentTime, segmentPosition);
                  source.stop(segmentTime + segmentDuration);
                }*/
            }

            if (this.callback && Object.prototype.toString.call(this.callback) == '[object Function]') {
                var result = this.callback(segmentIndex);
                //if (result)
                //    console.log(result);
            }

            //console.log("Sequencer.Trigger: " + segmentIndex + " Position: " + segmentPosition);

            // grain period randon variation
            if (this.periodVar > 0.0) segmentPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

            return Math.max(this.periodMin, segmentPeriod);
        }
    }]);
    return SequencerEngine;
}(_segmentEngine2.default);

exports.default = SequencerEngine;

},{"../core/audio-time-engine":2,"./segment-engine":10,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _audioContext = require('./core/audio-context');

Object.defineProperty(exports, 'audioContext', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioContext).default;
  }
});

var _timeEngine = require('./core/time-engine');

Object.defineProperty(exports, 'TimeEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_timeEngine).default;
  }
});

var _audioTimeEngine = require('./core/audio-time-engine');

Object.defineProperty(exports, 'AudioTimeEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioTimeEngine).default;
  }
});

var _priorityQueue = require('./core/priority-queue');

Object.defineProperty(exports, 'PriorityQueue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_priorityQueue).default;
  }
});

var _schedulingQueue = require('./core/scheduling-queue');

Object.defineProperty(exports, 'SchedulingQueue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_schedulingQueue).default;
  }
});

var _granularEngine = require('./engines/granular-engine');

Object.defineProperty(exports, 'GranularEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_granularEngine).default;
  }
});

var _metronome = require('./engines/metronome');

Object.defineProperty(exports, 'Metronome', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_metronome).default;
  }
});

var _playerEngine = require('./engines/player-engine');

Object.defineProperty(exports, 'PlayerEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_playerEngine).default;
  }
});

var _segmentEngine = require('./engines/segment-engine');

Object.defineProperty(exports, 'SegmentEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_segmentEngine).default;
  }
});

var _sequencerEngine = require('./engines/sequencer-engine');

Object.defineProperty(exports, 'SequencerEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sequencerEngine).default;
  }
});

var _phasevocoderEngine = require('./engines/phasevocoder-engine');

Object.defineProperty(exports, 'PhasevocoderEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_phasevocoderEngine).default;
  }
});

var _playControl = require('./masters/play-control');

Object.defineProperty(exports, 'PlayControl', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_playControl).default;
  }
});

var _transport = require('./masters/transport');

Object.defineProperty(exports, 'Transport', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_transport).default;
  }
});

var _scheduler = require('./masters/scheduler');

Object.defineProperty(exports, 'Scheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_scheduler).default;
  }
});

var _simpleScheduler = require('./masters/simple-scheduler');

Object.defineProperty(exports, 'SimpleScheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_simpleScheduler).default;
  }
});

var _factories = require('./masters/factories');

Object.defineProperty(exports, 'getScheduler', {
  enumerable: true,
  get: function get() {
    return _factories.getScheduler;
  }
});
Object.defineProperty(exports, 'getSimpleScheduler', {
  enumerable: true,
  get: function get() {
    return _factories.getSimpleScheduler;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./core/audio-context":1,"./core/audio-time-engine":2,"./core/priority-queue":3,"./core/scheduling-queue":4,"./core/time-engine":5,"./engines/granular-engine":6,"./engines/metronome":7,"./engines/phasevocoder-engine":8,"./engines/player-engine":9,"./engines/segment-engine":10,"./engines/sequencer-engine":11,"./masters/factories":13,"./masters/play-control":14,"./masters/scheduler":15,"./masters/simple-scheduler":16,"./masters/transport":17}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSimpleScheduler = exports.getScheduler = undefined;

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _scheduler = require('./scheduler');

var _scheduler2 = _interopRequireDefault(_scheduler);

var _simpleScheduler = require('./simple-scheduler');

var _simpleScheduler2 = _interopRequireDefault(_simpleScheduler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var schedulerMap = new _weakMap2.default(); // schedulers should be singletons

var simpleSchedulerMap = new _weakMap2.default();

/**
 * Returns a unique instance of `Scheduler`
 *
 * @global
 * @function
 * @returns {Scheduler}
 * @see Scheduler
 */
var getScheduler = exports.getScheduler = function getScheduler() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;

  var scheduler = schedulerMap.get(audioContext);

  if (!scheduler) {
    scheduler = new _scheduler2.default({ audioContext: audioContext });
    schedulerMap.set(audioContext, scheduler);
  }

  return scheduler;
};

/**
 * Returns a unique instance of `SimpleScheduler`
 *
 * @global
 * @function
 * @returns {SimpleScheduler}
 * @see SimpleScheduler
 */
var getSimpleScheduler = exports.getSimpleScheduler = function getSimpleScheduler() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;

  var simpleScheduler = simpleSchedulerMap.get(audioContext);

  if (!simpleScheduler) {
    simpleScheduler = new _simpleScheduler2.default({ audioContext: audioContext });
    simpleSchedulerMap.set(audioContext, simpleScheduler);
  }

  return simpleScheduler;
};

},{"../core/audio-context":1,"./scheduler":15,"./simple-scheduler":16,"babel-runtime/core-js/weak-map":32}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _factories = require('./factories');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EPSILON = 1e-8;

var LoopControl = function (_TimeEngine) {
  (0, _inherits3.default)(LoopControl, _TimeEngine);

  function LoopControl(playControl) {
    (0, _classCallCheck3.default)(this, LoopControl);

    var _this = (0, _possibleConstructorReturn3.default)(this, (LoopControl.__proto__ || (0, _getPrototypeOf2.default)(LoopControl)).call(this));

    _this.__playControl = playControl;
    _this.speed = 1;
    _this.lower = -Infinity;
    _this.upper = Infinity;
    return _this;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(LoopControl, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var playControl = this.__playControl;
      var speed = this.speed;
      var lower = this.lower;
      var upper = this.upper;

      if (speed > 0) time += EPSILON;else time -= EPSILON;

      if (speed > 0) {
        playControl.syncSpeed(time, lower, speed, true);
        return playControl.__getTimeAtPosition(upper) - EPSILON;
      } else if (speed < 0) {
        playControl.syncSpeed(time, upper, speed, true);
        return playControl.__getTimeAtPosition(lower) + EPSILON;
      }

      return Infinity;
    }
  }, {
    key: 'reschedule',
    value: function reschedule(speed) {
      var playControl = this.__playControl;
      var lower = Math.min(playControl.__loopStart, playControl.__loopEnd);
      var upper = Math.max(playControl.__loopStart, playControl.__loopEnd);

      this.speed = speed;
      this.lower = lower;
      this.upper = upper;

      if (lower === upper) speed = 0;

      if (speed > 0) this.resetTime(playControl.__getTimeAtPosition(upper) - EPSILON);else if (speed < 0) this.resetTime(playControl.__getTimeAtPosition(lower) + EPSILON);else this.resetTime(Infinity);
    }
  }, {
    key: 'applyLoopBoundaries',
    value: function applyLoopBoundaries(position, speed) {
      var lower = this.lower;
      var upper = this.upper;

      if (speed > 0 && position >= upper) return lower + (position - lower) % (upper - lower);else if (speed < 0 && position < lower) return upper - (upper - position) % (upper - lower);

      return position;
    }
  }]);
  return LoopControl;
}(_timeEngine2.default);

// play controlled base class


var PlayControlled = function () {
  function PlayControlled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlled);

    this.__playControl = playControl;

    engine.master = this;
    this.__engine = engine;
  }

  (0, _createClass3.default)(PlayControlled, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      this.__engine.syncSpeed(time, position, speed, seek);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__playControl = null;

      this.__engine.master = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlled;
}();

// play control for engines implementing the *speed-controlled* interface


var PlayControlledSpeedControlled = function (_PlayControlled) {
  (0, _inherits3.default)(PlayControlledSpeedControlled, _PlayControlled);

  function PlayControlledSpeedControlled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSpeedControlled);
    return (0, _possibleConstructorReturn3.default)(this, (PlayControlledSpeedControlled.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSpeedControlled)).call(this, playControl, engine));
  }

  return PlayControlledSpeedControlled;
}(PlayControlled);

// play control for engines implmenting the *transported* interface


var PlayControlledTransported = function (_PlayControlled2) {
  (0, _inherits3.default)(PlayControlledTransported, _PlayControlled2);

  function PlayControlledTransported(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledTransported);

    var _this3 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledTransported.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledTransported)).call(this, playControl, engine));

    _this3.__schedulerHook = new PlayControlledSchedulerHook(playControl, engine);
    return _this3;
  }

  (0, _createClass3.default)(PlayControlledTransported, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      if (speed !== lastSpeed || seek && speed !== 0) {
        var nextPosition;

        // resync transported engines
        if (seek || speed * lastSpeed < 0) {
          // seek or reverse direction
          nextPosition = this.__engine.syncPosition(time, position, speed);
        } else if (lastSpeed === 0) {
          // start
          nextPosition = this.__engine.syncPosition(time, position, speed);
        } else if (speed === 0) {
          // stop
          nextPosition = Infinity;

          if (this.__engine.syncSpeed) this.__engine.syncSpeed(time, position, 0);
        } else if (this.__engine.syncSpeed) {
          // change speed without reversing direction
          this.__engine.syncSpeed(time, position, speed);
        }

        this.__schedulerHook.resetPosition(nextPosition);
      }
    }
  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(engine) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (position === undefined) {
        var playControl = this.__playControl;
        var time = playControl.__sync();

        position = this.__engine.syncPosition(time, playControl.__position, playControl.__speed);
      }

      this.__schedulerHook.resetPosition(position);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__schedulerHook.destroy();
      this.__schedulerHook = null;

      (0, _get3.default)(PlayControlledTransported.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledTransported.prototype), 'destroy', this).call(this);
    }
  }]);
  return PlayControlledTransported;
}(PlayControlled);

// play control for time engines implementing the *scheduled* interface


var PlayControlledScheduled = function (_PlayControlled3) {
  (0, _inherits3.default)(PlayControlledScheduled, _PlayControlled3);

  function PlayControlledScheduled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledScheduled);

    // scheduling queue becomes master of engine
    var _this4 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledScheduled.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledScheduled)).call(this, playControl, engine));

    engine.master = null;
    _this4.__schedulingQueue = new PlayControlledSchedulingQueue(playControl, engine);
    return _this4;
  }

  (0, _createClass3.default)(PlayControlledScheduled, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      if (lastSpeed === 0 && speed !== 0) // start or seek
        this.__engine.resetTime();else if (lastSpeed !== 0 && speed === 0) // stop
        this.__engine.resetTime(Infinity);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__schedulingQueue.destroy();
      (0, _get3.default)(PlayControlledScheduled.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledScheduled.prototype), 'destroy', this).call(this);
    }
  }]);
  return PlayControlledScheduled;
}(PlayControlled);

// translates transported engine advancePosition into global scheduler times


var PlayControlledSchedulerHook = function (_TimeEngine2) {
  (0, _inherits3.default)(PlayControlledSchedulerHook, _TimeEngine2);

  function PlayControlledSchedulerHook(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSchedulerHook);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledSchedulerHook.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSchedulerHook)).call(this));

    _this5.__playControl = playControl;
    _this5.__engine = engine;

    _this5.__nextPosition = Infinity;
    playControl.__scheduler.add(_this5, Infinity);
    return _this5;
  }

  (0, _createClass3.default)(PlayControlledSchedulerHook, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var playControl = this.__playControl;
      var engine = this.__engine;
      var position = this.__nextPosition;
      var nextPosition = engine.advancePosition(time, position, playControl.__speed);
      var nextTime = playControl.__getTimeAtPosition(nextPosition);

      this.__nextPosition = nextPosition;
      return nextTime;
    }
  }, {
    key: 'resetPosition',
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__nextPosition;

      var time = this.__playControl.__getTimeAtPosition(position);
      this.__nextPosition = position;
      this.resetTime(time);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__playControl.__scheduler.remove(this);
      this.__playControl = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlledSchedulerHook;
}(_timeEngine2.default);

// internal scheduling queue that returns the current position (and time) of the play control


var PlayControlledSchedulingQueue = function (_SchedulingQueue) {
  (0, _inherits3.default)(PlayControlledSchedulingQueue, _SchedulingQueue);

  function PlayControlledSchedulingQueue(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSchedulingQueue);

    var _this6 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledSchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSchedulingQueue)).call(this));

    _this6.__playControl = playControl;
    _this6.__engine = engine;

    _this6.add(engine, Infinity);
    playControl.__scheduler.add(_this6, Infinity);
    return _this6;
  }

  (0, _createClass3.default)(PlayControlledSchedulingQueue, [{
    key: 'destroy',
    value: function destroy() {
      this.__playControl.__scheduler.remove(this);
      this.remove(this.__engine);

      this.__playControl = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlledSchedulingQueue;
}(_schedulingQueue2.default);

/**
 * Extends Time Engine to provide playback control of a Time Engine instance.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/play-control.html}
 *
 * @extends TimeEngine
 * @param {TimeEngine} engine - engine to control
 *
 * @example
 * import * as audio from 'waves-audio';
 * const playerEngine = audio.PlayerEngine();
 * const playControl = new audio.PlayControl(playerEngine);
 *
 * playControl.start();
 */


var PlayControl = function (_TimeEngine3) {
  (0, _inherits3.default)(PlayControl, _TimeEngine3);

  function PlayControl(engine) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, PlayControl);

    var _this7 = (0, _possibleConstructorReturn3.default)(this, (PlayControl.__proto__ || (0, _getPrototypeOf2.default)(PlayControl)).call(this));

    _this7.audioContext = options.audioContext || _audioContext2.default;
    _this7.__scheduler = (0, _factories.getScheduler)(_this7.audioContext);

    _this7.__playControlled = null;

    _this7.__loopControl = null;
    _this7.__loopStart = 0;
    _this7.__loopEnd = 1;

    // synchronized tie, position, and speed
    _this7.__time = 0;
    _this7.__position = 0;
    _this7.__speed = 0;

    // non-zero "user" speed
    _this7.__playingSpeed = 1;

    if (engine) _this7.__setEngine(engine);
    return _this7;
  }

  (0, _createClass3.default)(PlayControl, [{
    key: '__setEngine',
    value: function __setEngine(engine) {
      if (engine.master) throw new Error("object has already been added to a master");

      if (_timeEngine2.default.implementsSpeedControlled(engine)) this.__playControlled = new PlayControlledSpeedControlled(this, engine);else if (_timeEngine2.default.implementsTransported(engine)) this.__playControlled = new PlayControlledTransported(this, engine);else if (_timeEngine2.default.implementsScheduled(engine)) this.__playControlled = new PlayControlledScheduled(this, engine);else throw new Error("object cannot be added to play control");
    }
  }, {
    key: '__resetEngine',
    value: function __resetEngine() {
      this.__playControlled.destroy();
      this.__playControlled = null;
    }

    /**
     * Calculate/extrapolate playing time for given position
     *
     * @param {Number} position position
     * @return {Number} extrapolated time
     * @private
     */

  }, {
    key: '__getTimeAtPosition',
    value: function __getTimeAtPosition(position) {
      return this.__time + (position - this.__position) / this.__speed;
    }

    /**
     * Calculate/extrapolate playing position for given time
     *
     * @param {Number} time time
     * @return {Number} extrapolated position
     * @private
     */

  }, {
    key: '__getPositionAtTime',
    value: function __getPositionAtTime(time) {
      return this.__position + (time - this.__time) * this.__speed;
    }
  }, {
    key: '__sync',
    value: function __sync() {
      var now = this.currentTime;
      this.__position += (now - this.__time) * this.__speed;
      this.__time = now;
      return now;
    }

    /**
     * Get current master time.
     * This function will be replaced when the play-control is added to a master.
     *
     * @name currentTime
     * @type {Number}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'set',
    value: function set() {
      var engine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var time = this.__sync();
      var speed = this.__speed;

      if (this.__playControlled !== null && this.__playControlled.__engine !== engine) {

        this.syncSpeed(time, this.__position, 0);

        if (this.__playControlled) this.__resetEngine();

        if (this.__playControlled === null && engine !== null) {
          this.__setEngine(engine);

          if (speed !== 0) this.syncSpeed(time, this.__position, speed);
        }
      }
    }

    /**
     * Sets the play control loop behavior.
     *
     * @type {Boolean}
     * @name loop
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'setLoopBoundaries',


    /**
     * Sets loop start and end time.
     *
     * @param {Number} loopStart - loop start value.
     * @param {Number} loopEnd - loop end value.
     */
    value: function setLoopBoundaries(loopStart, loopEnd) {
      this.__loopStart = loopStart;
      this.__loopEnd = loopEnd;

      this.loop = this.loop;
    }

    /**
     * Sets loop start value
     *
     * @type {Number}
     * @name loopStart
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'syncSpeed',


    // TimeEngine method (speed-controlled interface)
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      if (speed !== lastSpeed || seek) {
        if ((seek || lastSpeed === 0) && this.__loopControl) position = this.__loopControl.applyLoopBoundaries(position, speed);

        this.__time = time;
        this.__position = position;
        this.__speed = speed;

        if (this.__playControlled) this.__playControlled.syncSpeed(time, position, speed, seek, lastSpeed);

        if (this.__loopControl) this.__loopControl.reschedule(speed);
      }
    }

    /**
     * Starts playback
     */

  }, {
    key: 'start',
    value: function start() {
      var time = this.__sync();
      this.syncSpeed(time, this.__position, this.__playingSpeed);
    }

    /**
     * Pauses playback and stays at the same position.
     */

  }, {
    key: 'pause',
    value: function pause() {
      var time = this.__sync();
      this.syncSpeed(time, this.__position, 0);
    }

    /**
     * Stops playback and seeks to initial (0) position.
     */

  }, {
    key: 'stop',
    value: function stop() {
      var time = this.__sync();
      this.syncSpeed(time, 0, 0, true);
    }

    /**
     * If speed if provided, sets the playback speed. The speed value should
     * be non-zero between -16 and -1/16 or between 1/16 and 16.
     *
     * @type {Number}
     * @name speed
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'seek',


    /**
     * Set (jump to) playing position.
     *
     * @param {Number} position target position
     */
    value: function seek(position) {
      var time = this.__sync();
      this.__position = position;
      this.syncSpeed(time, position, this.__speed, true);
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__scheduler.currentTime;
    }

    /**
     * Get current master position.
     * This function will be replaced when the play-control is added to a master.
     *
     * @name currentPosition
     * @type {Number}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__position + (this.__scheduler.currentTime - this.__time) * this.__speed;
    }

    /**
     * Returns if the play control is runnin g.
     *
     * @name running
     * @type {Boolean}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'running',
    get: function get() {
      return !(this.__speed === 0);
    }
  }, {
    key: 'loop',
    set: function set(enable) {
      if (enable && this.__loopStart > -Infinity && this.__loopEnd < Infinity) {
        if (!this.__loopControl) {
          this.__loopControl = new LoopControl(this);
          this.__scheduler.add(this.__loopControl, Infinity);
        }

        if (this.__speed !== 0) {
          var position = this.currentPosition;
          var lower = Math.min(this.__loopStart, this.__loopEnd);
          var upper = Math.max(this.__loopStart, this.__loopEnd);

          if (this.__speed > 0 && position > upper) this.seek(upper);else if (this.__speed < 0 && position < lower) this.seek(lower);else this.__loopControl.reschedule(this.__speed);
        }
      } else if (this.__loopControl) {
        this.__scheduler.remove(this.__loopControl);
        this.__loopControl = null;
      }
    },
    get: function get() {
      return !!this.__loopControl;
    }
  }, {
    key: 'loopStart',
    set: function set(loopStart) {
      this.setLoopBoundaries(loopStart, this.__loopEnd);
    },
    get: function get() {
      return this.__loopStart;
    }

    /**
     * Sets loop end value
     *
     * @type {Number}
     * @name loopEnd
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'loopEnd',
    set: function set(loopEnd) {
      this.setLoopBoundaries(this.__loopStart, loopEnd);
    },
    get: function get() {
      return this.__loopEnd;
    }
  }, {
    key: 'speed',
    set: function set(speed) {
      var time = this.__sync();

      if (speed >= 0) {
        if (speed < 0.01) speed = 0.01;else if (speed > 100) speed = 100;
      } else {
        if (speed < -100) speed = -100;else if (speed > -0.01) speed = -0.01;
      }

      this.__playingSpeed = speed;

      if (!this.master && this.__speed !== 0) this.syncSpeed(time, this.__position, speed);
    },
    get: function get() {
      return this.__playingSpeed;
    }
  }]);
  return PlayControl;
}(_timeEngine2.default);

exports.default = PlayControl;

},{"../core/audio-context":1,"../core/scheduling-queue":4,"../core/time-engine":5,"./factories":13,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('wavesjs:audio');

/**
 * The `Scheduler` class implements a master for `TimeEngine` or `AudioTimeEngine`
 * instances that implement the *scheduled* interface such as the `Metronome`
 * `GranularEngine`.
 *
 * A `Scheduler` can also schedule simple callback functions.
 * The class is based on recursive calls to `setTimeOut` and uses the
 * `audioContext.currentTime` as logical passed to the `advanceTime` methods
 * of the scheduled engines or to the scheduled callback functions.
 * It extends the `SchedulingQueue` class that itself includes a `PriorityQueue`
 * to assure the order of the scheduled engines (see `SimpleScheduler` for a
 * simplified scheduler implementation without `PriorityQueue`).
 *
 * To get a unique instance of `Scheduler` as the global scheduler of an
 * application, the `getScheduler` factory function should be used. The
 * function accepts an audio context as optional argument and uses the Waves
 * default audio context (see `audioContext`) as
 * default. The factory creates a single scheduler for each audio context.
 *
 * Example that shows three Metronome engines running in a Scheduler:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/scheduler.html}
 *
 * @param {Object} [options={}] - default options
 * @param {Number} [options.period=0.025] - period of the scheduler.
 * @param {Number} [options.lookahead=0.1] - lookahead of the scheduler.
 *
 * @see TimeEngine
 * @see AudioTimeEngine
 * @see getScheduler
 * @see SimpleScheduler
 *
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 *
 * scheduler.add(myEngine);
 */

var Scheduler = function (_SchedulingQueue) {
  (0, _inherits3.default)(Scheduler, _SchedulingQueue);

  function Scheduler() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Scheduler);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Scheduler.__proto__ || (0, _getPrototypeOf2.default)(Scheduler)).call(this));

    _this.audioContext = options.audioContext || _audioContext2.default;

    _this.__currentTime = null;
    _this.__nextTime = Infinity;
    _this.__timeout = null;

    /**
     * scheduler (setTimeout) period
     * @type {Number}
     * @name period
     * @memberof Scheduler
     * @instance
     */
    _this.period = options.period || 0.025;

    /**
     * scheduler lookahead time (> period)
     * @type {Number}
     * @name lookahead
     * @memberof Scheduler
     * @instance
     */
    _this.lookahead = options.lookahead || 0.1;
    return _this;
  }

  // setTimeout scheduling loop


  (0, _createClass3.default)(Scheduler, [{
    key: '__tick',
    value: function __tick() {
      var audioContext = this.audioContext;
      var currentTime = audioContext.currentTime;
      var time = this.__nextTime;

      this.__timeout = null;

      while (time <= currentTime + this.lookahead) {
        this.__currentTime = time;
        time = this.advanceTime(time);
      }

      this.__currentTime = null;
      this.resetTime(time);
    }
  }, {
    key: 'resetTime',
    value: function resetTime() {
      var _this2 = this;

      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentTime;

      if (this.master) {
        this.master.reset(this, time);
      } else {
        if (this.__timeout) {
          clearTimeout(this.__timeout);
          this.__timeout = null;
        }

        if (time !== Infinity) {
          if (this.__nextTime === Infinity) log('Scheduler Start');

          var timeOutDelay = Math.max(time - this.lookahead - this.audioContext.currentTime, this.period);

          this.__timeout = setTimeout(function () {
            _this2.__tick();
          }, Math.ceil(timeOutDelay * 1000));
        } else if (this.__nextTime !== Infinity) {
          log('Scheduler Stop');
        }

        this.__nextTime = time;
      }
    }

    /**
     * Scheduler current logical time.
     *
     * @name currentTime
     * @type {Number}
     * @memberof Scheduler
     * @instance
     */

  }, {
    key: 'currentTime',
    get: function get() {
      if (this.master) return this.master.currentTime;

      return this.__currentTime || this.audioContext.currentTime + this.lookahead;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return undefined;
    }

    // inherited from scheduling queue
    /**
     * Add a TimeEngine or a simple callback function to the scheduler at an
     * optionally given time. Whether the add method is called with a TimeEngine
     * or a callback function it returns a TimeEngine that can be used as argument
     * of the methods remove and resetEngineTime. A TimeEngine added to a scheduler
     * has to implement the scheduled interface. The callback function added to a
     * scheduler will be called at the given time and with the given time as
     * argument. The callback can return a new scheduling time (i.e. the next
     * time when it will be called) or it can return Infinity to suspend scheduling
     * without removing the function from the scheduler. A function that does
     * not return a value (or returns null or 0) is removed from the scheduler
     * and cannot be used as argument of the methods remove and resetEngineTime
     * anymore.
     *
     * @name add
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine|Function} engine - Engine to add to the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    /**
     * Remove a TimeEngine from the scheduler that has been added to the
     * scheduler using the add method.
     *
     * @name add
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine} engine - Engine to remove from the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    /**
     * Reschedule a scheduled time engine at a given time.
     *
     * @name resetEngineTime
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine} engine - Engine to reschedule
     * @param {Number} time - Schedule time
     */
    /**
     * Remove all scheduled callbacks and engines from the scheduler.
     *
     * @name clear
     * @function
     * @memberof Scheduler
     * @instance
     */

  }]);
  return Scheduler;
}(_schedulingQueue2.default);

exports.default = Scheduler;

},{"../core/audio-context":1,"../core/scheduling-queue":4,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"debug":148}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('wavesjs:audio');

/**
 *
 *
 *
 * The SimpleScheduler class implements a simplified master for time engines
 * (see TimeEngine or AudioTimeEngine) that implement the scheduled interface
 * such as the Metronome and the GranularEngine. The API and funtionalities of
 * the SimpleScheduler class are identical to the Scheduler class. But, other
 * than the Scheduler, the SimpleScheduler class does not guarantee the order
 * of events (i.e. calls to the advanceTime method of scheduled time engines
 * and to scheduled callback functions) within a scheduling period (see period
 * attribute).
 *
 * To get a unique instance of SimpleScheduler as the global scheduler of an
 * application, the getSimpleScheduler factory function should be used. The
 * function accepts an audio context as optional argument and uses the Waves
 * default audio context (see Audio Context) as default. The factory creates
 * a single (simple) scheduler for each audio context.
 *
 * Example that shows three Metronome engines running in a SimpleScheduler:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/simple-scheduler.html}
 *
 * @param {Object} [options={}] - default options
 * @param {Number} [options.period=0.025] - period of the scheduler.
 * @param {Number} [options.lookahead=0.1] - lookahead of the scheduler.
 *
 * @see TimeEngine
 * @see AudioTimeEngine
 * @see getSimpleScheduler
 * @see Scheduler
 *
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getSimpleScheduler();
 *
 * scheduler.add(myEngine);
 */

var SimpleScheduler = function () {
  function SimpleScheduler() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SimpleScheduler);

    this.audioContext = options.audioContext || _audioContext2.default;

    this.__engines = new _set2.default();

    this.__schedEngines = [];
    this.__schedTimes = [];

    this.__currentTime = null;
    this.__timeout = null;

    /**
     * scheduler (setTimeout) period
     * @type {Number}
     * @name period
     * @memberof Scheduler
     * @instance
     */
    this.period = options.period || 0.025;

    /**
     * scheduler lookahead time (> period)
     * @type {Number}
     * @name lookahead
     * @memberof Scheduler
     * @instance
     */
    this.lookahead = options.lookahead || 0.1;
  }

  (0, _createClass3.default)(SimpleScheduler, [{
    key: '__scheduleEngine',
    value: function __scheduleEngine(engine, time) {
      this.__schedEngines.push(engine);
      this.__schedTimes.push(time);
    }
  }, {
    key: '__rescheduleEngine',
    value: function __rescheduleEngine(engine, time) {
      var index = this.__schedEngines.indexOf(engine);

      if (index >= 0) {
        if (time !== Infinity) {
          this.__schedTimes[index] = time;
        } else {
          this.__schedEngines.splice(index, 1);
          this.__schedTimes.splice(index, 1);
        }
      } else if (time < Infinity) {
        this.__schedEngines.push(engine);
        this.__schedTimes.push(time);
      }
    }
  }, {
    key: '__unscheduleEngine',
    value: function __unscheduleEngine(engine) {
      var index = this.__schedEngines.indexOf(engine);

      if (index >= 0) {
        this.__schedEngines.splice(index, 1);
        this.__schedTimes.splice(index, 1);
      }
    }
  }, {
    key: '__resetTick',
    value: function __resetTick() {
      if (this.__schedEngines.length > 0) {
        if (!this.__timeout) {
          log('SimpleScheduler Start');
          this.__tick();
        }
      } else if (this.__timeout) {
        log('SimpleScheduler Stop');
        clearTimeout(this.__timeout);
        this.__timeout = null;
      }
    }
  }, {
    key: '__tick',
    value: function __tick() {
      var _this = this;

      var audioContext = this.audioContext;
      var currentTime = audioContext.currentTime;
      var i = 0;

      while (i < this.__schedEngines.length) {
        var engine = this.__schedEngines[i];
        var time = this.__schedTimes[i];

        while (time && time <= currentTime + this.lookahead) {
          time = Math.max(time, currentTime);
          this.__currentTime = time;
          time = engine.advanceTime(time);
        }

        if (time && time < Infinity) {
          this.__schedTimes[i++] = time;
        } else {
          this.__unscheduleEngine(engine);

          // remove engine from scheduler
          if (!time) {
            engine.master = null;
            this.__engines.delete(engine);
          }
        }
      }

      this.__currentTime = null;
      this.__timeout = null;

      if (this.__schedEngines.length > 0) {
        this.__timeout = setTimeout(function () {
          _this.__tick();
        }, this.period * 1000);
      }
    }

    /**
     * Scheduler current logical time.
     *
     * @name currentTime
     * @type {Number}
     * @memberof Scheduler
     * @instance
     */

  }, {
    key: 'defer',


    // call a function at a given time
    /**
     * Defer the execution of a function at a given time.
     *
     * @param {Function} fun - Function to defer
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    value: function defer(fun) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!(fun instanceof Function)) throw new Error("object cannot be defered by scheduler");

      this.add({
        advanceTime: function advanceTime(time) {
          fun(time);
        } // make sur that the advanceTime method does not returm anything
      }, time);
    }

    /**
     * Add a TimeEngine function to the scheduler at an optionally given time.
     *
     * @param {TimeEngine} engine - Engine to add to the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */

  }, {
    key: 'add',
    value: function add(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!_timeEngine2.default.implementsScheduled(engine)) throw new Error("object cannot be added to scheduler");

      if (engine.master) throw new Error("object has already been added to a master");

      // set master and add to array
      engine.master = this;
      this.__engines.add(engine);

      // schedule engine
      this.__scheduleEngine(engine, time);
      this.__resetTick();
    }

    /**
     * Remove a TimeEngine from the scheduler that has been added to the
     * scheduler using the add method.
     *
     * @param {TimeEngine} engine - Engine to remove from the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */

  }, {
    key: 'remove',
    value: function remove(engine) {
      if (!engine.master || engine.master !== this) throw new Error("engine has not been added to this scheduler");

      // reset master and remove from array
      engine.master = null;
      this.__engines.delete(engine);

      // unschedule engine
      this.__unscheduleEngine(engine);
      this.__resetTick();
    }

    /**
     * Reschedule a scheduled time engine at a given time.
     *
     * @param {TimeEngine} engine - Engine to reschedule
     * @param {Number} time - Schedule time
     */

  }, {
    key: 'resetEngineTime',
    value: function resetEngineTime(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      this.__rescheduleEngine(engine, time);
      this.__resetTick();
    }

    /**
     * Check whether a given engine is scheduled.
     *
     * @param {TimeEngine} engine - Engine to check
     */

  }, {
    key: 'has',
    value: function has(engine) {
      return this.__engines.has(engine);
    }

    /**
     * Remove all engines from the scheduler.
     */

  }, {
    key: 'clear',
    value: function clear() {
      if (this.__timeout) {
        clearTimeout(this.__timeout);
        this.__timeout = null;
      }

      this.__schedEngines.length = 0;
      this.__schedTimes.length = 0;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__currentTime || this.audioContext.currentTime + this.lookahead;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return undefined;
    }
  }]);
  return SimpleScheduler;
}();

exports.default = SimpleScheduler;

},{"../core/audio-context":1,"../core/time-engine":5,"babel-runtime/core-js/set":29,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"debug":148}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _priorityQueue = require('../core/priority-queue');

var _priorityQueue2 = _interopRequireDefault(_priorityQueue);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _factories = require('./factories');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addDuplet(firstArray, secondArray, firstElement, secondElement) {
  firstArray.push(firstElement);
  secondArray.push(secondElement);
}

function removeDuplet(firstArray, secondArray, firstElement) {
  var index = firstArray.indexOf(firstElement);

  if (index >= 0) {
    var secondElement = secondArray[index];

    firstArray.splice(index, 1);
    secondArray.splice(index, 1);

    return secondElement;
  }

  return null;
}

// The Transported call is the base class of the adapters between
// different types of engines (i.e. transported, scheduled, play-controlled)
// The adapters are at the same time masters for the engines added to the transport
// and transported TimeEngines inserted into the transport's position-based pritority queue.

var Transported = function (_TimeEngine) {
  (0, _inherits3.default)(Transported, _TimeEngine);

  function Transported(transport, engine, start, duration, offset) {
    var stretch = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    (0, _classCallCheck3.default)(this, Transported);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Transported.__proto__ || (0, _getPrototypeOf2.default)(Transported)).call(this));

    _this.master = transport;

    _this.__engine = engine;
    engine.master = _this;

    _this.__startPosition = start;
    _this.__endPosition = !isFinite(duration) ? Infinity : start + duration;
    _this.__offsetPosition = start + offset;
    _this.__stretchPosition = stretch;
    _this.__isRunning = false;
    return _this;
  }

  (0, _createClass3.default)(Transported, [{
    key: 'setBoundaries',
    value: function setBoundaries(start, duration) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var stretch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      this.__startPosition = start;
      this.__endPosition = start + duration;
      this.__offsetPosition = start + offset;
      this.__stretchPosition = stretch;
      this.resetPosition();
    }
  }, {
    key: 'start',
    value: function start(time, position, speed) {}
  }, {
    key: 'stop',
    value: function stop(time, position) {}
  }, {
    key: 'resetPosition',
    value: function resetPosition(position) {
      if (position !== undefined) position += this.__offsetPosition;

      this.master.resetEnginePosition(this, position);
    }
  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (speed > 0) {
        if (position < this.__startPosition) {

          if (this.__isRunning) this.stop(time, position - this.__offsetPosition);

          this.__isRunning = false;
          return this.__startPosition;
        } else if (position < this.__endPosition) {
          this.start(time, position - this.__offsetPosition, speed);

          this.__isRunning = true;
          return this.__endPosition;
        }
      } else {
        if (position > this.__endPosition) {
          if (this.__isRunning) // if engine is running
            this.stop(time, position - this.__offsetPosition);

          this.__isRunning = false;
          return this.__endPosition;
        } else if (position > this.__startPosition) {
          this.start(time, position - this.__offsetPosition, speed);

          this.__isRunning = true;
          return this.__startPosition;
        }
      }

      if (this.__isRunning) // if engine is running
        this.stop(time, position);

      this.__isRunning = false;
      return Infinity * speed;
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      if (!this.__isRunning) {
        this.start(time, position - this.__offsetPosition, speed);
        this.__isRunning = true;

        if (speed > 0) return this.__endPosition;

        return this.__startPosition;
      }

      // stop engine
      this.stop(time, position - this.__offsetPosition);

      this.__isRunning = false;
      return Infinity * speed;
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (speed === 0) // stop
        this.stop(time, position - this.__offsetPosition);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.master = null;

      this.__engine.master = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.master.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.master.currentPosition - this.__offsetPosition;
    }
  }]);
  return Transported;
}(_timeEngine2.default);

// TransportedTransported
// has to switch on and off the scheduled engines when the transport hits the engine's start and end position


var TransportedTransported = function (_Transported) {
  (0, _inherits3.default)(TransportedTransported, _Transported);

  function TransportedTransported(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedTransported);
    return (0, _possibleConstructorReturn3.default)(this, (TransportedTransported.__proto__ || (0, _getPrototypeOf2.default)(TransportedTransported)).call(this, transport, engine, startPosition, endPosition, offsetPosition));
  }

  (0, _createClass3.default)(TransportedTransported, [{
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (speed > 0 && position < this.__endPosition) position = Math.max(position, this.__startPosition);else if (speed < 0 && position >= this.__startPosition) position = Math.min(position, this.__endPosition);

      return this.__offsetPosition + this.__engine.syncPosition(time, position - this.__offsetPosition, speed);
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      position = this.__offsetPosition + this.__engine.advancePosition(time, position - this.__offsetPosition, speed);

      if (speed > 0 && position < this.__endPosition || speed < 0 && position >= this.__startPosition) return position;

      return Infinity * speed;
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (this.__engine.syncSpeed) this.__engine.syncSpeed(time, position, speed);
    }
  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(engine) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (position !== undefined) position += this.__offsetPosition;

      this.resetPosition(position);
    }
  }]);
  return TransportedTransported;
}(Transported);

// TransportedSpeedControlled
// has to start and stop the speed-controlled engines when the transport hits the engine's start and end position


var TransportedSpeedControlled = function (_Transported2) {
  (0, _inherits3.default)(TransportedSpeedControlled, _Transported2);

  function TransportedSpeedControlled(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedSpeedControlled);
    return (0, _possibleConstructorReturn3.default)(this, (TransportedSpeedControlled.__proto__ || (0, _getPrototypeOf2.default)(TransportedSpeedControlled)).call(this, transport, engine, startPosition, endPosition, offsetPosition));
  }

  (0, _createClass3.default)(TransportedSpeedControlled, [{
    key: 'start',
    value: function start(time, position, speed) {
      this.__engine.syncSpeed(time, position, speed, true);
    }
  }, {
    key: 'stop',
    value: function stop(time, position) {
      this.__engine.syncSpeed(time, position, 0);
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (this.__isRunning) this.__engine.syncSpeed(time, position, speed);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__engine.syncSpeed(this.master.currentTime, this.master.currentPosition - this.__offsetPosition, 0);
      (0, _get3.default)(TransportedSpeedControlled.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedSpeedControlled.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedSpeedControlled;
}(Transported);

// TransportedScheduled
// has to switch on and off the scheduled engines when the transport hits the engine's start and end position


var TransportedScheduled = function (_Transported3) {
  (0, _inherits3.default)(TransportedScheduled, _Transported3);

  function TransportedScheduled(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedScheduled);

    // scheduling queue becomes master of engine
    var _this4 = (0, _possibleConstructorReturn3.default)(this, (TransportedScheduled.__proto__ || (0, _getPrototypeOf2.default)(TransportedScheduled)).call(this, transport, engine, startPosition, endPosition, offsetPosition));

    engine.master = null;
    transport.__schedulingQueue.add(engine, Infinity);
    return _this4;
  }

  (0, _createClass3.default)(TransportedScheduled, [{
    key: 'start',
    value: function start(time, position, speed) {
      this.master.__schedulingQueue.resetEngineTime(this.__engine, time);
    }
  }, {
    key: 'stop',
    value: function stop(time, position) {
      this.master.__schedulingQueue.resetEngineTime(this.__engine, Infinity);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.master.__schedulingQueue.remove(this.__engine);
      (0, _get3.default)(TransportedScheduled.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedScheduled.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedScheduled;
}(Transported);

// translates advancePosition of *transported* engines into global scheduler times


var TransportSchedulerHook = function (_TimeEngine2) {
  (0, _inherits3.default)(TransportSchedulerHook, _TimeEngine2);

  function TransportSchedulerHook(transport) {
    (0, _classCallCheck3.default)(this, TransportSchedulerHook);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (TransportSchedulerHook.__proto__ || (0, _getPrototypeOf2.default)(TransportSchedulerHook)).call(this));

    _this5.__transport = transport;

    _this5.__nextPosition = Infinity;
    _this5.__nextTime = Infinity;
    transport.__scheduler.add(_this5, Infinity);
    return _this5;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(TransportSchedulerHook, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var transport = this.__transport;
      var position = this.__nextPosition;
      var speed = transport.__speed;
      var nextPosition = transport.advancePosition(time, position, speed);
      var nextTime = transport.__getTimeAtPosition(nextPosition);

      this.__nextPosition = nextPosition;
      this.__nextTime = nextTime;

      return nextTime;
    }
  }, {
    key: 'resetPosition',
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__nextPosition;

      var transport = this.__transport;
      var time = transport.__getTimeAtPosition(position);

      this.__nextPosition = position;
      this.__nextTime = time;

      this.resetTime(time);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__transport.__scheduler.remove(this);
      this.__transport = null;
    }
  }]);
  return TransportSchedulerHook;
}(_timeEngine2.default);

// internal scheduling queue that returns the current position (and time) of the play control


var TransportSchedulingQueue = function (_SchedulingQueue) {
  (0, _inherits3.default)(TransportSchedulingQueue, _SchedulingQueue);

  function TransportSchedulingQueue(transport) {
    (0, _classCallCheck3.default)(this, TransportSchedulingQueue);

    var _this6 = (0, _possibleConstructorReturn3.default)(this, (TransportSchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(TransportSchedulingQueue)).call(this));

    _this6.__transport = transport;
    transport.__scheduler.add(_this6, Infinity);
    return _this6;
  }

  (0, _createClass3.default)(TransportSchedulingQueue, [{
    key: 'destroy',
    value: function destroy() {
      this.__transport.__scheduler.remove(this);
      this.__transport = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__transport.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__transport.currentPosition;
    }
  }]);
  return TransportSchedulingQueue;
}(_schedulingQueue2.default);

/**
 * Provides synchronized scheduling of Time Engine instances.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/transport.html}
 *
 * @example
 * import * as audio from 'waves-audio';
 * const transport = audio.Transport();
 * const playControl = new audio.PlayControl(transport);
 * const myEngine = new MyEngine();
 * const yourEngine = new yourEngine();
 *
 * transport.add(myEngine);
 * transport.add(yourEngine);
 *
 * playControl.start();
 */


var Transport = function (_TimeEngine3) {
  (0, _inherits3.default)(Transport, _TimeEngine3);

  function Transport() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Transport);

    var _this7 = (0, _possibleConstructorReturn3.default)(this, (Transport.__proto__ || (0, _getPrototypeOf2.default)(Transport)).call(this));

    _this7.audioContext = options.audioContext || _audioContext2.default;

    _this7.__engines = [];
    _this7.__transported = [];

    _this7.__scheduler = (0, _factories.getScheduler)(_this7.audioContext);
    _this7.__schedulerHook = new TransportSchedulerHook(_this7);
    _this7.__transportedQueue = new _priorityQueue2.default();
    _this7.__schedulingQueue = new TransportSchedulingQueue(_this7);

    // syncronized time, position, and speed
    _this7.__time = 0;
    _this7.__position = 0;
    _this7.__speed = 0;
    return _this7;
  }

  (0, _createClass3.default)(Transport, [{
    key: '__getTimeAtPosition',
    value: function __getTimeAtPosition(position) {
      return this.__time + (position - this.__position) / this.__speed;
    }
  }, {
    key: '__getPositionAtTime',
    value: function __getPositionAtTime(time) {
      return this.__position + (time - this.__time) * this.__speed;
    }
  }, {
    key: '__syncTransportedPosition',
    value: function __syncTransportedPosition(time, position, speed) {
      var numTransportedEngines = this.__transported.length;
      var nextPosition = Infinity * speed;

      if (numTransportedEngines > 0) {
        this.__transportedQueue.clear();
        this.__transportedQueue.reverse = speed < 0;

        for (var i = 0; i < numTransportedEngines; i++) {
          var engine = this.__transported[i];
          var nextEnginePosition = engine.syncPosition(time, position, speed);
          this.__transportedQueue.insert(engine, nextEnginePosition);
        }

        nextPosition = this.__transportedQueue.time;
      }

      return nextPosition;
    }
  }, {
    key: '__syncTransportedSpeed',
    value: function __syncTransportedSpeed(time, position, speed) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.__transported), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var transported = _step.value;

          transported.syncSpeed(time, position, speed);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Get current master time. This getter will be replaced when the transport
     * is added to a master (i.e. transport or play-control).
     *
     * @type {Number}
     * @name currentTime
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'resetPosition',


    /**
     * Reset next transport position
     *
     * @param {Number} next - transport position
     */
    value: function resetPosition(position) {
      var master = this.master;

      if (master && master.resetEnginePosition !== undefined) master.resetEnginePosition(this, position);else this.__schedulerHook.resetPosition(position);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     */

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      this.__time = time;
      this.__position = position;
      this.__speed = speed;

      return this.__syncTransportedPosition(time, position, speed);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     */

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var engine = this.__transportedQueue.head;
      var nextEnginePosition = engine.advancePosition(time, position, speed);
      return this.__transportedQueue.move(engine, nextEnginePosition);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     * @param {Boolean} [seek=false]
     */

  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      this.__time = time;
      this.__position = position;
      this.__speed = speed;

      if (speed !== lastSpeed || seek && speed !== 0) {
        var nextPosition = void 0;

        // resync transported engines
        if (seek || speed * lastSpeed < 0) {
          // seek or reverse direction
          nextPosition = this.__syncTransportedPosition(time, position, speed);
        } else if (lastSpeed === 0) {
          // start
          nextPosition = this.__syncTransportedPosition(time, position, speed);
        } else if (speed === 0) {
          // stop
          nextPosition = Infinity;
          this.__syncTransportedSpeed(time, position, 0);
        } else {
          // change speed without reversing direction
          this.__syncTransportedSpeed(time, position, speed);
        }

        this.resetPosition(nextPosition);
      }
    }

    /**
     * Add a time engine to the transport.
     *
     * @param {Object} engine - engine to be added to the transport
     * @param {Number} position - start position
     */

  }, {
    key: 'add',
    value: function add(engine) {
      var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var endPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
      var offsetPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      var transported = null;

      if (offsetPosition === -Infinity) offsetPosition = 0;

      if (engine.master) throw new Error("object has already been added to a master");

      if (_timeEngine2.default.implementsTransported(engine)) transported = new TransportedTransported(this, engine, startPosition, endPosition, offsetPosition);else if (_timeEngine2.default.implementsSpeedControlled(engine)) transported = new TransportedSpeedControlled(this, engine, startPosition, endPosition, offsetPosition);else if (_timeEngine2.default.implementsScheduled(engine)) transported = new TransportedScheduled(this, engine, startPosition, endPosition, offsetPosition);else throw new Error("object cannot be added to a transport");

      if (transported) {
        var speed = this.__speed;

        addDuplet(this.__engines, this.__transported, engine, transported);

        if (speed !== 0) {
          // sync and start
          var nextEnginePosition = transported.syncPosition(this.currentTime, this.currentPosition, speed);
          var nextPosition = this.__transportedQueue.insert(transported, nextEnginePosition);

          this.resetPosition(nextPosition);
        }
      }

      return transported;
    }

    /**
     * Remove a time engine from the transport.
     *
     * @param {object} engineOrTransported - engine or transported to be removed from the transport
     */

  }, {
    key: 'remove',
    value: function remove(engineOrTransported) {
      var engine = engineOrTransported;
      var transported = removeDuplet(this.__engines, this.__transported, engineOrTransported);

      if (!transported) {
        engine = removeDuplet(this.__transported, this.__engines, engineOrTransported);
        transported = engineOrTransported;
      }

      if (engine && transported) {
        var nextPosition = this.__transportedQueue.remove(transported);

        transported.destroy();

        if (this.__speed !== 0) this.resetPosition(nextPosition);
      } else {
        throw new Error("object has not been added to this transport");
      }
    }

    /**
     * Reset position of the given engine.
     *
     * @param {TimeEngine} transported - Engine to reset
     * @param {Number} position - New position
     */

  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(transported) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      var speed = this.__speed;

      if (speed !== 0) {
        if (position === undefined) position = transported.syncPosition(this.currentTime, this.currentPosition, speed);

        var nextPosition = this.__transportedQueue.move(transported, position);
        this.resetPosition(nextPosition);
      }
    }

    /**
     * Remove all time engines from the transport.
     */

  }, {
    key: 'clear',
    value: function clear() {
      this.syncSpeed(this.currentTime, this.currentPosition, 0);

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this.__transported), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var transported = _step2.value;

          transported.destroy();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__scheduler.currentTime;
    }

    /**
     * Get current master position. This getter will be replaced when the transport
     * is added to a master (i.e. transport or play-control).
     *
     * @type {Number}
     * @name currentPosition
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return this.__position + (this.__scheduler.currentTime - this.__time) * this.__speed;
    }
  }]);
  return Transport;
}(_timeEngine2.default);

exports.default = Transport;

},{"../core/audio-context":1,"../core/priority-queue":3,"../core/scheduling-queue":4,"../core/time-engine":5,"./factories":13,"babel-runtime/core-js/get-iterator":22,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _cbuffer = require('./cbuffer');

var _cbuffer2 = _interopRequireDefault(_cbuffer);

var _dsp = require('./dsp.js');

var _dsp2 = require('./dsp');

var _dsp3 = _interopRequireDefault(_dsp2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PhaseVocoder(winSize, sampleRate) {

	var _sampleRate = sampleRate;var _Hs = 0;var _Ha = 0;var _omega;

	var _previousInputPhase;var _previousOutputPhase;var _framingWindow;

	var _squaredFramingWindow;var _winSize = winSize;

	var _overlapBuffers;var _owOverlapBuffers;

	var _first = true;

	var _overlapFactor = 4;

	var _lastInputAlpha = 1;

	/*****************************************************/
	/******************* dsp.js FFT **********************/
	/*****************************************************/

	var fft = new _dsp.FFT(_winSize, sampleRate);
	/*****************************************************/
	/*****************************************************/
	/*****************************************************/

	var sqrt = Math.sqrt;var cos = Math.cos;
	var sin = Math.sin;var atan2 = Math.atan2;
	var round = Math.round;var max = Math.max;
	var ceil = Math.ceil;var pow = Math.pow;
	var PI = Math.PI;

	/*****************************************************/
	/***************PRE-ALLOCATE MEMORY*******************/
	/*****************************************************/

	//find_peaks
	var _hlfSize = round(_winSize / 2) + 1;

	// // process
	var _process = {
		fftObj: {
			real: new Float32Array(_hlfSize),
			imag: new Float32Array(_hlfSize),
			magnitude: new Float32Array(_hlfSize),
			phase: new Float32Array(_hlfSize)
		},
		pvOut: {
			real: create_constant_array(_winSize, 0, Float32Array),
			imag: create_constant_array(_winSize, 0, Float32Array),
			magnitude: create_constant_array(_winSize, 0, Float32Array),
			phase: create_constant_array(_winSize, 0, Float32Array)
		},
		processedFrame: new Float32Array(_winSize)
	};

	var _pv_step = {
		instPhaseAdv: new Float32Array(_hlfSize),
		phTh: new Float32Array(_hlfSize)
	};

	var _STFT = {
		_inputFrame: new Float32Array(_winSize),
		_zeros: new Float32Array(_winSize)
		/*****************************************************/
		/*****************************************************/
		/*****************************************************/

	};var phTh_idx = 0;
	var twoPI = 2 * PI;
	var expectedPhaseAdv, auxHeterodynedPhaseIncr, heterodynedPhaseIncr, instPhaseAdvPerSampleHop, instPhaseAdv_, prevInstPhaseAdv_;

	function overlap_and_slide(Hs, inF, squaredWinF, oBuf, owOBuf, windowSize, outF) {

		var owSample,
		    oSample = 0;

		for (var i = 0; i < Hs; i++) {
			owSample = owOBuf.shift() || 0;
			oSample = oBuf.shift() || 0;
			outF.push(oSample / (owSample < 10e-3 ? 1 : owSample));
			oBuf.push(0);
			owOBuf.push(0);
		}

		for (var i = 0; i < windowSize; i++) {
			oSample = oBuf.shift();
			oBuf.push(inF[i] + oSample);
			owSample = owOBuf.shift();
			owOBuf.push(squaredWinF[i] + owSample);
		}
	}

	function pv_step(fftObj, prevInPh, prevOutPh, omega, Ha, Hs, out) {

		var currInPh = fftObj.phase;
		var mag = fftObj.magnitude;
		var instPhaseAdv = _pv_step.instPhaseAdv;
		var phTh = _pv_step.phTh;

		var peak, prevPeak, reg, regStart, prevRegEnd, prevRegStart, d, i;
		phTh_idx = 0;

		for (i = 0; i < omega.length; i++) {
			expectedPhaseAdv = omega[i] * Ha;

			auxHeterodynedPhaseIncr = currInPh[i] - prevInPh[i] - expectedPhaseAdv;
			heterodynedPhaseIncr = auxHeterodynedPhaseIncr - twoPI * round(auxHeterodynedPhaseIncr / twoPI);

			instPhaseAdvPerSampleHop = omega[i] + heterodynedPhaseIncr / Ha;

			instPhaseAdv_ = instPhaseAdvPerSampleHop * Hs;

			if (mag[i] > max(mag[i - 2] | 0, mag[i - 1] | 0, mag[i + 1] | 0, mag[i + 2] | 0)) {
				// if (mag[i] > (mag[i-2]|0) && mag[i] > (mag[i-1]|0) && mag[i] > (mag[i+1]|0) && mag[i] > (mag[i+2]|0)) {
				peak = i;
				regStart = ceil((prevPeak + peak) / 2) | 0;
				prevRegEnd = regStart - 1;
				reg = max(0, prevRegEnd - prevRegStart + 1);
				prevRegStart = regStart;
				for (d = 0; d < reg; d++, phTh_idx++) {
					phTh[phTh_idx] = prevOutPh[prevPeak] + prevInstPhaseAdv_ - currInPh[prevPeak];
				}
				prevPeak = peak;
				prevInstPhaseAdv_ = instPhaseAdv_;
			}
		}

		for (var i = 0; i < phTh.length; i++) {
			var theta = phTh[i];

			var phThRe = cos(phTh[i]);
			var phThIm = sin(phTh[i]);

			out.real[i] = phThRe * fftObj.real[i] - phThIm * fftObj.imag[i];
			out.imag[i] = phThRe * fftObj.imag[i] + phThIm * fftObj.real[i];
			out.phase[i] = atan2(out.imag[i], out.real[i]);
		}

		return;
	}

	this.process = function (inputArray, outputArray) {

		var _ = this;

		var __Hs = _Hs;
		var __Ha = _Ha;

		// ----------------------------------
		// ----------ANALYSIS STEP-----------
		// ----------------------------------

		var processedFrame = _process.processedFrame;;
		var fftObj = _process.fftObj;
		// FOR SOME REASON, IF I DON'T CREATE A NEW "phase" ARHaY, I GET ARTIFACTS.
		// fftObj.phase = new Float32Array(_hlfSize); 
		var pvOut = _process.pvOut;
		_.STFT(inputArray, _framingWindow, _hlfSize, fftObj);
		pv_step(fftObj, _previousInputPhase, _previousOutputPhase, _omega, __Ha, __Hs, pvOut);
		_previousOutputPhase = pvOut.phase;
		// The "phase" issue mentioned above is related to this line. 
		// If I create a new Float array using the phase array, I get no issues.
		_previousInputPhase = new Float32Array(fftObj.phase);
		_.ISTFT(pvOut.real, pvOut.imag, _framingWindow, false, processedFrame);

		// ----------------------------------
		// ------OVERLAP AND SLIDE STEP------
		// ----------------------------------
		// var outputFrame = new Array(__Hs);

		overlap_and_slide(__Hs, processedFrame, _squaredFramingWindow, _overlapBuffers, _owOverlapBuffers, _winSize, outputArray);

		return __Hs;
	};

	this.STFT = function (inputFrame, windowFrame, wantedSize, out) {
		this.STFT_drom(inputFrame, windowFrame, wantedSize, out);
	};

	this.STFT_drom = function (inputFrame, windowFrame, wantedSize, out) {
		var winSize = windowFrame.length;
		var _inputFrame = _STFT._inputFrame;

		for (var i = 0; i < winSize; i++) {
			_inputFrame[i] = inputFrame[i] * windowFrame[i];
		}

		fft.forward(_inputFrame);
		out.real = fft.real;
		out.imag = fft.imag;

		var R = out.real;var I = out.imag;
		var P = out.phase;var M = out.magnitude;

		for (var p = 0; p < winSize && p < wantedSize; p++) {
			M[p] = sqrt(I[p] * I[p] + R[p] * R[p]) * 1000;
			P[p] = atan2(I[p], R[p]);
		}

		return;
	};

	this.ISTFT = function (real, imag, windowFrame, restoreEnergy, timeFrame) {
		this.ISTFT_drom(real, imag, windowFrame, restoreEnergy, timeFrame);
	};

	this.ISTFT_drom = function (real, imag, windowFrame, restoreEnergy, timeFrame) {

		fft.inverse(real, imag, timeFrame);

		return;
	};

	this.init = function () {

		_omega = create_omega_array(winSize);

		this.reset_phases_and_overlap_buffers();

		_framingWindow = create_sin_beta_window_array(winSize, 1);

		_squaredFramingWindow = _framingWindow.map(function (x, i) {
			return x * x;
		});

		this.set_alpha(1);
	};

	function create_omega_array(size) {
		return Array.apply(null, Array(size / 2 + 1)).map(function (x, i) {
			return twoPI * i / size;
		});
	}

	function create_sin_beta_window_array(size, beta) {
		return Array.apply(null, Array(size)).map(function (x, i) {
			return pow(sin(PI * i / size), beta);
		});
	}

	function create_constant_array(size, constant, ArrayType) {
		var arr = new (ArrayType ? ArrayType : Array)(size);
		for (var i = 0; i < size; i++) {
			arr[i] = constant;
		}return arr;
	}

	this.reset_phases_and_overlap_buffers = function () {

		_previousInputPhase = create_constant_array(winSize / 2, 0);
		_previousOutputPhase = create_constant_array(winSize / 2, 0);

		_overlapBuffers = new _cbuffer2.default(winSize);
		_owOverlapBuffers = new _cbuffer2.default(winSize);
		for (var i = 0; i < winSize; i++) {
			_overlapBuffers.push(0);
			_owOverlapBuffers.push(0);
		}

		_first = true;
	};

	this.reset_phases = function () {

		_previousInputPhase = create_constant_array(winSize / 2, 0);
		_previousOutputPhase = create_constant_array(winSize / 2, 0);

		_first = true;
	};

	this.get_previous_input_phase = function () {
		return _previousInputPhase;
	};

	this.get_previous_output_phase = function () {
		return _previousOutputPhase;
	};

	this.get_analysis_hop = function () {
		return _Ha;
	};

	this.get_synthesis_hop = function () {
		return _Hs;
	};

	this.get_alpha = function () {
		return _Hs / _Ha;
	};

	this.get_framing_window = function () {
		return _framingWindow;
	};

	this.get_squared_framing_window = function () {
		return _squaredFramingWindow;
	};

	this.set_alpha = function (newAlpha) {
		_lastInputAlpha = newAlpha;
		if (newAlpha <= 0.8) _overlapFactor = 2;else if (newAlpha <= 1) _overlapFactor = 4;else _overlapFactor = 5;

		/* "Fixed" synthesis hop size. */
		_Ha = round(_winSize / _overlapFactor);
		_Hs = round(newAlpha * _Ha);

		// _Hs = _Ha;

		// _Hs = round(_winSize/2);
		// _Ha = round(_Hs / newAlpha);
	};

	this.get_alpha_step = function () {
		return 1 / _Ha;
	};

	this.set_hops = function (Ha, Hs) {
		_Ha = Ha;
		_Hs = Hs;
	};

	this.get_specified_alpha = function () {
		return _lastInputAlpha;
	};

	this.set_overlap_factor = function (overlapFactor) {
		_overlapFactor = overlapFactor;
		this.set_alpha(_lastInputAlpha);
	};
} /*  From PhaseVocoder.js (c) 2015 by Echo66
      https://github.com/echo66/PhaseVocoderJS
  
      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
  	along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */

exports.default = PhaseVocoder;

},{"./cbuffer":20,"./dsp":21,"./dsp.js":21}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _cbuffer = require('./cbuffer');

var _cbuffer2 = _interopRequireDefault(_cbuffer);

var _PV_fast_ = require('./PV_fast_5');

var _PV_fast_2 = _interopRequireDefault(_PV_fast_);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function BufferedPV(frameSize) {

	var _frameSize = frameSize || 4096;
	var _pvL = new _PV_fast_2.default(_frameSize, _audioContext2.default.sampleRate);_pvL.init();
	var _pvR = new _PV_fast_2.default(_frameSize, _audioContext2.default.sampleRate);_pvR.init();
	var _buffer;
	var _position = 0;
	var _newAlpha = 1;

	var _midBufL = new _cbuffer2.default(Math.round(_frameSize * 2));
	var _midBufR = new _cbuffer2.default(Math.round(_frameSize * 2));

	this.processMono = function (outputAudioBuffer) {

		if (!_buffer) {
			console.error("No input buffer");
			return;
		}

		var sampleCounter = 0;

		var il = _buffer.getChannelData(0);
		var ir = _buffer.getChannelData(0);
		var ol = outputAudioBuffer.getChannelData(0);
		var or = outputAudioBuffer.getChannelData(1);

		while (_midBufR.size > 0 && sampleCounter < outputAudioBuffer.length) {
			var i = sampleCounter++;
			ol[i] = _midBufL.shift();
			or[i] = _midBufR.shift();
		}

		if (sampleCounter == outputAudioBuffer.length) return;

		do {

			var bufL = il.subarray(_position, _position + _frameSize);
			var bufR = ir.subarray(_position, _position + _frameSize);

			if (_newAlpha != undefined && _newAlpha != _pvL.get_alpha()) {
				_pvL.set_alpha(_newAlpha);
				_pvR.set_alpha(_newAlpha);
				_newAlpha = undefined;
			}

			/* LEFT */
			_pvL.process(bufL, _midBufL);
			_pvR.process(bufR, _midBufR);
			for (var i = sampleCounter; _midBufL.size > 0 && i < outputAudioBuffer.length; i++) {
				ol[i] = _midBufL.shift();
				or[i] = _midBufR.shift();
			}

			sampleCounter += _pvL.get_synthesis_hop();

			_position += _pvL.get_analysis_hop();
		} while (sampleCounter < outputAudioBuffer.length);
	};

	this.processStereo = function (outputAudioBuffer) {

		if (!_buffer || _buffer.numberOfChannels != 2) {
			console.error("No input buffer or wrong number of channels");
			return;
		}

		var sampleCounter = 0;

		var il = _buffer.getChannelData(0);
		var ir = _buffer.getChannelData(1);
		var ol = outputAudioBuffer.getChannelData(0);
		var or = outputAudioBuffer.getChannelData(1);

		while (_midBufR.size > 0 && sampleCounter < outputAudioBuffer.length) {
			var i = sampleCounter++;
			ol[i] = _midBufL.shift();
			or[i] = _midBufR.shift();
		}

		if (sampleCounter == outputAudioBuffer.length) return;

		do {

			var bufL = il.subarray(_position, _position + _frameSize);
			var bufR = ir.subarray(_position, _position + _frameSize);

			if (_newAlpha != undefined && _newAlpha != _pvL.get_alpha()) {
				_pvL.set_alpha(_newAlpha);
				_pvR.set_alpha(_newAlpha);
				_newAlpha = undefined;
			}

			/* LEFT */
			_pvL.process(bufL, _midBufL);
			_pvR.process(bufR, _midBufR);
			for (var i = sampleCounter; _midBufL.size > 0 && i < outputAudioBuffer.length; i++) {
				ol[i] = _midBufL.shift();
				or[i] = _midBufR.shift();
			}

			sampleCounter += _pvL.get_synthesis_hop();

			_position += _pvL.get_analysis_hop();
		} while (sampleCounter < outputAudioBuffer.length);
	};

	this.process = this.processMono;

	this.set_audio_buffer = function (newBuffer) {
		_buffer = newBuffer;
		if (_buffer.numberOfChannels == 2) this.process = this.processStereo;else this.process = this.processMono;

		_position = 0;
		_newAlpha = 1;
	};

	this.resetPhase = function () {
		_pvL.reset_phases();
		_pvR.reset_phases();
	};

	(0, _defineProperties2.default)(this, {
		'position': {
			get: function get() {
				return _position;
			},
			set: function set(newPosition) {
				_position = newPosition;
			}
		},
		'alpha': {
			get: function get() {
				return _pvL.get_alpha();
			},
			set: function set(newAlpha) {
				_newAlpha = newAlpha;
			}
		}
	});
} /*  From PhaseVocoder.js (c) 2015 by Echo66
      https://github.com/echo66/PhaseVocoderJS
  
  	This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
  	along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */

exports.default = BufferedPV;

},{"../core/audio-context":1,"./PV_fast_5":18,"./cbuffer":20,"babel-runtime/core-js/object/define-properties":24}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
/*
	The MIT License (MIT)
	Copyright (c) 2013 Trevor Norris <trev.norris@gmail.com>

	Permission is hereby granted, free of charge, to any person obtaining a copy of
	this software and associated documentation files (the "Software"), to deal in
	the Software without restriction, including without limitation the rights to
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
	the Software, and to permit persons to whom the Software is furnished to do so,
	subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
	FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
	COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
	IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

function CBuffer() {
	// handle cases where "new" keyword wasn't used
	if (!(this instanceof CBuffer)) {
		// multiple conditions need to be checked to properly emulate Array
		if (arguments.length > 1 || typeof arguments[0] !== 'number') {
			return CBuffer.apply(new CBuffer(arguments.length), arguments);
		} else {
			return new CBuffer(arguments[0]);
		}
	}
	// if no arguments, then nothing needs to be set
	if (arguments.length === 0) throw new Error('Missing Argument: You must pass a valid buffer length');
	// this is the same in either scenario
	this.size = this.start = 0;
	// set to callback fn if data is about to be overwritten
	this.overflow = null;
	// emulate Array based on passed arguments
	if (arguments.length > 1 || typeof arguments[0] !== 'number') {
		this.data = new Float32Array(arguments.length);
		this.end = (this.length = arguments.length) - 1;
		this.push.apply(this, arguments);
	} else {
		this.data = new Float32Array(arguments[0]);
		this.end = (this.length = arguments[0]) - 1;
	}
	// need to `return this` so `return CBuffer.apply` works
	return this;
}

function defaultComparitor(a, b) {
	return a == b ? 0 : a > b ? 1 : -1;
}

CBuffer.prototype = {
	// properly set constructor
	constructor: CBuffer,

	/* mutator methods */
	// pop last item
	pop: function pop() {
		var item;
		if (this.size === 0) return;
		item = this.data[this.end];
		// remove the reference to the object so it can be garbage collected
		delete this.data[this.end];
		this.end = (this.end - 1 + this.length) % this.length;
		this.size--;
		return item;
	},
	// push item to the end
	push: function push() {
		var i = 0;
		// check if overflow is set, and if data is about to be overwritten
		if (this.overflow && this.size + arguments.length > this.length) {
			// call overflow function and send data that's about to be overwritten
			for (; i < this.size + arguments.length - this.length; i++) {
				this.overflow(this.data[(this.end + i + 1) % this.length], this);
			}
		}
		// push items to the end, wrapping and erasing existing items
		// using arguments variable directly to reduce gc footprint
		for (i = 0; i < arguments.length; i++) {
			this.data[(this.end + i + 1) % this.length] = arguments[i];
		}
		// recalculate size
		if (this.size < this.length) {
			if (this.size + i > this.length) this.size = this.length;else this.size += i;
		}
		// recalculate end
		this.end = (this.end + i) % this.length;
		// recalculate start
		this.start = (this.length + this.end - this.size + 1) % this.length;
		// return number current number of items in CBuffer
		return this.size;
	},
	// reverse order of the buffer
	reverse: function reverse() {
		var i = 0,
		    tmp;
		for (; i < ~~(this.size / 2); i++) {
			tmp = this.data[(this.start + i) % this.length];
			this.data[(this.start + i) % this.length] = this.data[(this.start + (this.size - i - 1)) % this.length];
			this.data[(this.start + (this.size - i - 1)) % this.length] = tmp;
		}
		return this;
	},
	// rotate buffer to the left by cntr, or by 1
	rotateLeft: function rotateLeft(cntr) {
		if (typeof cntr === 'undefined') cntr = 1;
		if (typeof cntr !== 'number') throw new Error("Argument must be a number");
		while (--cntr >= 0) {
			this.push(this.shift());
		}
		return this;
	},
	// rotate buffer to the right by cntr, or by 1
	rotateRight: function rotateRight(cntr) {
		if (typeof cntr === 'undefined') cntr = 1;
		if (typeof cntr !== 'number') throw new Error("Argument must be a number");
		while (--cntr >= 0) {
			this.unshift(this.pop());
		}
		return this;
	},
	// remove and return first item
	shift: function shift() {
		var item;
		// check if there are any items in CBuff
		if (this.size === 0) return;
		// store first item for return
		item = this.data[this.start];
		// recalculate start of CBuffer
		this.start = (this.start + 1) % this.length;
		// decrement size
		this.size--;
		return item;
	},
	// sort items
	sort: function sort(fn) {
		// this.data.sort(fn || defaultComparitor);
		// this.start = 0;
		// this.end = this.size - 1;
		return this;
	},
	// add item to beginning of buffer
	unshift: function unshift() {
		var i = 0;
		// check if overflow is set, and if data is about to be overwritten
		if (this.overflow && this.size + arguments.length > this.length) {
			// call overflow function and send data that's about to be overwritten
			for (; i < this.size + arguments.length - this.length; i++) {
				this.overflow(this.data[this.end - i % this.length], this);
			}
		}
		for (i = 0; i < arguments.length; i++) {
			this.data[(this.length + this.start - i % this.length - 1) % this.length] = arguments[i];
		}
		if (this.length - this.size - i < 0) {
			this.end += this.length - this.size - i;
			if (this.end < 0) this.end = this.length + this.end % this.length;
		}
		if (this.size < this.length) {
			if (this.size + i > this.length) this.size = this.length;else this.size += i;
		}
		this.start -= arguments.length;
		if (this.start < 0) this.start = this.length + this.start % this.length;
		return this.size;
	},

	/* accessor methods */
	// return index of first matched element
	indexOf: function indexOf(arg, idx) {
		if (!idx) idx = 0;
		for (; idx < this.size; idx++) {
			if (this.data[(this.start + idx) % this.length] === arg) return idx;
		}
		return -1;
	},
	// return last index of the first match
	lastIndexOf: function lastIndexOf(arg, idx) {
		if (!idx) idx = this.size - 1;
		for (; idx >= 0; idx--) {
			if (this.data[(this.start + idx) % this.length] === arg) return idx;
		}
		return -1;
	},

	// return the index an item would be inserted to if this
	// is a sorted circular buffer
	sortedIndex: function sortedIndex(value, comparitor, context) {
		comparitor = comparitor || defaultComparitor;
		var low = this.start,
		    high = this.size - 1;

		// Tricky part is finding if its before or after the pivot
		// we can get this info by checking if the target is less than
		// the last item. After that it's just a typical binary search.
		if (low && comparitor.call(context, value, this.data[high]) > 0) {
			low = 0, high = this.end;
		}

		while (low < high) {
			var mid = low + high >>> 1;
			if (comparitor.call(context, value, this.data[mid]) > 0) low = mid + 1;else high = mid;
		}
		// http://stackoverflow.com/a/18618273/1517919
		return ((low - this.start) % this.size + this.size) % this.size;
	},

	/* iteration methods */
	// check every item in the array against a test
	every: function every(callback, context) {
		var i = 0;
		for (; i < this.size; i++) {
			if (!callback.call(context, this.data[(this.start + i) % this.length], i, this)) return false;
		}
		return true;
	},
	// loop through each item in buffer
	// TODO: figure out how to emulate Array use better
	forEach: function forEach(callback, context) {
		var i = 0;
		for (; i < this.size; i++) {
			callback.call(context, this.data[(this.start + i) % this.length], i, this);
		}
	},
	// check items agains test until one returns true
	// TODO: figure out how to emuldate Array use better
	some: function some(callback, context) {
		var i = 0;
		for (; i < this.size; i++) {
			if (callback.call(context, this.data[(this.start + i) % this.length], i, this)) return true;
		}
		return false;
	},
	// calculate the average value of a circular buffer
	avg: function avg() {
		return this.size == 0 ? 0 : this.sum() / this.size;
	},
	// loop through each item in buffer and calculate sum
	sum: function sum() {
		var index = this.size;
		var s = 0;
		while (index--) {
			s += this.data[index];
		}return s;
	},
	// loop through each item in buffer and calculate median
	median: function median() {
		if (this.size === 0) return 0;
		var values = this.slice().sort(defaultComparitor);
		var half = Math.floor(values.length / 2);
		if (values.length % 2) return values[half];else return (values[half - 1] + values[half]) / 2.0;
	},
	/* utility methods */
	// reset pointers to buffer with zero items
	// note: this will not remove values in cbuffer, so if for security values
	//       need to be overwritten, run `.fill(null).empty()`
	empty: function empty() {
		var i = 0;
		this.size = this.start = 0;
		this.end = this.length - 1;
		return this;
	},
	// fill all places with passed value or function
	fill: function fill(arg) {
		var i = 0;
		if (typeof arg === 'function') {
			while (this.data[i] = arg(), ++i < this.length) {}
		} else {
			while (this.data[i] = arg, ++i < this.length) {}
		}
		// reposition start/end
		this.start = 0;
		this.end = this.length - 1;
		this.size = this.length;
		return this;
	},
	// return first item in buffer
	first: function first() {
		return this.data[this.start];
	},
	// return last item in buffer
	last: function last() {
		return this.data[this.end];
	},
	// return specific index in buffer
	get: function get(arg) {
		return this.data[(this.start + arg) % this.length];
	},
	isFull: function isFull(arg) {
		return this.length === this.size;
	},
	// set value at specified index
	set: function set(idx, arg) {
		return this.data[(this.start + idx) % this.length] = arg;
	},
	// return clean array of values
	toArray: function toArray() {
		return this.slice();
	},
	// slice the buffer to an arraay
	slice: function slice(start, end) {
		var length = this.size;

		start = +start || 0;

		if (start < 0) {
			if (start >= end) return [];
			start = -start > length ? 0 : length + start;
		}

		if (end == null || end > length) end = length;else if (end < 0) end += length;else end = +end || 0;

		length = start < end ? end - start : 0;

		var result = Array(length);
		for (var index = 0; index < length; index++) {
			result[index] = this.data[(this.start + start + index) % this.length];
		}
		return result;
	}
};

//if (typeof module === 'object' && module.exports) module.exports = CBuffer;
//else global.CBuffer = CBuffer;

exports.default = CBuffer;

},{}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FFT = undefined;

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* 
 *  DSP.js - a comprehensive digital signal processing  library for javascript
 * 
 *  Created by Corban Brook <corbanbrook@gmail.com> on 2010-01-01.
 *  Copyright 2010 Corban Brook. All rights reserved.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 * 
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 * 
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

////////////////////////////////////////////////////////////////////////////////
//                                  CONSTANTS                                 //
////////////////////////////////////////////////////////////////////////////////

/**
 * DSP is an object which contains general purpose utility functions and constants
 */
var DSP = {
  // Channels
  LEFT: 0,
  RIGHT: 1,
  MIX: 2,

  // Waveforms
  SINE: 1,
  TRIANGLE: 2,
  SAW: 3,
  SQUARE: 4,

  // Filters
  LOWPASS: 0,
  HIGHPASS: 1,
  BANDPASS: 2,
  NOTCH: 3,

  // Window functions
  BARTLETT: 1,
  BARTLETTHANN: 2,
  BLACKMAN: 3,
  COSINE: 4,
  GAUSS: 5,
  HAMMING: 6,
  HANN: 7,
  LANCZOS: 8,
  RECTANGULAR: 9,
  TRIANGULAR: 10,

  // Loop modes
  OFF: 0,
  FW: 1,
  BW: 2,
  FWBW: 3,

  // Math
  TWO_PI: 2 * Math.PI
};

// Setup arrays for platforms which do not support byte arrays
function setupTypedArray(name, fallback) {
  var self = window;
  // check if TypedArray exists
  // typeof on Minefield and Chrome return function, typeof on Webkit returns object.
  if (typeof self[name] !== "function" && (0, _typeof3.default)(self[name]) !== "object") {
    // nope.. check if WebGLArray exists
    if (typeof self[fallback] === "function" && (0, _typeof3.default)(self[fallback]) !== "object") {
      self[name] = self[fallback];
    } else {
      // nope.. set as Native JS array
      self[name] = function (obj) {
        if (obj instanceof Array) {
          return obj;
        } else if (typeof obj === "number") {
          return new Array(obj);
        }
      };
    }
  }
}

setupTypedArray("Float32Array", "WebGLFloatArray");
setupTypedArray("Int32Array", "WebGLIntArray");
setupTypedArray("Uint16Array", "WebGLUnsignedShortArray");
setupTypedArray("Uint8Array", "WebGLUnsignedByteArray");

////////////////////////////////////////////////////////////////////////////////
//                            DSP UTILITY FUNCTIONS                           //
////////////////////////////////////////////////////////////////////////////////

/**
 * Inverts the phase of a signal
 *
 * @param {Array} buffer A sample buffer
 *
 * @returns The inverted sample buffer
 */
DSP.invert = function (buffer) {
  for (var i = 0, len = buffer.length; i < len; i++) {
    buffer[i] *= -1;
  }

  return buffer;
};

/**
 * Converts split-stereo (dual mono) sample buffers into a stereo interleaved sample buffer
 *
 * @param {Array} left  A sample buffer
 * @param {Array} right A sample buffer
 *
 * @returns The stereo interleaved buffer
 */
DSP.interleave = function (left, right) {
  if (left.length !== right.length) {
    throw "Can not interleave. Channel lengths differ.";
  }

  var stereoInterleaved = new Float32Array(left.length * 2);

  for (var i = 0, len = left.length; i < len; i++) {
    stereoInterleaved[2 * i] = left[i];
    stereoInterleaved[2 * i + 1] = right[i];
  }

  return stereoInterleaved;
};

/**
 * Converts a stereo-interleaved sample buffer into split-stereo (dual mono) sample buffers
 *
 * @param {Array} buffer A stereo-interleaved sample buffer
 *
 * @returns an Array containing left and right channels
 */
DSP.deinterleave = function () {
  var left,
      right,
      mix,
      deinterleaveChannel = [];

  deinterleaveChannel[DSP.MIX] = function (buffer) {
    for (var i = 0, len = buffer.length / 2; i < len; i++) {
      mix[i] = (buffer[2 * i] + buffer[2 * i + 1]) / 2;
    }
    return mix;
  };

  deinterleaveChannel[DSP.LEFT] = function (buffer) {
    for (var i = 0, len = buffer.length / 2; i < len; i++) {
      left[i] = buffer[2 * i];
    }
    return left;
  };

  deinterleaveChannel[DSP.RIGHT] = function (buffer) {
    for (var i = 0, len = buffer.length / 2; i < len; i++) {
      right[i] = buffer[2 * i + 1];
    }
    return right;
  };

  return function (channel, buffer) {
    left = left || new Float32Array(buffer.length / 2);
    right = right || new Float32Array(buffer.length / 2);
    mix = mix || new Float32Array(buffer.length / 2);

    if (buffer.length / 2 !== left.length) {
      left = new Float32Array(buffer.length / 2);
      right = new Float32Array(buffer.length / 2);
      mix = new Float32Array(buffer.length / 2);
    }

    return deinterleaveChannel[channel](buffer);
  };
}();

/**
 * Separates a channel from a stereo-interleaved sample buffer
 *
 * @param {Array}  buffer A stereo-interleaved sample buffer
 * @param {Number} channel A channel constant (LEFT, RIGHT, MIX)
 *
 * @returns an Array containing a signal mono sample buffer
 */
DSP.getChannel = DSP.deinterleave;

/**
 * Helper method (for Reverb) to mix two (interleaved) samplebuffers. It's possible
 * to negate the second buffer while mixing and to perform a volume correction
 * on the final signal.
 *
 * @param {Array} sampleBuffer1 Array containing Float values or a Float32Array
 * @param {Array} sampleBuffer2 Array containing Float values or a Float32Array
 * @param {Boolean} negate When true inverts/flips the audio signal
 * @param {Number} volumeCorrection When you add multiple sample buffers, use this to tame your signal ;)
 *
 * @returns A new Float32Array interleaved buffer.
 */
DSP.mixSampleBuffers = function (sampleBuffer1, sampleBuffer2, negate, volumeCorrection) {
  var outputSamples = new Float32Array(sampleBuffer1);

  for (var i = 0; i < sampleBuffer1.length; i++) {
    outputSamples[i] += (negate ? -sampleBuffer2[i] : sampleBuffer2[i]) / volumeCorrection;
  }

  return outputSamples;
};

// Biquad filter types
DSP.LPF = 0; // H(s) = 1 / (s^2 + s/Q + 1)
DSP.HPF = 1; // H(s) = s^2 / (s^2 + s/Q + 1)
DSP.BPF_CONSTANT_SKIRT = 2; // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
DSP.BPF_CONSTANT_PEAK = 3; // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
DSP.NOTCH = 4; // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
DSP.APF = 5; // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
DSP.PEAKING_EQ = 6; // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
DSP.LOW_SHELF = 7; // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
DSP.HIGH_SHELF = 8; // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)

// Biquad filter parameter types
DSP.Q = 1;
DSP.BW = 2; // SHARED with BACKWARDS LOOP MODE
DSP.S = 3;

// Find RMS of signal
DSP.RMS = function (buffer) {
  var total = 0;

  for (var i = 0, n = buffer.length; i < n; i++) {
    total += buffer[i] * buffer[i];
  }

  return Math.sqrt(total / n);
};

// Find Peak of signal
DSP.Peak = function (buffer) {
  var peak = 0;

  for (var i = 0, n = buffer.length; i < n; i++) {
    peak = Math.abs(buffer[i]) > peak ? Math.abs(buffer[i]) : peak;
  }

  return peak;
};

// Fourier Transform Module used by DFT, FFT, RFFT
function FourierTransform(bufferSize, sampleRate) {
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.bandwidth = 2 / bufferSize * sampleRate / 2;

  this.spectrum = new Float32Array(bufferSize / 2);
  this.real = new Float32Array(bufferSize);
  this.imag = new Float32Array(bufferSize);

  this.peakBand = 0;
  this.peak = 0;

  /**
   * Calculates the *middle* frequency of an FFT band.
   *
   * @param {Number} index The index of the FFT band.
   *
   * @returns The middle frequency in Hz.
   */
  this.getBandFrequency = function (index) {
    return this.bandwidth * index + this.bandwidth / 2;
  };

  this.calculateSpectrum = function () {
    var spectrum = this.spectrum,
        real = this.real,
        imag = this.imag,
        bSi = 2 / this.bufferSize,
        sqrt = Math.sqrt,
        rval,
        ival,
        mag;

    for (var i = 0, N = bufferSize / 2; i < N; i++) {
      rval = real[i];
      ival = imag[i];
      mag = bSi * sqrt(rval * rval + ival * ival);

      if (mag > this.peak) {
        this.peakBand = i;
        this.peak = mag;
      }

      spectrum[i] = mag;
    }
  };
}

/**
 * DFT is a class for calculating the Discrete Fourier Transform of a signal.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function DFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  var N = bufferSize / 2 * bufferSize;
  var TWO_PI = 2 * Math.PI;

  this.sinTable = new Float32Array(N);
  this.cosTable = new Float32Array(N);

  for (var i = 0; i < N; i++) {
    this.sinTable[i] = Math.sin(i * TWO_PI / bufferSize);
    this.cosTable[i] = Math.cos(i * TWO_PI / bufferSize);
  }
}

/**
 * Performs a forward transform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer
 *
 * @returns The frequency spectrum array
 */
DFT.prototype.forward = function (buffer) {
  var real = this.real,
      imag = this.imag,
      rval,
      ival;

  for (var k = 0; k < this.bufferSize / 2; k++) {
    rval = 0.0;
    ival = 0.0;

    for (var n = 0; n < buffer.length; n++) {
      rval += this.cosTable[k * n] * buffer[n];
      ival += this.sinTable[k * n] * buffer[n];
    }

    real[k] = rval;
    imag[k] = ival;
  }

  return this.calculateSpectrum();
};

/**
 * FFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function FFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  this.reverseTable = new Uint32Array(bufferSize);

  var limit = 1;
  var bit = bufferSize >> 1;

  var i;

  while (limit < bufferSize) {
    for (i = 0; i < limit; i++) {
      this.reverseTable[i + limit] = this.reverseTable[i] + bit;
    }

    limit = limit << 1;
    bit = bit >> 1;
  }

  this.sinTable = new Float32Array(bufferSize);
  this.cosTable = new Float32Array(bufferSize);

  for (i = 0; i < bufferSize; i++) {
    this.sinTable[i] = Math.sin(-Math.PI / i);
    this.cosTable[i] = Math.cos(-Math.PI / i);
  }
}

/**
 * Performs a forward transform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer. Buffer Length must be power of 2
 *
 * @returns The frequency spectrum array
 */
FFT.prototype.forward = function (buffer) {
  // Locally scope variables for speed up
  var bufferSize = this.bufferSize,
      cosTable = this.cosTable,
      sinTable = this.sinTable,
      reverseTable = this.reverseTable,
      real = this.real,
      imag = this.imag,
      spectrum = this.spectrum;

  var k = Math.floor(Math.log(bufferSize) / Math.LN2);

  if (Math.pow(2, k) !== bufferSize) {
    throw "Invalid buffer size, must be a power of 2.";
  }
  if (bufferSize !== buffer.length) {
    throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length;
  }

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    real[i] = buffer[reverseTable[i]];
    imag[i] = 0;
  }

  while (halfSize < bufferSize) {
    //phaseShiftStepReal = Math.cos(-Math.PI/halfSize);
    //phaseShiftStepImag = Math.sin(-Math.PI/halfSize);
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];

    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = currentPhaseShiftReal * real[off] - currentPhaseShiftImag * imag[off];
        ti = currentPhaseShiftReal * imag[off] + currentPhaseShiftImag * real[off];

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = tmpReal * phaseShiftStepReal - currentPhaseShiftImag * phaseShiftStepImag;
      currentPhaseShiftImag = tmpReal * phaseShiftStepImag + currentPhaseShiftImag * phaseShiftStepReal;
    }

    halfSize = halfSize << 1;
  }

  return this.calculateSpectrum();
};

FFT.prototype.inverse = function (real, imag, buffer) {
  // Locally scope variables for speed up
  var bufferSize = this.bufferSize,
      cosTable = this.cosTable,
      sinTable = this.sinTable,
      reverseTable = this.reverseTable,
      spectrum = this.spectrum;

  real = real || this.real;
  imag = imag || this.imag;

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    imag[i] *= -1;
  }

  var revReal = new Float32Array(bufferSize);
  var revImag = new Float32Array(bufferSize);

  for (i = 0; i < real.length; i++) {
    revReal[i] = real[reverseTable[i]];
    revImag[i] = imag[reverseTable[i]];
  }

  real = revReal;
  imag = revImag;

  while (halfSize < bufferSize) {
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];
    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = currentPhaseShiftReal * real[off] - currentPhaseShiftImag * imag[off];
        ti = currentPhaseShiftReal * imag[off] + currentPhaseShiftImag * real[off];

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = tmpReal * phaseShiftStepReal - currentPhaseShiftImag * phaseShiftStepImag;
      currentPhaseShiftImag = tmpReal * phaseShiftStepImag + currentPhaseShiftImag * phaseShiftStepReal;
    }

    halfSize = halfSize << 1;
  }

  // var buffer = new Float32Array(bufferSize); // this should be reused instead
  for (i = 0; i < bufferSize; i++) {
    buffer[i] = real[i] / bufferSize;
  }

  return buffer;
};

/**
 * RFFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * This method currently only contains a forward transform but is highly optimized.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */

// lookup tables don't really gain us any speed, but they do increase
// cache footprint, so don't use them in here

// also we don't use sepearate arrays for real/imaginary parts

// this one a little more than twice as fast as the one in FFT
// however I only did the forward transform

// the rest of this was translated from C, see http://www.jjj.de/fxt/
// this is the real split radix FFT

function RFFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  this.trans = new Float32Array(bufferSize);

  this.reverseTable = new Uint32Array(bufferSize);

  // don't use a lookup table to do the permute, use this instead
  this.reverseBinPermute = function (dest, source) {
    var bufferSize = this.bufferSize,
        halfSize = bufferSize >>> 1,
        nm1 = bufferSize - 1,
        i = 1,
        r = 0,
        h;

    dest[0] = source[0];

    do {
      r += halfSize;
      dest[i] = source[r];
      dest[r] = source[i];

      i++;

      h = halfSize << 1;
      while (h = h >> 1, !((r ^= h) & h)) {}

      if (r >= i) {
        dest[i] = source[r];
        dest[r] = source[i];

        dest[nm1 - i] = source[nm1 - r];
        dest[nm1 - r] = source[nm1 - i];
      }
      i++;
    } while (i < halfSize);
    dest[nm1] = source[nm1];
  };

  this.generateReverseTable = function () {
    var bufferSize = this.bufferSize,
        halfSize = bufferSize >>> 1,
        nm1 = bufferSize - 1,
        i = 1,
        r = 0,
        h;

    this.reverseTable[0] = 0;

    do {
      r += halfSize;

      this.reverseTable[i] = r;
      this.reverseTable[r] = i;

      i++;

      h = halfSize << 1;
      while (h = h >> 1, !((r ^= h) & h)) {}

      if (r >= i) {
        this.reverseTable[i] = r;
        this.reverseTable[r] = i;

        this.reverseTable[nm1 - i] = nm1 - r;
        this.reverseTable[nm1 - r] = nm1 - i;
      }
      i++;
    } while (i < halfSize);

    this.reverseTable[nm1] = nm1;
  };

  this.generateReverseTable();
}

// Ordering of output:
//
// trans[0]     = re[0] (==zero frequency, purely real)
// trans[1]     = re[1]
//             ...
// trans[n/2-1] = re[n/2-1]
// trans[n/2]   = re[n/2]    (==nyquist frequency, purely real)
//
// trans[n/2+1] = im[n/2-1]
// trans[n/2+2] = im[n/2-2]
//             ...
// trans[n-1]   = im[1] 

RFFT.prototype.forward = function (buffer) {
  var n = this.bufferSize,
      spectrum = this.spectrum,
      x = this.trans,
      TWO_PI = 2 * Math.PI,
      sqrt = Math.sqrt,
      i = n >>> 1,
      bSi = 2 / n,
      n2,
      n4,
      n8,
      nn,
      t1,
      t2,
      t3,
      t4,
      i1,
      i2,
      i3,
      i4,
      i5,
      i6,
      i7,
      i8,
      st1,
      cc1,
      ss1,
      cc3,
      ss3,
      e,
      a,
      rval,
      ival,
      mag;

  this.reverseBinPermute(x, buffer);

  /*
  var reverseTable = this.reverseTable;
   for (var k = 0, len = reverseTable.length; k < len; k++) {
    x[k] = buffer[reverseTable[k]];
  }
  */

  for (var ix = 0, id = 4; ix < n; id *= 4) {
    for (var i0 = ix; i0 < n; i0 += id) {
      //sumdiff(x[i0], x[i0+1]); // {a, b}  <--| {a+b, a-b}
      st1 = x[i0] - x[i0 + 1];
      x[i0] += x[i0 + 1];
      x[i0 + 1] = st1;
    }
    ix = 2 * (id - 1);
  }

  n2 = 2;
  nn = n >>> 1;

  while (nn = nn >>> 1) {
    ix = 0;
    n2 = n2 << 1;
    id = n2 << 1;
    n4 = n2 >>> 2;
    n8 = n2 >>> 3;
    do {
      if (n4 !== 1) {
        for (i0 = ix; i0 < n; i0 += id) {
          i1 = i0;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;

          //diffsum3_r(x[i3], x[i4], t1); // {a, b, s} <--| {a, b-a, a+b}
          t1 = x[i3] + x[i4];
          x[i4] -= x[i3];
          //sumdiff3(x[i1], t1, x[i3]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i3] = x[i1] - t1;
          x[i1] += t1;

          i1 += n8;
          i2 += n8;
          i3 += n8;
          i4 += n8;

          //sumdiff(x[i3], x[i4], t1, t2); // {s, d}  <--| {a+b, a-b}
          t1 = x[i3] + x[i4];
          t2 = x[i3] - x[i4];

          t1 = -t1 * Math.SQRT1_2;
          t2 *= Math.SQRT1_2;

          // sumdiff(t1, x[i2], x[i4], x[i3]); // {s, d}  <--| {a+b, a-b}
          st1 = x[i2];
          x[i4] = t1 + st1;
          x[i3] = t1 - st1;

          //sumdiff3(x[i1], t2, x[i2]); // {a, b, d} <--| {a+b, b, a-b}
          x[i2] = x[i1] - t2;
          x[i1] += t2;
        }
      } else {
        for (i0 = ix; i0 < n; i0 += id) {
          i1 = i0;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;

          //diffsum3_r(x[i3], x[i4], t1); // {a, b, s} <--| {a, b-a, a+b}
          t1 = x[i3] + x[i4];
          x[i4] -= x[i3];

          //sumdiff3(x[i1], t1, x[i3]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i3] = x[i1] - t1;
          x[i1] += t1;
        }
      }

      ix = (id << 1) - n2;
      id = id << 2;
    } while (ix < n);

    e = TWO_PI / n2;

    for (var j = 1; j < n8; j++) {
      a = j * e;
      ss1 = Math.sin(a);
      cc1 = Math.cos(a);

      //ss3 = sin(3*a); cc3 = cos(3*a);
      cc3 = 4 * cc1 * (cc1 * cc1 - 0.75);
      ss3 = 4 * ss1 * (0.75 - ss1 * ss1);

      ix = 0;id = n2 << 1;
      do {
        for (i0 = ix; i0 < n; i0 += id) {
          i1 = i0 + j;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;

          i5 = i0 + n4 - j;
          i6 = i5 + n4;
          i7 = i6 + n4;
          i8 = i7 + n4;

          //cmult(c, s, x, y, &u, &v)
          //cmult(cc1, ss1, x[i7], x[i3], t2, t1); // {u,v} <--| {x*c-y*s, x*s+y*c}
          t2 = x[i7] * cc1 - x[i3] * ss1;
          t1 = x[i7] * ss1 + x[i3] * cc1;

          //cmult(cc3, ss3, x[i8], x[i4], t4, t3);
          t4 = x[i8] * cc3 - x[i4] * ss3;
          t3 = x[i8] * ss3 + x[i4] * cc3;

          //sumdiff(t2, t4);   // {a, b} <--| {a+b, a-b}
          st1 = t2 - t4;
          t2 += t4;
          t4 = st1;

          //sumdiff(t2, x[i6], x[i8], x[i3]); // {s, d}  <--| {a+b, a-b}
          //st1 = x[i6]; x[i8] = t2 + st1; x[i3] = t2 - st1;
          x[i8] = t2 + x[i6];
          x[i3] = t2 - x[i6];

          //sumdiff_r(t1, t3); // {a, b} <--| {a+b, b-a}
          st1 = t3 - t1;
          t1 += t3;
          t3 = st1;

          //sumdiff(t3, x[i2], x[i4], x[i7]); // {s, d}  <--| {a+b, a-b}
          //st1 = x[i2]; x[i4] = t3 + st1; x[i7] = t3 - st1;
          x[i4] = t3 + x[i2];
          x[i7] = t3 - x[i2];

          //sumdiff3(x[i1], t1, x[i6]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i6] = x[i1] - t1;
          x[i1] += t1;

          //diffsum3_r(t4, x[i5], x[i2]); // {a, b, s} <--| {a, b-a, a+b}
          x[i2] = t4 + x[i5];
          x[i5] -= t4;
        }

        ix = (id << 1) - n2;
        id = id << 2;
      } while (ix < n);
    }
  }

  while (--i) {
    rval = x[i];
    ival = x[n - i - 1];
    mag = bSi * sqrt(rval * rval + ival * ival);

    if (mag > this.peak) {
      this.peakBand = i;
      this.peak = mag;
    }

    spectrum[i] = mag;
  }

  spectrum[0] = bSi * x[0];

  return spectrum;
};

function Sampler(file, bufferSize, sampleRate, playStart, playEnd, loopStart, loopEnd, loopMode) {
  this.file = file;
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.playStart = playStart || 0; // 0%
  this.playEnd = playEnd || 1; // 100%
  this.loopStart = loopStart || 0;
  this.loopEnd = loopEnd || 1;
  this.loopMode = loopMode || DSP.OFF;
  this.loaded = false;
  this.samples = [];
  this.signal = new Float32Array(bufferSize);
  this.frameCount = 0;
  this.envelope = null;
  this.amplitude = 1;
  this.rootFrequency = 110; // A2 110
  this.frequency = 550;
  this.step = this.frequency / this.rootFrequency;
  this.duration = 0;
  this.samplesProcessed = 0;
  this.playhead = 0;

  var audio = /* new Audio();*/document.createElement("AUDIO");
  var self = this;

  this.loadSamples = function (event) {
    var buffer = DSP.getChannel(DSP.MIX, event.frameBuffer);
    for (var i = 0; i < buffer.length; i++) {
      self.samples.push(buffer[i]);
    }
  };

  this.loadComplete = function () {
    // convert flexible js array into a fast typed array
    self.samples = new Float32Array(self.samples);
    self.loaded = true;
  };

  this.loadMetaData = function () {
    self.duration = audio.duration;
  };

  audio.addEventListener("MozAudioAvailable", this.loadSamples, false);
  audio.addEventListener("loadedmetadata", this.loadMetaData, false);
  audio.addEventListener("ended", this.loadComplete, false);
  audio.muted = true;
  audio.src = file;
  audio.play();
}

Sampler.prototype.applyEnvelope = function () {
  this.envelope.process(this.signal);
  return this.signal;
};

Sampler.prototype.generate = function () {
  var frameOffset = this.frameCount * this.bufferSize;

  var loopWidth = this.playEnd * this.samples.length - this.playStart * this.samples.length;
  var playStartSamples = this.playStart * this.samples.length; // ie 0.5 -> 50% of the length
  var playEndSamples = this.playEnd * this.samples.length; // ie 0.5 -> 50% of the length
  var offset;

  for (var i = 0; i < this.bufferSize; i++) {
    switch (this.loopMode) {
      case DSP.OFF:
        this.playhead = Math.round(this.samplesProcessed * this.step + playStartSamples);
        if (this.playhead < this.playEnd * this.samples.length) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        } else {
          this.signal[i] = 0;
        }
        break;

      case DSP.FW:
        this.playhead = Math.round(this.samplesProcessed * this.step % loopWidth + playStartSamples);
        if (this.playhead < this.playEnd * this.samples.length) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;

      case DSP.BW:
        this.playhead = playEndSamples - Math.round(this.samplesProcessed * this.step % loopWidth);
        if (this.playhead < this.playEnd * this.samples.length) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;

      case DSP.FWBW:
        if (Math.floor(this.samplesProcessed * this.step / loopWidth) % 2 === 0) {
          this.playhead = Math.round(this.samplesProcessed * this.step % loopWidth + playStartSamples);
        } else {
          this.playhead = playEndSamples - Math.round(this.samplesProcessed * this.step % loopWidth);
        }
        if (this.playhead < this.playEnd * this.samples.length) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;
    }
    this.samplesProcessed++;
  }

  this.frameCount++;

  return this.signal;
};

Sampler.prototype.setFreq = function (frequency) {
  var totalProcessed = this.samplesProcessed * this.step;
  this.frequency = frequency;
  this.step = this.frequency / this.rootFrequency;
  this.samplesProcessed = Math.round(totalProcessed / this.step);
};

Sampler.prototype.reset = function () {
  this.samplesProcessed = 0;
  this.playhead = 0;
};

/**
 * Oscillator class for generating and modifying signals
 *
 * @param {Number} type       A waveform constant (eg. DSP.SINE)
 * @param {Number} frequency  Initial frequency of the signal
 * @param {Number} amplitude  Initial amplitude of the signal
 * @param {Number} bufferSize Size of the sample buffer to generate
 * @param {Number} sampleRate The sample rate of the signal
 *
 * @contructor
 */
function Oscillator(type, frequency, amplitude, bufferSize, sampleRate) {
  this.frequency = frequency;
  this.amplitude = amplitude;
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  //this.pulseWidth = pulseWidth;
  this.frameCount = 0;

  this.waveTableLength = 2048;

  this.cyclesPerSample = frequency / sampleRate;

  this.signal = new Float32Array(bufferSize);
  this.envelope = null;

  switch (parseInt(type, 10)) {
    case DSP.TRIANGLE:
      this.func = Oscillator.Triangle;
      break;

    case DSP.SAW:
      this.func = Oscillator.Saw;
      break;

    case DSP.SQUARE:
      this.func = Oscillator.Square;
      break;

    default:
    case DSP.SINE:
      this.func = Oscillator.Sine;
      break;
  }

  this.generateWaveTable = function () {
    Oscillator.waveTable[this.func] = new Float32Array(2048);
    var waveTableTime = this.waveTableLength / this.sampleRate;
    var waveTableHz = 1 / waveTableTime;

    for (var i = 0; i < this.waveTableLength; i++) {
      Oscillator.waveTable[this.func][i] = this.func(i * waveTableHz / this.sampleRate);
    }
  };

  if (typeof Oscillator.waveTable === 'undefined') {
    Oscillator.waveTable = {};
  }

  if (typeof Oscillator.waveTable[this.func] === 'undefined') {
    this.generateWaveTable();
  }

  this.waveTable = Oscillator.waveTable[this.func];
}

/**
 * Set the amplitude of the signal
 *
 * @param {Number} amplitude The amplitude of the signal (between 0 and 1)
 */
Oscillator.prototype.setAmp = function (amplitude) {
  if (amplitude >= 0 && amplitude <= 1) {
    this.amplitude = amplitude;
  } else {
    throw "Amplitude out of range (0..1).";
  }
};

/**
 * Set the frequency of the signal
 *
 * @param {Number} frequency The frequency of the signal
 */
Oscillator.prototype.setFreq = function (frequency) {
  this.frequency = frequency;
  this.cyclesPerSample = frequency / this.sampleRate;
};

// Add an oscillator
Oscillator.prototype.add = function (oscillator) {
  for (var i = 0; i < this.bufferSize; i++) {
    //this.signal[i] += oscillator.valueAt(i);
    this.signal[i] += oscillator.signal[i];
  }

  return this.signal;
};

// Add a signal to the current generated osc signal
Oscillator.prototype.addSignal = function (signal) {
  for (var i = 0; i < signal.length; i++) {
    if (i >= this.bufferSize) {
      break;
    }
    this.signal[i] += signal[i];

    /*
    // Constrain amplitude
    if ( this.signal[i] > 1 ) {
      this.signal[i] = 1;
    } else if ( this.signal[i] < -1 ) {
      this.signal[i] = -1;
    }
    */
  }
  return this.signal;
};

// Add an envelope to the oscillator
Oscillator.prototype.addEnvelope = function (envelope) {
  this.envelope = envelope;
};

Oscillator.prototype.applyEnvelope = function () {
  this.envelope.process(this.signal);
};

Oscillator.prototype.valueAt = function (offset) {
  return this.waveTable[offset % this.waveTableLength];
};

Oscillator.prototype.generate = function () {
  var frameOffset = this.frameCount * this.bufferSize;
  var step = this.waveTableLength * this.frequency / this.sampleRate;
  var offset;

  for (var i = 0; i < this.bufferSize; i++) {
    //var step = (frameOffset + i) * this.cyclesPerSample % 1;
    //this.signal[i] = this.func(step) * this.amplitude;
    //this.signal[i] = this.valueAt(Math.round((frameOffset + i) * step)) * this.amplitude;
    offset = Math.round((frameOffset + i) * step);
    this.signal[i] = this.waveTable[offset % this.waveTableLength] * this.amplitude;
  }

  this.frameCount++;

  return this.signal;
};

Oscillator.Sine = function (step) {
  return Math.sin(DSP.TWO_PI * step);
};

Oscillator.Square = function (step) {
  return step < 0.5 ? 1 : -1;
};

Oscillator.Saw = function (step) {
  return 2 * (step - Math.round(step));
};

Oscillator.Triangle = function (step) {
  return 1 - 4 * Math.abs(Math.round(step) - step);
};

Oscillator.Pulse = function (step) {
  // stub
};

function ADSR(attackLength, decayLength, sustainLevel, sustainLength, releaseLength, sampleRate) {
  this.sampleRate = sampleRate;
  // Length in seconds
  this.attackLength = attackLength;
  this.decayLength = decayLength;
  this.sustainLevel = sustainLevel;
  this.sustainLength = sustainLength;
  this.releaseLength = releaseLength;
  this.sampleRate = sampleRate;

  // Length in samples
  this.attackSamples = attackLength * sampleRate;
  this.decaySamples = decayLength * sampleRate;
  this.sustainSamples = sustainLength * sampleRate;
  this.releaseSamples = releaseLength * sampleRate;

  // Updates the envelope sample positions
  this.update = function () {
    this.attack = this.attackSamples;
    this.decay = this.attack + this.decaySamples;
    this.sustain = this.decay + this.sustainSamples;
    this.release = this.sustain + this.releaseSamples;
  };

  this.update();

  this.samplesProcessed = 0;
}

ADSR.prototype.noteOn = function () {
  this.samplesProcessed = 0;
  this.sustainSamples = this.sustainLength * this.sampleRate;
  this.update();
};

// Send a note off when using a sustain of infinity to let the envelope enter the release phase
ADSR.prototype.noteOff = function () {
  this.sustainSamples = this.samplesProcessed - this.decaySamples;
  this.update();
};

ADSR.prototype.processSample = function (sample) {
  var amplitude = 0;

  if (this.samplesProcessed <= this.attack) {
    amplitude = 0 + (1 - 0) * ((this.samplesProcessed - 0) / (this.attack - 0));
  } else if (this.samplesProcessed > this.attack && this.samplesProcessed <= this.decay) {
    amplitude = 1 + (this.sustainLevel - 1) * ((this.samplesProcessed - this.attack) / (this.decay - this.attack));
  } else if (this.samplesProcessed > this.decay && this.samplesProcessed <= this.sustain) {
    amplitude = this.sustainLevel;
  } else if (this.samplesProcessed > this.sustain && this.samplesProcessed <= this.release) {
    amplitude = this.sustainLevel + (0 - this.sustainLevel) * ((this.samplesProcessed - this.sustain) / (this.release - this.sustain));
  }

  return sample * amplitude;
};

ADSR.prototype.value = function () {
  var amplitude = 0;

  if (this.samplesProcessed <= this.attack) {
    amplitude = 0 + (1 - 0) * ((this.samplesProcessed - 0) / (this.attack - 0));
  } else if (this.samplesProcessed > this.attack && this.samplesProcessed <= this.decay) {
    amplitude = 1 + (this.sustainLevel - 1) * ((this.samplesProcessed - this.attack) / (this.decay - this.attack));
  } else if (this.samplesProcessed > this.decay && this.samplesProcessed <= this.sustain) {
    amplitude = this.sustainLevel;
  } else if (this.samplesProcessed > this.sustain && this.samplesProcessed <= this.release) {
    amplitude = this.sustainLevel + (0 - this.sustainLevel) * ((this.samplesProcessed - this.sustain) / (this.release - this.sustain));
  }

  return amplitude;
};

ADSR.prototype.process = function (buffer) {
  for (var i = 0; i < buffer.length; i++) {
    buffer[i] *= this.value();

    this.samplesProcessed++;
  }

  return buffer;
};

ADSR.prototype.isActive = function () {
  if (this.samplesProcessed > this.release || this.samplesProcessed === -1) {
    return false;
  } else {
    return true;
  }
};

ADSR.prototype.disable = function () {
  this.samplesProcessed = -1;
};

function IIRFilter(type, cutoff, resonance, sampleRate) {
  this.sampleRate = sampleRate;

  switch (type) {
    case DSP.LOWPASS:
    case DSP.LP12:
      this.func = new IIRFilter.LP12(cutoff, resonance, sampleRate);
      break;
  }
}

IIRFilter.prototype.__defineGetter__('cutoff', function () {
  return this.func.cutoff;
});

IIRFilter.prototype.__defineGetter__('resonance', function () {
  return this.func.resonance;
});

IIRFilter.prototype.set = function (cutoff, resonance) {
  this.func.calcCoeff(cutoff, resonance);
};

IIRFilter.prototype.process = function (buffer) {
  this.func.process(buffer);
};

// Add an envelope to the filter
IIRFilter.prototype.addEnvelope = function (envelope) {
  if (envelope instanceof ADSR) {
    this.func.addEnvelope(envelope);
  } else {
    throw "Not an envelope.";
  }
};

IIRFilter.LP12 = function (cutoff, resonance, sampleRate) {
  this.sampleRate = sampleRate;
  this.vibraPos = 0;
  this.vibraSpeed = 0;
  this.envelope = false;

  this.calcCoeff = function (cutoff, resonance) {
    this.w = 2.0 * Math.PI * cutoff / this.sampleRate;
    this.q = 1.0 - this.w / (2.0 * (resonance + 0.5 / (1.0 + this.w)) + this.w - 2.0);
    this.r = this.q * this.q;
    this.c = this.r + 1.0 - 2.0 * Math.cos(this.w) * this.q;

    this.cutoff = cutoff;
    this.resonance = resonance;
  };

  this.calcCoeff(cutoff, resonance);

  this.process = function (buffer) {
    for (var i = 0; i < buffer.length; i++) {
      this.vibraSpeed += (buffer[i] - this.vibraPos) * this.c;
      this.vibraPos += this.vibraSpeed;
      this.vibraSpeed *= this.r;

      /*
      var temp = this.vibraPos;
            if ( temp > 1.0 ) {
        temp = 1.0;
      } else if ( temp < -1.0 ) {
        temp = -1.0;
      } else if ( temp != temp ) {
        temp = 1;
      }
            buffer[i] = temp;
      */

      if (this.envelope) {
        buffer[i] = buffer[i] * (1 - this.envelope.value()) + this.vibraPos * this.envelope.value();
        this.envelope.samplesProcessed++;
      } else {
        buffer[i] = this.vibraPos;
      }
    }
  };
};

IIRFilter.LP12.prototype.addEnvelope = function (envelope) {
  this.envelope = envelope;
};

function IIRFilter2(type, cutoff, resonance, sampleRate) {
  this.type = type;
  this.cutoff = cutoff;
  this.resonance = resonance;
  this.sampleRate = sampleRate;

  this.f = Float32Array(4);
  this.f[0] = 0.0; // lp
  this.f[1] = 0.0; // hp
  this.f[2] = 0.0; // bp
  this.f[3] = 0.0; // br 

  this.calcCoeff = function (cutoff, resonance) {
    this.freq = 2 * Math.sin(Math.PI * Math.min(0.25, cutoff / (this.sampleRate * 2)));
    this.damp = Math.min(2 * (1 - Math.pow(resonance, 0.25)), Math.min(2, 2 / this.freq - this.freq * 0.5));
  };

  this.calcCoeff(cutoff, resonance);
}

IIRFilter2.prototype.process = function (buffer) {
  var input, output;
  var f = this.f;

  for (var i = 0; i < buffer.length; i++) {
    input = buffer[i];

    // first pass
    f[3] = input - this.damp * f[2];
    f[0] = f[0] + this.freq * f[2];
    f[1] = f[3] - f[0];
    f[2] = this.freq * f[1] + f[2];
    output = 0.5 * f[this.type];

    // second pass
    f[3] = input - this.damp * f[2];
    f[0] = f[0] + this.freq * f[2];
    f[1] = f[3] - f[0];
    f[2] = this.freq * f[1] + f[2];
    output += 0.5 * f[this.type];

    if (this.envelope) {
      buffer[i] = buffer[i] * (1 - this.envelope.value()) + output * this.envelope.value();
      this.envelope.samplesProcessed++;
    } else {
      buffer[i] = output;
    }
  }
};

IIRFilter2.prototype.addEnvelope = function (envelope) {
  if (envelope instanceof ADSR) {
    this.envelope = envelope;
  } else {
    throw "This is not an envelope.";
  }
};

IIRFilter2.prototype.set = function (cutoff, resonance) {
  this.calcCoeff(cutoff, resonance);
};

function WindowFunction(type, alpha) {
  this.alpha = alpha;

  switch (type) {
    case DSP.BARTLETT:
      this.func = WindowFunction.Bartlett;
      break;

    case DSP.BARTLETTHANN:
      this.func = WindowFunction.BartlettHann;
      break;

    case DSP.BLACKMAN:
      this.func = WindowFunction.Blackman;
      this.alpha = this.alpha || 0.16;
      break;

    case DSP.COSINE:
      this.func = WindowFunction.Cosine;
      break;

    case DSP.GAUSS:
      this.func = WindowFunction.Gauss;
      this.alpha = this.alpha || 0.25;
      break;

    case DSP.HAMMING:
      this.func = WindowFunction.Hamming;
      break;

    case DSP.HANN:
      this.func = WindowFunction.Hann;
      break;

    case DSP.LANCZOS:
      this.func = WindowFunction.Lanczoz;
      break;

    case DSP.RECTANGULAR:
      this.func = WindowFunction.Rectangular;
      break;

    case DSP.TRIANGULAR:
      this.func = WindowFunction.Triangular;
      break;
  }
}

WindowFunction.prototype.process = function (buffer) {
  var length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] *= this.func(length, i, this.alpha);
  }
  return buffer;
};

WindowFunction.Bartlett = function (length, index) {
  return 2 / (length - 1) * ((length - 1) / 2 - Math.abs(index - (length - 1) / 2));
};

WindowFunction.BartlettHann = function (length, index) {
  return 0.62 - 0.48 * Math.abs(index / (length - 1) - 0.5) - 0.38 * Math.cos(DSP.TWO_PI * index / (length - 1));
};

WindowFunction.Blackman = function (length, index, alpha) {
  var a0 = (1 - alpha) / 2;
  var a1 = 0.5;
  var a2 = alpha / 2;

  return a0 - a1 * Math.cos(DSP.TWO_PI * index / (length - 1)) + a2 * Math.cos(4 * Math.PI * index / (length - 1));
};

WindowFunction.Cosine = function (length, index) {
  return Math.cos(Math.PI * index / (length - 1) - Math.PI / 2);
};

WindowFunction.Gauss = function (length, index, alpha) {
  return Math.pow(Math.E, -0.5 * Math.pow((index - (length - 1) / 2) / (alpha * (length - 1) / 2), 2));
};

WindowFunction.Hamming = function (length, index) {
  return 0.54 - 0.46 * Math.cos(DSP.TWO_PI * index / (length - 1));
};

WindowFunction.Hann = function (length, index) {
  return 0.5 * (1 - Math.cos(DSP.TWO_PI * index / (length - 1)));
};

WindowFunction.Lanczos = function (length, index) {
  var x = 2 * index / (length - 1) - 1;
  return Math.sin(Math.PI * x) / (Math.PI * x);
};

WindowFunction.Rectangular = function (length, index) {
  return 1;
};

WindowFunction.Triangular = function (length, index) {
  return 2 / length * (length / 2 - Math.abs(index - (length - 1) / 2));
};

function sinh(arg) {
  // Returns the hyperbolic sine of the number, defined as (exp(number) - exp(-number))/2 
  //
  // version: 1004.2314
  // discuss at: http://phpjs.org/functions/sinh    // +   original by: Onno Marsman
  // *     example 1: sinh(-0.9834330348825909);
  // *     returns 1: -1.1497971402636502
  return (Math.exp(arg) - Math.exp(-arg)) / 2;
}

/* 
 *  Biquad filter
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 */
// Implementation based on:
// http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
function Biquad(type, sampleRate) {
  this.Fs = sampleRate;
  this.type = type; // type of the filter
  this.parameterType = DSP.Q; // type of the parameter

  this.x_1_l = 0;
  this.x_2_l = 0;
  this.y_1_l = 0;
  this.y_2_l = 0;

  this.x_1_r = 0;
  this.x_2_r = 0;
  this.y_1_r = 0;
  this.y_2_r = 0;

  this.b0 = 1;
  this.a0 = 1;

  this.b1 = 0;
  this.a1 = 0;

  this.b2 = 0;
  this.a2 = 0;

  this.b0a0 = this.b0 / this.a0;
  this.b1a0 = this.b1 / this.a0;
  this.b2a0 = this.b2 / this.a0;
  this.a1a0 = this.a1 / this.a0;
  this.a2a0 = this.a2 / this.a0;

  this.f0 = 3000; // "wherever it's happenin', man."  Center Frequency or
  // Corner Frequency, or shelf midpoint frequency, depending
  // on which filter type.  The "significant frequency".

  this.dBgain = 12; // used only for peaking and shelving filters

  this.Q = 1; // the EE kind of definition, except for peakingEQ in which A*Q is
  // the classic EE Q.  That adjustment in definition was made so that
  // a boost of N dB followed by a cut of N dB for identical Q and
  // f0/Fs results in a precisely flat unity gain filter or "wire".

  this.BW = -3; // the bandwidth in octaves (between -3 dB frequencies for BPF
  // and notch or between midpoint (dBgain/2) gain frequencies for
  // peaking EQ

  this.S = 1; // a "shelf slope" parameter (for shelving EQ only).  When S = 1,
  // the shelf slope is as steep as it can be and remain monotonically
  // increasing or decreasing gain with frequency.  The shelf slope, in
  // dB/octave, remains proportional to S for all other values for a
  // fixed f0/Fs and dBgain.

  this.coefficients = function () {
    var b = [this.b0, this.b1, this.b2];
    var a = [this.a0, this.a1, this.a2];
    return { b: b, a: a };
  };

  this.setFilterType = function (type) {
    this.type = type;
    this.recalculateCoefficients();
  };

  this.setSampleRate = function (rate) {
    this.Fs = rate;
    this.recalculateCoefficients();
  };

  this.setQ = function (q) {
    this.parameterType = DSP.Q;
    this.Q = Math.max(Math.min(q, 115.0), 0.001);
    this.recalculateCoefficients();
  };

  this.setBW = function (bw) {
    this.parameterType = DSP.BW;
    this.BW = bw;
    this.recalculateCoefficients();
  };

  this.setS = function (s) {
    this.parameterType = DSP.S;
    this.S = Math.max(Math.min(s, 5.0), 0.0001);
    this.recalculateCoefficients();
  };

  this.setF0 = function (freq) {
    this.f0 = freq;
    this.recalculateCoefficients();
  };

  this.setDbGain = function (g) {
    this.dBgain = g;
    this.recalculateCoefficients();
  };

  this.recalculateCoefficients = function () {
    var A;
    if (type === DSP.PEAKING_EQ || type === DSP.LOW_SHELF || type === DSP.HIGH_SHELF) {
      A = Math.pow(10, this.dBgain / 40); // for peaking and shelving EQ filters only
    } else {
      A = Math.sqrt(Math.pow(10, this.dBgain / 20));
    }

    var w0 = DSP.TWO_PI * this.f0 / this.Fs;

    var cosw0 = Math.cos(w0);
    var sinw0 = Math.sin(w0);

    var alpha = 0;

    switch (this.parameterType) {
      case DSP.Q:
        alpha = sinw0 / (2 * this.Q);
        break;

      case DSP.BW:
        alpha = sinw0 * sinh(Math.LN2 / 2 * this.BW * w0 / sinw0);
        break;

      case DSP.S:
        alpha = sinw0 / 2 * Math.sqrt((A + 1 / A) * (1 / this.S - 1) + 2);
        break;
    }

    /**
        FYI: The relationship between bandwidth and Q is
             1/Q = 2*sinh(ln(2)/2*BW*w0/sin(w0))     (digital filter w BLT)
        or   1/Q = 2*sinh(ln(2)/2*BW)             (analog filter prototype)
         The relationship between shelf slope and Q is
             1/Q = sqrt((A + 1/A)*(1/S - 1) + 2)
    */

    var coeff;

    switch (this.type) {
      case DSP.LPF:
        // H(s) = 1 / (s^2 + s/Q + 1)
        this.b0 = (1 - cosw0) / 2;
        this.b1 = 1 - cosw0;
        this.b2 = (1 - cosw0) / 2;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.HPF:
        // H(s) = s^2 / (s^2 + s/Q + 1)
        this.b0 = (1 + cosw0) / 2;
        this.b1 = -(1 + cosw0);
        this.b2 = (1 + cosw0) / 2;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.BPF_CONSTANT_SKIRT:
        // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
        this.b0 = sinw0 / 2;
        this.b1 = 0;
        this.b2 = -sinw0 / 2;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.BPF_CONSTANT_PEAK:
        // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
        this.b0 = alpha;
        this.b1 = 0;
        this.b2 = -alpha;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.NOTCH:
        // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
        this.b0 = 1;
        this.b1 = -2 * cosw0;
        this.b2 = 1;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.APF:
        // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
        this.b0 = 1 - alpha;
        this.b1 = -2 * cosw0;
        this.b2 = 1 + alpha;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.PEAKING_EQ:
        // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
        this.b0 = 1 + alpha * A;
        this.b1 = -2 * cosw0;
        this.b2 = 1 - alpha * A;
        this.a0 = 1 + alpha / A;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha / A;
        break;

      case DSP.LOW_SHELF:
        // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
        coeff = sinw0 * Math.sqrt((A ^ 2 + 1) * (1 / this.S - 1) + 2 * A);
        this.b0 = A * (A + 1 - (A - 1) * cosw0 + coeff);
        this.b1 = 2 * A * (A - 1 - (A + 1) * cosw0);
        this.b2 = A * (A + 1 - (A - 1) * cosw0 - coeff);
        this.a0 = A + 1 + (A - 1) * cosw0 + coeff;
        this.a1 = -2 * (A - 1 + (A + 1) * cosw0);
        this.a2 = A + 1 + (A - 1) * cosw0 - coeff;
        break;

      case DSP.HIGH_SHELF:
        // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)
        coeff = sinw0 * Math.sqrt((A ^ 2 + 1) * (1 / this.S - 1) + 2 * A);
        this.b0 = A * (A + 1 + (A - 1) * cosw0 + coeff);
        this.b1 = -2 * A * (A - 1 + (A + 1) * cosw0);
        this.b2 = A * (A + 1 + (A - 1) * cosw0 - coeff);
        this.a0 = A + 1 - (A - 1) * cosw0 + coeff;
        this.a1 = 2 * (A - 1 - (A + 1) * cosw0);
        this.a2 = A + 1 - (A - 1) * cosw0 - coeff;
        break;
    }

    this.b0a0 = this.b0 / this.a0;
    this.b1a0 = this.b1 / this.a0;
    this.b2a0 = this.b2 / this.a0;
    this.a1a0 = this.a1 / this.a0;
    this.a2a0 = this.a2 / this.a0;
  };

  this.process = function (buffer) {
    //y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
    //       - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]

    var len = buffer.length;
    var output = new Float32Array(len);

    for (var i = 0; i < buffer.length; i++) {
      output[i] = this.b0a0 * buffer[i] + this.b1a0 * this.x_1_l + this.b2a0 * this.x_2_l - this.a1a0 * this.y_1_l - this.a2a0 * this.y_2_l;
      this.y_2_l = this.y_1_l;
      this.y_1_l = output[i];
      this.x_2_l = this.x_1_l;
      this.x_1_l = buffer[i];
    }

    return output;
  };

  this.processStereo = function (buffer) {
    //y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
    //       - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]

    var len = buffer.length;
    var output = new Float32Array(len);

    for (var i = 0; i < len / 2; i++) {
      output[2 * i] = this.b0a0 * buffer[2 * i] + this.b1a0 * this.x_1_l + this.b2a0 * this.x_2_l - this.a1a0 * this.y_1_l - this.a2a0 * this.y_2_l;
      this.y_2_l = this.y_1_l;
      this.y_1_l = output[2 * i];
      this.x_2_l = this.x_1_l;
      this.x_1_l = buffer[2 * i];

      output[2 * i + 1] = this.b0a0 * buffer[2 * i + 1] + this.b1a0 * this.x_1_r + this.b2a0 * this.x_2_r - this.a1a0 * this.y_1_r - this.a2a0 * this.y_2_r;
      this.y_2_r = this.y_1_r;
      this.y_1_r = output[2 * i + 1];
      this.x_2_r = this.x_1_r;
      this.x_1_r = buffer[2 * i + 1];
    }

    return output;
  };
}

/* 
 *  Magnitude to decibels
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 *  @buffer array of magnitudes to convert to decibels
 *
 *  @returns the array in decibels
 *
 */
DSP.mag2db = function (buffer) {
  var minDb = -120;
  var minMag = Math.pow(10.0, minDb / 20.0);

  var log = Math.log;
  var max = Math.max;

  var result = Float32Array(buffer.length);
  for (var i = 0; i < buffer.length; i++) {
    result[i] = 20.0 * log(max(buffer[i], minMag));
  }

  return result;
};

/* 
 *  Frequency response
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 *  Calculates the frequency response at the given points.
 *
 *  @b b coefficients of the filter
 *  @a a coefficients of the filter
 *  @w w points (normally between -PI and PI) where to calculate the frequency response
 *
 *  @returns the frequency response in magnitude
 *
 */
DSP.freqz = function (b, a, w) {
  var i, j;

  if (!w) {
    w = Float32Array(200);
    for (i = 0; i < w.length; i++) {
      w[i] = DSP.TWO_PI / w.length * i - Math.PI;
    }
  }

  var result = Float32Array(w.length);

  var sqrt = Math.sqrt;
  var cos = Math.cos;
  var sin = Math.sin;

  for (i = 0; i < w.length; i++) {
    var numerator = { real: 0.0, imag: 0.0 };
    for (j = 0; j < b.length; j++) {
      numerator.real += b[j] * cos(-j * w[i]);
      numerator.imag += b[j] * sin(-j * w[i]);
    }

    var denominator = { real: 0.0, imag: 0.0 };
    for (j = 0; j < a.length; j++) {
      denominator.real += a[j] * cos(-j * w[i]);
      denominator.imag += a[j] * sin(-j * w[i]);
    }

    result[i] = sqrt(numerator.real * numerator.real + numerator.imag * numerator.imag) / sqrt(denominator.real * denominator.real + denominator.imag * denominator.imag);
  }

  return result;
};

/* 
 *  Graphical Equalizer
 *
 *  Implementation of a graphic equalizer with a configurable bands-per-octave
 *  and minimum and maximum frequencies
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 */
function GraphicalEq(sampleRate) {
  this.FS = sampleRate;
  this.minFreq = 40.0;
  this.maxFreq = 16000.0;

  this.bandsPerOctave = 1.0;

  this.filters = [];
  this.freqzs = [];

  this.calculateFreqzs = true;

  this.recalculateFilters = function () {
    var bandCount = Math.round(Math.log(this.maxFreq / this.minFreq) * this.bandsPerOctave / Math.LN2);

    this.filters = [];
    for (var i = 0; i < bandCount; i++) {
      var freq = this.minFreq * Math.pow(2, i / this.bandsPerOctave);
      var newFilter = new Biquad(DSP.PEAKING_EQ, this.FS);
      newFilter.setDbGain(0);
      newFilter.setBW(1 / this.bandsPerOctave);
      newFilter.setF0(freq);
      this.filters[i] = newFilter;
      this.recalculateFreqz(i);
    }
  };

  this.setMinimumFrequency = function (freq) {
    this.minFreq = freq;
    this.recalculateFilters();
  };

  this.setMaximumFrequency = function (freq) {
    this.maxFreq = freq;
    this.recalculateFilters();
  };

  this.setBandsPerOctave = function (bands) {
    this.bandsPerOctave = bands;
    this.recalculateFilters();
  };

  this.setBandGain = function (bandIndex, gain) {
    if (bandIndex < 0 || bandIndex > this.filters.length - 1) {
      throw "The band index of the graphical equalizer is out of bounds.";
    }

    if (!gain) {
      throw "A gain must be passed.";
    }

    this.filters[bandIndex].setDbGain(gain);
    this.recalculateFreqz(bandIndex);
  };

  this.recalculateFreqz = function (bandIndex) {
    if (!this.calculateFreqzs) {
      return;
    }

    if (bandIndex < 0 || bandIndex > this.filters.length - 1) {
      throw "The band index of the graphical equalizer is out of bounds. " + bandIndex + " is out of [" + 0 + ", " + this.filters.length - 1 + "]";
    }

    if (!this.w) {
      this.w = Float32Array(400);
      for (var i = 0; i < this.w.length; i++) {
        this.w[i] = Math.PI / this.w.length * i;
      }
    }

    var b = [this.filters[bandIndex].b0, this.filters[bandIndex].b1, this.filters[bandIndex].b2];
    var a = [this.filters[bandIndex].a0, this.filters[bandIndex].a1, this.filters[bandIndex].a2];

    this.freqzs[bandIndex] = DSP.mag2db(DSP.freqz(b, a, this.w));
  };

  this.process = function (buffer) {
    var output = buffer;

    for (var i = 0; i < this.filters.length; i++) {
      output = this.filters[i].process(output);
    }

    return output;
  };

  this.processStereo = function (buffer) {
    var output = buffer;

    for (var i = 0; i < this.filters.length; i++) {
      output = this.filters[i].processStereo(output);
    }

    return output;
  };
}

/**
 * MultiDelay effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: http://code.almeros.com/code-examples/delay-firefox-audio-api/
 *
 * This is a delay that feeds it's own delayed signal back into its circular
 * buffer. Also known as a CombFilter.
 *
 * Compatible with interleaved stereo (or more channel) buffers and
 * non-interleaved mono buffers.
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffer)
 * @param {Number} delayInSamples Initial delay in samples
 * @param {Number} masterVolume Initial master volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} delayVolume Initial feedback delay volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 *
 * @constructor
 */
function MultiDelay(maxDelayInSamplesSize, delayInSamples, masterVolume, delayVolume) {
  this.delayBufferSamples = new Float32Array(maxDelayInSamplesSize); // The maximum size of delay
  this.delayInputPointer = delayInSamples;
  this.delayOutputPointer = 0;

  this.delayInSamples = delayInSamples;
  this.masterVolume = masterVolume;
  this.delayVolume = delayVolume;
}

/**
 * Change the delay time in samples.
 *
 * @param {Number} delayInSamples Delay in samples
 */
MultiDelay.prototype.setDelayInSamples = function (delayInSamples) {
  this.delayInSamples = delayInSamples;

  this.delayInputPointer = this.delayOutputPointer + delayInSamples;

  if (this.delayInputPointer >= this.delayBufferSamples.length - 1) {
    this.delayInputPointer = this.delayInputPointer - this.delayBufferSamples.length;
  }
};

/**
 * Change the master volume.
 *
 * @param {Number} masterVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
MultiDelay.prototype.setMasterVolume = function (masterVolume) {
  this.masterVolume = masterVolume;
};

/**
 * Change the delay feedback volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
MultiDelay.prototype.setDelayVolume = function (delayVolume) {
  this.delayVolume = delayVolume;
};

/**
 * Process a given interleaved or mono non-interleaved float value Array and adds the delayed audio.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved or mono non-interleaved as was fed to this function.
 */
MultiDelay.prototype.process = function (samples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(samples.length);

  for (var i = 0; i < samples.length; i++) {
    // delayBufferSamples could contain initial NULL's, return silence in that case
    var delaySample = this.delayBufferSamples[this.delayOutputPointer] === null ? 0.0 : this.delayBufferSamples[this.delayOutputPointer];

    // Mix normal audio data with delayed audio
    var sample = delaySample * this.delayVolume + samples[i];

    // Add audio data with the delay in the delay buffer
    this.delayBufferSamples[this.delayInputPointer] = sample;

    // Return the audio with delay mix
    outputSamples[i] = sample * this.masterVolume;

    // Manage circulair delay buffer pointers
    this.delayInputPointer++;
    if (this.delayInputPointer >= this.delayBufferSamples.length - 1) {
      this.delayInputPointer = 0;
    }

    this.delayOutputPointer++;
    if (this.delayOutputPointer >= this.delayBufferSamples.length - 1) {
      this.delayOutputPointer = 0;
    }
  }

  return outputSamples;
};

/**
 * SingleDelay effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: See usage in Reverb class
 *
 * This is a delay that does NOT feeds it's own delayed signal back into its 
 * circular buffer, neither does it return the original signal. Also known as
 * an AllPassFilter(?).
 *
 * Compatible with interleaved stereo (or more channel) buffers and
 * non-interleaved mono buffers.
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffer)
 * @param {Number} delayInSamples Initial delay in samples
 * @param {Number} delayVolume Initial feedback delay volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 *
 * @constructor
 */

function SingleDelay(maxDelayInSamplesSize, delayInSamples, delayVolume) {
  this.delayBufferSamples = new Float32Array(maxDelayInSamplesSize); // The maximum size of delay
  this.delayInputPointer = delayInSamples;
  this.delayOutputPointer = 0;

  this.delayInSamples = delayInSamples;
  this.delayVolume = delayVolume;
}

/**
 * Change the delay time in samples.
 *
 * @param {Number} delayInSamples Delay in samples
 */
SingleDelay.prototype.setDelayInSamples = function (delayInSamples) {
  this.delayInSamples = delayInSamples;
  this.delayInputPointer = this.delayOutputPointer + delayInSamples;

  if (this.delayInputPointer >= this.delayBufferSamples.length - 1) {
    this.delayInputPointer = this.delayInputPointer - this.delayBufferSamples.length;
  }
};

/**
 * Change the return signal volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
SingleDelay.prototype.setDelayVolume = function (delayVolume) {
  this.delayVolume = delayVolume;
};

/**
 * Process a given interleaved or mono non-interleaved float value Array and
 * returns the delayed audio.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved or mono non-interleaved as was fed to this function.
 */
SingleDelay.prototype.process = function (samples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(samples.length);

  for (var i = 0; i < samples.length; i++) {

    // Add audio data with the delay in the delay buffer
    this.delayBufferSamples[this.delayInputPointer] = samples[i];

    // delayBufferSamples could contain initial NULL's, return silence in that case
    var delaySample = this.delayBufferSamples[this.delayOutputPointer];

    // Return the audio with delay mix
    outputSamples[i] = delaySample * this.delayVolume;

    // Manage circulair delay buffer pointers
    this.delayInputPointer++;

    if (this.delayInputPointer >= this.delayBufferSamples.length - 1) {
      this.delayInputPointer = 0;
    }

    this.delayOutputPointer++;

    if (this.delayOutputPointer >= this.delayBufferSamples.length - 1) {
      this.delayOutputPointer = 0;
    }
  }

  return outputSamples;
};

/**
 * Reverb effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: http://code.almeros.com/code-examples/reverb-firefox-audio-api/
 *
 * This reverb consists of 6 SingleDelays, 6 MultiDelays and an IIRFilter2
 * for each of the two stereo channels.
 *
 * Compatible with interleaved stereo buffers only!
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffers)
 * @param {Number} delayInSamples Initial delay in samples for internal (Single/Multi)delays
 * @param {Number} masterVolume Initial master volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} mixVolume Initial reverb signal mix volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} delayVolume Initial feedback delay volume for internal (Single/Multi)delays. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} dampFrequency Initial low pass filter frequency. 0 to 44100 (depending on your maximum sampling frequency)
 *
 * @constructor
 */
function Reverb(maxDelayInSamplesSize, delayInSamples, masterVolume, mixVolume, delayVolume, dampFrequency) {
  this.delayInSamples = delayInSamples;
  this.masterVolume = masterVolume;
  this.mixVolume = mixVolume;
  this.delayVolume = delayVolume;
  this.dampFrequency = dampFrequency;

  this.NR_OF_MULTIDELAYS = 6;
  this.NR_OF_SINGLEDELAYS = 6;

  this.LOWPASSL = new IIRFilter2(DSP.LOWPASS, dampFrequency, 0, 44100);
  this.LOWPASSR = new IIRFilter2(DSP.LOWPASS, dampFrequency, 0, 44100);

  this.singleDelays = [];

  var i, delayMultiply;

  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    delayMultiply = 1.0 + i / 7.0; // 1.0, 1.1, 1.2...
    this.singleDelays[i] = new SingleDelay(maxDelayInSamplesSize, Math.round(this.delayInSamples * delayMultiply), this.delayVolume);
  }

  this.multiDelays = [];

  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    delayMultiply = 1.0 + i / 10.0; // 1.0, 1.1, 1.2... 
    this.multiDelays[i] = new MultiDelay(maxDelayInSamplesSize, Math.round(this.delayInSamples * delayMultiply), this.masterVolume, this.delayVolume);
  }
}

/**
 * Change the delay time in samples as a base for all delays.
 *
 * @param {Number} delayInSamples Delay in samples
 */
Reverb.prototype.setDelayInSamples = function (delayInSamples) {
  this.delayInSamples = delayInSamples;

  var i, delayMultiply;

  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    delayMultiply = 1.0 + i / 7.0; // 1.0, 1.1, 1.2...
    this.singleDelays[i].setDelayInSamples(Math.round(this.delayInSamples * delayMultiply));
  }

  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    delayMultiply = 1.0 + i / 10.0; // 1.0, 1.1, 1.2...
    this.multiDelays[i].setDelayInSamples(Math.round(this.delayInSamples * delayMultiply));
  }
};

/**
 * Change the master volume.
 *
 * @param {Number} masterVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setMasterVolume = function (masterVolume) {
  this.masterVolume = masterVolume;
};

/**
 * Change the reverb signal mix level.
 *
 * @param {Number} mixVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setMixVolume = function (mixVolume) {
  this.mixVolume = mixVolume;
};

/**
 * Change all delays feedback volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setDelayVolume = function (delayVolume) {
  this.delayVolume = delayVolume;

  var i;

  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    this.singleDelays[i].setDelayVolume(this.delayVolume);
  }

  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    this.multiDelays[i].setDelayVolume(this.delayVolume);
  }
};

/**
 * Change the Low Pass filter frequency.
 *
 * @param {Number} dampFrequency low pass filter frequency. 0 to 44100 (depending on your maximum sampling frequency)
 */
Reverb.prototype.setDampFrequency = function (dampFrequency) {
  this.dampFrequency = dampFrequency;

  this.LOWPASSL.set(dampFrequency, 0);
  this.LOWPASSR.set(dampFrequency, 0);
};

/**
 * Process a given interleaved float value Array and copies and adds the reverb signal.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved buffer.
 */
Reverb.prototype.process = function (interleavedSamples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(interleavedSamples.length);

  // Perform low pass on the input samples to mimick damp
  var leftRightMix = DSP.deinterleave(interleavedSamples);
  this.LOWPASSL.process(leftRightMix[DSP.LEFT]);
  this.LOWPASSR.process(leftRightMix[DSP.RIGHT]);
  var filteredSamples = DSP.interleave(leftRightMix[DSP.LEFT], leftRightMix[DSP.RIGHT]);

  var i;

  // Process MultiDelays in parallel
  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    // Invert the signal of every even multiDelay
    outputSamples = DSP.mixSampleBuffers(outputSamples, this.multiDelays[i].process(filteredSamples), 2 % i === 0, this.NR_OF_MULTIDELAYS);
  }

  // Process SingleDelays in series
  var singleDelaySamples = new Float32Array(outputSamples.length);
  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    // Invert the signal of every even singleDelay
    singleDelaySamples = DSP.mixSampleBuffers(singleDelaySamples, this.singleDelays[i].process(outputSamples), 2 % i === 0, 1);
  }

  // Apply the volume of the reverb signal
  for (i = 0; i < singleDelaySamples.length; i++) {
    singleDelaySamples[i] *= this.mixVolume;
  }

  // Mix the original signal with the reverb signal
  outputSamples = DSP.mixSampleBuffers(singleDelaySamples, interleavedSamples, 0, 1);

  // Apply the master volume to the complete signal
  for (i = 0; i < outputSamples.length; i++) {
    outputSamples[i] *= this.masterVolume;
  }

  return outputSamples;
};

exports.default = DSP;
exports.FFT = FFT;

},{"babel-runtime/helpers/typeof":38}],22:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":39}],23:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":40}],24:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-properties"), __esModule: true };
},{"core-js/library/fn/object/define-properties":41}],25:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":42}],26:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":43}],27:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/get-prototype-of":44}],28:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":45}],29:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":46}],30:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":47}],31:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":48}],32:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/weak-map"), __esModule: true };
},{"core-js/library/fn/weak-map":49}],33:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],34:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
},{"../core-js/object/define-property":25}],35:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getPrototypeOf = require("../core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _getOwnPropertyDescriptor = require("../core-js/object/get-own-property-descriptor");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);

  if (desc === undefined) {
    var parent = (0, _getPrototypeOf2.default)(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};
},{"../core-js/object/get-own-property-descriptor":26,"../core-js/object/get-prototype-of":27}],36:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _setPrototypeOf = require("../core-js/object/set-prototype-of");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = require("../core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
},{"../core-js/object/create":23,"../core-js/object/set-prototype-of":28,"../helpers/typeof":38}],37:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};
},{"../helpers/typeof":38}],38:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":30,"../core-js/symbol/iterator":31}],39:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');

},{"../modules/core.get-iterator":127,"../modules/es6.string.iterator":137,"../modules/web.dom.iterable":147}],40:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};

},{"../../modules/_core":65,"../../modules/es6.object.create":129}],41:[function(require,module,exports){
require('../../modules/es6.object.define-properties');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperties(T, D) {
  return $Object.defineProperties(T, D);
};

},{"../../modules/_core":65,"../../modules/es6.object.define-properties":130}],42:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

},{"../../modules/_core":65,"../../modules/es6.object.define-property":131}],43:[function(require,module,exports){
require('../../modules/es6.object.get-own-property-descriptor');
var $Object = require('../../modules/_core').Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};

},{"../../modules/_core":65,"../../modules/es6.object.get-own-property-descriptor":132}],44:[function(require,module,exports){
require('../../modules/es6.object.get-prototype-of');
module.exports = require('../../modules/_core').Object.getPrototypeOf;

},{"../../modules/_core":65,"../../modules/es6.object.get-prototype-of":133}],45:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/_core').Object.setPrototypeOf;

},{"../../modules/_core":65,"../../modules/es6.object.set-prototype-of":134}],46:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
require('../modules/es7.set.of');
require('../modules/es7.set.from');
module.exports = require('../modules/_core').Set;

},{"../modules/_core":65,"../modules/es6.object.to-string":135,"../modules/es6.set":136,"../modules/es6.string.iterator":137,"../modules/es7.set.from":140,"../modules/es7.set.of":141,"../modules/es7.set.to-json":142,"../modules/web.dom.iterable":147}],47:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":65,"../../modules/es6.object.to-string":135,"../../modules/es6.symbol":138,"../../modules/es7.symbol.async-iterator":143,"../../modules/es7.symbol.observable":144}],48:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":124,"../../modules/es6.string.iterator":137,"../../modules/web.dom.iterable":147}],49:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/web.dom.iterable');
require('../modules/es6.weak-map');
require('../modules/es7.weak-map.of');
require('../modules/es7.weak-map.from');
module.exports = require('../modules/_core').WeakMap;

},{"../modules/_core":65,"../modules/es6.object.to-string":135,"../modules/es6.weak-map":139,"../modules/es7.weak-map.from":145,"../modules/es7.weak-map.of":146,"../modules/web.dom.iterable":147}],50:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],51:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],52:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],53:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":83}],54:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":74}],55:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":115,"./_to-iobject":117,"./_to-length":118}],56:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":58,"./_ctx":66,"./_iobject":80,"./_to-length":118,"./_to-object":119}],57:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":82,"./_is-object":83,"./_wks":125}],58:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":57}],59:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":60,"./_wks":125}],60:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],61:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":52,"./_ctx":66,"./_descriptors":68,"./_for-of":74,"./_iter-define":86,"./_iter-step":87,"./_meta":90,"./_object-create":92,"./_object-dp":93,"./_redefine-all":105,"./_set-species":110,"./_validate-collection":122}],62:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":54,"./_classof":59}],63:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":52,"./_an-object":53,"./_array-methods":56,"./_for-of":74,"./_has":76,"./_is-object":83,"./_meta":90,"./_redefine-all":105,"./_validate-collection":122}],64:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var meta = require('./_meta');
var fails = require('./_fails');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var setToStringTag = require('./_set-to-string-tag');
var dP = require('./_object-dp').f;
var each = require('./_array-methods')(0);
var DESCRIPTORS = require('./_descriptors');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":52,"./_array-methods":56,"./_descriptors":68,"./_export":72,"./_fails":73,"./_for-of":74,"./_global":75,"./_hide":77,"./_is-object":83,"./_meta":90,"./_object-dp":93,"./_redefine-all":105,"./_set-to-string-tag":111}],65:[function(require,module,exports){
var core = module.exports = { version: '2.5.4' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],66:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":50}],67:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],68:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":73}],69:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":75,"./_is-object":83}],70:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],71:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":98,"./_object-keys":101,"./_object-pie":102}],72:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":65,"./_ctx":66,"./_global":75,"./_has":76,"./_hide":77}],73:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],74:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":53,"./_ctx":66,"./_is-array-iter":81,"./_iter-call":84,"./_to-length":118,"./core.get-iterator-method":126}],75:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],76:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],77:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":68,"./_object-dp":93,"./_property-desc":104}],78:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":75}],79:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":68,"./_dom-create":69,"./_fails":73}],80:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":60}],81:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":88,"./_wks":125}],82:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":60}],83:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],84:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":53}],85:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":77,"./_object-create":92,"./_property-desc":104,"./_set-to-string-tag":111,"./_wks":125}],86:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":72,"./_hide":77,"./_iter-create":85,"./_iterators":88,"./_library":89,"./_object-gpo":99,"./_redefine":106,"./_set-to-string-tag":111,"./_wks":125}],87:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],88:[function(require,module,exports){
module.exports = {};

},{}],89:[function(require,module,exports){
module.exports = true;

},{}],90:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":73,"./_has":76,"./_is-object":83,"./_object-dp":93,"./_uid":121}],91:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":73,"./_iobject":80,"./_object-gops":98,"./_object-keys":101,"./_object-pie":102,"./_to-object":119}],92:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":53,"./_dom-create":69,"./_enum-bug-keys":70,"./_html":78,"./_object-dps":94,"./_shared-key":112}],93:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":53,"./_descriptors":68,"./_ie8-dom-define":79,"./_to-primitive":120}],94:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":53,"./_descriptors":68,"./_object-dp":93,"./_object-keys":101}],95:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":68,"./_has":76,"./_ie8-dom-define":79,"./_object-pie":102,"./_property-desc":104,"./_to-iobject":117,"./_to-primitive":120}],96:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":97,"./_to-iobject":117}],97:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":70,"./_object-keys-internal":100}],98:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],99:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":76,"./_shared-key":112,"./_to-object":119}],100:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":55,"./_has":76,"./_shared-key":112,"./_to-iobject":117}],101:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":70,"./_object-keys-internal":100}],102:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],103:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":65,"./_export":72,"./_fails":73}],104:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],105:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};

},{"./_hide":77}],106:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":77}],107:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":50,"./_ctx":66,"./_export":72,"./_for-of":74}],108:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":72}],109:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":53,"./_ctx":66,"./_is-object":83,"./_object-gopd":95}],110:[function(require,module,exports){
'use strict';
var global = require('./_global');
var core = require('./_core');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_core":65,"./_descriptors":68,"./_global":75,"./_object-dp":93,"./_wks":125}],111:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":76,"./_object-dp":93,"./_wks":125}],112:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":113,"./_uid":121}],113:[function(require,module,exports){
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":75}],114:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":67,"./_to-integer":116}],115:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":116}],116:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],117:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":67,"./_iobject":80}],118:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":116}],119:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":67}],120:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":83}],121:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],122:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":83}],123:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":65,"./_global":75,"./_library":89,"./_object-dp":93,"./_wks-ext":124}],124:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":125}],125:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":75,"./_shared":113,"./_uid":121}],126:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":59,"./_core":65,"./_iterators":88,"./_wks":125}],127:[function(require,module,exports){
var anObject = require('./_an-object');
var get = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

},{"./_an-object":53,"./_core":65,"./core.get-iterator-method":126}],128:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":51,"./_iter-define":86,"./_iter-step":87,"./_iterators":88,"./_to-iobject":117}],129:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":72,"./_object-create":92}],130:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":68,"./_export":72,"./_object-dps":94}],131:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":68,"./_export":72,"./_object-dp":93}],132:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":95,"./_object-sap":103,"./_to-iobject":117}],133:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":99,"./_object-sap":103,"./_to-object":119}],134:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":72,"./_set-proto":109}],135:[function(require,module,exports){

},{}],136:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":64,"./_collection-strong":61,"./_validate-collection":122}],137:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":86,"./_string-at":114}],138:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":53,"./_descriptors":68,"./_enum-keys":71,"./_export":72,"./_fails":73,"./_global":75,"./_has":76,"./_hide":77,"./_is-array":82,"./_is-object":83,"./_library":89,"./_meta":90,"./_object-create":92,"./_object-dp":93,"./_object-gopd":95,"./_object-gopn":97,"./_object-gopn-ext":96,"./_object-gops":98,"./_object-keys":101,"./_object-pie":102,"./_property-desc":104,"./_redefine":106,"./_set-to-string-tag":111,"./_shared":113,"./_to-iobject":117,"./_to-primitive":120,"./_uid":121,"./_wks":125,"./_wks-define":123,"./_wks-ext":124}],139:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":56,"./_collection":64,"./_collection-weak":63,"./_fails":73,"./_is-object":83,"./_meta":90,"./_object-assign":91,"./_redefine":106,"./_validate-collection":122}],140:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":107}],141:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":108}],142:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":62,"./_export":72}],143:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":123}],144:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":123}],145:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":107}],146:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":108}],147:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":75,"./_hide":77,"./_iterators":88,"./_wks":125,"./es6.array.iterator":128}],148:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":149,"_process":151}],149:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":150}],150:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],151:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[12])(12)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2NvcmUvYXVkaW8tY29udGV4dC5qcyIsImRpc3QvY29yZS9hdWRpby10aW1lLWVuZ2luZS5qcyIsImRpc3QvY29yZS9wcmlvcml0eS1xdWV1ZS5qcyIsImRpc3QvY29yZS9zY2hlZHVsaW5nLXF1ZXVlLmpzIiwiZGlzdC9jb3JlL3RpbWUtZW5naW5lLmpzIiwiZGlzdC9lbmdpbmVzL2dyYW51bGFyLWVuZ2luZS5qcyIsImRpc3QvZW5naW5lcy9tZXRyb25vbWUuanMiLCJkaXN0L2VuZ2luZXMvcGhhc2V2b2NvZGVyLWVuZ2luZS5qcyIsImRpc3QvZW5naW5lcy9wbGF5ZXItZW5naW5lLmpzIiwiZGlzdC9lbmdpbmVzL3NlZ21lbnQtZW5naW5lLmpzIiwiZGlzdC9lbmdpbmVzL3NlcXVlbmNlci1lbmdpbmUuanMiLCJkaXN0L2luZGV4LmpzIiwiZGlzdC9tYXN0ZXJzL2ZhY3Rvcmllcy5qcyIsImRpc3QvbWFzdGVycy9wbGF5LWNvbnRyb2wuanMiLCJkaXN0L21hc3RlcnMvc2NoZWR1bGVyLmpzIiwiZGlzdC9tYXN0ZXJzL3NpbXBsZS1zY2hlZHVsZXIuanMiLCJkaXN0L21hc3RlcnMvdHJhbnNwb3J0LmpzIiwiZGlzdC91dGlscy9QVl9mYXN0XzUuanMiLCJkaXN0L3V0aWxzL2J1ZmZlcmVkLXB2LmpzIiwiZGlzdC91dGlscy9jYnVmZmVyLmpzIiwiZGlzdC91dGlscy9kc3AuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3dlYWstbWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vd2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LndlYWstbWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0Lm9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcud2Vhay1tYXAub2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUNBQSxJQUFNLGVBQWUsT0FBTyxZQUFQLElBQXVCLE9BQU8sa0JBQW5EOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQSxJQUFJLGVBQWUsSUFBbkI7O0FBRUEsSUFBSSxZQUFKLEVBQWtCO0FBQ2hCLGlCQUFlLElBQUksWUFBSixFQUFmOztBQUVBLE1BQUksaUJBQWlCLElBQWpCLENBQXNCLFVBQVUsU0FBaEMsS0FBOEMsYUFBYSxV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QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9cmV0dXJuIGV9KSgpIiwiY29uc3QgQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xyXG5cclxuLyoqXHJcbiAqIEV4cG9zZSBhIHVuaXF1ZSBhdWRpbyBjb250ZXh0IHNpbmdsZXRvbiBhcyB0aGUgZGVmYXVsdCBhdWRpb1xyXG4gKiBjb250ZXh0IHVzZWQgYnkgdGhlIGNvbXBvbmVudHMgb2YgdGhlIFdhdmVzIEF1ZGlvIGxpYnJhcnkgYW5kXHJcbiAqIGFwcGxpY2F0aW9ucyB1c2luZyB0aGUgbGlicmFyeS5cclxuICpcclxuICogQHR5cGUgQXVkaW9Db250ZXh0XHJcbiAqIEBuYW1lIGF1ZGlvQ29udGV4dFxyXG4gKiBAY29uc3RhbnRcclxuICogQGdsb2JhbFxyXG4gKiBAaW5zdGFuY2VcclxuICpcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0ICogYXMgYXVkaW8gZnJvbSAnd2F2ZXMtYXVkaW8nO1xyXG4gKiBjb25zdCBhdWRpb0NvbnRleHQgPSBhdWRpby5hdWRpb0NvbnRleHQ7XHJcbiAqL1xyXG5sZXQgYXVkaW9Db250ZXh0ID0gbnVsbDtcclxuXHJcbmlmIChBdWRpb0NvbnRleHQpIHtcclxuICBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XHJcblxyXG4gIGlmICgvKGlQaG9uZXxpUGFkKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgPCA0NDEwMCkge1xyXG4gICAgY29uc3QgYnVmZmVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCA0NDEwMCk7XHJcbiAgICBjb25zdCBkdW1teSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgIGR1bW15LmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgIGR1bW15LmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcclxuICAgIGR1bW15LnN0YXJ0KDApO1xyXG4gICAgZHVtbXkuZGlzY29ubmVjdCgpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXVkaW9Db250ZXh0O1xyXG4iLCJpbXBvcnQgVGltZUVuZ2luZSBmcm9tICcuL3RpbWUtZW5naW5lJztcclxuaW1wb3J0IGRlZmF1bHRBdWRpb0NvbnRleHQgZnJvbSAnLi9hdWRpby1jb250ZXh0JztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgYXVkaW8gcmVsYXRlZCB0aW1lIGVuZ2luZSBjb21wb25lbnRzLiBJdCBpc1xyXG4gKiB1c2VkIHRvIGhhbmRsZSBhdWRpbyByZWxhdGVkIGV2ZW50cyBzdWNoIGFzIHRoZSBwbGF5YmFjayBvZiBhIG1lZGlhIHN0cmVhbS5cclxuICogSXQgZXh0ZW5kcyB0aGUgVGltZUVuZ2luZSBjbGFzcyBieSB0aGUgc3RhbmRhcmQgd2ViIGF1ZGlvIG5vZGUgbWV0aG9kc1xyXG4gKiBjb25uZWN0IGFuZCBkaXNjb25uZWN0LlxyXG4gKlxyXG4gKiBbZXhhbXBsZV17QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL2F1ZGlvLXRpbWUtZW5naW5lLmh0bWx9XHJcbiAqXHJcbiAqIEBleHRlbmRzIFRpbWVFbmdpbmVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICpcclxuICogY2xhc3MgTXlFbmdpbmUgZXh0ZW5kcyBhdWRpby5BdWRpb1RpbWVFbmdpbmUge1xyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICAgc3VwZXIoKTtcclxuICogICAgIC8vIC4uLlxyXG4gKiAgIH1cclxuICogfVxyXG4gKi9cclxuY2xhc3MgQXVkaW9UaW1lRW5naW5lIGV4dGVuZHMgVGltZUVuZ2luZSB7XHJcbiAgY29uc3RydWN0b3IoYXVkaW9Db250ZXh0ID0gZGVmYXVsdEF1ZGlvQ29udGV4dCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1ZGlvIGNvbnRleHQgdXNlZCBieSB0aGUgVGltZUVuZ2luZSwgZGVmYXVsdCB0byB0aGUgZ2xvYmFsIGF1ZGlvQ29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBuYW1lIGF1ZGlvQ29udGV4dFxyXG4gICAgICogQHR5cGUgQXVkaW9Db250ZXh0XHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UaW1lRW5naW5lXHJcbiAgICAgKiBAc2VlIGF1ZGlvQ29udGV4dFxyXG4gICAgICovXHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE91dHB1dCBhdWRpbyBub2RlLiBCeSBkZWZhdWx0IHRoZSBjb25uZWN0IG1ldGhvZCBjb25uZWN0cyBhIGdpdmVuIG5vZGVcclxuICAgICAqIHRvIHRoaXMgb3V0cHV0IG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgb3V0cHV0Tm9kZVxyXG4gICAgICogQHR5cGUgQXVkaW9Ob2RlXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UaW1lRW5naW5lXHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKi9cclxuICAgIHRoaXMub3V0cHV0Tm9kZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25uZWN0IHRvIGFuIGF1ZGlvIG5vZGUgKGUuZy4gYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBdWRpb05vZGV9IHRhcmdldCAtIFRhcmdldCBhdWRpbyBub2RlXHJcbiAgICovXHJcbiAgY29ubmVjdCh0YXJnZXQpIHtcclxuICAgIHRoaXMub3V0cHV0Tm9kZS5jb25uZWN0KHRhcmdldCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc2Nvbm5lY3QgZnJvbSBhbiBhdWRpbyBub2RlIChlLmcuIGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbikuIElmIHVuZGVmaW5lZFxyXG4gICAqIGRpc2Nvbm5lY3QgZnJvbSBhbGwgdGFyZ2V0IG5vZGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBdWRpb05vZGV9IHRhcmdldCAtIFRhcmdldCBhdWRpbyBub2RlLlxyXG4gICAqL1xyXG4gIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xyXG4gICAgdGhpcy5vdXRwdXROb2RlLmRpc2Nvbm5lY3QoY29ubmVjdGlvbik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEF1ZGlvVGltZUVuZ2luZTtcclxuIiwiLy8gd29ya3MgYnkgcmVmZXJlbmNlXHJcbmZ1bmN0aW9uIHN3YXAoYXJyLCBpMSwgaTIpIHtcclxuICBjb25zdCB0bXAgPSBhcnJbaTFdO1xyXG4gIGFycltpMV0gPSBhcnJbaTJdO1xyXG4gIGFycltpMl0gPSB0bXA7XHJcbn1cclxuXHJcbi8vIGh0dHBzOi8vanNwZXJmLmNvbS9qcy1mb3ItbG9vcC12cy1hcnJheS1pbmRleG9mLzM0NlxyXG5mdW5jdGlvbiBpbmRleE9mKGFyciwgZWwpIHtcclxuICBjb25zdCBsID0gYXJyLmxlbmd0aDtcclxuICAvLyBpZ25vcmUgZmlyc3QgZWxlbWVudCBhcyBpdCBjYW4ndCBiZSBhIGVudHJ5XHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsOyBpKyspIHtcclxuICAgIGlmIChhcnJbaV0gPT09IGVsKSB7XHJcbiAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIC0xO1xyXG59XHJcblxyXG4vKipcclxuICogRGVmaW5lIGlmIGB0aW1lMWAgc2hvdWxkIGJlIGxvd2VyIGluIHRoZSB0b3BvZ3JhcGh5IHRoYW4gYHRpbWUyYC5cclxuICogSXMgZHluYW1pY2FsbHkgYWZmZWN0ZWQgdG8gdGhlIHByaW9yaXR5IHF1ZXVlIGFjY29yZGluZyB0byBoYW5kbGUgYG1pbmAgYW5kIGBtYXhgIGhlYXAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lMVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZTJcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmNvbnN0IF9pc0xvd2VyTWF4SGVhcCA9IGZ1bmN0aW9uKHRpbWUxLCB0aW1lMikge1xyXG4gIHJldHVybiB0aW1lMSA8IHRpbWUyO1xyXG59O1xyXG5cclxuY29uc3QgX2lzTG93ZXJNaW5IZWFwID0gZnVuY3Rpb24odGltZTEsIHRpbWUyKSB7XHJcbiAgcmV0dXJuIHRpbWUxID4gdGltZTI7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVmaW5lIGlmIGB0aW1lMWAgc2hvdWxkIGJlIGhpZ2hlciBpbiB0aGUgdG9wb2dyYXBoeSB0aGFuIGB0aW1lMmAuXHJcbiAqIElzIGR5bmFtaWNhbGx5IGFmZmVjdGVkIHRvIHRoZSBwcmlvcml0eSBxdWV1ZSBhY2NvcmRpbmcgdG8gaGFuZGxlIGBtaW5gIGFuZCBgbWF4YCBoZWFwLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZTFcclxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUyXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5jb25zdCBfaXNIaWdoZXJNYXhIZWFwID0gZnVuY3Rpb24odGltZTEsIHRpbWUyKSB7XHJcbiAgcmV0dXJuIHRpbWUxID4gdGltZTI7XHJcbn07XHJcblxyXG5jb25zdCBfaXNIaWdoZXJNaW5IZWFwID0gZnVuY3Rpb24odGltZTEsIHRpbWUyKSB7XHJcbiAgcmV0dXJuIHRpbWUxIDwgdGltZTI7XHJcbn07XHJcblxyXG5jb25zdCBQT1NJVElWRV9JTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHJcbi8qKlxyXG4gKiBQcmlvcml0eSBxdWV1ZSBpbXBsZW1lbnRpbmcgYSBiaW5hcnkgaGVhcC5cclxuICogQWN0cyBhcyBhIG1pbiBoZWFwIGJ5IGRlZmF1bHQsIGNhbiBiZSBkeW5hbWljYWxseSBjaGFuZ2VkIHRvIGEgbWF4IGhlYXBcclxuICogYnkgc2V0dGluZyBgcmV2ZXJzZWAgdG8gdHJ1ZS5cclxuICpcclxuICogX25vdGVfOiB0aGUgcXVldWUgY3JlYXRlcyBhbmQgbWFpbnRhaW5zIGEgbmV3IHByb3BlcnR5IChpLmUuIGBxdWV1ZVRpbWVgKVxyXG4gKiB0byBlYWNoIG9iamVjdCBhZGRlZC5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtoZWFwTGVuZ3RoPTEwMF0gLSBEZWZhdWx0IHNpemUgb2YgdGhlIGFycmF5IHVzZWQgdG8gY3JlYXRlIHRoZSBoZWFwLlxyXG4gKi9cclxuY2xhc3MgUHJpb3JpdHlRdWV1ZSB7XHJcbiAgY29uc3RydWN0b3IoaGVhcExlbmd0aCA9IDEwMCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb2ludGVyIHRvIHRoZSBmaXJzdCBlbXB0eSBpbmRleCBvZiB0aGUgaGVhcC5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUHJpb3JpdHlRdWV1ZVxyXG4gICAgICogQG5hbWUgX2N1cnJlbnRMZW5ndGhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2N1cnJlbnRMZW5ndGggPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2YgdGhlIHNvcnRlZCBpbmRleGVzIG9mIHRoZSBlbnRyaWVzLCB0aGUgYWN0dWFsIGhlYXAuIElnbm9yZSB0aGUgaW5kZXggMC5cclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqIEBtZW1iZXJvZiBQcmlvcml0eVF1ZXVlXHJcbiAgICAgKiBAbmFtZSBfaGVhcFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5faGVhcCA9IG5ldyBBcnJheShoZWFwTGVuZ3RoICsgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUeXBlIG9mIHRoZSBxdWV1ZTogYG1pbmAgaGVhcCBpZiBgZmFsc2VgLCBgbWF4YCBoZWFwIGlmIGB0cnVlYFxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAbWVtYmVyb2YgUHJpb3JpdHlRdWV1ZVxyXG4gICAgICogQG5hbWUgX3JldmVyc2VcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3JldmVyc2UgPSBudWxsO1xyXG5cclxuICAgIC8vIGluaXRpYWxpemUgY29tcGFyZSBmdW5jdGlvbnNcclxuICAgIHRoaXMucmV2ZXJzZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGltZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYmluYXJ5IGhlYXAuXHJcbiAgICogQHJldHVybnMge051bWJlcn1cclxuICAgKi9cclxuICBnZXQgdGltZSgpIHtcclxuICAgIGlmICh0aGlzLl9jdXJyZW50TGVuZ3RoID4gMSlcclxuICAgICAgcmV0dXJuIHRoaXMuX2hlYXBbMV0ucXVldWVUaW1lO1xyXG5cclxuICAgIHJldHVybiBJbmZpbml0eTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpcnN0IGVsZW1lbnQgaW4gdGhlIGJpbmFyeSBoZWFwLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGhlYWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faGVhcFsxXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIHF1ZXVlIChtYXggaGVhcCBpZiB0cnVlLCBtaW4gaGVhcCBpZiBmYWxzZSksXHJcbiAgICogcmVidWlsZCB0aGUgaGVhcCB3aXRoIHRoZSBleGlzdGluZyBlbnRyaWVzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgc2V0IHJldmVyc2UodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcmV2ZXJzZSkge1xyXG4gICAgICB0aGlzLl9yZXZlcnNlID0gdmFsdWU7XHJcblxyXG4gICAgICBpZiAodGhpcy5fcmV2ZXJzZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuX2lzTG93ZXIgPSBfaXNMb3dlck1heEhlYXA7XHJcbiAgICAgICAgdGhpcy5faXNIaWdoZXIgPSBfaXNIaWdoZXJNYXhIZWFwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX2lzTG93ZXIgPSBfaXNMb3dlck1pbkhlYXA7XHJcbiAgICAgICAgdGhpcy5faXNIaWdoZXIgPSBfaXNIaWdoZXJNaW5IZWFwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmJ1aWxkSGVhcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IHJldmVyc2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpeCB0aGUgaGVhcCBieSBtb3ZpbmcgYW4gZW50cnkgdG8gYSBuZXcgdXBwZXIgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBlbnRyeSB0byBtb3ZlLlxyXG4gICAqL1xyXG4gIF9idWJibGVVcChzdGFydEluZGV4KSB7XHJcbiAgICBsZXQgZW50cnkgPSB0aGlzLl9oZWFwW3N0YXJ0SW5kZXhdO1xyXG5cclxuICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7XHJcbiAgICBsZXQgcGFyZW50SW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gMik7XHJcbiAgICBsZXQgcGFyZW50ID0gdGhpcy5faGVhcFtwYXJlbnRJbmRleF07XHJcblxyXG4gICAgd2hpbGUgKHBhcmVudCAmJiB0aGlzLl9pc0hpZ2hlcihlbnRyeS5xdWV1ZVRpbWUsIHBhcmVudC5xdWV1ZVRpbWUpKSB7XHJcbiAgICAgIHN3YXAodGhpcy5faGVhcCwgaW5kZXgsIHBhcmVudEluZGV4KTtcclxuXHJcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XHJcbiAgICAgIHBhcmVudEluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIDIpO1xyXG4gICAgICBwYXJlbnQgPSB0aGlzLl9oZWFwW3BhcmVudEluZGV4XTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpeCB0aGUgaGVhcCBieSBtb3ZpbmcgYW4gZW50cnkgdG8gYSBuZXcgbG93ZXIgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBlbnRyeSB0byBtb3ZlLlxyXG4gICAqL1xyXG4gIF9idWJibGVEb3duKHN0YXJ0SW5kZXgpIHtcclxuICAgIGxldCBlbnRyeSA9IHRoaXMuX2hlYXBbc3RhcnRJbmRleF07XHJcblxyXG4gICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleDtcclxuICAgIGxldCBjMWluZGV4ID0gaW5kZXggKiAyO1xyXG4gICAgbGV0IGMyaW5kZXggPSBjMWluZGV4ICsgMTtcclxuICAgIGxldCBjaGlsZDEgPSB0aGlzLl9oZWFwW2MxaW5kZXhdO1xyXG4gICAgbGV0IGNoaWxkMiA9IHRoaXMuX2hlYXBbYzJpbmRleF07XHJcblxyXG4gICAgd2hpbGUgKChjaGlsZDEgJiYgdGhpcy5faXNMb3dlcihlbnRyeS5xdWV1ZVRpbWUsIGNoaWxkMS5xdWV1ZVRpbWUpKcKgfHxcclxuICAgICAgICAgICAoY2hpbGQyICYmIHRoaXMuX2lzTG93ZXIoZW50cnkucXVldWVUaW1lLCBjaGlsZDIucXVldWVUaW1lKSkpXHJcbiAgICB7XHJcbiAgICAgIC8vIHN3YXAgd2l0aCB0aGUgbWluaW11bSBjaGlsZFxyXG4gICAgICBsZXQgdGFyZ2V0SW5kZXg7XHJcblxyXG4gICAgICBpZiAoY2hpbGQyKVxyXG4gICAgICAgIHRhcmdldEluZGV4ID0gdGhpcy5faXNIaWdoZXIoY2hpbGQxLnF1ZXVlVGltZSwgY2hpbGQyLnF1ZXVlVGltZSkgPyBjMWluZGV4IDogYzJpbmRleDtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRhcmdldEluZGV4ID0gYzFpbmRleDtcclxuXHJcbiAgICAgIHN3YXAodGhpcy5faGVhcCwgaW5kZXgsIHRhcmdldEluZGV4KTtcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSB0byBmaW5kIG5leHQgY2hpbGRyZW5cclxuICAgICAgaW5kZXggPSB0YXJnZXRJbmRleDtcclxuICAgICAgYzFpbmRleCA9IGluZGV4ICogMjtcclxuICAgICAgYzJpbmRleCA9IGMxaW5kZXggKyAxO1xyXG4gICAgICBjaGlsZDEgPSB0aGlzLl9oZWFwW2MxaW5kZXhdO1xyXG4gICAgICBjaGlsZDIgPSB0aGlzLl9oZWFwW2MyaW5kZXhdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGQgdGhlIGhlYXAgKGZyb20gYm90dG9tIHVwKS5cclxuICAgKi9cclxuICBidWlsZEhlYXAoKSB7XHJcbiAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBpbnRlcm5hbCBub2RlXHJcbiAgICAvLyBAdG9kbyAtIG1ha2Ugc3VyZSB0aGF0J3MgdGhlIHJpZ2h0IHdheSB0byBkby5cclxuICAgIGxldCBtYXhJbmRleCA9IE1hdGguZmxvb3IoKHRoaXMuX2N1cnJlbnRMZW5ndGggLSAxKSAvIDIpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBtYXhJbmRleDsgaSA+IDA7IGktLSlcclxuICAgICAgdGhpcy5fYnViYmxlRG93bihpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIG5ldyBvYmplY3QgaW4gdGhlIGJpbmFyeSBoZWFwIGFuZCBzb3J0IGl0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudHJ5IC0gRW50cnkgdG8gaW5zZXJ0LlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gVGltZSBhdCB3aGljaCB0aGUgZW50cnkgc2hvdWxkIGJlIG9yZGVyZXIuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gLSBUaW1lIG9mIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgaGVhcC5cclxuICAgKi9cclxuICBpbnNlcnQoZW50cnksIHRpbWUpIHtcclxuICAgIGlmIChNYXRoLmFicyh0aW1lKSAhPT0gUE9TSVRJVkVfSU5GSU5JVFkpIHtcclxuICAgICAgZW50cnkucXVldWVUaW1lID0gdGltZTtcclxuICAgICAgLy8gYWRkIHRoZSBuZXcgZW50cnkgYXQgdGhlIGVuZCBvZiB0aGUgaGVhcFxyXG4gICAgICB0aGlzLl9oZWFwW3RoaXMuX2N1cnJlbnRMZW5ndGhdID0gZW50cnk7XHJcbiAgICAgIC8vIGJ1YmJsZSBpdCB1cFxyXG4gICAgICB0aGlzLl9idWJibGVVcCh0aGlzLl9jdXJyZW50TGVuZ3RoKTtcclxuICAgICAgdGhpcy5fY3VycmVudExlbmd0aCArPSAxO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMudGltZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRyeS5xdWV1ZVRpbWUgPSB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoZW50cnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW92ZSBhIGdpdmVuIGVudHJ5IHRvIGEgbmV3IHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudHJ5IC0gRW50cnkgdG8gbW92ZS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIFRpbWUgYXQgd2hpY2ggdGhlIGVudHJ5IHNob3VsZCBiZSBvcmRlcmVyLlxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBUaW1lIG9mIGZpcnN0IGVudHJ5IGluIHRoZSBoZWFwLlxyXG4gICAqL1xyXG4gIG1vdmUoZW50cnksIHRpbWUpIHtcclxuICAgIGlmIChNYXRoLmFicyh0aW1lKSAhPT0gUE9TSVRJVkVfSU5GSU5JVFkpIHtcclxuICAgICAgY29uc3QgaW5kZXggPSBpbmRleE9mKHRoaXMuX2hlYXAsIGVudHJ5KTtcclxuXHJcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBlbnRyeS5xdWV1ZVRpbWUgPSB0aW1lO1xyXG4gICAgICAgIC8vIGRlZmluZSBpZiB0aGUgZW50cnkgc2hvdWxkIGJlIGJ1YmJsZWQgdXAgb3IgZG93blxyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2hlYXBbTWF0aC5mbG9vcihpbmRleCAvIDIpXTtcclxuXHJcbiAgICAgICAgaWYgKHBhcmVudCAmJiB0aGlzLl9pc0hpZ2hlcih0aW1lLCBwYXJlbnQucXVldWVUaW1lKSlcclxuICAgICAgICAgIHRoaXMuX2J1YmJsZVVwKGluZGV4KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0aGlzLl9idWJibGVEb3duKGluZGV4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMudGltZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRyeS5xdWV1ZVRpbWUgPSB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoZW50cnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFuIGVudHJ5IGZyb20gdGhlIGhlYXAgYW5kIGZpeCB0aGUgaGVhcC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSAtIEVudHJ5IHRvIHJlbW92ZS5cclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gVGltZSBvZiBmaXJzdCBlbnRyeSBpbiB0aGUgaGVhcC5cclxuICAgKi9cclxuICByZW1vdmUoZW50cnkpIHtcclxuICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBlbnRyeVxyXG4gICAgY29uc3QgaW5kZXggPSBpbmRleE9mKHRoaXMuX2hlYXAsIGVudHJ5KTtcclxuXHJcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHRoaXMuX2N1cnJlbnRMZW5ndGggLSAxO1xyXG5cclxuICAgICAgLy8gaWYgdGhlIGVudHJ5IGlzIHRoZSBsYXN0IG9uZVxyXG4gICAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xyXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIGhlYXBcclxuICAgICAgICB0aGlzLl9oZWFwW2xhc3RJbmRleF0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gdXBkYXRlIGN1cnJlbnQgbGVuZ3RoXHJcbiAgICAgICAgdGhpcy5fY3VycmVudExlbmd0aCA9IGxhc3RJbmRleDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBzd2FwIHdpdGggdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgaGVhcFxyXG4gICAgICAgIHN3YXAodGhpcy5faGVhcCwgaW5kZXgsIGxhc3RJbmRleCk7XHJcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gaGVhcFxyXG4gICAgICAgIHRoaXMuX2hlYXBbbGFzdEluZGV4XSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ID09PSAxKSB7XHJcbiAgICAgICAgICB0aGlzLl9idWJibGVEb3duKDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBidWJibGUgdGhlIChleCBsYXN0KSBlbGVtZW50IHVwIG9yIGRvd24gYWNjb3JkaW5nIHRvIGl0cyBuZXcgY29udGV4dFxyXG4gICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLl9oZWFwW2luZGV4XTtcclxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2hlYXBbTWF0aC5mbG9vcihpbmRleCAvIDIpXTtcclxuXHJcbiAgICAgICAgICBpZiAocGFyZW50ICYmIHRoaXMuX2lzSGlnaGVyKGVudHJ5LnF1ZXVlVGltZSwgcGFyZW50LnF1ZXVlVGltZSkpXHJcbiAgICAgICAgICAgIHRoaXMuX2J1YmJsZVVwKGluZGV4KTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5fYnViYmxlRG93bihpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB1cGRhdGUgY3VycmVudCBsZW5ndGhcclxuICAgICAgdGhpcy5fY3VycmVudExlbmd0aCA9IGxhc3RJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy50aW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXIgdGhlIHF1ZXVlLlxyXG4gICAqL1xyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5fY3VycmVudExlbmd0aCA9IDE7XHJcbiAgICB0aGlzLl9oZWFwID0gbmV3IEFycmF5KHRoaXMuX2hlYXAubGVuZ3RoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgaWYgdGhlIHF1ZXVlIGNvbnRhaW5zIHRoZSBnaXZlbiBgZW50cnlgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudHJ5IC0gRW50cnkgdG8gYmUgY2hlY2tlZFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaGFzKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5faGVhcC5pbmRleE9mKGVudHJ5KSAhPT0gLTE7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcmlvcml0eVF1ZXVlO1xyXG4iLCIvKipcclxuICogU2NoZWR1bGluZ1F1ZXVlIGJhc2UgY2xhc3NcclxuICogaHR0cDovL3dhdmVzanMuZ2l0aHViLmlvL2F1ZGlvLyNhdWRpby1zY2hlZHVsaW5nLXF1ZXVlXHJcbiAqXHJcbiAqIE5vcmJlcnQuU2NobmVsbEBpcmNhbS5mclxyXG4gKiBDb3B5cmlnaHQgMjAxNCwgMjAxNSBJUkNBTSDigJPCoENlbnRyZSBQb21waWRvdVxyXG4gKi9cclxuXHJcbmltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gJy4vcHJpb3JpdHktcXVldWUnO1xyXG5pbXBvcnQgVGltZUVuZ2luZSBmcm9tICcuL3RpbWUtZW5naW5lJztcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgU2NoZWR1bGluZ1F1ZXVlXHJcbiAqIEBleHRlbmRzIFRpbWVFbmdpbmVcclxuICovXHJcbmNsYXNzIFNjaGVkdWxpbmdRdWV1ZSBleHRlbmRzIFRpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9fcXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xyXG4gICAgdGhpcy5fX2VuZ2luZXMgPSBuZXcgU2V0KCk7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lICdzY2hlZHVsZWQnIGludGVyZmFjZVxyXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcclxuICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX19xdWV1ZS5oZWFkO1xyXG4gICAgY29uc3QgbmV4dEVuZ2luZVRpbWUgPSBlbmdpbmUuYWR2YW5jZVRpbWUodGltZSk7XHJcblxyXG4gICAgaWYgKCFuZXh0RW5naW5lVGltZSkge1xyXG4gICAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcclxuICAgICAgdGhpcy5fX2VuZ2luZXMuZGVsZXRlKGVuZ2luZSk7XHJcbiAgICAgIHRoaXMuX19xdWV1ZS5yZW1vdmUoZW5naW5lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX19xdWV1ZS5tb3ZlKGVuZ2luZSwgbmV4dEVuZ2luZVRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9fcXVldWUudGltZTtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWFzdGVyIG1ldGhvZCB0byBiZSBpbXBsZW1lbnRlZCBieSBkZXJpdmVkIGNsYXNzXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICAvLyBjYWxsIGEgZnVuY3Rpb24gYXQgYSBnaXZlbiB0aW1lXHJcbiAgZGVmZXIoZnVuLCB0aW1lID0gdGhpcy5jdXJyZW50VGltZSkge1xyXG4gICAgaWYgKCEoZnVuIGluc3RhbmNlb2YgRnVuY3Rpb24pKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgY2Fubm90IGJlIGRlZmVyZWQgYnkgc2NoZWR1bGVyXCIpO1xyXG5cclxuICAgIHRoaXMuYWRkKHtcclxuICAgICAgYWR2YW5jZVRpbWU6IGZ1bmN0aW9uKHRpbWUpIHsgZnVuKHRpbWUpOyB9LCAvLyBtYWtlIHN1ciB0aGF0IHRoZSBhZHZhbmNlVGltZSBtZXRob2QgZG9lcyBub3QgcmV0dXJtIGFueXRoaW5nXHJcbiAgICB9LCB0aW1lKTtcclxuICB9XHJcblxyXG4gIC8vIGFkZCBhIHRpbWUgZW5naW5lIHRvIHRoZSBzY2hlZHVsZXJcclxuICBhZGQoZW5naW5lLCB0aW1lID0gdGhpcy5jdXJyZW50VGltZSkge1xyXG4gICAgaWYgKCFUaW1lRW5naW5lLmltcGxlbWVudHNTY2hlZHVsZWQoZW5naW5lKSlcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGNhbm5vdCBiZSBhZGRlZCB0byBzY2hlZHVsZXJcIik7XHJcblxyXG4gICAgaWYgKGVuZ2luZS5tYXN0ZXIpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIGEgbWFzdGVyXCIpO1xyXG5cclxuICAgIGVuZ2luZS5tYXN0ZXIgPSB0aGlzO1xyXG5cclxuICAgIC8vIGFkZCB0byBlbmdpbmVzIGFuZCBxdWV1ZVxyXG4gICAgdGhpcy5fX2VuZ2luZXMuYWRkKGVuZ2luZSk7XHJcbiAgICBjb25zdCBuZXh0VGltZSA9IHRoaXMuX19xdWV1ZS5pbnNlcnQoZW5naW5lLCB0aW1lKTtcclxuXHJcbiAgICAvLyByZXNjaGVkdWxlIHF1ZXVlXHJcbiAgICB0aGlzLnJlc2V0VGltZShuZXh0VGltZSk7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgYSB0aW1lIGVuZ2luZSBmcm9tIHRoZSBxdWV1ZVxyXG4gIHJlbW92ZShlbmdpbmUpIHtcclxuICAgIGlmIChlbmdpbmUubWFzdGVyICE9PSB0aGlzKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoaXMgc2NoZWR1bGVyXCIpO1xyXG5cclxuICAgIGVuZ2luZS5tYXN0ZXIgPSBudWxsO1xyXG5cclxuICAgIC8vIHJlbW92ZSBmcm9tIGFycmF5IGFuZCBxdWV1ZVxyXG4gICAgdGhpcy5fX2VuZ2luZXMuZGVsZXRlKGVuZ2luZSk7XHJcbiAgICBjb25zdCBuZXh0VGltZSA9IHRoaXMuX19xdWV1ZS5yZW1vdmUoZW5naW5lKTtcclxuXHJcbiAgICAvLyByZXNjaGVkdWxlIHF1ZXVlXHJcbiAgICB0aGlzLnJlc2V0VGltZShuZXh0VGltZSk7XHJcbiAgfVxyXG5cclxuICAvLyByZXNldCBuZXh0IGVuZ2luZSB0aW1lXHJcbiAgcmVzZXRFbmdpbmVUaW1lKGVuZ2luZSwgdGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcclxuICAgIGlmIChlbmdpbmUubWFzdGVyICE9PSB0aGlzKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoaXMgc2NoZWR1bGVyXCIpO1xyXG5cclxuICAgIGxldCBuZXh0VGltZTtcclxuXHJcbiAgICBpZiAodGhpcy5fX3F1ZXVlLmhhcyhlbmdpbmUpKVxyXG4gICAgICBuZXh0VGltZSA9IHRoaXMuX19xdWV1ZS5tb3ZlKGVuZ2luZSwgdGltZSk7XHJcbiAgICBlbHNlXHJcbiAgICAgIG5leHRUaW1lID0gdGhpcy5fX3F1ZXVlLmluc2VydChlbmdpbmUsIHRpbWUpO1xyXG5cclxuICAgIHRoaXMucmVzZXRUaW1lKG5leHRUaW1lKTtcclxuICB9XHJcblxyXG4gIC8vIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiBlbmdpbmUgaXMgc2NoZWR1bGVkXHJcbiAgaGFzKGVuZ2luZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19lbmdpbmVzLmhhcyhlbmdpbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gY2xlYXIgcXVldWVcclxuICBjbGVhcigpIHtcclxuICAgIGZvcihsZXQgZW5naW5lIG9mIHRoaXMuX19lbmdpbmVzKVxyXG4gICAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9fcXVldWUuY2xlYXIoKTtcclxuICAgIHRoaXMuX19lbmdpbmVzLmNsZWFyKCk7XHJcbiAgICB0aGlzLnJlc2V0VGltZShJbmZpbml0eSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTY2hlZHVsaW5nUXVldWVcclxuIiwiLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIHRpbWUgZW5naW5lc1xyXG4gKlxyXG4gKiBBIHRpbWUgZW5naW5lIGdlbmVyYXRlcyBtb3JlIG9yIGxlc3MgcmVndWxhciBldmVudHMgYW5kL29yIHBsYXlzIGJhY2sgYVxyXG4gKiBtZWRpYSBzdHJlYW0uIEl0IGltcGxlbWVudHMgb25lIG9yIG11bHRpcGxlIGludGVyZmFjZXMgdG8gYmUgZHJpdmVuIGJ5IGFcclxuICogbWFzdGVyIChpLmUuIGEgU2NoZWR1bGVyLCBhIFRyYW5zcG9ydCBvciBhIFBsYXlDb250cm9sKSBpbiBzeW5jaHJvbml6YXRpb25cclxuICogd2l0aCBvdGhlciBlbmdpbmVzLiBUaGUgcHJvdmlkZWQgaW50ZXJmYWNlcyBhcmUgc2NoZWR1bGVkLCB0cmFuc3BvcnRlZCxcclxuICogYW5kIHBsYXktY29udHJvbGxlZC5cclxuICpcclxuICpcclxuICogIyMjIyBUaGUgYHNjaGVkdWxlZGAgaW50ZXJmYWNlXHJcbiAqXHJcbiAqIFRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlIGFsbG93cyBmb3Igc3luY2hyb25pemluZyBhbiBlbmdpbmUgdG8gYSBtb25vdG9ub3VzIHRpbWVcclxuICogYXMgaXQgaXMgcHJvdmlkZWQgYnkgdGhlIFNjaGVkdWxlciBtYXN0ZXIuXHJcbiAqXHJcbiAqICMjIyMjIyBgYWR2YW5jZVRpbWUodGltZSA6TnVtYmVyKSAtPiB7TnVtYmVyfWBcclxuICpcclxuICogVGhlIGBhZHZhbmNlVGltZWAgbWV0aG9kIGhhcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhbiBgVGltZUVuZ2luZWAgYXMgcGFydCBvZiB0aGVcclxuICogc2NoZWR1bGVkIGludGVyZmFjZS4gVGhlIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG1hc3RlciAoZS5nLiB0aGUgc2NoZWR1bGVyKS5cclxuICogSXQgZ2VuZXJhdGVzIGFuIGV2ZW50IGFuZCB0byByZXR1cm5zIHRoZSB0aW1lIG9mIHRoZSBuZXh0IGV2ZW50IChpLmUuIHRoZSBuZXh0XHJcbiAqIGNhbGwgb2YgYWR2YW5jZVRpbWUpLiBUaGUgcmV0dXJuZWQgdGltZSBoYXMgdG8gYmUgZ3JlYXRlciB0aGFuIHRoZSB0aW1lXHJcbiAqIHJlY2VpdmVkIGFzIGFyZ3VtZW50IG9mIHRoZSBtZXRob2QuIEluIGNhc2UgdGhhdCBhIFRpbWVFbmdpbmUgaGFzIHRvIGdlbmVyYXRlXHJcbiAqIG11bHRpcGxlIGV2ZW50cyBhdCB0aGUgc2FtZSB0aW1lLCB0aGUgZW5naW5lIGhhcyB0byBpbXBsZW1lbnQgaXRzIG93biBsb29wXHJcbiAqIHdoaWxlKGV2ZW50LnRpbWUgPD0gdGltZSkgYW5kIHJldHVybiB0aGUgdGltZSBvZiB0aGUgbmV4dCBldmVudCAoaWYgYW55KS5cclxuICpcclxuICogIyMjIyMjIGByZXNldFRpbWUodGltZT11bmRlZmluZWQgOk51bWJlcilgXHJcbiAqXHJcbiAqIFRoZSBgcmVzZXRUaW1lYCBtZXRob2QgaXMgcHJvdmlkZWQgYnkgdGhlIGBUaW1lRW5naW5lYCBiYXNlIGNsYXNzLiBBbiBlbmdpbmUgbWF5XHJcbiAqIGNhbGwgdGhpcyBtZXRob2QgdG8gcmVzZXQgaXRzIG5leHQgZXZlbnQgdGltZSAoZS5nLiB3aGVuIGEgcGFyYW1ldGVyIGlzXHJcbiAqIGNoYW5nZWQgdGhhdCBpbmZsdWVuY2VzIHRoZSBlbmdpbmUncyB0ZW1wb3JhbCBiZWhhdmlvcikuIFdoZW4gbm8gYXJndW1lbnRcclxuICogaXMgZ2l2ZW4sIHRoZSB0aW1lIGlzIHJlc2V0IHRvIHRoZSBjdXJyZW50IG1hc3RlciB0aW1lLiBXaGVuIGNhbGxpbmcgdGhlXHJcbiAqIG1ldGhvZCB3aXRoIEluZmluaXR5IHRoZSBlbmdpbmUgaXMgc3VzcGVuZGVkIHdpdGhvdXQgYmVpbmcgcmVtb3ZlZCBmcm9tIHRoZVxyXG4gKiBtYXN0ZXIuXHJcbiAqXHJcbiAqXHJcbiAqICMjIyMgVGhlIGB0cmFuc3BvcnRlZGAgaW50ZXJmYWNlXHJcbiAqXHJcbiAqIFRoZSB0cmFuc3BvcnRlZCBpbnRlcmZhY2UgYWxsb3dzIGZvciBzeW5jaHJvbml6aW5nIGFuIGVuZ2luZSB0byBhIHBvc2l0aW9uXHJcbiAqIChpLmUuIG1lZGlhIHBsYXliYWNrIHRpbWUpIHRoYXQgY2FuIHJ1biBmb3J3YXJkIGFuZCBiYWNrd2FyZCBhbmQganVtcCBhcyBpdFxyXG4gKiBpcyBwcm92aWRlZCBieSB0aGUgVHJhbnNwb3J0IG1hc3Rlci5cclxuICpcclxuICogIyMjIyMjIGBzeW5jUG9zaXRpb24odGltZSA6TnVtYmVyLCBwb3NpdGlvbiA6TnVtYmVyLCBzcGVlZCA6TnVtYmVyKSAtPiB7TnVtYmVyfWBcclxuICpcclxuICogVGhlIGBzeW5jUG9zaXRvbmAgbWV0aG9kIGhhcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhIGBUaW1lRW5naW5lYCBhcyBwYXJ0IG9mIHRoZVxyXG4gKiB0cmFuc3BvcnRlZCBpbnRlcmZhY2UuIFRoZSBtZXRob2Qgc3luY1Bvc2l0b24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBtYXN0ZXJcclxuICogb2YgYSB0cmFuc3BvcnRlZCBlbmdpbmUgaGFzIHRvIChyZS0pc3luY2hyb25pemUgdGhlIGVuZ2luZSdzIHBvc2l0aW9uLiBUaGlzXHJcbiAqIGlzIGZvciBleGFtcGxlIHJlcXVpcmVkIHdoZW4gdGhlIG1hc3RlciAocmUtKXN0YXJ0cyBwbGF5YmFjaywganVtcHMgdG8gYW5cclxuICogYXJiaXRyYXJ5IHBvc2l0aW9uLCBhbmQgd2hlbiByZXZlcnNpbmcgcGxheWJhY2sgZGlyZWN0aW9uLiBUaGUgbWV0aG9kIHJldHVybnNcclxuICogdGhlIG5leHQgcG9zaXRpb24gb2YgdGhlIGVuZ2luZSBpbiB0aGUgZ2l2ZW4gcGxheWJhY2sgZGlyZWN0aW9uXHJcbiAqIChpLmUuIGBzcGVlZCA8IDBgIG9yIGBzcGVlZCA+IDBgKS5cclxuICpcclxuICogIyMjIyMjIGBhZHZhbmNlUG9zaXRpb24odGltZSA6TnVtYmVyLCBwb3NpdGlvbiA6TnVtYmVyLCBzcGVlZCA6TnVtYmVyKSAtPiB7TnVtYmVyfWBcclxuICpcclxuICogVGhlIGBhZHZhbmNlUG9zaXRpb25gIG1ldGhvZCBoYXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYSBgVGltZUVuZ2luZWAgYXMgcGFydFxyXG4gKiBvZiB0aGUgdHJhbnNwb3J0ZWQgaW50ZXJmYWNlLiBUaGUgbWFzdGVyIGNhbGxzIHRoZSBhZHZhbmNlUG9zaXRvbiBtZXRob2Qgd2hlblxyXG4gKiB0aGUgZW5naW5lJ3MgZXZlbnQgcG9zaXRpb24gaXMgcmVhY2hlZC4gVGhlIG1ldGhvZCBnZW5lcmF0ZXMgYW4gZXZlbnQgYW5kXHJcbiAqIHJldHVybnMgdGhlIG5leHQgcG9zaXRpb24gaW4gdGhlIGdpdmVuIHBsYXliYWNrIGRpcmVjdGlvbiAoaS5lLiBzcGVlZCA8IDAgb3JcclxuICogc3BlZWQgPiAwKS4gVGhlIHJldHVybmVkIHBvc2l0aW9uIGhhcyB0byBiZSBncmVhdGVyIChpLmUuIHdoZW4gc3BlZWQgPiAwKVxyXG4gKiBvciBsZXNzIChpLmUuIHdoZW4gc3BlZWQgPCAwKSB0aGFuIHRoZSBwb3NpdGlvbiByZWNlaXZlZCBhcyBhcmd1bWVudCBvZiB0aGVcclxuICogbWV0aG9kLlxyXG4gKlxyXG4gKiAjIyMjIyMgYHJlc2V0UG9zaXRpb24ocG9zaXRpb249dW5kZWZpbmVkIDpOdW1iZXIpYFxyXG4gKlxyXG4gKiBUaGUgcmVzZXRQb3NpdGlvbiBtZXRob2QgaXMgcHJvdmlkZWQgYnkgdGhlIFRpbWVFbmdpbmUgYmFzZSBjbGFzcy4gQW4gZW5naW5lXHJcbiAqIG1heSBjYWxsIHRoaXMgbWV0aG9kIHRvIHJlc2V0IGl0cyBuZXh0IGV2ZW50IHBvc2l0aW9uLiBXaGVuIG5vIGFyZ3VtZW50XHJcbiAqIGlzIGdpdmVuLCB0aGUgdGltZSBpcyByZXNldCB0byB0aGUgY3VycmVudCBtYXN0ZXIgdGltZS4gV2hlbiBjYWxsaW5nIHRoZVxyXG4gKiBtZXRob2Qgd2l0aCBJbmZpbml0eSB0aGUgZW5naW5lIGlzIHN1c3BlbmRlZCB3aXRob3V0IGJlaW5nIHJlbW92ZWQgZnJvbVxyXG4gKiB0aGUgbWFzdGVyLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyMjIFRoZSBzcGVlZC1jb250cm9sbGVkIGludGVyZmFjZVxyXG4gKlxyXG4gKiBUaGUgXCJzcGVlZC1jb250cm9sbGVkXCIgaW50ZXJmYWNlIGFsbG93cyBmb3Igc3luY3Jvbml6aW5nIGFuIGVuZ2luZSB0aGF0IGlzXHJcbiAqIG5laXRoZXIgZHJpdmVuIHRocm91Z2ggdGhlIHNjaGVkdWxlZCBub3IgdGhlIHRyYW5zcG9ydGVkIGludGVyZmFjZS4gVGhlXHJcbiAqIGludGVyZmFjZSBhbGxvd3MgaW4gcGFydGljdWxhciB0byBzeW5jaHJvbml6ZSBlbmdpbmVzIHRoYXQgYXNzdXJlIHRoZWlyIG93blxyXG4gKiBzY2hlZHVsaW5nIChpLmUuIGF1ZGlvIHBsYXllciBvciBhbiBvc2NpbGxhdG9yKSB0byB0aGUgZXZlbnQtYmFzZWQgc2NoZWR1bGVkXHJcbiAqIGFuZCB0cmFuc3BvcnRlZCBlbmdpbmVzLlxyXG4gKlxyXG4gKiAjIyMjIyMgYHN5bmNTcGVlZCh0aW1lIDpOdW1iZXIsIHBvc2l0aW9uIDpOdW1iZXIsIHNwZWVkIDpOdW1iZXIsIHNlZWs9ZmFsc2UgOkJvb2xlYW4pYFxyXG4gKlxyXG4gKiBUaGUgc3luY1NwZWVkIG1ldGhvZCBoYXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYSBUaW1lRW5naW5lIGFzIHBhcnQgb2YgdGhlXHJcbiAqIHNwZWVkLWNvbnRyb2xsZWQgaW50ZXJmYWNlLiBUaGUgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgbWFzdGVyIHdoZW5ldmVyIHRoZVxyXG4gKiBwbGF5YmFjayBzcGVlZCBjaGFuZ2VzIG9yIHRoZSBwb3NpdGlvbiBqdW1wcyBhcmJpdGFyaWx5IChpLmUuIG9uIGEgc2VlaykuXHJcbiAqXHJcbiAqXHJcbiAqIDxociAvPlxyXG4gKlxyXG4gKiBFeGFtcGxlIHRoYXQgc2hvd3MgYSBgVGltZUVuZ2luZWAgcnVubmluZyBpbiBhIGBTY2hlZHVsZXJgIHRoYXQgY291bnRzIHVwXHJcbiAqIGF0IGEgZ2l2ZW4gZnJlcXVlbmN5OlxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3RpbWUtZW5naW5lLmh0bWx9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICpcclxuICogY2xhc3MgTXlFbmdpbmUgZXh0ZW5kcyBhdWRpby5UaW1lRW5naW5lIHtcclxuICogICBjb25zdHJ1Y3RvcigpIHtcclxuICogICAgIHN1cGVyKCk7XHJcbiAqICAgICAvLyAuLi5cclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICovXHJcbmNsYXNzIFRpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZW5naW5lJ3MgbWFzdGVyLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtNaXhlZH1cclxuICAgICAqIEBuYW1lIG1hc3RlclxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVFbmdpbmVcclxuICAgICAqL1xyXG4gICAgdGhpcy5tYXN0ZXIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRpbWUgZW5naW5lJ3MgY3VycmVudCAobWFzdGVyKSB0aW1lLlxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbWVtYmVyb2YgVGltZUVuZ2luZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50VGltZSgpIHtcclxuICAgIGlmICh0aGlzLm1hc3RlcilcclxuICAgICAgcmV0dXJuIHRoaXMubWFzdGVyLmN1cnJlbnRUaW1lO1xyXG5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgdGltZSBlbmdpbmUncyBjdXJyZW50IChtYXN0ZXIpIHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbWVtYmVyb2YgVGltZUVuZ2luZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICB2YXIgbWFzdGVyID0gdGhpcy5tYXN0ZXI7XHJcblxyXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uO1xyXG5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY2hlZHVsZWQgaW50ZXJmYWNlXHJcbiAgICogICAtIGFkdmFuY2VUaW1lKHRpbWUpLCBjYWxsZWQgdG8gZ2VuZXJhdGUgbmV4dCBldmVudCBhdCBnaXZlbiB0aW1lLCByZXR1cm5zIG5leHQgdGltZVxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXHJcbiAgICovXHJcbiAgc3RhdGljIGltcGxlbWVudHNTY2hlZHVsZWQoZW5naW5lKSB7XHJcbiAgICByZXR1cm4gKGVuZ2luZS5hZHZhbmNlVGltZSAmJiBlbmdpbmUuYWR2YW5jZVRpbWUgaW5zdGFuY2VvZiBGdW5jdGlvbik7XHJcbiAgfVxyXG5cclxuICByZXNldFRpbWUodGltZSA9IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHRoaXMubWFzdGVyKVxyXG4gICAgICB0aGlzLm1hc3Rlci5yZXNldEVuZ2luZVRpbWUodGhpcywgdGltZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc3BvcnRlZCBpbnRlcmZhY2VcclxuICAgKiAgIC0gc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCksIGNhbGxlZCB0byByZXBvc2l0aW9uIFRpbWVFbmdpbmUsIHJldHVybnMgbmV4dCBwb3NpdGlvblxyXG4gICAqICAgLSBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSwgY2FsbGVkIHRvIGdlbmVyYXRlIG5leHQgZXZlbnQgYXQgZ2l2ZW4gdGltZSBhbmQgcG9zaXRpb24sIHJldHVybnMgbmV4dCBwb3NpdGlvblxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXHJcbiAgICovXHJcbiAgc3RhdGljIGltcGxlbWVudHNUcmFuc3BvcnRlZChlbmdpbmUpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIGVuZ2luZS5zeW5jUG9zaXRpb24gJiYgZW5naW5lLnN5bmNQb3NpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmXHJcbiAgICAgIGVuZ2luZS5hZHZhbmNlUG9zaXRpb24gJiYgZW5naW5lLmFkdmFuY2VQb3NpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbiA9IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHRoaXMubWFzdGVyKVxyXG4gICAgICB0aGlzLm1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNwZWVkLWNvbnRyb2xsZWQgaW50ZXJmYWNlXHJcbiAgICogICAtIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsICksIGNhbGxlZCB0b1xyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXHJcbiAgICovXHJcbiAgc3RhdGljIGltcGxlbWVudHNTcGVlZENvbnRyb2xsZWQoZW5naW5lKSB7XHJcbiAgICByZXR1cm4gKGVuZ2luZS5zeW5jU3BlZWQgJiYgZW5naW5lLnN5bmNTcGVlZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRpbWVFbmdpbmU7XHJcbiIsImltcG9ydCBBdWRpb1RpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS9hdWRpby10aW1lLWVuZ2luZSc7XHJcblxyXG5mdW5jdGlvbiBvcHRPckRlZihvcHQsIGRlZikge1xyXG4gIGlmIChvcHQgIT09IHVuZGVmaW5lZClcclxuICAgIHJldHVybiBvcHQ7XHJcblxyXG4gIHJldHVybiBkZWY7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR3JhbnVsYXIgc3ludGhlc2lzIFRpbWVFbmdpbmUgaW1wbGVtZW50aW5nIHRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlLlxyXG4gKiBUaGUgZ3JhaW4gcG9zaXRpb24gKGdyYWluIG9uc2V0IG9yIGNlbnRlciB0aW1lIGluIHRoZSBhdWRpbyBidWZmZXIpIGlzXHJcbiAqIG9wdGlvbmFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgZW5naW5lJ3MgY3VycmVudFBvc2l0aW9uIGF0dHJpYnV0ZS5cclxuICpcclxuICogRXhhbXBsZSB0aGF0IHNob3dzIGEgYEdyYW51bGFyRW5naW5lYCAod2l0aCBhIGZldyBwYXJhbWV0ZXIgY29udHJvbHMpIGRyaXZlblxyXG4gKiBieSBhIGBTY2hlZHVsZXJgIGFuZCBhIGBQbGF5Q29udHJvbGA6XHJcbiAqIHtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvZ3JhbnVsYXItZW5naW5lLmh0bWx9XHJcbiAqXHJcbiAqIEBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XHJcbiAqIGNvbnN0IHNjaGVkdWxlciA9IGF1ZGlvLmdldFNjaGVkdWxlcigpO1xyXG4gKiBjb25zdCBncmFudWxhckVuZ2luZSA9IG5ldyBhdWRpby5HcmFudWxhckVuZ2luZSgpO1xyXG4gKlxyXG4gKiBzY2hlZHVsZXIuYWRkKGdyYW51bGFyRW5naW5lKTtcclxuICpcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnM9e30gLSBQYXJhbWV0ZXJzXHJcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IFtvcHRpb25zLmJ1ZmZlcj1udWxsXSAtIEF1ZGlvIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kQWJzPTAuMDFdIC0gQWJzb2x1dGUgZ3JhaW4gcGVyaW9kIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kUmVsPTBdIC0gR3JhaW4gcGVyaW9kIHJlbGF0aXZlIHRvIGFic29sdXRlXHJcbiAqICBkdXJhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kVmFyPTBdIC0gQW1vdXQgb2YgcmFuZG9tIGdyYWluIHBlcmlvZFxyXG4gKiAgdmFyaWF0aW9uIHJlbGF0aXZlIHRvIGdyYWluIHBlcmlvZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kTWluPTAuMDAxXSAtIE1pbmltdW0gZ3JhaW4gcGVyaW9kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3NpdGlvbj0wXSAtIEdyYWluIHBvc2l0aW9uIChvbnNldCB0aW1lIGluIGF1ZGlvXHJcbiAqICBidWZmZXIpIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zaXRpb25WYXI9MC4wMDNdIC0gQW1vdXQgb2YgcmFuZG9tIGdyYWluIHBvc2l0aW9uXHJcbiAqICB2YXJpYXRpb24gaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbkFicz0wLjFdIC0gQWJzb2x1dGUgZ3JhaW4gZHVyYXRpb24gaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvblJlbD0wXSAtIEdyYWluIGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdyYWluXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvblZhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBkdXJhdGlvblxyXG4gKiAgcGVyaW9kIChvdmVybGFwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXR0YWNrQWJzPTBdIC0gQWJzb2x1dGUgYXR0YWNrIHRpbWUgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hdHRhY2tSZWw9MC41XSAtIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIGdyYWluIGR1cmF0aW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hdHRhY2tTaGFwZT0nbGluJ10gLSBTaGFwZSBvZiBhdHRhY2tcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VBYnM9MF0gLSBBYnNvbHV0ZSByZWxlYXNlIHRpbWUgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZWxlYXNlUmVsPTAuNV0gLSBSZWxlYXNlIHRpbWUgcmVsYXRpdmUgdG8gZ3JhaW4gZHVyYXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VTaGFwZT0nbGluJ10gLSBTaGFwZSBvZiByZWxlYXNlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5leHBSYW1wT2Zmc2V0PTAuMDAwMV0gLSBPZmZzZXQgKHN0YXJ0L2VuZCB2YWx1ZSlcclxuICogIGZvciBleHBvbmVudGlhbCBhdHRhY2svcmVsZWFzZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzYW1wbGluZz0wXSAtIEdyYWluIHJlc2FtcGxpbmcgaW4gY2VudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzYW1wbGluZ1Zhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSByZXNhbXBsaW5nIHZhcmlhdGlvbiBpbiBjZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5nYWluPTFdIC0gTGluZWFyIGdhaW4gZmFjdG9yXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2VudGVyZWQ9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBncmFpbiBwb3NpdGlvbiByZWZlcnNcclxuICogIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGdyYWluIChvciB0aGUgYmVnaW5uaW5nKVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmN5Y2xpYz1mYWxzZV0gLSBXaGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgYW5kIGdyYWluXHJcbiAqICBwb3NpdGlvbiBhcmUgY29uc2lkZXJlZCBhcyBjeWNsaWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb249MF0gLSBQb3J0aW9uIGF0IHRoZSBlbmQgb2YgdGhlXHJcbiAqICBhdWRpbyBidWZmZXIgdGhhdCBoYXMgYmVlbiBjb3BpZWQgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIGFzc3VyZSBjeWNsaWMgYmVoYXZpb3JcclxuICovXHJcbmNsYXNzIEdyYW51bGFyRW5naW5lIGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG9wdGlvbnMuYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1ZGlvIGJ1ZmZlclxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtBdWRpb0J1ZmZlcn1cclxuICAgICAqIEBuYW1lIGJ1ZmZlclxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5idWZmZXIgPSBvcHRPckRlZihvcHRpb25zLmJ1ZmZlciwgbnVsbCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBncmFpbiBwZXJpb2QgaW4gc2VjXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHBlcmlvZEFic1xyXG4gICAgICogQGRlZmF1bHQgMC4wMVxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RBYnMgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZEFicywgMC4wMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmFpbiBwZXJpb2QgcmVsYXRpdmUgdG8gYWJzb2x1dGUgZHVyYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcGVyaW9kUmVsXHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZFJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kUmVsLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBwZXJpb2QgdmFyaWF0aW9uIHJlbGF0aXZlIHRvIGdyYWluIHBlcmlvZFxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBwZXJpb2RWYXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGVyaW9kVmFyID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RWYXIsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWluaW11bSBncmFpbiBwZXJpb2RcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcGVyaW9kTWluXHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwMVxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RNaW4gPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZE1pbiwgMC4wMDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR3JhaW4gcG9zaXRpb24gKG9uc2V0IHRpbWUgaW4gYXVkaW8gYnVmZmVyKSBpbiBzZWNcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcG9zaXRpb25cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zaXRpb24gPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBwb3NpdGlvbiB2YXJpYXRpb24gaW4gc2VjXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHBvc2l0aW9uVmFyXHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwM1xyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3NpdGlvblZhciA9IG9wdE9yRGVmKG9wdGlvbnMucG9zaXRpb25WYXIsIDAuMDAzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIGdyYWluIGR1cmF0aW9uIGluIHNlY1xyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBkdXJhdGlvbkFic1xyXG4gICAgICogQGRlZmF1bHQgMC4xXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmR1cmF0aW9uQWJzID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvbkFicywgMC4xKTsgLy8gYWJzb2x1dGUgZ3JhaW4gZHVyYXRpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyYWluIGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdyYWluIHBlcmlvZCAob3ZlcmxhcClcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgZHVyYXRpb25SZWxcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHVyYXRpb25SZWwgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uUmVsLCAwKTtcclxuICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBkdXJhdGlvbiB2YXJpYXRpb24gaW4gc2VjXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBuYW1lIGR1cmF0aW9uVmFyXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZHVyYXRpb25WYXIgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIGF0dGFjayB0aW1lIGluIHNlY1xyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBhdHRhY2tBYnNcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXR0YWNrQWJzID0gb3B0T3JEZWYob3B0aW9ucy5hdHRhY2tBYnMsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNrIHRpbWUgcmVsYXRpdmUgdG8gZ3JhaW4gZHVyYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgYXR0YWNrUmVsXHJcbiAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXR0YWNrUmVsID0gb3B0T3JEZWYob3B0aW9ucy5hdHRhY2tSZWwsIDAuNSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaGFwZSBvZiBhdHRhY2sgKCdsaW4nIGZvciBsaW5lYXIgcmFtcCwgJ2V4cCcgZm9yIGV4cG9uZW50aWFsIHJhbXApXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBuYW1lIGF0dGFja1NoYXBlXHJcbiAgICAgKiBAZGVmYXVsdCAnbGluJ1xyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdHRhY2tTaGFwZSA9IG9wdE9yRGVmKG9wdGlvbnMuYXR0YWNrU2hhcGUsICdsaW4nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIHJlbGVhc2UgdGltZSBpbiBzZWNcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcmVsZWFzZUFic1xyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWxlYXNlQWJzID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlQWJzLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBncmFpbiBkdXJhdGlvblxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSByZWxlYXNlUmVsXHJcbiAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZVJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucmVsZWFzZVJlbCwgMC41KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNoYXBlIG9mIHJlbGVhc2UgKCdsaW4nIGZvciBsaW5lYXIgcmFtcCwgJ2V4cCcgZm9yIGV4cG9uZW50aWFsIHJhbXApXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBuYW1lIHJlbGVhc2VTaGFwZVxyXG4gICAgICogQGRlZmF1bHQgJ2xpbidcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZVNoYXBlID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlU2hhcGUsICdsaW4nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9mZnNldCAoc3RhcnQvZW5kIHZhbHVlKSBmb3IgZXhwb25lbnRpYWwgYXR0YWNrL3JlbGVhc2VcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgZXhwUmFtcE9mZnNldFxyXG4gICAgICogQGRlZmF1bHQgMC4wMDAxXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmV4cFJhbXBPZmZzZXQgPSBvcHRPckRlZihvcHRpb25zLmV4cFJhbXBPZmZzZXQsIDAuMDAwMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmFpbiByZXNhbXBsaW5nIGluIGNlbnRcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcmVzYW1wbGluZ1xyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNhbXBsaW5nID0gb3B0T3JEZWYob3B0aW9ucy5yZXNhbXBsaW5nLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSByZXNhbXBsaW5nIHZhcmlhdGlvbiBpbiBjZW50XHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHJlc2FtcGxpbmdWYXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzYW1wbGluZ1ZhciA9IG9wdE9yRGVmKG9wdGlvbnMucmVzYW1wbGluZ1ZhciwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lYXIgZ2FpbiBmYWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgZ2FpblxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5nYWluID0gb3B0T3JEZWYob3B0aW9ucy5nYWluLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGdyYWluIHBvc2l0aW9uIHJlZmVycyB0byB0aGUgY2VudGVyIG9mIHRoZSBncmFpbiAob3IgdGhlIGJlZ2lubmluZylcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBuYW1lIGNlbnRlcmVkXHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNlbnRlcmVkID0gb3B0T3JEZWYob3B0aW9ucy5jZW50ZXJlZCwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgYW5kIGdyYWluIHBvc2l0aW9uIGFyZSBjb25zaWRlcmVkIGFzIGN5Y2xpY1xyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQG5hbWUgY3ljbGljXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5jeWNsaWMgPSBvcHRPckRlZihvcHRpb25zLmN5Y2xpYywgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9ydGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBidWZmZXIgdGhhdCBoYXMgYmVlbiBjb3BpZWQgZnJvbSB0aGVcclxuICAgICAqIGJlZ2lubmluZyB0byBhc3N1cmUgY3ljbGljIGJlaGF2aW9yXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHdyYXBBcm91bmRFeHRlbnNpb25cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbiA9IG9wdE9yRGVmKG9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiwgMCk7XHJcblxyXG4gICAgdGhpcy5vdXRwdXROb2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGJ1ZmZlciBkdXJhdGlvbiAoZXhjbHVkaW5nIHdyYXBBcm91bmRFeHRlbnNpb24pXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGJ1ZmZlckR1cmF0aW9uXHJcbiAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGJ1ZmZlckR1cmF0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XHJcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xyXG5cclxuICAgICAgaWYgKHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbilcclxuICAgICAgICBidWZmZXJEdXJhdGlvbiAtPSB0aGlzLndyYXBBcm91bmRFeHRlbnNpb247XHJcblxyXG4gICAgICByZXR1cm4gYnVmZmVyRHVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDdXJyZW50IHBvc2l0aW9uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGN1cnJlbnRQb3NpdGlvblxyXG4gICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICB2YXIgbWFzdGVyID0gdGhpcy5tYXN0ZXI7XHJcblxyXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgYWR2YW5jZVRpbWUodGltZSkge1xyXG4gICAgdGltZSA9IE1hdGgubWF4KHRpbWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKTtcclxuICAgIHJldHVybiB0aW1lICsgdGhpcy50cmlnZ2VyKHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlciBhIGdyYWluLiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgYXQgYW55IHRpbWUgKHdoZXRoZXIgdGhlXHJcbiAgICogZW5naW5lIGlzIHNjaGVkdWxlZCBvciBub3QpIHRvIGdlbmVyYXRlIGEgc2luZ2xlIGdyYWluIGFjY29yZGluZyB0byB0aGVcclxuICAgKiBjdXJyZW50IGdyYWluIHBhcmFtZXRlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIGdyYWluIHN5bnRoZXNpcyBhdWRpbyB0aW1lXHJcbiAgICogQHJldHVybiB7TnVtYmVyfSAtIHBlcmlvZCB0byBuZXh0IGdyYWluXHJcbiAgICovXHJcbiAgdHJpZ2dlcih0aW1lKSB7XHJcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XHJcbiAgICB2YXIgZ3JhaW5UaW1lID0gdGltZSB8fCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XHJcbiAgICB2YXIgZ3JhaW5QZXJpb2QgPSB0aGlzLnBlcmlvZEFicztcclxuICAgIHZhciBncmFpblBvc2l0aW9uID0gdGhpcy5jdXJyZW50UG9zaXRpb247XHJcbiAgICB2YXIgZ3JhaW5EdXJhdGlvbiA9IHRoaXMuZHVyYXRpb25BYnM7XHJcblxyXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XHJcbiAgICAgIHZhciByZXNhbXBsaW5nUmF0ZSA9IDEuMDtcclxuXHJcbiAgICAgIC8vIGNhbGN1bGF0ZSByZXNhbXBsaW5nXHJcbiAgICAgIGlmICh0aGlzLnJlc2FtcGxpbmcgIT09IDAgfHwgdGhpcy5yZXNhbXBsaW5nVmFyID4gMCkge1xyXG4gICAgICAgIHZhciByYW5kb21SZXNhbXBsaW5nID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMi4wICogdGhpcy5yZXNhbXBsaW5nVmFyO1xyXG4gICAgICAgIHJlc2FtcGxpbmdSYXRlID0gTWF0aC5wb3coMi4wLCAodGhpcy5yZXNhbXBsaW5nICsgcmFuZG9tUmVzYW1wbGluZykgLyAxMjAwLjApO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyByYW5kb21pemUgZ3JhaW4gZHVyYXRpb25cclxuICAgICAgaWYgKHRoaXMuZHVyYXRpb25WYXIgPiAwKSBncmFpbkR1cmF0aW9uICs9ICgyLjAgKiBNYXRoLnJhbmRvbSgpIC0gMSkgKiB0aGlzLmR1cmF0aW9uVmFyO1xyXG5cclxuICAgICAgZ3JhaW5QZXJpb2QgKz0gdGhpcy5wZXJpb2RSZWwgKiBncmFpbkR1cmF0aW9uO1xyXG4gICAgICBncmFpbkR1cmF0aW9uICs9IHRoaXMuZHVyYXRpb25SZWwgKiBncmFpblBlcmlvZDtcclxuXHJcbiAgICAgIC8vIGdyYWluIHBlcmlvZCByYW5kb24gdmFyaWF0aW9uXHJcbiAgICAgIGlmICh0aGlzLnBlcmlvZFZhciA+IDAuMClcclxuICAgICAgICBncmFpblBlcmlvZCArPSAyLjAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLnBlcmlvZFZhciAqIGdyYWluUGVyaW9kO1xyXG5cclxuICAgICAgLy8gY2VudGVyIGdyYWluXHJcbiAgICAgIGlmICh0aGlzLmNlbnRlcmVkKVxyXG4gICAgICAgIGdyYWluUG9zaXRpb24gLT0gMC41ICogZ3JhaW5EdXJhdGlvbjtcclxuXHJcbiAgICAgIC8vIHJhbmRvbWl6ZSBncmFpbiBwb3NpdGlvblxyXG4gICAgICBpZiAodGhpcy5wb3NpdGlvblZhciA+IDApXHJcbiAgICAgICAgZ3JhaW5Qb3NpdGlvbiArPSAoMi4wICogTWF0aC5yYW5kb20oKSAtIDEpICogdGhpcy5wb3NpdGlvblZhcjtcclxuXHJcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAvLyB3cmFwIG9yIGNsaXAgZ3JhaW4gcG9zaXRpb24gYW5kIGR1cmF0aW9uIGludG8gYnVmZmVyIGR1cmF0aW9uXHJcbiAgICAgIGlmIChncmFpblBvc2l0aW9uIDwgMCB8fCBncmFpblBvc2l0aW9uID49IGJ1ZmZlckR1cmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3ljbGljKSB7XHJcbiAgICAgICAgICB2YXIgY3ljbGVzID0gZ3JhaW5Qb3NpdGlvbiAvIGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICAgICAgZ3JhaW5Qb3NpdGlvbiA9IChjeWNsZXMgLSBNYXRoLmZsb29yKGN5Y2xlcykpICogYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAgICAgaWYgKGdyYWluUG9zaXRpb24gKyBncmFpbkR1cmF0aW9uID4gdGhpcy5idWZmZXIuZHVyYXRpb24pXHJcbiAgICAgICAgICAgIGdyYWluRHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIGdyYWluUG9zaXRpb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChncmFpblBvc2l0aW9uIDwgMCkge1xyXG4gICAgICAgICAgICBncmFpblRpbWUgLT0gZ3JhaW5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgZ3JhaW5EdXJhdGlvbiArPSBncmFpblBvc2l0aW9uO1xyXG4gICAgICAgICAgICBncmFpblBvc2l0aW9uID0gMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoZ3JhaW5Qb3NpdGlvbiArIGdyYWluRHVyYXRpb24gPiBidWZmZXJEdXJhdGlvbilcclxuICAgICAgICAgICAgZ3JhaW5EdXJhdGlvbiA9IGJ1ZmZlckR1cmF0aW9uIC0gZ3JhaW5Qb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG1ha2UgZ3JhaW5cclxuICAgICAgaWYgKHRoaXMuZ2FpbiA+IDAgJiYgZ3JhaW5EdXJhdGlvbiA+PSAwLjAwMSkge1xyXG4gICAgICAgIC8vIG1ha2UgZ3JhaW4gZW52ZWxvcGVcclxuICAgICAgICB2YXIgZW52ZWxvcGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHZhciBhdHRhY2sgPSB0aGlzLmF0dGFja0FicyArIHRoaXMuYXR0YWNrUmVsICogZ3JhaW5EdXJhdGlvbjtcclxuICAgICAgICB2YXIgcmVsZWFzZSA9IHRoaXMucmVsZWFzZUFicyArIHRoaXMucmVsZWFzZVJlbCAqIGdyYWluRHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmIChhdHRhY2sgKyByZWxlYXNlID4gZ3JhaW5EdXJhdGlvbikge1xyXG4gICAgICAgICAgdmFyIGZhY3RvciA9IGdyYWluRHVyYXRpb24gLyAoYXR0YWNrICsgcmVsZWFzZSk7XHJcbiAgICAgICAgICBhdHRhY2sgKj0gZmFjdG9yO1xyXG4gICAgICAgICAgcmVsZWFzZSAqPSBmYWN0b3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYXR0YWNrRW5kVGltZSA9IGdyYWluVGltZSArIGF0dGFjaztcclxuICAgICAgICB2YXIgZ3JhaW5FbmRUaW1lID0gZ3JhaW5UaW1lICsgZ3JhaW5EdXJhdGlvbiAvIHJlc2FtcGxpbmdSYXRlO1xyXG4gICAgICAgIHZhciByZWxlYXNlU3RhcnRUaW1lID0gZ3JhaW5FbmRUaW1lIC0gcmVsZWFzZTtcclxuXHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi52YWx1ZSA9IDA7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmF0dGFja1NoYXBlID09PSAnbGluJykge1xyXG4gICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLjAsIGdyYWluVGltZSk7XHJcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5leHBSYW1wT2Zmc2V0LCBncmFpblRpbWUpO1xyXG4gICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVsZWFzZVN0YXJ0VGltZSA+IGF0dGFja0VuZFRpbWUpXHJcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgcmVsZWFzZVN0YXJ0VGltZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnJlbGVhc2VTaGFwZSA9PT0gJ2xpbicpIHtcclxuICAgICAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMC4wLCBncmFpbkVuZFRpbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5leHBSYW1wT2Zmc2V0LCBncmFpbkVuZFRpbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZW52ZWxvcGUuY29ubmVjdCh0aGlzLm91dHB1dE5vZGUpO1xyXG5cclxuICAgICAgICAvLyBtYWtlIHNvdXJjZVxyXG4gICAgICAgIHZhciBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcblxyXG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICBzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmVzYW1wbGluZ1JhdGU7XHJcbiAgICAgICAgc291cmNlLmNvbm5lY3QoZW52ZWxvcGUpO1xyXG5cclxuICAgICAgICBzb3VyY2Uuc3RhcnQoZ3JhaW5UaW1lLCBncmFpblBvc2l0aW9uKTtcclxuICAgICAgICBzb3VyY2Uuc3RvcChncmFpbkVuZFRpbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucGVyaW9kTWluLCBncmFpblBlcmlvZCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHcmFudWxhckVuZ2luZTtcclxuIiwiaW1wb3J0IEF1ZGlvVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcclxuXHJcbmZ1bmN0aW9uIG9wdE9yRGVmKG9wdCwgZGVmKSB7XHJcbiAgaWYob3B0ICE9PSB1bmRlZmluZWQpXHJcbiAgICByZXR1cm4gb3B0O1xyXG5cclxuICByZXR1cm4gZGVmO1xyXG59XHJcblxyXG4vKipcclxuICogTWV0cm9ub21lIGF1ZGlvIGVuZ2luZS4gSXQgZXh0ZW5kcyBUaW1lIEVuZ2luZSBhcyBhIHRyYW5zcG9ydGVkIGludGVyZmFjZS5cclxuICogW2V4YW1wbGVde0BsaW5rIGh0dHBzOi8vcmF3Z2l0LmNvbS93YXZlc2pzL3dhdmVzLWF1ZGlvL21hc3Rlci9leGFtcGxlcy9tZXRyb25vbWUuaHRtbH1cclxuICpcclxuICogQGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XHJcbiAqIGNvbnN0IG1ldHJvbm9tZSA9IG5ldyBhdWRpby5NZXRyb25vbWUoe3BlcmlvZDogMC4zMzN9KTtcclxuICpcclxuICogc2NoZWR1bGVyLmFkZChtZXRyb25vbWUpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gRGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2Q9MV0gLSBNZXRyb25vbWUgcGVyaW9kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jbGlja0ZyZXE9NjAwXSAtIE1ldHJvbm9tZSBjbGljayBmcmVxdWVuY3lcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNsaWNrQXR0YWNrPTAuMDAyXSAtIE1ldHJvbm9tZSBjbGljayBhdHRhY2sgdGltZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2xpY2tSZWxlYXNlPTAuMDk4XSAtIE1ldHJvbm9tZSBjbGljayByZWxlYXNlIHRpbWVcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdhaW49MV0gLSBHYWluXHJcbiAqL1xyXG5jbGFzcyBNZXRyb25vbWUgZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIob3B0aW9ucy5hdWRpb0NvbnRleHQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0cm9ub21lIHBlcmlvZFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX19wZXJpb2QgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZCwgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRyb25vbWUgY2xpY2sgZnJlcXVlbmN5XHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBNZXRyb25vbWVcclxuICAgICAqIEBuYW1lIGNsaWNrRnJlcVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xpY2tGcmVxID0gb3B0T3JEZWYob3B0aW9ucy5jbGlja0ZyZXEsIDYwMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRyb25vbWUgY2xpY2sgYXR0YWNrIHRpbWVcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxyXG4gICAgICogQG5hbWUgY2xpY2tBdHRhY2tcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaWNrQXR0YWNrID0gb3B0T3JEZWYob3B0aW9ucy5jbGlja0F0dGFjaywgMC4wMDIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0cm9ub21lIGNsaWNrIHJlbGVhc2UgdGltZVxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgTWV0cm9ub21lXHJcbiAgICAgKiBAbmFtZSBjbGlja1JlbGVhc2VcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaWNrUmVsZWFzZSA9IG9wdE9yRGVmKG9wdGlvbnMuY2xpY2tSZWxlYXNlLCAwLjA5OCk7XHJcblxyXG4gICAgdGhpcy5fX2xhc3RUaW1lID0gMDtcclxuICAgIHRoaXMuX19waGFzZSA9IDA7XHJcblxyXG4gICAgdGhpcy5fX2dhaW5Ob2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgdGhpcy5fX2dhaW5Ob2RlLmdhaW4udmFsdWUgPSBvcHRPckRlZihvcHRpb25zLmdhaW4sIDEpO1xyXG5cclxuICAgIHRoaXMub3V0cHV0Tm9kZSA9IHRoaXMuX19nYWluTm9kZTtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kIChzY2hlZHVsZWQgaW50ZXJmYWNlKVxyXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcclxuICAgIHRoaXMudHJpZ2dlcih0aW1lKTtcclxuICAgIHRoaXMuX19sYXN0VGltZSA9IHRpbWU7XHJcbiAgICByZXR1cm4gdGltZSArIHRoaXMuX19wZXJpb2Q7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAodHJhbnNwb3J0ZWQgaW50ZXJmYWNlKVxyXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGlmICh0aGlzLl9fcGVyaW9kID4gMCkge1xyXG4gICAgICB2YXIgbmV4dFBvc2l0aW9uID0gKE1hdGguZmxvb3IocG9zaXRpb24gLyB0aGlzLl9fcGVyaW9kKSArIHRoaXMuX19waGFzZSkgKiB0aGlzLl9fcGVyaW9kO1xyXG5cclxuICAgICAgaWYgKHNwZWVkID4gMCAmJiBuZXh0UG9zaXRpb24gPCBwb3NpdGlvbilcclxuICAgICAgICBuZXh0UG9zaXRpb24gKz0gdGhpcy5fX3BlcmlvZDtcclxuICAgICAgZWxzZSBpZiAoc3BlZWQgPCAwICYmIG5leHRQb3NpdGlvbiA+IHBvc2l0aW9uKVxyXG4gICAgICAgIG5leHRQb3NpdGlvbiAtPSB0aGlzLl9fcGVyaW9kO1xyXG5cclxuICAgICAgcmV0dXJuIG5leHRQb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gSW5maW5pdHkgKiBzcGVlZDtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXHJcbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdGhpcy50cmlnZ2VyKHRpbWUpO1xyXG5cclxuICAgIGlmIChzcGVlZCA8IDApXHJcbiAgICAgIHJldHVybiBwb3NpdGlvbiAtIHRoaXMuX19wZXJpb2Q7XHJcblxyXG4gICAgcmV0dXJuIHBvc2l0aW9uICsgdGhpcy5fX3BlcmlvZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXIgbWV0cm9ub21lIGNsaWNrXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgbWV0cm9ub21lIGNsaWNrIHN5bnRoZXNpcyBhdWRpbyB0aW1lXHJcbiAgICovXHJcbiAgdHJpZ2dlcih0aW1lKSB7XHJcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcclxuICAgIGNvbnN0IGNsaWNrQXR0YWNrID0gdGhpcy5jbGlja0F0dGFjaztcclxuICAgIGNvbnN0IGNsaWNrUmVsZWFzZSA9IHRoaXMuY2xpY2tSZWxlYXNlO1xyXG5cclxuICAgIGNvbnN0IGVudiA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICBlbnYuZ2Fpbi52YWx1ZSA9IDAuMDtcclxuICAgIGVudi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xyXG4gICAgZW52LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMS4wLCB0aW1lICsgY2xpY2tBdHRhY2spO1xyXG4gICAgZW52LmdhaW4uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSgwLjAwMDAwMDEsIHRpbWUgKyBjbGlja0F0dGFjayArIGNsaWNrUmVsZWFzZSk7XHJcbiAgICBlbnYuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcclxuICAgIGVudi5jb25uZWN0KHRoaXMub3V0cHV0Tm9kZSk7XHJcblxyXG4gICAgY29uc3Qgb3NjID0gYXVkaW9Db250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuICAgIG9zYy5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmNsaWNrRnJlcTtcclxuICAgIG9zYy5zdGFydCh0aW1lKTtcclxuICAgIG9zYy5zdG9wKHRpbWUgKyBjbGlja0F0dGFjayArIGNsaWNrUmVsZWFzZSk7XHJcbiAgICBvc2MuY29ubmVjdChlbnYpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogbGluZWFyIGdhaW4gZmFjdG9yXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGdhaW5cclxuICAgKiBAbWVtYmVyb2YgTWV0cm9ub21lXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcbiAgc2V0IGdhaW4odmFsdWUpIHtcclxuICAgIHRoaXMuX19nYWluTm9kZS5nYWluLnZhbHVlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBnZXQgZ2FpbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZ2Fpbk5vZGUuZ2Fpbi52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIG1ldHJvbm9tZSBwZXJpb2RcclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG5hbWUgcGVyaW9kXHJcbiAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBwZXJpb2QocGVyaW9kKSB7XHJcbiAgICB0aGlzLl9fcGVyaW9kID0gcGVyaW9kO1xyXG5cclxuICAgIGNvbnN0IG1hc3RlciA9IHRoaXMubWFzdGVyO1xyXG5cclxuICAgIGlmIChtYXN0ZXIpIHtcclxuICAgICAgaWYgKG1hc3Rlci5yZXNldEVuZ2luZVRpbWUpXHJcbiAgICAgICAgbWFzdGVyLnJlc2V0RW5naW5lVGltZSh0aGlzLCB0aGlzLl9fbGFzdFRpbWUgKyBwZXJpb2QpO1xyXG4gICAgICBlbHNlIGlmIChtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbilcclxuICAgICAgICBtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbih0aGlzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBwZXJpb2QoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3BlcmlvZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBwaGFzZSBwYXJhbWV0ZXIgKGF2YWlsYWJsZSBvbmx5IHdoZW4gJ3RyYW5zcG9ydGVkJyksIHNob3VsZCBiZVxyXG4gICAqIGJldHdlZW4gWzAsIDFbXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIHBoYXNlXHJcbiAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBwaGFzZShwaGFzZSkge1xyXG4gICAgdGhpcy5fX3BoYXNlID0gcGhhc2UgLSBNYXRoLmZsb29yKHBoYXNlKTtcclxuXHJcbiAgICBjb25zdCBtYXN0ZXIgPSB0aGlzLm1hc3RlcjtcclxuXHJcbiAgICBpZiAobWFzdGVyICYmIG1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIG1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBoYXNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19waGFzZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1ldHJvbm9tZTtcclxuIiwiaW1wb3J0IEF1ZGlvVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcclxuaW1wb3J0IFBoYXNlVm9jb2RlciBmcm9tICcuLi91dGlscy9QVl9mYXN0XzUnO1xyXG5pbXBvcnQgQnVmZmVyZWRQViBmcm9tICcuLi91dGlscy9idWZmZXJlZC1wdic7XHJcblxyXG5mdW5jdGlvbiBvcHRPckRlZihvcHQsIGRlZikge1xyXG4gIGlmIChvcHQgIT09IHVuZGVmaW5lZClcclxuICAgIHJldHVybiBvcHQ7XHJcblxyXG4gIHJldHVybiBkZWY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRPclByZXZpb3VzSW5kZXgoc29ydGVkQXJyYXksIHZhbHVlLCBpbmRleCA9IC0xKSB7XHJcbiAgdmFyIHNpemUgPSBzb3J0ZWRBcnJheS5sZW5ndGg7XHJcblxyXG4gIGlmIChzaXplID4gMCkge1xyXG4gICAgdmFyIGZpcnN0VmFsID0gc29ydGVkQXJyYXlbMF07XHJcbiAgICB2YXIgbGFzdFZhbCA9IHNvcnRlZEFycmF5W3NpemUgLSAxXTtcclxuXHJcbiAgICBpZiAodmFsdWUgPCBmaXJzdFZhbClcclxuICAgICAgaW5kZXggPSAtMTtcclxuICAgIGVsc2UgaWYgKHZhbHVlID49IGxhc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gc2l6ZSAtIDE7XHJcbiAgICBlbHNlIHtcclxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKVxyXG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoc2l6ZSAtIDEpICogKHZhbHVlIC0gZmlyc3RWYWwpIC8gKGxhc3RWYWwgLSBmaXJzdFZhbCkpO1xyXG5cclxuICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4XSA+IHZhbHVlKVxyXG4gICAgICAgIGluZGV4LS07XHJcblxyXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXggKyAxXSA8PSB2YWx1ZSlcclxuICAgICAgICBpbmRleCsrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGluZGV4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDdXJyZW50T3JOZXh0SW5kZXgoc29ydGVkQXJyYXksIHZhbHVlLCBpbmRleCA9IC0xKSB7XHJcbiAgdmFyIHNpemUgPSBzb3J0ZWRBcnJheS5sZW5ndGg7XHJcblxyXG4gIGlmIChzaXplID4gMCkge1xyXG4gICAgdmFyIGZpcnN0VmFsID0gc29ydGVkQXJyYXlbMF07XHJcbiAgICB2YXIgbGFzdFZhbCA9IHNvcnRlZEFycmF5W3NpemUgLSAxXTtcclxuXHJcbiAgICBpZiAodmFsdWUgPD0gZmlyc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gMDtcclxuICAgIGVsc2UgaWYgKHZhbHVlID49IGxhc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gc2l6ZTtcclxuICAgIGVsc2Uge1xyXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNpemUpXHJcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChzaXplIC0gMSkgKiAodmFsdWUgLSBmaXJzdFZhbCkgLyAobGFzdFZhbCAtIGZpcnN0VmFsKSk7XHJcblxyXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXhdIDwgdmFsdWUpXHJcbiAgICAgICAgaW5kZXgrKztcclxuXHJcbiAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleCAtIDFdID49IHZhbHVlKVxyXG4gICAgICAgIGluZGV4LS07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaW5kZXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VkIHdpdGggYSBidWZmZXIgdG8gc2VydmUgYXVkaW8gZmlsZXMgdmlhIGdyYW51bGFyIHN5bnRoZXNpcy5cclxuICpcclxuICogVGhlIGVuZ2luZSBpbXBsZW1lbnRzIHRoZSBcInNjaGVkdWxlZFwiIGFuZCBcInRyYW5zcG9ydGVkXCIgaW50ZXJmYWNlcy5cclxuICogV2hlbiBcInNjaGVkdWxlZFwiLCB0aGUgZW5naW5lICBnZW5lcmF0ZXMgc2VnbWVudHMgbW9yZSBvciBsZXNzwqBwZXJpb2RpY2FsbHlcclxuICogKGNvbnRyb2xsZWQgYnkgdGhlIHBlcmlvZEFicywgcGVyaW9kUmVsLCBhbmQgcGVyaW9WYXIgYXR0cmlidXRlcykuXHJcbiAqIFdoZW4gXCJ0cmFuc3BvcnRlZFwiLCB0aGUgZW5naW5lIGdlbmVyYXRlcyBzZWdtZW50cyBhdCB0aGUgcG9zaXRpb24gb2YgdGhlaXIgb25zZXQgdGltZS5cclxuICpcclxuICogRXhhbXBsZSB0aGF0IHNob3dzIGEgYFBoYXNldm9jb2RlckVuZ2luZWAgd2l0aCBhIGZldyBwYXJhbWV0ZXIgY29udHJvbHMgcnVubmluZyBpbiBhIGBTY2hlZHVsZXJgLlxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3BoYXNldm9jb2Rlci1lbmdpbmUuaHRtbH1cclxuICpcclxuICogQGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XHJcbiAqIGNvbnN0IFBoYXNldm9jb2RlckVuZ2luZSA9IG5ldyBhdWRpby5QaGFzZXZvY29kZXJFbmdpbmUoKTtcclxuICpcclxuICogc2NoZWR1bGVyLmFkZChQaGFzZXZvY29kZXJFbmdpbmUpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gRGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IFtvcHRpb25zLmJ1ZmZlcj1udWxsXSAtIEF1ZGlvIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kQWJzPTBdIC0gQWJzb2x1dGUgc2VnbWVudCBwZXJpb2QgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RSZWw9MV0gLSBTZWdtZW50IHBlcmlvZCByZWxhdGl2ZSB0byBpbnRlci1zZWdtZW50IGRpc3RhbmNlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RWYXI9MF0gLSBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwZXJpb2QgdmFyaWF0aW9uIHJlbGF0aXZlXHJcbiAqICB0byBzZWdtZW50IHBlcmlvZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kTWluPTAuMDAxXSAtIE1pbmltdW0gc2VnbWVudCBwZXJpb2RcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvc2l0aW9uQXJyYXk9WzAuMF1dIC0gQXJyYXkgb2Ygc2VnbWVudCBwb3NpdGlvbnMgKG9uc2V0IHRpbWVzXHJcbiAqICBpbiBhdWRpbyBidWZmZXIpIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zaXRpb25WYXI9MF0gLSBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwb3NpdGlvbiB2YXJpYXRpb24gaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbkFycmF5PVswLjBdXSAtIEFycmF5IG9mIHNlZ21lbnQgZHVyYXRpb25zIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25BYnM9MF0gLSBBYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25SZWw9MV0gLSBTZWdtZW50IGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdpdmVuIHNlZ21lbnRcclxuICogIGR1cmF0aW9uIG9yIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMub2Zmc2V0QXJyYXk9WzAuMF1dIC0gQXJyYXkgb2Ygc2VnbWVudCBvZmZzZXRzIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0QWJzPS0wLjAwNV0gLSBBYnNvbHV0ZSBzZWdtZW50IG9mZnNldCBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFJlbD0wXSAtIFNlZ21lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlbGF5PTAuMDA1XSAtIFRpbWUgYnkgd2hpY2ggYWxsIHNlZ21lbnRzIGFyZSBkZWxheWVkIChlc3BlY2lhbGx5XHJcbiAqICB0byByZWFsaXplIHNlZ21lbnQgb2Zmc2V0cylcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF0dGFja0Ficz0wLjAwNV0gLSBBYnNvbHV0ZSBhdHRhY2sgdGltZSBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF0dGFja1JlbD0wXSAtIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VBYnM9MC4wMDVdIC0gQWJzb2x1dGUgcmVsZWFzZSB0aW1lIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVsZWFzZVJlbD0wXSAtIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNhbXBsaW5nPTBdIC0gU2VnbWVudCByZXNhbXBsaW5nIGluIGNlbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc2FtcGxpbmdWYXI9MF0gLSBBbW91dCBvZiByYW5kb20gcmVzYW1wbGluZyB2YXJpYXRpb24gaW4gY2VudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ2Fpbj0xXSAtIExpbmVhciBnYWluIGZhY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYWJvcnRUaW1lPTAuMDA1XSAtIGZhZGUtb3V0IHRpbWUgd2hlbiBhYm9ydGVkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zZWdtZW50SW5kZXg9MF0gLSBJbmRleCBvZiB0aGUgc2VnbWVudCB0byBzeW50aGVzaXplIChpLmUuIG9mXHJcbiAqICB0aGlzLnBvc2l0aW9uQXJyYXkvZHVyYXRpb25BcnJheS9vZmZzZXRBcnJheSlcclxuICogQHBhcmFtIHtCb29sfSBbb3B0aW9ucy5jeWNsaWM9ZmFsc2VdIC0gV2hldGhlciB0aGUgYXVkaW8gYnVmZmVyIGFuZCBzZWdtZW50IGluZGljZXMgYXJlXHJcbiAqICBjb25zaWRlcmVkIGFzIGN5Y2xpY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbj0wXSAtIFBvcnRpb24gYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gYnVmZmVyXHJcbiAqICB0aGF0IGhhcyBiZWVuIGNvcGllZCBmcm9tIHRoZSBiZWdpbm5pbmcgdG8gYXNzdXJlIGN5Y2xpYyBiZWhhdmlvclxyXG4gKi9cclxuY2xhc3MgUGhhc2V2b2NvZGVyRW5naW5lIGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG9wdGlvbnMuYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1ZGlvIGJ1ZmZlclxyXG4gICAgICogQG5hbWUgYnVmZmVyXHJcbiAgICAgKiBAdHlwZSB7QXVkaW9CdWZmZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5idWZmZXIgPSBvcHRPckRlZihvcHRpb25zLmJ1ZmZlciwgbnVsbCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBzZWdtZW50IHBlcmlvZCBpbiBzZWNcclxuICAgICAqIEBuYW1lIHBlcmlvZEFic1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZEFicyA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kQWJzLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZ21lbnQgcGVyaW9kIHJlbGF0aXZlIHRvIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICAgICAqIEBuYW1lIHBlcmlvZFJlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZFJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kUmVsLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBlcmlvZCB2YXJpYXRpb24gcmVsYXRpdmUgdG8gc2VnbWVudCBwZXJpb2RcclxuICAgICAqIEBuYW1lIHBlcmlvZFZhclxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZFZhciA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1pbmltdW0gc2VnbWVudCBwZXJpb2RcclxuICAgICAqIEBuYW1lIHBlcmlvZE1pblxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDAxXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RNaW4gPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZE1pbiwgMC4wMDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2Ygc2VnbWVudCBwb3NpdGlvbnMgKG9uc2V0IHRpbWVzIGluIGF1ZGlvIGJ1ZmZlcikgaW4gc2VjXHJcbiAgICAgKiBAbmFtZSBwb3NpdGlvbkFycmF5XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgWzAuMF1cclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc2l0aW9uQXJyYXkgPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uQXJyYXksIFswLjBdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBvc2l0aW9uIHZhcmlhdGlvbiBpbiBzZWNcclxuICAgICAqIEBuYW1lIHBvc2l0aW9uVmFyXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zaXRpb25WYXIgPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHNlZ21lbnQgZHVyYXRpb25zIGluIHNlY1xyXG4gICAgICogQG5hbWUgZHVyYXRpb25BcnJheVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IFswLjBdXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kdXJhdGlvbkFycmF5ID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvbkFycmF5LCBbMC4wXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uIGluIHNlY1xyXG4gICAgICogQG5hbWUgZHVyYXRpb25BYnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kdXJhdGlvbkFicyA9IG9wdE9yRGVmKG9wdGlvbnMuZHVyYXRpb25BYnMsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VnbWVudCBkdXJhdGlvbiByZWxhdGl2ZSB0byBnaXZlbiBzZWdtZW50IGR1cmF0aW9uIG9yIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICAgICAqIEBuYW1lIGR1cmF0aW9uUmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHVyYXRpb25SZWwgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uUmVsLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHNlZ21lbnQgb2Zmc2V0cyBpbiBzZWNcclxuICAgICAqXHJcbiAgICAgKiBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICogb2Zmc2V0IDwgMDogdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb24gaXMgdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb25cclxuICAgICAqIGFuZCB0aGUgZHVyYXRpb24gaGFzIHRvIGJlIGNvcnJlY3RlZCBieSB0aGUgb2Zmc2V0XHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgb2Zmc2V0QXJyYXlcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqIEBkZWZhdWx0IFswLjBdXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5vZmZzZXRBcnJheSA9IG9wdE9yRGVmKG9wdGlvbnMub2Zmc2V0QXJyYXksIFswLjBdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIHNlZ21lbnQgb2Zmc2V0IGluIHNlY1xyXG4gICAgICogQG5hbWUgb2Zmc2V0QWJzXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgLTAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5vZmZzZXRBYnMgPSBvcHRPckRlZihvcHRpb25zLm9mZnNldEFicywgMC4wMDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VnbWVudCBvZmZzZXQgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICogQG5hbWUgb2Zmc2V0UmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMub2Zmc2V0UmVsID0gb3B0T3JEZWYob3B0aW9ucy5vZmZzZXRSZWwsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGltZSBieSB3aGljaCBhbGwgc2VnbWVudHMgYXJlIGRlbGF5ZWQgKGVzcGVjaWFsbHkgdG8gcmVhbGl6ZSBzZWdtZW50IG9mZnNldHMpXHJcbiAgICAgKiBAbmFtZSBkZWxheVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kZWxheSA9IG9wdE9yRGVmKG9wdGlvbnMuZGVsYXksIDAuMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBhdHRhY2sgdGltZSBpbiBzZWNcclxuICAgICAqIEBuYW1lIGF0dGFja0Fic1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdHRhY2tBYnMgPSBvcHRPckRlZihvcHRpb25zLmF0dGFja0FicywgMC4wKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAqIEBuYW1lIGF0dGFja1JlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmF0dGFja1JlbCA9IG9wdE9yRGVmKG9wdGlvbnMuYXR0YWNrUmVsLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIHJlbGVhc2UgdGltZSBpbiBzZWNcclxuICAgICAqIEBuYW1lIHJlbGVhc2VBYnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZUFicyA9IG9wdE9yRGVmKG9wdGlvbnMucmVsZWFzZUFicywgMC4wKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXHJcbiAgICAgKiBAbmFtZSByZWxlYXNlUmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZVJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucmVsZWFzZVJlbCwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWdtZW50IHJlc2FtcGxpbmcgaW4gY2VudFxyXG4gICAgICogQG5hbWUgcmVzYW1wbGluZ1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc2FtcGxpbmcgPSBvcHRPckRlZihvcHRpb25zLnJlc2FtcGxpbmcsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW1vdXQgb2YgcmFuZG9tIHJlc2FtcGxpbmcgdmFyaWF0aW9uIGluIGNlbnRcclxuICAgICAqIEBuYW1lIHJlc2FtcGxpbmdWYXJcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNhbXBsaW5nVmFyID0gb3B0T3JEZWYob3B0aW9ucy5yZXNhbXBsaW5nVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmVhciBnYWluIGZhY3RvclxyXG4gICAgICogQG5hbWUgZ2FpblxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmdhaW4gPSBvcHRPckRlZihvcHRpb25zLmdhaW4sIDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kZXggb2YgdGhlIHNlZ21lbnQgdG8gc3ludGhlc2l6ZSAoaS5lLiBvZiB0aGlzLnBvc2l0aW9uQXJyYXkvZHVyYXRpb25BcnJheS9vZmZzZXRBcnJheSlcclxuICAgICAqIEBuYW1lIHNlZ21lbnRJbmRleFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IG9wdE9yRGVmKG9wdGlvbnMuc2VnbWVudEluZGV4LCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGF1ZGlvIGJ1ZmZlciBhbmQgc2VnbWVudCBpbmRpY2VzIGFyZSBjb25zaWRlcmVkIGFzIGN5Y2xpY1xyXG4gICAgICogQG5hbWUgY3ljbGljXHJcbiAgICAgKiBAdHlwZSB7Qm9vbH1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5jeWNsaWMgPSBvcHRPckRlZihvcHRpb25zLmN5Y2xpYywgZmFsc2UpO1xyXG4gICAgdGhpcy5fX2N5Y2xpY09mZnNldCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBsYXN0IHNlZ21lbnQgaXMgYWJvcnRlZCB3aGVuIHRyaWdnZXJpbmcgdGhlIG5leHRcclxuICAgICAqIEBuYW1lIG1vbm9waG9uaWNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubW9ub3Bob25pYyA9IG9wdE9yRGVmKG9wdGlvbnMubW9ub3Bob25pYywgZmFsc2UpO1xyXG4gICAgdGhpcy5fX2N1cnJlbnRTcmMgPSBudWxsO1xyXG4gICAgdGhpcy5fX2N1cnJlbnRFbnYgPSBudWxsO1xyXG4gICAgdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUgPSAwO1xyXG4gICAgdGhpcy5fX2N1cnJlbnRHYWluID0gMDtcclxuICAgIHRoaXMuX19jdXJyZW50RW5kVGltZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGYWRlLW91dCB0aW1lICh3aGVuIGFib3J0ZWQpXHJcbiAgICAgKiBAbmFtZSBhYm9ydFRpbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWJvcnRUaW1lID0gb3B0T3JEZWYob3B0aW9ucy5hYm9ydFRpbWUsIDAuMDA1KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvcnRpb24gYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gYnVmZmVyIHRoYXQgaGFzIGJlZW4gY29waWVkIGZyb20gdGhlIGJlZ2lubmluZyB0byBhc3N1cmUgY3ljbGljIGJlaGF2aW9yXHJcbiAgICAgKiBAbmFtZSB3cmFwQXJvdW5kRXh0ZW5zaW9uXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbiA9IG9wdE9yRGVmKG9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiwgMCk7XHJcblxyXG4gICAgdGhpcy5vdXRwdXROb2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG5cclxuICAgLyoqXHJcbiAgICogU2l6ZSBvZiBwaGFzZXZvY29kZXIgYW5hbHlzaXMgZnJhbWVcclxuICAgKiBAbmFtZSBmcmFtZVNpemVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBkZWZhdWx0IDQwOTZcclxuICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcbiAgICB0aGlzLmZyYW1lU2l6ZSA9IG9wdE9yRGVmKG9wdGlvbnMuZnJhbWVTaXplLCAyMDQ4KTtcclxuXHJcbiAgICAvLyBTZXR1cCB2b2NvZGVyXHJcbiAgICB0aGlzLl9wdiA9IG5ldyBCdWZmZXJlZFBWKHRoaXMuZnJhbWVTaXplKTtcclxuICAgIHRoaXMuX3B2LnNldF9hdWRpb19idWZmZXIodGhpcy5idWZmZXIpO1xyXG4gICAgdGhpcy5fcHYuYWxwaGEgPSAxO1xyXG5cclxuICAgIC8vIEZJWE1FOiBCVUZGRVJfU0laRSBub3QgaW4gdXNlIHlldC4uLlxyXG4gICAgLy8gVGhpbmtpbmcgdGhhdCBpZiB1c2VyIGRvbnQgcHJvdmlkZSBzZWdtZW50cyAoaWUgbWFya2VyYnVmZmVyKSwgXHJcbiAgICAvLyB0aGVuIHRoZSBlbmdpbmUganVzdCBjaG9wcyB0aGUgYnVmZmVyIGludG8gY2h1bmtzIHdoaXRoIHRoaXMgc2l6ZS5cclxuICAgIHRoaXMuQlVGRkVSX1NJWkUgPSA0MDk2O1xyXG4gICAgICAgIFxyXG4gICAvKipcclxuICAgKiBUaGUgYW1vdW50IHRvIHN0cmV0Y2ggdGhlIGF1ZGlvIHNlZ21lbnRzIHdpdGhcclxuICAgKiBAbmFtZSBzdHJldGNoRmFjdG9yXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAZGVmYXVsdCAxXHJcbiAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gICAgdGhpcy5zdHJldGNoRmFjdG9yID0gb3B0T3JEZWYob3B0aW9ucy5zdHJldGNoRmFjdG9yLCAxKTtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYnVmZmVyIGR1cmF0aW9uIChleGNsdWRpbmcgd3JhcEFyb3VuZEV4dGVuc2lvbilcclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQGRlZmF1bHQgMFxyXG4gICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKi9cclxuICBnZXQgYnVmZmVyRHVyYXRpb24oKSB7XHJcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcclxuICAgICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXIuZHVyYXRpb247XHJcblxyXG4gICAgICBpZiAodGhpcy53cmFwQXJvdW5kRXh0ZW5zaW9uKVxyXG4gICAgICAgIGJ1ZmZlckR1cmF0aW9uIC09IHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbjtcclxuXHJcbiAgICAgIHJldHVybiBidWZmZXJEdXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXHJcbiAgYWR2YW5jZVRpbWUodGltZSkge1xyXG4gICAgdGltZSA9IE1hdGgubWF4KHRpbWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKTtcclxuICAgIHJldHVybiB0aW1lICsgdGhpcy50cmlnZ2VyKHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHRyYW5zcG9ydGVkIGludGVyZmFjZSlcclxuICBzeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLnNlZ21lbnRJbmRleDtcclxuICAgIHZhciBjeWNsaWNPZmZzZXQgPSAwO1xyXG4gICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICBpZiAodGhpcy5jeWNsaWMpIHtcclxuICAgICAgdmFyIGN5Y2xlcyA9IHBvc2l0aW9uIC8gYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICBjeWNsaWNPZmZzZXQgPSBNYXRoLmZsb29yKGN5Y2xlcykgKiBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgcG9zaXRpb24gLT0gY3ljbGljT2Zmc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzcGVlZCA+IDApIHtcclxuICAgICAgaW5kZXggPSBnZXRDdXJyZW50T3JOZXh0SW5kZXgodGhpcy5wb3NpdGlvbkFycmF5LCBwb3NpdGlvbik7XHJcblxyXG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICBjeWNsaWNPZmZzZXQgKz0gYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jeWNsaWMpXHJcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoc3BlZWQgPCAwKSB7XHJcbiAgICAgIGluZGV4ID0gZ2V0Q3VycmVudE9yUHJldmlvdXNJbmRleCh0aGlzLnBvc2l0aW9uQXJyYXksIHBvc2l0aW9uKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICBpbmRleCA9IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxO1xyXG4gICAgICAgIGN5Y2xpY09mZnNldCAtPSBidWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcclxuICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IGluZGV4O1xyXG4gICAgdGhpcy5fX2N5Y2xpY09mZnNldCA9IGN5Y2xpY09mZnNldDtcclxuXHJcbiAgICByZXR1cm4gY3ljbGljT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbkFycmF5W2luZGV4XTtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXHJcbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5zZWdtZW50SW5kZXg7XHJcbiAgICB2YXIgY3ljbGljT2Zmc2V0ID0gdGhpcy5fX2N5Y2xpY09mZnNldDtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGltZSk7XHJcblxyXG4gICAgaWYgKHNwZWVkID4gMCkge1xyXG4gICAgICBpbmRleCsrO1xyXG5cclxuICAgICAgaWYgKGluZGV4ID49IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGgpIHtcclxuICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgY3ljbGljT2Zmc2V0ICs9IHRoaXMuYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jeWNsaWMpXHJcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGluZGV4LS07XHJcblxyXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgaW5kZXggPSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoIC0gMTtcclxuICAgICAgICBjeWNsaWNPZmZzZXQgLT0gdGhpcy5idWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcclxuICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IGluZGV4O1xyXG4gICAgdGhpcy5fX2N5Y2xpY09mZnNldCA9IGN5Y2xpY09mZnNldDtcclxuXHJcbiAgICByZXR1cm4gY3ljbGljT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbkFycmF5W2luZGV4XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXIgYSBzZWdtZW50LlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCBhdCBhbnkgdGltZSAod2hldGhlciB0aGUgZW5naW5lIGlzIHNjaGVkdWxlZC90cmFuc3BvcnRlZCBvciBub3QpXHJcbiAgICogdG8gZ2VuZXJhdGUgYSBzaW5nbGUgc2VnbWVudCBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc2VnbWVudCBwYXJhbWV0ZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgc2VnbWVudCBzeW50aGVzaXMgYXVkaW8gdGltZVxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gcGVyaW9kIHRvIG5leHQgc2VnbWVudFxyXG4gICAqL1xyXG4gIHRyaWdnZXIodGltZSkge1xyXG4gICAgdmFyIGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xyXG4gICAgdmFyIHNlZ21lbnRUaW1lID0gKHRpbWUgfHwgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKSArIHRoaXMuZGVsYXk7XHJcbiAgICB2YXIgc2VnbWVudFBlcmlvZCA9IHRoaXMucGVyaW9kQWJzO1xyXG4gICAgdmFyIHNlZ21lbnRJbmRleCA9IHRoaXMuc2VnbWVudEluZGV4O1xyXG5cclxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xyXG4gICAgICB2YXIgc2VnbWVudFBvc2l0aW9uID0gMC4wO1xyXG4gICAgICB2YXIgc2VnbWVudER1cmF0aW9uID0gMC4wO1xyXG4gICAgICB2YXIgc2VnbWVudE9mZnNldCA9IDAuMDtcclxuICAgICAgdmFyIHJlc2FtcGxpbmdSYXRlID0gMS4wO1xyXG4gICAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgICAgaWYgKHRoaXMuY3ljbGljKVxyXG4gICAgICAgIHNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleCAlIHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGg7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBzZWdtZW50SW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWdtZW50SW5kZXgsIHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxKSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5wb3NpdGlvbkFycmF5KVxyXG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XHJcblxyXG4gICAgICBpZiAodGhpcy5kdXJhdGlvbkFycmF5KVxyXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiA9IHRoaXMuZHVyYXRpb25BcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XHJcblxyXG4gICAgICBpZiAodGhpcy5vZmZzZXRBcnJheSlcclxuICAgICAgICBzZWdtZW50T2Zmc2V0ID0gdGhpcy5vZmZzZXRBcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XHJcblxyXG4gICAgICAvLyBjYWxjdWxhdGUgcmVzYW1wbGluZ1xyXG4gICAgICBpZiAodGhpcy5yZXNhbXBsaW5nICE9PSAwIHx8IHRoaXMucmVzYW1wbGluZ1ZhciA+IDApIHtcclxuICAgICAgICB2YXIgcmFuZG9tUmVzYW1wbGluZyA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIuMCAqIHRoaXMucmVzYW1wbGluZ1ZhcjtcclxuICAgICAgICByZXNhbXBsaW5nUmF0ZSA9IE1hdGgucG93KDIuMCwgKHRoaXMucmVzYW1wbGluZyArIHJhbmRvbVJlc2FtcGxpbmcpIC8gMTIwMC4wKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY2FsY3VsYXRlIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICAgICAgaWYgKHNlZ21lbnREdXJhdGlvbiA9PT0gMCB8fCB0aGlzLnBlcmlvZFJlbCA+IDApIHtcclxuICAgICAgICB2YXIgbmV4dFNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleCArIDE7XHJcbiAgICAgICAgdmFyIG5leHRQb3NpdGlvbiwgbmV4dE9mZnNldDtcclxuXHJcbiAgICAgICAgaWYgKG5leHRTZWdtZW50SW5kZXggPT09IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgIGlmICh0aGlzLmN5Y2xpYykge1xyXG4gICAgICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uQXJyYXlbMF0gKyBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgICAgICAgbmV4dE9mZnNldCA9IHRoaXMub2Zmc2V0QXJyYXlbMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgICAgICAgbmV4dE9mZnNldCA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVtuZXh0U2VnbWVudEluZGV4XTtcclxuICAgICAgICAgIG5leHRPZmZzZXQgPSB0aGlzLm9mZnNldEFycmF5W25leHRTZWdtZW50SW5kZXhdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGludGVyU2VnbWVudERpc3RhbmNlID0gbmV4dFBvc2l0aW9uIC0gc2VnbWVudFBvc2l0aW9uO1xyXG5cclxuICAgICAgICAvLyBjb3JyZWN0IGludGVyLXNlZ21lbnQgZGlzdGFuY2UgYnkgb2Zmc2V0c1xyXG4gICAgICAgIC8vICAgb2Zmc2V0ID4gMDogdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gaXMgYWZ0ZXIgdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb25cclxuICAgICAgICBpZiAoc2VnbWVudE9mZnNldCA+IDApXHJcbiAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSAtPSBzZWdtZW50T2Zmc2V0O1xyXG5cclxuICAgICAgICBpZiAobmV4dE9mZnNldCA+IDApXHJcbiAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSArPSBuZXh0T2Zmc2V0O1xyXG5cclxuICAgICAgICBpZiAoaW50ZXJTZWdtZW50RGlzdGFuY2UgPCAwKVxyXG4gICAgICAgICAgaW50ZXJTZWdtZW50RGlzdGFuY2UgPSAwO1xyXG5cclxuICAgICAgICAvLyB1c2UgaW50ZXItc2VnbWVudCBkaXN0YW5jZSBpbnN0ZWFkIG9mIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAgICBpZiAoc2VnbWVudER1cmF0aW9uID09PSAwKVxyXG4gICAgICAgICAgc2VnbWVudER1cmF0aW9uID0gaW50ZXJTZWdtZW50RGlzdGFuY2U7XHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBwZXJpb2QgcmVsYXRpdmUgdG8gaW50ZXIgbWFya2VyIGRpc3RhbmNlXHJcbiAgICAgICAgc2VnbWVudFBlcmlvZCArPSB0aGlzLnBlcmlvZFJlbCAqIGludGVyU2VnbWVudERpc3RhbmNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhZGQgcmVsYXRpdmUgYW5kIGFic29sdXRlIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAgc2VnbWVudER1cmF0aW9uICo9IHRoaXMuZHVyYXRpb25SZWw7XHJcbiAgICAgIHNlZ21lbnREdXJhdGlvbiArPSB0aGlzLmR1cmF0aW9uQWJzO1xyXG5cclxuICAgICAgLy8gYWRkIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBzZWdtZW50IG9mZnNldFxyXG4gICAgICBzZWdtZW50T2Zmc2V0ICo9IHRoaXMub2Zmc2V0UmVsO1xyXG4gICAgICBzZWdtZW50T2Zmc2V0ICs9IHRoaXMub2Zmc2V0QWJzO1xyXG5cclxuICAgICAgLy8gYXBwbHkgc2VnbWVudCBvZmZzZXRcclxuICAgICAgLy8gICBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICAvLyAgIG9mZnNldCA8IDA6IHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uIGlzIHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGFuZCB0aGUgZHVyYXRpb24gaGFzIHRvIGJlIGNvcnJlY3RlZCBieSB0aGUgb2Zmc2V0XHJcbiAgICAgIGlmIChzZWdtZW50T2Zmc2V0IDwgMCkge1xyXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiAtPSBzZWdtZW50T2Zmc2V0O1xyXG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiArPSBzZWdtZW50T2Zmc2V0O1xyXG4gICAgICAgIHNlZ21lbnRUaW1lICs9IChzZWdtZW50T2Zmc2V0IC8gcmVzYW1wbGluZ1JhdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlZ21lbnRUaW1lIC09IChzZWdtZW50T2Zmc2V0IC8gcmVzYW1wbGluZ1JhdGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByYW5kb21pemUgc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICBpZiAodGhpcy5wb3NpdGlvblZhciA+IDApXHJcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uICs9IDIuMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRoaXMucG9zaXRpb25WYXI7XHJcblxyXG4gICAgICAvLyBzaG9ydGVuIGR1cmF0aW9uIG9mIHNlZ21lbnRzIG92ZXIgdGhlIGVkZ2VzIG9mIHRoZSBidWZmZXJcclxuICAgICAgaWYgKHNlZ21lbnRQb3NpdGlvbiA8IDApIHtcclxuICAgICAgICAvL3NlZ21lbnRUaW1lIC09IGdyYWluUG9zaXRpb247IGhtLCBub3Qgc3VyZSBpZiB3ZSB3YW50IHRvIGRvIHRoaXNcclxuICAgICAgICBzZWdtZW50RHVyYXRpb24gKz0gc2VnbWVudFBvc2l0aW9uO1xyXG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZWdtZW50UG9zaXRpb24gKyBzZWdtZW50RHVyYXRpb24gPiB0aGlzLmJ1ZmZlci5kdXJhdGlvbilcclxuICAgICAgICBzZWdtZW50RHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIHNlZ21lbnRQb3NpdGlvbjtcclxuXHJcbiAgICAgIHNlZ21lbnREdXJhdGlvbiAvPSByZXNhbXBsaW5nUmF0ZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1vbm9waG9uaWMpXHJcbiAgICAgICAgdGhpcy5hYm9ydChzZWdtZW50VGltZSk7XHJcblxyXG4gICAgICAvLyBtYWtlIHNlZ21lbnRcclxuICAgICAgaWYgKHRoaXMuZ2FpbiA+IDAgJiYgc2VnbWVudER1cmF0aW9uID4gMCkge1xyXG4gICAgICAgIC8vIG1ha2Ugc2VnbWVudCBlbnZlbG9wZVxyXG4gICAgICAgIHZhciBlbnZlbG9wZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdmFyIGF0dGFjayA9IHRoaXMuYXR0YWNrQWJzICsgdGhpcy5hdHRhY2tSZWwgKiBzZWdtZW50RHVyYXRpb247XHJcbiAgICAgICAgdmFyIHJlbGVhc2UgPSB0aGlzLnJlbGVhc2VBYnMgKyB0aGlzLnJlbGVhc2VSZWwgKiBzZWdtZW50RHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmIChhdHRhY2sgKyByZWxlYXNlID4gc2VnbWVudER1cmF0aW9uKSB7XHJcbiAgICAgICAgICB2YXIgZmFjdG9yID0gc2VnbWVudER1cmF0aW9uIC8gKGF0dGFjayArIHJlbGVhc2UpO1xyXG4gICAgICAgICAgYXR0YWNrICo9IGZhY3RvcjtcclxuICAgICAgICAgIHJlbGVhc2UgKj0gZmFjdG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGF0dGFja0VuZFRpbWUgPSBzZWdtZW50VGltZSArIGF0dGFjaztcclxuICAgICAgICB2YXIgc2VnbWVudEVuZFRpbWUgPSBzZWdtZW50VGltZSArIHNlZ21lbnREdXJhdGlvbjtcclxuICAgICAgICB2YXIgcmVsZWFzZVN0YXJ0VGltZSA9IHNlZ21lbnRFbmRUaW1lIC0gcmVsZWFzZTtcclxuXHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi52YWx1ZSA9IDA7XHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLjAsIHNlZ21lbnRUaW1lKTtcclxuICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XHJcblxyXG4gICAgICAgIGlmIChyZWxlYXNlU3RhcnRUaW1lID4gYXR0YWNrRW5kVGltZSlcclxuICAgICAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5nYWluLCByZWxlYXNlU3RhcnRUaW1lKTtcclxuXHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLjAsIHNlZ21lbnRFbmRUaW1lKTtcclxuICAgICAgICBlbnZlbG9wZS5jb25uZWN0KHRoaXMub3V0cHV0Tm9kZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX19jdXJyZW50RW52ID0gZW52ZWxvcGU7XHJcblxyXG4gICAgICAgIC8vIG1ha2Ugc291cmNlXHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuXHJcbiAgICAgICAgLy8gQnVmZmVyIHRvIHNhdmUgdGhlIHN0cmV0Y2ggYXVkaW8gaW50b1xyXG4gICAgICAgIHZhciBzdHJldGNoZWRCdWZmZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKDIsIHNlZ21lbnREdXJhdGlvbiAqIGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlLCBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7XHJcblxyXG4gICAgICAgIC8vIFNldCB0aGUgcGhhc2V2b2NvZGVyJ3MgcG9zaXRpb24gaW4gc291cmNlIGJ1ZmZlciAoaWUgdGhpcy5idWZmZXIpLlxyXG4gICAgICAgIHRoaXMuX3B2LnBvc2l0aW9uID0gc2VnbWVudFBvc2l0aW9uICogYXVkaW9Db250ZXh0LnNhbXBsZVJhdGU7ICAgICAgIFxyXG4gICAgICAgIHRoaXMuX3B2LnByb2Nlc3Moc3RyZXRjaGVkQnVmZmVyKTtcclxuICAgICAgICAvLyBGSVhNRTogSWYgcGhhc2UgaXMgbm90IHJlc2V0LCB0aGUgYXVkaW8gaXMgc2lsZW5jZWQgd2hlbiBsb29wZWQuLi4gZG9udCBrbm93IHdoeS4uLlxyXG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uQXJyYXkpIHtcclxuICAgICAgICAgIGlmIChzZWdtZW50SW5kZXggPT0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgdGhpcy5fcHYucmVzZXRQaGFzZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc291cmNlLmJ1ZmZlciA9IHN0cmV0Y2hlZEJ1ZmZlcjtcclxuICAgICAgICBzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmVzYW1wbGluZ1JhdGU7XHJcbiAgICAgICAgLy9zb3VyY2UuY29ubmVjdChlbnZlbG9wZSk7IC8vRklYTUU6IFVzaW5nIGVudmVsb3BlIGNhdXNlcyBcInRyZW1vbG9cIiBldmVuIGlmIGFsbCByYW1waW5nIGlzIDAuXHJcbiAgICAgICAgc291cmNlLmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTsgXHJcblxyXG4gICAgICAgIHNvdXJjZS5zdGFydChzZWdtZW50VGltZSk7XHJcbiAgICAgICAgc291cmNlLnN0b3Aoc2VnbWVudFRpbWUgKyBzZWdtZW50RHVyYXRpb24pO1xyXG5cclxuICAgICAgICB0aGlzLl9fY3VycmVudFNyYyA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZSA9IHJlbGVhc2VTdGFydFRpbWU7XHJcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRHYWluID0gdGhpcy5nYWluO1xyXG4gICAgICAgIHRoaXMuX19jdXJyZW50RW5kVGltZSA9IHNlZ21lbnRFbmRUaW1lO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIGdyYWluIHBlcmlvZCByYW5kb24gdmFyaWF0aW9uXHJcbiAgICBpZiAodGhpcy5wZXJpb2RWYXIgPiAwLjApXHJcbiAgICAgIHNlZ21lbnRQZXJpb2QgKz0gMi4wICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5wZXJpb2RWYXIgKiBncmFpblBlcmlvZDtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5wZXJpb2RNaW4sIHNlZ21lbnRQZXJpb2QpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWJvcnQgdGhlIGN1cnJlbnQgc2VnbWVudCBhdCBnaXZlbiB0aW1lLCBmYWRlIG91dCBkdXJhdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBhYm9ydCB0aW1lXHJcbiAgICovXHJcbiAgYWJvcnQodGltZSkge1xyXG4gICAgY29uc3QgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XHJcbiAgICBjb25zdCBlbmRUaW1lID0gdGhpcy5fX2N1cnJlbnRFbmRUaW1lO1xyXG4gICAgY29uc3QgYWJvcnRUaW1lID0gdGltZSB8fCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XHJcblxyXG4gICAgaWYgKGFib3J0VGltZSA8IGVuZFRpbWUpIHtcclxuICAgICAgY29uc3Qgc2VnbWVudEVuZFRpbWUgPSBNYXRoLm1pbihhYm9ydFRpbWUgKyB0aGlzLmFib3J0VGltZSwgZW5kVGltZSk7XHJcbiAgICAgIGNvbnN0IGVudmVsb3BlID0gdGhpcy5fX2N1cnJlbnRFbnY7XHJcbiAgICAgIGxldCBjdXJyZW50R2FpblZhbHVlID0gdGhpcy5fX2N1cnJlbnRHYWluO1xyXG5cclxuICAgICAgaWYgKGFib3J0VGltZSA+IHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lKSB7XHJcbiAgICAgICAgY29uc3QgcmVsZWFzZVN0YXJ0ID0gdGhpcy5fX3JlbGVhc2VTdGFydFRpbWU7XHJcbiAgICAgICAgY3VycmVudEdhaW5WYWx1ZSAqPSAoYWJvcnRUaW1lIC0gcmVsZWFzZVN0YXJ0KSAvIChlbmRUaW1lIC0gcmVsZWFzZVN0YXJ0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZW52ZWxvcGUuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoYWJvcnRUaW1lKTtcclxuICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShjdXJyZW50R2FpblZhbHVlLCBhYm9ydFRpbWUpO1xyXG4gICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHNlZ21lbnRFbmRUaW1lKTtcclxuXHJcbiAgICAgIHRoaXMuX19jdXJyZW50U3JjID0gbnVsbDtcclxuICAgICAgdGhpcy5fX2N1cnJlbnRFbnYgPSBudWxsO1xyXG4gICAgICB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZSA9IDA7XHJcbiAgICAgIHRoaXMuX19jdXJyZW50R2FpbiA9IDA7XHJcbiAgICAgIHRoaXMuX19jdXJyZW50RW5kVGltZSA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzZXQgc3RyZXRjaEZhY3RvciAobmV3QWxwaGEpIHtcclxuICAgICAgaWYodGhpcy5fcHYpXHJcbiAgICAgICAgdGhpcy5fcHYuYWxwaGEgPSBuZXdBbHBoYTtcclxuICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQaGFzZXZvY29kZXJFbmdpbmU7XHJcbiIsImltcG9ydCBBdWRpb1RpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS9hdWRpby10aW1lLWVuZ2luZSc7XHJcblxyXG5mdW5jdGlvbiBvcHRPckRlZihvcHQsIGRlZikge1xyXG4gIGlmKG9wdCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgcmV0dXJuIG9wdDtcclxuXHJcbiAgcmV0dXJuIGRlZjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVzZWQgd2l0aCBhIGJ1ZmZlciB0byBzZXJ2ZSBhdWRpbyBmaWxlcy5cclxuICpcclxuICogW2V4YW1wbGVde0BsaW5rIGh0dHBzOi8vcmF3Z2l0LmNvbS93YXZlc2pzL3dhdmVzLWF1ZGlvL21hc3Rlci9leGFtcGxlcy9wbGF5ZXItZW5naW5lLmh0bWx9XHJcbiAqXHJcbiAqIEBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XHJcbiAqIGNvbnN0IHBsYXllckVuZ2luZSA9IGF1ZGlvLlBsYXllckVuZ2luZSgpO1xyXG4gKiBjb25zdCBwbGF5Q29udHJvbCA9IG5ldyBhdWRpby5QbGF5Q29udHJvbChwbGF5ZXJFbmdpbmUpO1xyXG4gKlxyXG4gKiBwbGF5Q29udHJvbC5zdGFydCgpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gRGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5idWZmZXI9MV0gLSBBdWRpbyBidWZmZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZhZGVUaW1lPTYwMF0gLSBGYWRlIHRpbWUgZm9yIGNoYWluaW5nIHNlZ21lbnRzXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jeWNsaWM9ZmFsc2VdIC0gTG9vcCBtb2RlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5nYWluPTFdIC0gR2FpblxyXG4gKi9cclxuY2xhc3MgUGxheWVyRW5naW5lIGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG9wdGlvbnMuYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7IC8vIHNldCB3aGVuIGFkZGVkIHRvIHRyYW5zcG9ydGVyXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdWRpbyBidWZmZXJcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7QXVkaW9CdWZmZXJ9XHJcbiAgICAgKiBAbmFtZSBidWZmZXJcclxuICAgICAqIEBtZW1iZXJvZiBQbGF5ZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICovXHJcbiAgICB0aGlzLmJ1ZmZlciA9IG9wdE9yRGVmKG9wdGlvbnMuYnVmZmVyLCBudWxsKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZhZGUgdGltZSBmb3IgY2hhaW5pbmcgc2VnbWVudHMgKGUuZy4gaW4gc3RhcnQsIHN0b3AsIGFuZCBzZWVrKVxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBmYWRlVGltZVxyXG4gICAgICogQG1lbWJlcm9mIFBsYXllckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxyXG4gICAgICovXHJcbiAgICB0aGlzLmZhZGVUaW1lID0gb3B0T3JEZWYob3B0aW9ucy5mYWRlVGltZSwgMC4wMDUpO1xyXG5cclxuICAgIHRoaXMuX190aW1lID0gMDtcclxuICAgIHRoaXMuX19wb3NpdGlvbiA9IDA7XHJcbiAgICB0aGlzLl9fc3BlZWQgPSAwO1xyXG5cclxuICAgIHRoaXMuX19idWZmZXJTb3VyY2UgPSBudWxsO1xyXG4gICAgdGhpcy5fX2Vudk5vZGUgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX19nYWluTm9kZSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgIHRoaXMuX19nYWluTm9kZS5nYWluLnZhbHVlID0gb3B0T3JEZWYob3B0aW9ucy5nYWluLCAxKTtcclxuXHJcbiAgICB0aGlzLl9fY3ljbGljID0gb3B0T3JEZWYob3B0aW9ucy5jeWNsaWMsIGZhbHNlKTtcclxuXHJcbiAgICB0aGlzLm91dHB1dE5vZGUgPSB0aGlzLl9fZ2Fpbk5vZGU7XHJcbiAgfVxyXG5cclxuICBfX3N0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdmFyIGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xyXG5cclxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xyXG4gICAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbjtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9fY3ljbGljICYmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gYnVmZmVyRHVyYXRpb24pKSB7XHJcbiAgICAgICAgdmFyIHBoYXNlID0gcG9zaXRpb24gLyBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgICBwb3NpdGlvbiA9IChwaGFzZSAtIE1hdGguZmxvb3IocGhhc2UpKSAqIGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocG9zaXRpb24gPj0gMCAmJiBwb3NpdGlvbiA8IGJ1ZmZlckR1cmF0aW9uICYmIHNwZWVkID4gMCkge1xyXG4gICAgICAgIHRoaXMuX19lbnZOb2RlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB0aGlzLl9fZW52Tm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xyXG4gICAgICAgIHRoaXMuX19lbnZOb2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMSwgdGltZSArIHRoaXMuZmFkZVRpbWUpO1xyXG4gICAgICAgIHRoaXMuX19lbnZOb2RlLmNvbm5lY3QodGhpcy5fX2dhaW5Ob2RlKTtcclxuXHJcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xyXG4gICAgICAgIHRoaXMuX19idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gc3BlZWQ7XHJcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5sb29wID0gdGhpcy5fX2N5Y2xpYztcclxuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLmxvb3BTdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5sb29wRW5kID0gYnVmZmVyRHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5zdGFydCh0aW1lLCBwb3NpdGlvbik7XHJcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5jb25uZWN0KHRoaXMuX19lbnZOb2RlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX19oYWx0KHRpbWUpIHtcclxuICAgIGlmICh0aGlzLl9fYnVmZmVyU291cmNlKSB7XHJcbiAgICAgIHRoaXMuX19lbnZOb2RlLmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRpbWUpO1xyXG4gICAgICB0aGlzLl9fZW52Tm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKHRoaXMuX19lbnZOb2RlLmdhaW4udmFsdWUsIHRpbWUpO1xyXG4gICAgICB0aGlzLl9fZW52Tm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHRpbWUgKyB0aGlzLmZhZGVUaW1lKTtcclxuICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5zdG9wKHRpbWUgKyB0aGlzLmZhZGVUaW1lKTtcclxuXHJcbiAgICAgIHRoaXMuX19idWZmZXJTb3VyY2UgPSBudWxsO1xyXG4gICAgICB0aGlzLl9fZW52Tm9kZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAoc3BlZWQtY29udHJvbGxlZCBpbnRlcmZhY2UpXHJcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlayA9IGZhbHNlKSB7XHJcbiAgICB2YXIgbGFzdFNwZWVkID0gdGhpcy5fX3NwZWVkO1xyXG5cclxuICAgIGlmIChzcGVlZCAhPT0gbGFzdFNwZWVkIHx8IHNlZWspIHtcclxuICAgICAgaWYgKHNlZWsgfHwgbGFzdFNwZWVkICogc3BlZWQgPCAwKSB7XHJcbiAgICAgICAgdGhpcy5fX2hhbHQodGltZSk7XHJcbiAgICAgICAgdGhpcy5fX3N0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgIH0gZWxzZSBpZiAobGFzdFNwZWVkID09PSAwIHx8IHNlZWspIHtcclxuICAgICAgICB0aGlzLl9fc3RhcnQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICAgICAgfSBlbHNlIGlmIChzcGVlZCA9PT0gMCkge1xyXG4gICAgICAgIHRoaXMuX19oYWx0KHRpbWUpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX19idWZmZXJTb3VyY2UpIHtcclxuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLnBsYXliYWNrUmF0ZS5zZXRWYWx1ZUF0VGltZShzcGVlZCwgdGltZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX19zcGVlZCA9IHNwZWVkO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHdoZXRoZXIgdGhlIGF1ZGlvIGJ1ZmZlciBpcyBjb25zaWRlcmVkIGFzIGN5Y2xpY1xyXG4gICAqIEB0eXBlIHtCb29sfVxyXG4gICAqIEBuYW1lIGN5Y2xpY1xyXG4gICAqIEBtZW1iZXJvZiBQbGF5ZXJFbmdpbmVcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKi9cclxuICBzZXQgY3ljbGljKGN5Y2xpYykge1xyXG4gICAgaWYgKGN5Y2xpYyAhPT0gdGhpcy5fX2N5Y2xpYykge1xyXG4gICAgICB2YXIgdGltZSA9IHRoaXMuY3VycmVudFRpbWU7XHJcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuY3VycmVudG9zaXRpb247XHJcblxyXG4gICAgICB0aGlzLl9faGFsdCh0aW1lKTtcclxuICAgICAgdGhpcy5fX2N5Y2xpYyA9IGN5Y2xpYztcclxuXHJcbiAgICAgIGlmICh0aGlzLl9fc3BlZWQgIT09IDApXHJcbiAgICAgICAgdGhpcy5fX3N0YXJ0KHRpbWUsIHBvc2l0aW9uLCB0aGlzLl9fc3BlZWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IGN5Y2xpYygpIHtcclxuICAgIHJldHVybiB0aGlzLl9fY3ljbGljO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTGluZWFyIGdhaW4gZmFjdG9yXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbmFtZSBnYWluXHJcbiAgICogQG1lbWJlcm9mIFBsYXllckVuZ2luZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBnYWluKHZhbHVlKSB7XHJcbiAgICB2YXIgdGltZSA9IHRoaXMuY3VycmVudFRpbWU7XHJcbiAgICB0aGlzLl9fZ2Fpbk5vZGUuY2FuY2VsU2NoZWR1bGVkVmFsdWVzKHRpbWUpO1xyXG4gICAgdGhpcy5fX2dhaW5Ob2RlLnNldFZhbHVlQXRUaW1lKHRoaXMuX19nYWluTm9kZS5nYWluLnZhbHVlLCB0aW1lKTtcclxuICAgIHRoaXMuX19nYWluTm9kZS5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCB0aW1lICsgdGhpcy5mYWRlVGltZSk7XHJcbiAgfVxyXG5cclxuICBnZXQgZ2FpbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZ2Fpbk5vZGUuZ2Fpbi52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBidWZmZXIgZHVyYXRpb25cclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGJ1ZmZlckR1cmF0aW9uXHJcbiAgICogQG1lbWJlcm9mIFBsYXllckVuZ2luZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBidWZmZXJEdXJhdGlvbigpIHtcclxuICAgIGlmKHRoaXMuYnVmZmVyKVxyXG4gICAgICByZXR1cm4gdGhpcy5idWZmZXIuZHVyYXRpb247XHJcblxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQbGF5ZXJFbmdpbmU7XHJcbiIsImltcG9ydCBBdWRpb1RpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS9hdWRpby10aW1lLWVuZ2luZSc7XHJcblxyXG5mdW5jdGlvbiBvcHRPckRlZihvcHQsIGRlZikge1xyXG4gIGlmIChvcHQgIT09IHVuZGVmaW5lZClcclxuICAgIHJldHVybiBvcHQ7XHJcblxyXG4gIHJldHVybiBkZWY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRPclByZXZpb3VzSW5kZXgoc29ydGVkQXJyYXksIHZhbHVlLCBpbmRleCA9IC0xKSB7XHJcbiAgdmFyIHNpemUgPSBzb3J0ZWRBcnJheS5sZW5ndGg7XHJcblxyXG4gIGlmIChzaXplID4gMCkge1xyXG4gICAgdmFyIGZpcnN0VmFsID0gc29ydGVkQXJyYXlbMF07XHJcbiAgICB2YXIgbGFzdFZhbCA9IHNvcnRlZEFycmF5W3NpemUgLSAxXTtcclxuXHJcbiAgICBpZiAodmFsdWUgPCBmaXJzdFZhbClcclxuICAgICAgaW5kZXggPSAtMTtcclxuICAgIGVsc2UgaWYgKHZhbHVlID49IGxhc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gc2l6ZSAtIDE7XHJcbiAgICBlbHNlIHtcclxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKVxyXG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoc2l6ZSAtIDEpICogKHZhbHVlIC0gZmlyc3RWYWwpIC8gKGxhc3RWYWwgLSBmaXJzdFZhbCkpO1xyXG5cclxuICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4XSA+IHZhbHVlKVxyXG4gICAgICAgIGluZGV4LS07XHJcblxyXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXggKyAxXSA8PSB2YWx1ZSlcclxuICAgICAgICBpbmRleCsrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGluZGV4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDdXJyZW50T3JOZXh0SW5kZXgoc29ydGVkQXJyYXksIHZhbHVlLCBpbmRleCA9IC0xKSB7XHJcbiAgdmFyIHNpemUgPSBzb3J0ZWRBcnJheS5sZW5ndGg7XHJcblxyXG4gIGlmIChzaXplID4gMCkge1xyXG4gICAgdmFyIGZpcnN0VmFsID0gc29ydGVkQXJyYXlbMF07XHJcbiAgICB2YXIgbGFzdFZhbCA9IHNvcnRlZEFycmF5W3NpemUgLSAxXTtcclxuXHJcbiAgICBpZiAodmFsdWUgPD0gZmlyc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gMDtcclxuICAgIGVsc2UgaWYgKHZhbHVlID49IGxhc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gc2l6ZTtcclxuICAgIGVsc2Uge1xyXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNpemUpXHJcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChzaXplIC0gMSkgKiAodmFsdWUgLSBmaXJzdFZhbCkgLyAobGFzdFZhbCAtIGZpcnN0VmFsKSk7XHJcblxyXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXhdIDwgdmFsdWUpXHJcbiAgICAgICAgaW5kZXgrKztcclxuXHJcbiAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleCAtIDFdID49IHZhbHVlKVxyXG4gICAgICAgIGluZGV4LS07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaW5kZXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VkIHdpdGggYSBidWZmZXIgdG8gc2VydmUgYXVkaW8gZmlsZXMgdmlhIGdyYW51bGFyIHN5bnRoZXNpcy5cclxuICpcclxuICogVGhlIGVuZ2luZSBpbXBsZW1lbnRzIHRoZSBcInNjaGVkdWxlZFwiIGFuZCBcInRyYW5zcG9ydGVkXCIgaW50ZXJmYWNlcy5cclxuICogV2hlbiBcInNjaGVkdWxlZFwiLCB0aGUgZW5naW5lICBnZW5lcmF0ZXMgc2VnbWVudHMgbW9yZSBvciBsZXNzwqBwZXJpb2RpY2FsbHlcclxuICogKGNvbnRyb2xsZWQgYnkgdGhlIHBlcmlvZEFicywgcGVyaW9kUmVsLCBhbmQgcGVyaW9WYXIgYXR0cmlidXRlcykuXHJcbiAqIFdoZW4gXCJ0cmFuc3BvcnRlZFwiLCB0aGUgZW5naW5lIGdlbmVyYXRlcyBzZWdtZW50cyBhdCB0aGUgcG9zaXRpb24gb2YgdGhlaXIgb25zZXQgdGltZS5cclxuICpcclxuICogRXhhbXBsZSB0aGF0IHNob3dzIGEgYFNlZ21lbnRFbmdpbmVgIHdpdGggYSBmZXcgcGFyYW1ldGVyIGNvbnRyb2xzIHJ1bm5pbmcgaW4gYSBgU2NoZWR1bGVyYC5cclxuICoge0BsaW5rIGh0dHBzOi8vcmF3Z2l0LmNvbS93YXZlc2pzL3dhdmVzLWF1ZGlvL21hc3Rlci9leGFtcGxlcy9zZWdtZW50LWVuZ2luZS5odG1sfVxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0ICogYXMgYXVkaW8gZnJvbSAnd2F2ZXMtYXVkaW8nO1xyXG4gKiBjb25zdCBzY2hlZHVsZXIgPSBhdWRpby5nZXRTY2hlZHVsZXIoKTtcclxuICogY29uc3Qgc2VnbWVudEVuZ2luZSA9IG5ldyBhdWRpby5TZWdtZW50RW5naW5lKCk7XHJcbiAqXHJcbiAqIHNjaGVkdWxlci5hZGQoc2VnbWVudEVuZ2luZSk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBEZWZhdWx0IG9wdGlvbnNcclxuICogQHBhcmFtIHtBdWRpb0J1ZmZlcn0gW29wdGlvbnMuYnVmZmVyPW51bGxdIC0gQXVkaW8gYnVmZmVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RBYnM9MF0gLSBBYnNvbHV0ZSBzZWdtZW50IHBlcmlvZCBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZFJlbD0xXSAtIFNlZ21lbnQgcGVyaW9kIHJlbGF0aXZlIHRvIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZFZhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBlcmlvZCB2YXJpYXRpb24gcmVsYXRpdmVcclxuICogIHRvIHNlZ21lbnQgcGVyaW9kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RNaW49MC4wMDFdIC0gTWluaW11bSBzZWdtZW50IHBlcmlvZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zaXRpb25BcnJheT1bMC4wXV0gLSBBcnJheSBvZiBzZWdtZW50IHBvc2l0aW9ucyAob25zZXQgdGltZXNcclxuICogIGluIGF1ZGlvIGJ1ZmZlcikgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3NpdGlvblZhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBvc2l0aW9uIHZhcmlhdGlvbiBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uQXJyYXk9WzAuMF1dIC0gQXJyYXkgb2Ygc2VnbWVudCBkdXJhdGlvbnMgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbkFicz0wXSAtIEFic29sdXRlIHNlZ21lbnQgZHVyYXRpb24gaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvblJlbD0xXSAtIFNlZ21lbnQgZHVyYXRpb24gcmVsYXRpdmUgdG8gZ2l2ZW4gc2VnbWVudFxyXG4gKiAgZHVyYXRpb24gb3IgaW50ZXItc2VnbWVudCBkaXN0YW5jZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5vZmZzZXRBcnJheT1bMC4wXV0gLSBBcnJheSBvZiBzZWdtZW50IG9mZnNldHMgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRBYnM9LTAuMDA1XSAtIEFic29sdXRlIHNlZ21lbnQgb2Zmc2V0IGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0UmVsPTBdIC0gU2VnbWVudCBvZmZzZXQgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZGVsYXk9MC4wMDVdIC0gVGltZSBieSB3aGljaCBhbGwgc2VnbWVudHMgYXJlIGRlbGF5ZWQgKGVzcGVjaWFsbHlcclxuICogIHRvIHJlYWxpemUgc2VnbWVudCBvZmZzZXRzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXR0YWNrQWJzPTAuMDA1XSAtIEFic29sdXRlIGF0dGFjayB0aW1lIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXR0YWNrUmVsPTBdIC0gQXR0YWNrIHRpbWUgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVsZWFzZUFicz0wLjAwNV0gLSBBYnNvbHV0ZSByZWxlYXNlIHRpbWUgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZWxlYXNlUmVsPTBdIC0gUmVsZWFzZSB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc2FtcGxpbmc9MF0gLSBTZWdtZW50IHJlc2FtcGxpbmcgaW4gY2VudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzYW1wbGluZ1Zhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSByZXNhbXBsaW5nIHZhcmlhdGlvbiBpbiBjZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5nYWluPTFdIC0gTGluZWFyIGdhaW4gZmFjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hYm9ydFRpbWU9MC4wMDVdIC0gZmFkZS1vdXQgdGltZSB3aGVuIGFib3J0ZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnNlZ21lbnRJbmRleD0wXSAtIEluZGV4IG9mIHRoZSBzZWdtZW50IHRvIHN5bnRoZXNpemUgKGkuZS4gb2ZcclxuICogIHRoaXMucG9zaXRpb25BcnJheS9kdXJhdGlvbkFycmF5L29mZnNldEFycmF5KVxyXG4gKiBAcGFyYW0ge0Jvb2x9IFtvcHRpb25zLmN5Y2xpYz1mYWxzZV0gLSBXaGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgYW5kIHNlZ21lbnQgaW5kaWNlcyBhcmVcclxuICogIGNvbnNpZGVyZWQgYXMgY3ljbGljXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53cmFwQXJvdW5kRXh0ZW5zaW9uPTBdIC0gUG9ydGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBidWZmZXJcclxuICogIHRoYXQgaGFzIGJlZW4gY29waWVkIGZyb20gdGhlIGJlZ2lubmluZyB0byBhc3N1cmUgY3ljbGljIGJlaGF2aW9yXHJcbiAqL1xyXG5jbGFzcyBTZWdtZW50RW5naW5lIGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG9wdGlvbnMuYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1ZGlvIGJ1ZmZlclxyXG4gICAgICogQG5hbWUgYnVmZmVyXHJcbiAgICAgKiBAdHlwZSB7QXVkaW9CdWZmZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYnVmZmVyID0gb3B0T3JEZWYob3B0aW9ucy5idWZmZXIsIG51bGwpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzb2x1dGUgc2VnbWVudCBwZXJpb2QgaW4gc2VjXHJcbiAgICAgKiBAbmFtZSBwZXJpb2RBYnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGVyaW9kQWJzID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RBYnMsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VnbWVudCBwZXJpb2QgcmVsYXRpdmUgdG8gaW50ZXItc2VnbWVudCBkaXN0YW5jZVxyXG4gICAgICogQG5hbWUgcGVyaW9kUmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZFJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kUmVsLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBlcmlvZCB2YXJpYXRpb24gcmVsYXRpdmUgdG8gc2VnbWVudCBwZXJpb2RcclxuICAgICAqIEBuYW1lIHBlcmlvZFZhclxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RWYXIgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZFZhciwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNaW5pbXVtIHNlZ21lbnQgcGVyaW9kXHJcbiAgICAgKiBAbmFtZSBwZXJpb2RNaW5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwMVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZE1pbiA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kTWluLCAwLjAwMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBzZWdtZW50IHBvc2l0aW9ucyAob25zZXQgdGltZXMgaW4gYXVkaW8gYnVmZmVyKSBpbiBzZWNcclxuICAgICAqIEBuYW1lIHBvc2l0aW9uQXJyYXlcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBbMC4wXVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc2l0aW9uQXJyYXkgPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uQXJyYXksIFswLjBdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBvc2l0aW9uIHZhcmlhdGlvbiBpbiBzZWNcclxuICAgICAqIEBuYW1lIHBvc2l0aW9uVmFyXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc2l0aW9uVmFyID0gb3B0T3JEZWYob3B0aW9ucy5wb3NpdGlvblZhciwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBzZWdtZW50IGR1cmF0aW9ucyBpbiBzZWNcclxuICAgICAqIEBuYW1lIGR1cmF0aW9uQXJyYXlcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBbMC4wXVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmR1cmF0aW9uQXJyYXkgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uQXJyYXksIFswLjBdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIHNlZ21lbnQgZHVyYXRpb24gaW4gc2VjXHJcbiAgICAgKiBAbmFtZSBkdXJhdGlvbkFic1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kdXJhdGlvbkFicyA9IG9wdE9yRGVmKG9wdGlvbnMuZHVyYXRpb25BYnMsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VnbWVudCBkdXJhdGlvbiByZWxhdGl2ZSB0byBnaXZlbiBzZWdtZW50IGR1cmF0aW9uIG9yIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICAgICAqIEBuYW1lIGR1cmF0aW9uUmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmR1cmF0aW9uUmVsID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvblJlbCwgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcnJheSBvZiBzZWdtZW50IG9mZnNldHMgaW4gc2VjXHJcbiAgICAgKlxyXG4gICAgICogb2Zmc2V0ID4gMDogdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gaXMgYWZ0ZXIgdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb25cclxuICAgICAqIG9mZnNldCA8IDA6IHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uIGlzIHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uXHJcbiAgICAgKiBhbmQgdGhlIGR1cmF0aW9uIGhhcyB0byBiZSBjb3JyZWN0ZWQgYnkgdGhlIG9mZnNldFxyXG4gICAgICpcclxuICAgICAqIEBuYW1lIG9mZnNldEFycmF5XHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAZGVmYXVsdCBbMC4wXVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9mZnNldEFycmF5ID0gb3B0T3JEZWYob3B0aW9ucy5vZmZzZXRBcnJheSwgWzAuMF0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzb2x1dGUgc2VnbWVudCBvZmZzZXQgaW4gc2VjXHJcbiAgICAgKiBAbmFtZSBvZmZzZXRBYnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAtMC4wMDVcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5vZmZzZXRBYnMgPSBvcHRPckRlZihvcHRpb25zLm9mZnNldEFicywgLTAuMDA1KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZ21lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAqIEBuYW1lIG9mZnNldFJlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5vZmZzZXRSZWwgPSBvcHRPckRlZihvcHRpb25zLm9mZnNldFJlbCwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaW1lIGJ5IHdoaWNoIGFsbCBzZWdtZW50cyBhcmUgZGVsYXllZCAoZXNwZWNpYWxseSB0byByZWFsaXplIHNlZ21lbnQgb2Zmc2V0cylcclxuICAgICAqIEBuYW1lIGRlbGF5XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMC4wMDVcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kZWxheSA9IG9wdE9yRGVmKG9wdGlvbnMuZGVsYXksIDAuMDA1KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIGF0dGFjayB0aW1lIGluIHNlY1xyXG4gICAgICogQG5hbWUgYXR0YWNrQWJzXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMC4wMDVcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdHRhY2tBYnMgPSBvcHRPckRlZihvcHRpb25zLmF0dGFja0FicywgMC4wMDUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNrIHRpbWUgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICogQG5hbWUgYXR0YWNrUmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmF0dGFja1JlbCA9IG9wdE9yRGVmKG9wdGlvbnMuYXR0YWNrUmVsLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIHJlbGVhc2UgdGltZSBpbiBzZWNcclxuICAgICAqIEBuYW1lIHJlbGVhc2VBYnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlbGVhc2VBYnMgPSBvcHRPckRlZihvcHRpb25zLnJlbGVhc2VBYnMsIDAuMDA1KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXHJcbiAgICAgKiBAbmFtZSByZWxlYXNlUmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlbGVhc2VSZWwgPSBvcHRPckRlZihvcHRpb25zLnJlbGVhc2VSZWwsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VnbWVudCByZXNhbXBsaW5nIGluIGNlbnRcclxuICAgICAqIEBuYW1lIHJlc2FtcGxpbmdcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzYW1wbGluZyA9IG9wdE9yRGVmKG9wdGlvbnMucmVzYW1wbGluZywgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbW91dCBvZiByYW5kb20gcmVzYW1wbGluZyB2YXJpYXRpb24gaW4gY2VudFxyXG4gICAgICogQG5hbWUgcmVzYW1wbGluZ1ZhclxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNhbXBsaW5nVmFyID0gb3B0T3JEZWYob3B0aW9ucy5yZXNhbXBsaW5nVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmVhciBnYWluIGZhY3RvclxyXG4gICAgICogQG5hbWUgZ2FpblxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5nYWluID0gb3B0T3JEZWYob3B0aW9ucy5nYWluLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGV4IG9mIHRoZSBzZWdtZW50IHRvIHN5bnRoZXNpemUgKGkuZS4gb2YgdGhpcy5wb3NpdGlvbkFycmF5L2R1cmF0aW9uQXJyYXkvb2Zmc2V0QXJyYXkpXHJcbiAgICAgKiBAbmFtZSBzZWdtZW50SW5kZXhcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuc2VnbWVudEluZGV4ID0gb3B0T3JEZWYob3B0aW9ucy5zZWdtZW50SW5kZXgsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgYXVkaW8gYnVmZmVyIGFuZCBzZWdtZW50IGluZGljZXMgYXJlIGNvbnNpZGVyZWQgYXMgY3ljbGljXHJcbiAgICAgKiBAbmFtZSBjeWNsaWNcclxuICAgICAqIEB0eXBlIHtCb29sfVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5jeWNsaWMgPSBvcHRPckRlZihvcHRpb25zLmN5Y2xpYywgZmFsc2UpO1xyXG4gICAgdGhpcy5fX2N5Y2xpY09mZnNldCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBsYXN0IHNlZ21lbnQgaXMgYWJvcnRlZCB3aGVuIHRyaWdnZXJpbmcgdGhlIG5leHRcclxuICAgICAqIEBuYW1lIG1vbm9waG9uaWNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vbm9waG9uaWMgPSBvcHRPckRlZihvcHRpb25zLm1vbm9waG9uaWMsIGZhbHNlKTtcclxuICAgIHRoaXMuX19jdXJyZW50U3JjID0gbnVsbDtcclxuICAgIHRoaXMuX19jdXJyZW50RW52ID0gbnVsbDtcclxuICAgIHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lID0gMDtcclxuICAgIHRoaXMuX19jdXJyZW50R2FpbiA9IDA7XHJcbiAgICB0aGlzLl9fY3VycmVudEVuZFRpbWUgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmFkZS1vdXQgdGltZSAod2hlbiBhYm9ydGVkKVxyXG4gICAgICogQG5hbWUgYWJvcnRUaW1lXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMC4wMDVcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5hYm9ydFRpbWUgPSBvcHRPckRlZihvcHRpb25zLmFib3J0VGltZSwgMC4wMDUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9ydGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBidWZmZXIgdGhhdCBoYXMgYmVlbiBjb3BpZWQgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIGFzc3VyZSBjeWNsaWMgYmVoYXZpb3JcclxuICAgICAqIEBuYW1lIHdyYXBBcm91bmRFeHRlbnNpb25cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbiA9IG9wdE9yRGVmKG9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiwgMCk7XHJcblxyXG4gICAgdGhpcy5vdXRwdXROb2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGJ1ZmZlciBkdXJhdGlvbiAoZXhjbHVkaW5nIHdyYXBBcm91bmRFeHRlbnNpb24pXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBkZWZhdWx0IDBcclxuICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGdldCBidWZmZXJEdXJhdGlvbigpIHtcclxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xyXG4gICAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbjtcclxuXHJcbiAgICAgIGlmICh0aGlzLndyYXBBcm91bmRFeHRlbnNpb24pXHJcbiAgICAgICAgYnVmZmVyRHVyYXRpb24gLT0gdGhpcy53cmFwQXJvdW5kRXh0ZW5zaW9uO1xyXG5cclxuICAgICAgcmV0dXJuIGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHRyYW5zcG9ydGVkIGludGVyZmFjZSlcclxuICBhZHZhbmNlVGltZSh0aW1lKSB7XHJcbiAgICB0aW1lID0gTWF0aC5tYXgodGltZSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUpO1xyXG4gICAgcmV0dXJuIHRpbWUgKyB0aGlzLnRyaWdnZXIodGltZSk7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAodHJhbnNwb3J0ZWQgaW50ZXJmYWNlKVxyXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIHZhciBpbmRleCA9IHRoaXMuc2VnbWVudEluZGV4O1xyXG4gICAgdmFyIGN5Y2xpY09mZnNldCA9IDA7XHJcbiAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgIGlmICh0aGlzLmN5Y2xpYykge1xyXG4gICAgICB2YXIgY3ljbGVzID0gcG9zaXRpb24gLyBidWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgIGN5Y2xpY09mZnNldCA9IE1hdGguZmxvb3IoY3ljbGVzKSAqIGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICBwb3NpdGlvbiAtPSBjeWNsaWNPZmZzZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNwZWVkID4gMCkge1xyXG4gICAgICBpbmRleCA9IGdldEN1cnJlbnRPck5leHRJbmRleCh0aGlzLnBvc2l0aW9uQXJyYXksIHBvc2l0aW9uKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA+PSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgIGN5Y2xpY09mZnNldCArPSBidWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcclxuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChzcGVlZCA8IDApIHtcclxuICAgICAgaW5kZXggPSBnZXRDdXJyZW50T3JQcmV2aW91c0luZGV4KHRoaXMucG9zaXRpb25BcnJheSwgcG9zaXRpb24pO1xyXG5cclxuICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgIGluZGV4ID0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgY3ljbGljT2Zmc2V0IC09IGJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuY3ljbGljKVxyXG4gICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIEluZmluaXR5O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2VnbWVudEluZGV4ID0gaW5kZXg7XHJcbiAgICB0aGlzLl9fY3ljbGljT2Zmc2V0ID0gY3ljbGljT2Zmc2V0O1xyXG5cclxuICAgIHJldHVybiBjeWNsaWNPZmZzZXQgKyB0aGlzLnBvc2l0aW9uQXJyYXlbaW5kZXhdO1xyXG4gIH1cclxuXHJcbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHRyYW5zcG9ydGVkIGludGVyZmFjZSlcclxuICBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLnNlZ21lbnRJbmRleDtcclxuICAgIHZhciBjeWNsaWNPZmZzZXQgPSB0aGlzLl9fY3ljbGljT2Zmc2V0O1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aW1lKTtcclxuXHJcbiAgICBpZiAoc3BlZWQgPiAwKSB7XHJcbiAgICAgIGluZGV4Kys7XHJcblxyXG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICBjeWNsaWNPZmZzZXQgKz0gdGhpcy5idWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcclxuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5kZXgtLTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICBpbmRleCA9IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxO1xyXG4gICAgICAgIGN5Y2xpY09mZnNldCAtPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuY3ljbGljKVxyXG4gICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2VnbWVudEluZGV4ID0gaW5kZXg7XHJcbiAgICB0aGlzLl9fY3ljbGljT2Zmc2V0ID0gY3ljbGljT2Zmc2V0O1xyXG5cclxuICAgIHJldHVybiBjeWNsaWNPZmZzZXQgKyB0aGlzLnBvc2l0aW9uQXJyYXlbaW5kZXhdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlciBhIHNlZ21lbnQuXHJcbiAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIGF0IGFueSB0aW1lICh3aGV0aGVyIHRoZSBlbmdpbmUgaXMgc2NoZWR1bGVkL3RyYW5zcG9ydGVkIG9yIG5vdClcclxuICAgKiB0byBnZW5lcmF0ZSBhIHNpbmdsZSBzZWdtZW50IGFjY29yZGluZyB0byB0aGUgY3VycmVudCBzZWdtZW50IHBhcmFtZXRlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBzZWdtZW50IHN5bnRoZXNpcyBhdWRpbyB0aW1lXHJcbiAgICogQHJldHVybiB7TnVtYmVyfSBwZXJpb2QgdG8gbmV4dCBzZWdtZW50XHJcbiAgICovXHJcbiAgdHJpZ2dlcih0aW1lKSB7XHJcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XHJcbiAgICB2YXIgc2VnbWVudFRpbWUgPSAodGltZSB8fCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWUpICsgdGhpcy5kZWxheTtcclxuICAgIHZhciBzZWdtZW50UGVyaW9kID0gdGhpcy5wZXJpb2RBYnM7XHJcbiAgICB2YXIgc2VnbWVudEluZGV4ID0gdGhpcy5zZWdtZW50SW5kZXg7XHJcblxyXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XHJcbiAgICAgIHZhciBzZWdtZW50UG9zaXRpb24gPSAwLjA7XHJcbiAgICAgIHZhciBzZWdtZW50RHVyYXRpb24gPSAwLjA7XHJcbiAgICAgIHZhciBzZWdtZW50T2Zmc2V0ID0gMC4wO1xyXG4gICAgICB2YXIgcmVzYW1wbGluZ1JhdGUgPSAxLjA7XHJcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICBpZiAodGhpcy5jeWNsaWMpXHJcbiAgICAgICAgc2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4ICUgdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aDtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHNlZ21lbnRJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNlZ21lbnRJbmRleCwgdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCAtIDEpKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uQXJyYXkpXHJcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkFycmF5W3NlZ21lbnRJbmRleF0gfHwgMDtcclxuXHJcbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uQXJyYXkpXHJcbiAgICAgICAgc2VnbWVudER1cmF0aW9uID0gdGhpcy5kdXJhdGlvbkFycmF5W3NlZ21lbnRJbmRleF0gfHwgMDtcclxuXHJcbiAgICAgIGlmICh0aGlzLm9mZnNldEFycmF5KVxyXG4gICAgICAgIHNlZ21lbnRPZmZzZXQgPSB0aGlzLm9mZnNldEFycmF5W3NlZ21lbnRJbmRleF0gfHwgMDtcclxuXHJcbiAgICAgIC8vIGNhbGN1bGF0ZSByZXNhbXBsaW5nXHJcbiAgICAgIGlmICh0aGlzLnJlc2FtcGxpbmcgIT09IDAgfHwgdGhpcy5yZXNhbXBsaW5nVmFyID4gMCkge1xyXG4gICAgICAgIHZhciByYW5kb21SZXNhbXBsaW5nID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMi4wICogdGhpcy5yZXNhbXBsaW5nVmFyO1xyXG4gICAgICAgIHJlc2FtcGxpbmdSYXRlID0gTWF0aC5wb3coMi4wLCAodGhpcy5yZXNhbXBsaW5nICsgcmFuZG9tUmVzYW1wbGluZykgLyAxMjAwLjApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjYWxjdWxhdGUgaW50ZXItc2VnbWVudCBkaXN0YW5jZVxyXG4gICAgICBpZiAoc2VnbWVudER1cmF0aW9uID09PSAwIHx8IHRoaXMucGVyaW9kUmVsID4gMCkge1xyXG4gICAgICAgIHZhciBuZXh0U2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4ICsgMTtcclxuICAgICAgICB2YXIgbmV4dFBvc2l0aW9uLCBuZXh0T2Zmc2V0O1xyXG5cclxuICAgICAgICBpZiAobmV4dFNlZ21lbnRJbmRleCA9PT0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuY3ljbGljKSB7XHJcbiAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVswXSArIGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gdGhpcy5vZmZzZXRBcnJheVswXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkFycmF5W25leHRTZWdtZW50SW5kZXhdO1xyXG4gICAgICAgICAgbmV4dE9mZnNldCA9IHRoaXMub2Zmc2V0QXJyYXlbbmV4dFNlZ21lbnRJbmRleF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW50ZXJTZWdtZW50RGlzdGFuY2UgPSBuZXh0UG9zaXRpb24gLSBzZWdtZW50UG9zaXRpb247XHJcblxyXG4gICAgICAgIC8vIGNvcnJlY3QgaW50ZXItc2VnbWVudCBkaXN0YW5jZSBieSBvZmZzZXRzXHJcbiAgICAgICAgLy8gICBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICAgIGlmIChzZWdtZW50T2Zmc2V0ID4gMClcclxuICAgICAgICAgIGludGVyU2VnbWVudERpc3RhbmNlIC09IHNlZ21lbnRPZmZzZXQ7XHJcblxyXG4gICAgICAgIGlmIChuZXh0T2Zmc2V0ID4gMClcclxuICAgICAgICAgIGludGVyU2VnbWVudERpc3RhbmNlICs9IG5leHRPZmZzZXQ7XHJcblxyXG4gICAgICAgIGlmIChpbnRlclNlZ21lbnREaXN0YW5jZSA8IDApXHJcbiAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSA9IDA7XHJcblxyXG4gICAgICAgIC8vIHVzZSBpbnRlci1zZWdtZW50IGRpc3RhbmNlIGluc3RlYWQgb2Ygc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICAgIGlmIChzZWdtZW50RHVyYXRpb24gPT09IDApXHJcbiAgICAgICAgICBzZWdtZW50RHVyYXRpb24gPSBpbnRlclNlZ21lbnREaXN0YW5jZTtcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHBlcmlvZCByZWxhdGl2ZSB0byBpbnRlciBtYXJrZXIgZGlzdGFuY2VcclxuICAgICAgICBzZWdtZW50UGVyaW9kICs9IHRoaXMucGVyaW9kUmVsICogaW50ZXJTZWdtZW50RGlzdGFuY2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGFkZCByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICBzZWdtZW50RHVyYXRpb24gKj0gdGhpcy5kdXJhdGlvblJlbDtcclxuICAgICAgc2VnbWVudER1cmF0aW9uICs9IHRoaXMuZHVyYXRpb25BYnM7XHJcblxyXG4gICAgICAvLyBhZGQgcmVsYXRpdmUgYW5kIGFic29sdXRlIHNlZ21lbnQgb2Zmc2V0XHJcbiAgICAgIHNlZ21lbnRPZmZzZXQgKj0gdGhpcy5vZmZzZXRSZWw7XHJcbiAgICAgIHNlZ21lbnRPZmZzZXQgKz0gdGhpcy5vZmZzZXRBYnM7XHJcblxyXG4gICAgICAvLyBhcHBseSBzZWdtZW50IG9mZnNldFxyXG4gICAgICAvLyAgIG9mZnNldCA+IDA6IHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGlzIGFmdGVyIHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uXHJcbiAgICAgIC8vICAgb2Zmc2V0IDwgMDogdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb24gaXMgdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gYW5kIHRoZSBkdXJhdGlvbiBoYXMgdG8gYmUgY29ycmVjdGVkIGJ5IHRoZSBvZmZzZXRcclxuICAgICAgaWYgKHNlZ21lbnRPZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgc2VnbWVudER1cmF0aW9uIC09IHNlZ21lbnRPZmZzZXQ7XHJcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uICs9IHNlZ21lbnRPZmZzZXQ7XHJcbiAgICAgICAgc2VnbWVudFRpbWUgKz0gKHNlZ21lbnRPZmZzZXQgLyByZXNhbXBsaW5nUmF0ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VnbWVudFRpbWUgLT0gKHNlZ21lbnRPZmZzZXQgLyByZXNhbXBsaW5nUmF0ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJhbmRvbWl6ZSBzZWdtZW50IHBvc2l0aW9uXHJcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uVmFyID4gMClcclxuICAgICAgICBzZWdtZW50UG9zaXRpb24gKz0gMi4wICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5wb3NpdGlvblZhcjtcclxuXHJcbiAgICAgIC8vIHNob3J0ZW4gZHVyYXRpb24gb2Ygc2VnbWVudHMgb3ZlciB0aGUgZWRnZXMgb2YgdGhlIGJ1ZmZlclxyXG4gICAgICBpZiAoc2VnbWVudFBvc2l0aW9uIDwgMCkge1xyXG4gICAgICAgIC8vc2VnbWVudFRpbWUgLT0gZ3JhaW5Qb3NpdGlvbjsgaG0sIG5vdCBzdXJlIGlmIHdlIHdhbnQgdG8gZG8gdGhpc1xyXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiArPSBzZWdtZW50UG9zaXRpb247XHJcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNlZ21lbnRQb3NpdGlvbiArIHNlZ21lbnREdXJhdGlvbiA+IHRoaXMuYnVmZmVyLmR1cmF0aW9uKVxyXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uIC0gc2VnbWVudFBvc2l0aW9uO1xyXG5cclxuICAgICAgc2VnbWVudER1cmF0aW9uIC89IHJlc2FtcGxpbmdSYXRlO1xyXG5cclxuICAgICAgaWYgKHRoaXMubW9ub3Bob25pYylcclxuICAgICAgICB0aGlzLmFib3J0KHNlZ21lbnRUaW1lKTtcclxuXHJcbiAgICAgIC8vIG1ha2Ugc2VnbWVudFxyXG4gICAgICBpZiAodGhpcy5nYWluID4gMCAmJiBzZWdtZW50RHVyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgLy8gbWFrZSBzZWdtZW50IGVudmVsb3BlXHJcbiAgICAgICAgdmFyIGVudmVsb3BlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB2YXIgYXR0YWNrID0gdGhpcy5hdHRhY2tBYnMgKyB0aGlzLmF0dGFja1JlbCAqIHNlZ21lbnREdXJhdGlvbjtcclxuICAgICAgICB2YXIgcmVsZWFzZSA9IHRoaXMucmVsZWFzZUFicyArIHRoaXMucmVsZWFzZVJlbCAqIHNlZ21lbnREdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKGF0dGFjayArIHJlbGVhc2UgPiBzZWdtZW50RHVyYXRpb24pIHtcclxuICAgICAgICAgIHZhciBmYWN0b3IgPSBzZWdtZW50RHVyYXRpb24gLyAoYXR0YWNrICsgcmVsZWFzZSk7XHJcbiAgICAgICAgICBhdHRhY2sgKj0gZmFjdG9yO1xyXG4gICAgICAgICAgcmVsZWFzZSAqPSBmYWN0b3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYXR0YWNrRW5kVGltZSA9IHNlZ21lbnRUaW1lICsgYXR0YWNrO1xyXG4gICAgICAgIHZhciBzZWdtZW50RW5kVGltZSA9IHNlZ21lbnRUaW1lICsgc2VnbWVudER1cmF0aW9uO1xyXG4gICAgICAgIHZhciByZWxlYXNlU3RhcnRUaW1lID0gc2VnbWVudEVuZFRpbWUgLSByZWxlYXNlO1xyXG5cclxuICAgICAgICBlbnZlbG9wZS5nYWluLnZhbHVlID0gMDtcclxuICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKDAuMCwgc2VnbWVudFRpbWUpO1xyXG4gICAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5nYWluLCBhdHRhY2tFbmRUaW1lKTtcclxuXHJcbiAgICAgICAgaWYgKHJlbGVhc2VTdGFydFRpbWUgPiBhdHRhY2tFbmRUaW1lKVxyXG4gICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh0aGlzLmdhaW4sIHJlbGVhc2VTdGFydFRpbWUpO1xyXG5cclxuICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAuMCwgc2VnbWVudEVuZFRpbWUpO1xyXG4gICAgICAgIGVudmVsb3BlLmNvbm5lY3QodGhpcy5vdXRwdXROb2RlKTtcclxuXHJcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRFbnYgPSBlbnZlbG9wZTtcclxuXHJcbiAgICAgICAgLy8gbWFrZSBzb3VyY2VcclxuICAgICAgICB2YXIgc291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG5cclxuICAgICAgICBzb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XHJcbiAgICAgICAgc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHJlc2FtcGxpbmdSYXRlO1xyXG4gICAgICAgIHNvdXJjZS5jb25uZWN0KGVudmVsb3BlKTtcclxuXHJcbiAgICAgICAgc291cmNlLnN0YXJ0KHNlZ21lbnRUaW1lLCBzZWdtZW50UG9zaXRpb24pO1xyXG4gICAgICAgIHNvdXJjZS5zdG9wKHNlZ21lbnRUaW1lICsgc2VnbWVudER1cmF0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRTcmMgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUgPSByZWxlYXNlU3RhcnRUaW1lO1xyXG4gICAgICAgIHRoaXMuX19jdXJyZW50R2FpbiA9IHRoaXMuZ2FpbjtcclxuICAgICAgICB0aGlzLl9fY3VycmVudEVuZFRpbWUgPSBzZWdtZW50RW5kVGltZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGdyYWluIHBlcmlvZCByYW5kb24gdmFyaWF0aW9uXHJcbiAgICBpZiAodGhpcy5wZXJpb2RWYXIgPiAwLjApXHJcbiAgICAgIHNlZ21lbnRQZXJpb2QgKz0gMi4wICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5wZXJpb2RWYXIgKiBncmFpblBlcmlvZDtcclxuXHJcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5wZXJpb2RNaW4sIHNlZ21lbnRQZXJpb2QpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWJvcnQgdGhlIGN1cnJlbnQgc2VnbWVudCBhdCBnaXZlbiB0aW1lLCBmYWRlIG91dCBkdXJhdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBhYm9ydCB0aW1lXHJcbiAgICovXHJcbiAgYWJvcnQodGltZSkge1xyXG4gICAgY29uc3QgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XHJcbiAgICBjb25zdCBlbmRUaW1lID0gdGhpcy5fX2N1cnJlbnRFbmRUaW1lO1xyXG4gICAgY29uc3QgYWJvcnRUaW1lID0gdGltZSB8fCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XHJcblxyXG4gICAgaWYgKGFib3J0VGltZSA8IGVuZFRpbWUpIHtcclxuICAgICAgY29uc3Qgc2VnbWVudEVuZFRpbWUgPSBNYXRoLm1pbihhYm9ydFRpbWUgKyB0aGlzLmFib3J0VGltZSwgZW5kVGltZSk7XHJcbiAgICAgIGNvbnN0IGVudmVsb3BlID0gdGhpcy5fX2N1cnJlbnRFbnY7XHJcbiAgICAgIGxldCBjdXJyZW50R2FpblZhbHVlID0gdGhpcy5fX2N1cnJlbnRHYWluO1xyXG5cclxuICAgICAgaWYgKGFib3J0VGltZSA+IHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lKSB7XHJcbiAgICAgICAgY29uc3QgcmVsZWFzZVN0YXJ0ID0gdGhpcy5fX3JlbGVhc2VTdGFydFRpbWU7XHJcbiAgICAgICAgY3VycmVudEdhaW5WYWx1ZSAqPSAoYWJvcnRUaW1lIC0gcmVsZWFzZVN0YXJ0KSAvIChlbmRUaW1lIC0gcmVsZWFzZVN0YXJ0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZW52ZWxvcGUuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXMoYWJvcnRUaW1lKTtcclxuICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZShjdXJyZW50R2FpblZhbHVlLCBhYm9ydFRpbWUpO1xyXG4gICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHNlZ21lbnRFbmRUaW1lKTtcclxuXHJcbiAgICAgIHRoaXMuX19jdXJyZW50U3JjID0gbnVsbDtcclxuICAgICAgdGhpcy5fX2N1cnJlbnRFbnYgPSBudWxsO1xyXG4gICAgICB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZSA9IDA7XHJcbiAgICAgIHRoaXMuX19jdXJyZW50R2FpbiA9IDA7XHJcbiAgICAgIHRoaXMuX19jdXJyZW50RW5kVGltZSA9IDA7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTZWdtZW50RW5naW5lO1xyXG4iLCJpbXBvcnQgQXVkaW9UaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvYXVkaW8tdGltZS1lbmdpbmUnO1xyXG5pbXBvcnQgU2VnbWVudEVuZ2luZSBmcm9tICcuL3NlZ21lbnQtZW5naW5lJztcclxuXHJcbmZ1bmN0aW9uIG9wdE9yRGVmKG9wdCwgZGVmKSB7XHJcbiAgICBpZiAob3B0ICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgcmV0dXJuIG9wdDtcclxuXHJcbiAgICByZXR1cm4gZGVmO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDdXJyZW50T3JQcmV2aW91c0luZGV4KHNvcnRlZEFycmF5LCB2YWx1ZSwgaW5kZXggPSAtMSkge1xyXG4gICAgdmFyIHNpemUgPSBzb3J0ZWRBcnJheS5sZW5ndGg7XHJcblxyXG4gICAgaWYgKHNpemUgPiAwKSB7XHJcbiAgICAgICAgdmFyIGZpcnN0VmFsID0gc29ydGVkQXJyYXlbMF07XHJcbiAgICAgICAgdmFyIGxhc3RWYWwgPSBzb3J0ZWRBcnJheVtzaXplIC0gMV07XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSA8IGZpcnN0VmFsKVxyXG4gICAgICAgICAgICBpbmRleCA9IC0xO1xyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID49IGxhc3RWYWwpXHJcbiAgICAgICAgICAgIGluZGV4ID0gc2l6ZSAtIDE7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2l6ZSlcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoc2l6ZSAtIDEpICogKHZhbHVlIC0gZmlyc3RWYWwpIC8gKGxhc3RWYWwgLSBmaXJzdFZhbCkpO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4XSA+IHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgaW5kZXgtLTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleCArIDFdIDw9IHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDdXJyZW50T3JOZXh0SW5kZXgoc29ydGVkQXJyYXksIHZhbHVlLCBpbmRleCA9IC0xKSB7XHJcbiAgICB2YXIgc2l6ZSA9IHNvcnRlZEFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICBpZiAoc2l6ZSA+IDApIHtcclxuICAgICAgICB2YXIgZmlyc3RWYWwgPSBzb3J0ZWRBcnJheVswXTtcclxuICAgICAgICB2YXIgbGFzdFZhbCA9IHNvcnRlZEFycmF5W3NpemUgLSAxXTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlIDw9IGZpcnN0VmFsKVxyXG4gICAgICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPj0gbGFzdFZhbClcclxuICAgICAgICAgICAgaW5kZXggPSBzaXplO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNpemUpXHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoKHNpemUgLSAxKSAqICh2YWx1ZSAtIGZpcnN0VmFsKSAvIChsYXN0VmFsIC0gZmlyc3RWYWwpKTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleF0gPCB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXggLSAxXSA+PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIGluZGV4LS07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbmRleDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBTZXF1ZW5jZXJFbmdpbmVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlcXVlbmNlckVuZ2luZSBleHRlbmRzIFNlZ21lbnRFbmdpbmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IGJ1ZmZlciBpbml0aWFsIGF1ZGlvIGJ1ZmZlciBmb3IgZ3JhbnVsYXIgc3ludGhlc2lzXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGVuZ2luZSBpbXBsZW1lbnRzIHRoZSBcInNjaGVkdWxlZFwiIGFuZCBcInRyYW5zcG9ydGVkXCIgaW50ZXJmYWNlcy5cclxuICAgICAqIFdoZW4gXCJzY2hlZHVsZWRcIiwgdGhlIGVuZ2luZSAgZ2VuZXJhdGVzIHNlZ21lbnRzIG1vcmUgb3IgbGVzc8KgcGVyaW9kaWNhbGx5XHJcbiAgICAgKiAoY29udHJvbGxlZCBieSB0aGUgcGVyaW9kQWJzLCBwZXJpb2RSZWwsIGFuZCBwZXJpb1ZhciBhdHRyaWJ1dGVzKS5cclxuICAgICAqIFdoZW4gXCJ0cmFuc3BvcnRlZFwiLCB0aGUgZW5naW5lIGdlbmVyYXRlcyBzZWdtZW50cyBhdCB0aGUgcG9zaXRpb24gb2YgdGhlaXIgb25zZXQgdGltZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmdW5jdGlvbiBjYWxsYmFjayB0aGF0IGdldHMgY2FsbGVkIGZyb20gdHJpZ2dlcigpLlxyXG4gICAgICAgICAqIFRoaXMgbGV0cyB5b3Ugc2V0IHVwIGV2ZW50cyB0byBiZSB0cmlnZ2VyZWQgYnkgdGhlIHNlcXVlbmNlci5cclxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IG9wdE9yRGVmKG9wdGlvbnMuY2FsbGJhY2ssIG51bGwpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXIgYSBzZWdtZW50XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBzZWdtZW50IHN5bnRoZXNpcyBhdWRpbyB0aW1lXHJcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHBlcmlvZCB0byBuZXh0IHNlZ21lbnRcclxuICAgICAqXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgYXQgYW55IHRpbWUgKHdoZXRoZXIgdGhlIGVuZ2luZSBpcyBzY2hlZHVsZWQvdHJhbnNwb3J0ZWQgb3Igbm90KVxyXG4gICAgICogdG8gZ2VuZXJhdGUgYSBzaW5nbGUgc2VnbWVudCBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc2VnbWVudCBwYXJhbWV0ZXJzLlxyXG4gICAgICovXHJcbiAgICB0cmlnZ2VyKHRpbWUpIHtcclxuICAgICAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XHJcbiAgICAgICAgdmFyIHNlZ21lbnRUaW1lID0gKHRpbWUgfHwgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKSArIHRoaXMuZGVsYXk7XHJcbiAgICAgICAgdmFyIHNlZ21lbnRQZXJpb2QgPSB0aGlzLnBlcmlvZEFicztcclxuICAgICAgICB2YXIgc2VnbWVudEluZGV4ID0gdGhpcy5zZWdtZW50SW5kZXg7XHJcblxyXG4gICAgICAgIC8vIElnbm9yZSBidWZmZXIgZm9yIG5vdywgdGhpcyBpcyBhIHNlcXVuY2VyLi4uIG5vIGF1ZGlvIHByb2R1Y2VkLlxyXG4gICAgICAgIGlmICggLyp0aGlzLmJ1ZmZlciovIHRydWUpIHtcclxuICAgICAgICAgICAgdmFyIHNlZ21lbnRQb3NpdGlvbiA9IDAuMDtcclxuICAgICAgICAgICAgdmFyIHNlZ21lbnREdXJhdGlvbiA9IDAuMDtcclxuICAgICAgICAgICAgdmFyIHNlZ21lbnRPZmZzZXQgPSAwLjA7XHJcbiAgICAgICAgICAgIHZhciByZXNhbXBsaW5nUmF0ZSA9IDEuMDtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN5Y2xpYylcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleCAlIHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNlZ21lbnRJbmRleCwgdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCAtIDEpKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uQXJyYXkpXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uQXJyYXlbc2VnbWVudEluZGV4XSB8fCAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuZHVyYXRpb25BcnJheSlcclxuICAgICAgICAgICAgICAgIHNlZ21lbnREdXJhdGlvbiA9IHRoaXMuZHVyYXRpb25BcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5vZmZzZXRBcnJheSlcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRPZmZzZXQgPSB0aGlzLm9mZnNldEFycmF5W3NlZ21lbnRJbmRleF0gfHwgMDtcclxuXHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZXNhbXBsaW5nXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc2FtcGxpbmcgIT09IDAgfHwgdGhpcy5yZXNhbXBsaW5nVmFyID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhbmRvbVJlc2FtcGxpbmcgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLjAgKiB0aGlzLnJlc2FtcGxpbmdWYXI7XHJcbiAgICAgICAgICAgICAgICByZXNhbXBsaW5nUmF0ZSA9IE1hdGgucG93KDIuMCwgKHRoaXMucmVzYW1wbGluZyArIHJhbmRvbVJlc2FtcGxpbmcpIC8gMTIwMC4wKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICAgICAgICAgICAgaWYgKHNlZ21lbnREdXJhdGlvbiA9PT0gMCB8fCB0aGlzLnBlcmlvZFJlbCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0U2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4ICsgMTtcclxuICAgICAgICAgICAgICAgIHZhciBuZXh0UG9zaXRpb24sIG5leHRPZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRTZWdtZW50SW5kZXggPT09IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jeWNsaWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkFycmF5WzBdICsgYnVmZmVyRHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRPZmZzZXQgPSB0aGlzLm9mZnNldEFycmF5WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0T2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVtuZXh0U2VnbWVudEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0T2Zmc2V0ID0gdGhpcy5vZmZzZXRBcnJheVtuZXh0U2VnbWVudEluZGV4XTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJTZWdtZW50RGlzdGFuY2UgPSBuZXh0UG9zaXRpb24gLSBzZWdtZW50UG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY29ycmVjdCBpbnRlci1zZWdtZW50IGRpc3RhbmNlIGJ5IG9mZnNldHNcclxuICAgICAgICAgICAgICAgIC8vICAgb2Zmc2V0ID4gMDogdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gaXMgYWZ0ZXIgdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50T2Zmc2V0ID4gMClcclxuICAgICAgICAgICAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSAtPSBzZWdtZW50T2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChuZXh0T2Zmc2V0ID4gMClcclxuICAgICAgICAgICAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSArPSBuZXh0T2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbnRlclNlZ21lbnREaXN0YW5jZSA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJTZWdtZW50RGlzdGFuY2UgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHVzZSBpbnRlci1zZWdtZW50IGRpc3RhbmNlIGluc3RlYWQgb2Ygc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnREdXJhdGlvbiA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50RHVyYXRpb24gPSBpbnRlclNlZ21lbnREaXN0YW5jZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgcGVyaW9kIHJlbGF0aXZlIHRvIGludGVyIG1hcmtlciBkaXN0YW5jZVxyXG4gICAgICAgICAgICAgICAgc2VnbWVudFBlcmlvZCArPSB0aGlzLnBlcmlvZFJlbCAqIGludGVyU2VnbWVudERpc3RhbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIC8vIGFkZCByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICAgICAgICBzZWdtZW50RHVyYXRpb24gKj0gdGhpcy5kdXJhdGlvblJlbDtcclxuICAgICAgICAgICAgc2VnbWVudER1cmF0aW9uICs9IHRoaXMuZHVyYXRpb25BYnM7XHJcblxyXG4gICAgICAgICAgICAvLyBhZGQgcmVsYXRpdmUgYW5kIGFic29sdXRlIHNlZ21lbnQgb2Zmc2V0XHJcbiAgICAgICAgICAgIHNlZ21lbnRPZmZzZXQgKj0gdGhpcy5vZmZzZXRSZWw7XHJcbiAgICAgICAgICAgIHNlZ21lbnRPZmZzZXQgKz0gdGhpcy5vZmZzZXRBYnM7XHJcblxyXG4gICAgICAgICAgICAvLyBhcHBseSBzZWdtZW50IG9mZnNldFxyXG4gICAgICAgICAgICAvLyAgIG9mZnNldCA+IDA6IHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGlzIGFmdGVyIHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIC8vICAgb2Zmc2V0IDwgMDogdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb24gaXMgdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gYW5kIHRoZSBkdXJhdGlvbiBoYXMgdG8gYmUgY29ycmVjdGVkIGJ5IHRoZSBvZmZzZXRcclxuICAgICAgICAgICAgaWYgKHNlZ21lbnRPZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50RHVyYXRpb24gLT0gc2VnbWVudE9mZnNldDtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRQb3NpdGlvbiArPSBzZWdtZW50T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudFRpbWUgKz0gKHNlZ21lbnRPZmZzZXQgLyByZXNhbXBsaW5nUmF0ZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50VGltZSAtPSAoc2VnbWVudE9mZnNldCAvIHJlc2FtcGxpbmdSYXRlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gcmFuZG9taXplIHNlZ21lbnQgcG9zaXRpb25cclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb25WYXIgPiAwKVxyXG4gICAgICAgICAgICAgICAgc2VnbWVudFBvc2l0aW9uICs9IDIuMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRoaXMucG9zaXRpb25WYXI7XHJcblxyXG4gICAgICAgICAgICAvLyBzaG9ydGVuIGR1cmF0aW9uIG9mIHNlZ21lbnRzIG92ZXIgdGhlIGVkZ2VzIG9mIHRoZSBidWZmZXJcclxuICAgICAgICAgICAgaWYgKHNlZ21lbnRQb3NpdGlvbiA8IDApIHtcclxuICAgICAgICAgICAgICAgIC8vc2VnbWVudFRpbWUgLT0gZ3JhaW5Qb3NpdGlvbjsgaG0sIG5vdCBzdXJlIGlmIHdlIHdhbnQgdG8gZG8gdGhpc1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudER1cmF0aW9uICs9IHNlZ21lbnRQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRQb3NpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50UG9zaXRpb24gKyBzZWdtZW50RHVyYXRpb24gPiB0aGlzLmJ1ZmZlci5kdXJhdGlvbilcclxuICAgICAgICAgICAgICAgIHNlZ21lbnREdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uIC0gc2VnbWVudFBvc2l0aW9uO1xyXG5cclxuICAgICAgICAgICAgc2VnbWVudER1cmF0aW9uIC89IHJlc2FtcGxpbmdSYXRlO1xyXG5cclxuICAgICAgICAgICAgLy8gbWFrZSBzZWdtZW50XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdhaW4gPiAwICYmIHNlZ21lbnREdXJhdGlvbiA+IDApIHtcclxuICAgICAgICAgICAgICAvLyBtYWtlIHNlZ21lbnQgZW52ZWxvcGVcclxuICAgICAgICAgICAgICB2YXIgZW52ZWxvcGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgICAgICAgIHZhciBhdHRhY2sgPSB0aGlzLmF0dGFja0FicyArIHRoaXMuYXR0YWNrUmVsICogc2VnbWVudER1cmF0aW9uO1xyXG4gICAgICAgICAgICAgIHZhciByZWxlYXNlID0gdGhpcy5yZWxlYXNlQWJzICsgdGhpcy5yZWxlYXNlUmVsICogc2VnbWVudER1cmF0aW9uO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoYXR0YWNrICsgcmVsZWFzZSA+IHNlZ21lbnREdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IHNlZ21lbnREdXJhdGlvbiAvIChhdHRhY2sgKyByZWxlYXNlKTtcclxuICAgICAgICAgICAgICAgIGF0dGFjayAqPSBmYWN0b3I7XHJcbiAgICAgICAgICAgICAgICByZWxlYXNlICo9IGZhY3RvcjtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIHZhciBhdHRhY2tFbmRUaW1lID0gc2VnbWVudFRpbWUgKyBhdHRhY2s7XHJcbiAgICAgICAgICAgICAgdmFyIHNlZ21lbnRFbmRUaW1lID0gc2VnbWVudFRpbWUgKyBzZWdtZW50RHVyYXRpb247XHJcbiAgICAgICAgICAgICAgdmFyIHJlbGVhc2VTdGFydFRpbWUgPSBzZWdtZW50RW5kVGltZSAtIHJlbGVhc2U7XHJcblxyXG4gICAgICAgICAgICAgIGVudmVsb3BlLmdhaW4udmFsdWUgPSAwO1xyXG4gICAgICAgICAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMC4wLCBzZWdtZW50VGltZSk7XHJcbiAgICAgICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLmdhaW4sIGF0dGFja0VuZFRpbWUpO1xyXG5cclxuICAgICAgICAgICAgICBpZiAocmVsZWFzZVN0YXJ0VGltZSA+IGF0dGFja0VuZFRpbWUpXHJcbiAgICAgICAgICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgcmVsZWFzZVN0YXJ0VGltZSk7XHJcblxyXG4gICAgICAgICAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMC4wLCBzZWdtZW50RW5kVGltZSk7XHJcbiAgICAgICAgICAgICAgZW52ZWxvcGUuY29ubmVjdCh0aGlzLm91dHB1dE5vZGUpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBtYWtlIHNvdXJjZVxyXG4gICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcblxyXG4gICAgICAgICAgICAgIHNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICAgICAgICBzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmVzYW1wbGluZ1JhdGU7XHJcbiAgICAgICAgICAgICAgc291cmNlLmNvbm5lY3QoZW52ZWxvcGUpO1xyXG5cclxuICAgICAgICAgICAgICBzb3VyY2Uuc3RhcnQoc2VnbWVudFRpbWUsIHNlZ21lbnRQb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgc291cmNlLnN0b3Aoc2VnbWVudFRpbWUgKyBzZWdtZW50RHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9Ki9cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBpZiAodGhpcy5jYWxsYmFjayAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcy5jYWxsYmFjaykgPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYWxsYmFjayhzZWdtZW50SW5kZXgpO1xyXG4gICAgICAgICAgICAvL2lmIChyZXN1bHQpXHJcbiAgICAgICAgICAgIC8vICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiU2VxdWVuY2VyLlRyaWdnZXI6IFwiICsgc2VnbWVudEluZGV4ICsgXCIgUG9zaXRpb246IFwiICsgc2VnbWVudFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgLy8gZ3JhaW4gcGVyaW9kIHJhbmRvbiB2YXJpYXRpb25cclxuICAgICAgICBpZiAodGhpcy5wZXJpb2RWYXIgPiAwLjApXHJcbiAgICAgICAgICAgIHNlZ21lbnRQZXJpb2QgKz0gMi4wICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5wZXJpb2RWYXIgKiBncmFpblBlcmlvZDtcclxuXHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucGVyaW9kTWluLCBzZWdtZW50UGVyaW9kKTtcclxuICAgIH1cclxufSIsIi8vIGNvcmVcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBhdWRpb0NvbnRleHQgfSBmcm9tICcuL2NvcmUvYXVkaW8tY29udGV4dCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVGltZUVuZ2luZSB9IGZyb20gJy4vY29yZS90aW1lLWVuZ2luZSc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQXVkaW9UaW1lRW5naW5lIH0gZnJvbSAnLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBQcmlvcml0eVF1ZXVlIH0gZnJvbSAnLi9jb3JlL3ByaW9yaXR5LXF1ZXVlJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTY2hlZHVsaW5nUXVldWUgfSBmcm9tICcuL2NvcmUvc2NoZWR1bGluZy1xdWV1ZSc7XHJcblxyXG4vLyBlbmdpbmVzXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR3JhbnVsYXJFbmdpbmUgfSBmcm9tICcuL2VuZ2luZXMvZ3JhbnVsYXItZW5naW5lJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBNZXRyb25vbWUgfSBmcm9tICcuL2VuZ2luZXMvbWV0cm9ub21lJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBQbGF5ZXJFbmdpbmUgfSBmcm9tICcuL2VuZ2luZXMvcGxheWVyLWVuZ2luZSc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VnbWVudEVuZ2luZSB9IGZyb20gJy4vZW5naW5lcy9zZWdtZW50LWVuZ2luZSc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VxdWVuY2VyRW5naW5lIH0gZnJvbSAnLi9lbmdpbmVzL3NlcXVlbmNlci1lbmdpbmUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBoYXNldm9jb2RlckVuZ2luZSB9IGZyb20gJy4vZW5naW5lcy9waGFzZXZvY29kZXItZW5naW5lJztcclxuXHJcbi8vIG1hc3RlcnNcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBQbGF5Q29udHJvbCB9IGZyb20gJy4vbWFzdGVycy9wbGF5LWNvbnRyb2wnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRyYW5zcG9ydCB9IGZyb20gJy4vbWFzdGVycy90cmFuc3BvcnQnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNjaGVkdWxlciB9IGZyb20gJy4vbWFzdGVycy9zY2hlZHVsZXInO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNpbXBsZVNjaGVkdWxlciB9IGZyb20gJy4vbWFzdGVycy9zaW1wbGUtc2NoZWR1bGVyJztcclxuXHJcbi8vIGZhY3Rvcmllc1xyXG5leHBvcnQgeyBnZXRTY2hlZHVsZXIgfSBmcm9tICcuL21hc3RlcnMvZmFjdG9yaWVzJztcclxuZXhwb3J0IHsgZ2V0U2ltcGxlU2NoZWR1bGVyIH0gZnJvbSAnLi9tYXN0ZXJzL2ZhY3Rvcmllcyc7XHJcbiIsIi8vIHNjaGVkdWxlcnMgc2hvdWxkIGJlIHNpbmdsZXRvbnNcclxuaW1wb3J0IGRlZmF1bHRBdWRpb0NvbnRleHQgZnJvbSAnLi4vY29yZS9hdWRpby1jb250ZXh0JztcclxuaW1wb3J0IFNjaGVkdWxlciBmcm9tICcuL3NjaGVkdWxlcic7XHJcbmltcG9ydCBTaW1wbGVTY2hlZHVsZXIgZnJvbSAnLi9zaW1wbGUtc2NoZWR1bGVyJztcclxuXHJcbmNvbnN0IHNjaGVkdWxlck1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmNvbnN0IHNpbXBsZVNjaGVkdWxlck1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHVuaXF1ZSBpbnN0YW5jZSBvZiBgU2NoZWR1bGVyYFxyXG4gKlxyXG4gKiBAZ2xvYmFsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7U2NoZWR1bGVyfVxyXG4gKiBAc2VlIFNjaGVkdWxlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFNjaGVkdWxlciA9IGZ1bmN0aW9uKGF1ZGlvQ29udGV4dCA9IGRlZmF1bHRBdWRpb0NvbnRleHQpIHtcclxuICBsZXQgc2NoZWR1bGVyID0gc2NoZWR1bGVyTWFwLmdldChhdWRpb0NvbnRleHQpO1xyXG5cclxuICBpZiAoIXNjaGVkdWxlcikge1xyXG4gICAgc2NoZWR1bGVyID0gbmV3IFNjaGVkdWxlcih7IGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0IH0pO1xyXG4gICAgc2NoZWR1bGVyTWFwLnNldChhdWRpb0NvbnRleHQsIHNjaGVkdWxlcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc2NoZWR1bGVyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSB1bmlxdWUgaW5zdGFuY2Ugb2YgYFNpbXBsZVNjaGVkdWxlcmBcclxuICpcclxuICogQGdsb2JhbFxyXG4gKiBAZnVuY3Rpb25cclxuICogQHJldHVybnMge1NpbXBsZVNjaGVkdWxlcn1cclxuICogQHNlZSBTaW1wbGVTY2hlZHVsZXJcclxuICovXHJcbmV4cG9ydCBjb25zdCBnZXRTaW1wbGVTY2hlZHVsZXIgPSBmdW5jdGlvbihhdWRpb0NvbnRleHQgPSBkZWZhdWx0QXVkaW9Db250ZXh0KSB7XHJcbiAgbGV0IHNpbXBsZVNjaGVkdWxlciA9IHNpbXBsZVNjaGVkdWxlck1hcC5nZXQoYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgaWYgKCFzaW1wbGVTY2hlZHVsZXIpIHtcclxuICAgIHNpbXBsZVNjaGVkdWxlciA9IG5ldyBTaW1wbGVTY2hlZHVsZXIoeyBhdWRpb0NvbnRleHQ6IGF1ZGlvQ29udGV4dCB9KTtcclxuICAgIHNpbXBsZVNjaGVkdWxlck1hcC5zZXQoYXVkaW9Db250ZXh0LCBzaW1wbGVTY2hlZHVsZXIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHNpbXBsZVNjaGVkdWxlcjtcclxufTtcclxuIiwiaW1wb3J0IGRlZmF1bHRBdWRpb0NvbnRleHQgZnJvbSAnLi4vY29yZS9hdWRpby1jb250ZXh0JztcclxuaW1wb3J0IFNjaGVkdWxpbmdRdWV1ZSBmcm9tICcuLi9jb3JlL3NjaGVkdWxpbmctcXVldWUnO1xyXG5pbXBvcnQgVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL3RpbWUtZW5naW5lJztcclxuaW1wb3J0IHsgZ2V0U2NoZWR1bGVyIH0gZnJvbSAnLi9mYWN0b3JpZXMnO1xyXG5cclxuY29uc3QgRVBTSUxPTiA9IDFlLTg7XHJcblxyXG5jbGFzcyBMb29wQ29udHJvbCBleHRlbmRzIFRpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKHBsYXlDb250cm9sKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IHBsYXlDb250cm9sO1xyXG4gICAgdGhpcy5zcGVlZCA9IDE7XHJcbiAgICB0aGlzLmxvd2VyID0gLUluZmluaXR5O1xyXG4gICAgdGhpcy51cHBlciA9IEluZmluaXR5O1xyXG4gIH1cclxuXHJcbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHNjaGVkdWxlZCBpbnRlcmZhY2UpXHJcbiAgYWR2YW5jZVRpbWUodGltZSkge1xyXG4gICAgY29uc3QgcGxheUNvbnRyb2wgPSB0aGlzLl9fcGxheUNvbnRyb2w7XHJcbiAgICBjb25zdCBzcGVlZCA9IHRoaXMuc3BlZWQ7XHJcbiAgICBjb25zdCBsb3dlciA9IHRoaXMubG93ZXI7XHJcbiAgICBjb25zdCB1cHBlciA9IHRoaXMudXBwZXI7XHJcblxyXG4gICAgaWYgKHNwZWVkID4gMClcclxuICAgICAgdGltZSArPSBFUFNJTE9OO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aW1lIC09IEVQU0lMT047XHJcblxyXG4gICAgaWYgKHNwZWVkID4gMCkge1xyXG4gICAgICBwbGF5Q29udHJvbC5zeW5jU3BlZWQodGltZSwgbG93ZXIsIHNwZWVkLCB0cnVlKTtcclxuICAgICAgcmV0dXJuIHBsYXlDb250cm9sLl9fZ2V0VGltZUF0UG9zaXRpb24odXBwZXIpIC0gRVBTSUxPTjtcclxuICAgIH0gZWxzZSBpZiAoc3BlZWQgPCAwKSB7XHJcbiAgICAgIHBsYXlDb250cm9sLnN5bmNTcGVlZCh0aW1lLCB1cHBlciwgc3BlZWQsIHRydWUpO1xyXG4gICAgICByZXR1cm4gcGxheUNvbnRyb2wuX19nZXRUaW1lQXRQb3NpdGlvbihsb3dlcikgKyBFUFNJTE9OO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBJbmZpbml0eTtcclxuICB9XHJcblxyXG4gIHJlc2NoZWR1bGUoc3BlZWQpIHtcclxuICAgIGNvbnN0IHBsYXlDb250cm9sID0gdGhpcy5fX3BsYXlDb250cm9sO1xyXG4gICAgY29uc3QgbG93ZXIgPSBNYXRoLm1pbihwbGF5Q29udHJvbC5fX2xvb3BTdGFydCwgcGxheUNvbnRyb2wuX19sb29wRW5kKTtcclxuICAgIGNvbnN0IHVwcGVyID0gTWF0aC5tYXgocGxheUNvbnRyb2wuX19sb29wU3RhcnQsIHBsYXlDb250cm9sLl9fbG9vcEVuZCk7XHJcblxyXG4gICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xyXG4gICAgdGhpcy5sb3dlciA9IGxvd2VyO1xyXG4gICAgdGhpcy51cHBlciA9IHVwcGVyO1xyXG5cclxuICAgIGlmIChsb3dlciA9PT0gdXBwZXIpXHJcbiAgICAgIHNwZWVkID0gMDtcclxuXHJcbiAgICBpZiAoc3BlZWQgPiAwKVxyXG4gICAgICB0aGlzLnJlc2V0VGltZShwbGF5Q29udHJvbC5fX2dldFRpbWVBdFBvc2l0aW9uKHVwcGVyKSAtIEVQU0lMT04pO1xyXG4gICAgZWxzZSBpZiAoc3BlZWQgPCAwKVxyXG4gICAgICB0aGlzLnJlc2V0VGltZShwbGF5Q29udHJvbC5fX2dldFRpbWVBdFBvc2l0aW9uKGxvd2VyKSArIEVQU0lMT04pO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLnJlc2V0VGltZShJbmZpbml0eSk7XHJcbiAgfVxyXG5cclxuICBhcHBseUxvb3BCb3VuZGFyaWVzKHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgY29uc3QgbG93ZXIgPSB0aGlzLmxvd2VyO1xyXG4gICAgY29uc3QgdXBwZXIgPSB0aGlzLnVwcGVyO1xyXG5cclxuICAgIGlmIChzcGVlZCA+IDAgJiYgcG9zaXRpb24gPj0gdXBwZXIpXHJcbiAgICAgIHJldHVybiBsb3dlciArIChwb3NpdGlvbiAtIGxvd2VyKSAlICh1cHBlciAtIGxvd2VyKTtcclxuICAgIGVsc2UgaWYgKHNwZWVkIDwgMCAmJiBwb3NpdGlvbiA8IGxvd2VyKVxyXG4gICAgICByZXR1cm4gdXBwZXIgLSAodXBwZXIgLSBwb3NpdGlvbikgJSAodXBwZXIgLSBsb3dlcik7XHJcblxyXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xyXG4gIH1cclxufVxyXG5cclxuLy8gcGxheSBjb250cm9sbGVkIGJhc2UgY2xhc3NcclxuY2xhc3MgUGxheUNvbnRyb2xsZWQge1xyXG4gIGNvbnN0cnVjdG9yKHBsYXlDb250cm9sLCBlbmdpbmUpIHtcclxuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IHBsYXlDb250cm9sO1xyXG5cclxuICAgIGVuZ2luZS5tYXN0ZXIgPSB0aGlzO1xyXG4gICAgdGhpcy5fX2VuZ2luZSA9IGVuZ2luZTtcclxuICB9XHJcblxyXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsIHNlZWssIGxhc3RTcGVlZCkge1xyXG4gICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrKTtcclxuICB9XHJcblxyXG4gIGdldCBjdXJyZW50VGltZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcGxheUNvbnRyb2wuY3VycmVudFRpbWU7XHJcbiAgfVxyXG5cclxuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19wbGF5Q29udHJvbC5jdXJyZW50UG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5fX3BsYXlDb250cm9sID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9fZW5naW5lLm1hc3RlciA9IG51bGw7XHJcbiAgICB0aGlzLl9fZW5naW5lID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vIHBsYXkgY29udHJvbCBmb3IgZW5naW5lcyBpbXBsZW1lbnRpbmcgdGhlICpzcGVlZC1jb250cm9sbGVkKiBpbnRlcmZhY2VcclxuY2xhc3MgUGxheUNvbnRyb2xsZWRTcGVlZENvbnRyb2xsZWQgZXh0ZW5kcyBQbGF5Q29udHJvbGxlZCB7XHJcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xyXG4gICAgc3VwZXIocGxheUNvbnRyb2wsIGVuZ2luZSk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBwbGF5IGNvbnRyb2wgZm9yIGVuZ2luZXMgaW1wbG1lbnRpbmcgdGhlICp0cmFuc3BvcnRlZCogaW50ZXJmYWNlXHJcbmNsYXNzIFBsYXlDb250cm9sbGVkVHJhbnNwb3J0ZWQgZXh0ZW5kcyBQbGF5Q29udHJvbGxlZCB7XHJcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xyXG4gICAgc3VwZXIocGxheUNvbnRyb2wsIGVuZ2luZSk7XHJcblxyXG4gICAgdGhpcy5fX3NjaGVkdWxlckhvb2sgPSBuZXcgUGxheUNvbnRyb2xsZWRTY2hlZHVsZXJIb29rKHBsYXlDb250cm9sLCBlbmdpbmUpO1xyXG4gIH1cclxuXHJcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlaywgbGFzdFNwZWVkKSB7XHJcbiAgICBpZiAoc3BlZWQgIT09IGxhc3RTcGVlZCB8fCAoc2VlayAmJiBzcGVlZCAhPT0gMCkpIHtcclxuICAgICAgdmFyIG5leHRQb3NpdGlvbjtcclxuXHJcbiAgICAgIC8vIHJlc3luYyB0cmFuc3BvcnRlZCBlbmdpbmVzXHJcbiAgICAgIGlmIChzZWVrIHx8IHNwZWVkICogbGFzdFNwZWVkIDwgMCkge1xyXG4gICAgICAgIC8vIHNlZWsgb3IgcmV2ZXJzZSBkaXJlY3Rpb25cclxuICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fZW5naW5lLnN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKGxhc3RTcGVlZCA9PT0gMCkge1xyXG4gICAgICAgIC8vIHN0YXJ0XHJcbiAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5fX2VuZ2luZS5zeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICAgICAgfSBlbHNlIGlmIChzcGVlZCA9PT0gMCkge1xyXG4gICAgICAgIC8vIHN0b3BcclxuICAgICAgICBuZXh0UG9zaXRpb24gPSBJbmZpbml0eTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKVxyXG4gICAgICAgICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIDApO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKSB7XHJcbiAgICAgICAgLy8gY2hhbmdlIHNwZWVkIHdpdGhvdXQgcmV2ZXJzaW5nIGRpcmVjdGlvblxyXG4gICAgICAgIHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuX19zY2hlZHVsZXJIb29rLnJlc2V0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJlc2V0RW5naW5lUG9zaXRpb24oZW5naW5lLCBwb3NpdGlvbiA9IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFyIHBsYXlDb250cm9sID0gdGhpcy5fX3BsYXlDb250cm9sO1xyXG4gICAgICB2YXIgdGltZSA9IHBsYXlDb250cm9sLl9fc3luYygpO1xyXG5cclxuICAgICAgcG9zaXRpb24gPSB0aGlzLl9fZW5naW5lLnN5bmNQb3NpdGlvbih0aW1lLCBwbGF5Q29udHJvbC5fX3Bvc2l0aW9uLCBwbGF5Q29udHJvbC5fX3NwZWVkKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9fc2NoZWR1bGVySG9vay5yZXNldFBvc2l0aW9uKHBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9fc2NoZWR1bGVySG9vay5kZXN0cm95KCk7XHJcbiAgICB0aGlzLl9fc2NoZWR1bGVySG9vayA9IG51bGw7XHJcblxyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gcGxheSBjb250cm9sIGZvciB0aW1lIGVuZ2luZXMgaW1wbGVtZW50aW5nIHRoZSAqc2NoZWR1bGVkKiBpbnRlcmZhY2VcclxuY2xhc3MgUGxheUNvbnRyb2xsZWRTY2hlZHVsZWQgZXh0ZW5kcyBQbGF5Q29udHJvbGxlZCB7XHJcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xyXG4gICAgc3VwZXIocGxheUNvbnRyb2wsIGVuZ2luZSk7XHJcblxyXG4gICAgLy8gc2NoZWR1bGluZyBxdWV1ZSBiZWNvbWVzIG1hc3RlciBvZiBlbmdpbmVcclxuICAgIGVuZ2luZS5tYXN0ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fX3NjaGVkdWxpbmdRdWV1ZSA9IG5ldyBQbGF5Q29udHJvbGxlZFNjaGVkdWxpbmdRdWV1ZShwbGF5Q29udHJvbCwgZW5naW5lKTtcclxuICB9XHJcblxyXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsIHNlZWssIGxhc3RTcGVlZCkge1xyXG4gICAgaWYgKGxhc3RTcGVlZCA9PT0gMCAmJiBzcGVlZCAhPT0gMCkgLy8gc3RhcnQgb3Igc2Vla1xyXG4gICAgICB0aGlzLl9fZW5naW5lLnJlc2V0VGltZSgpO1xyXG4gICAgZWxzZSBpZiAobGFzdFNwZWVkICE9PSAwICYmIHNwZWVkID09PSAwKSAvLyBzdG9wXHJcbiAgICAgIHRoaXMuX19lbmdpbmUucmVzZXRUaW1lKEluZmluaXR5KTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9fc2NoZWR1bGluZ1F1ZXVlLmRlc3Ryb3koKTtcclxuICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIHRyYW5zbGF0ZXMgdHJhbnNwb3J0ZWQgZW5naW5lIGFkdmFuY2VQb3NpdGlvbiBpbnRvIGdsb2JhbCBzY2hlZHVsZXIgdGltZXNcclxuY2xhc3MgUGxheUNvbnRyb2xsZWRTY2hlZHVsZXJIb29rIGV4dGVuZHMgVGltZUVuZ2luZSB7XHJcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2wgPSBwbGF5Q29udHJvbDtcclxuICAgIHRoaXMuX19lbmdpbmUgPSBlbmdpbmU7XHJcblxyXG4gICAgdGhpcy5fX25leHRQb3NpdGlvbiA9IEluZmluaXR5O1xyXG4gICAgcGxheUNvbnRyb2wuX19zY2hlZHVsZXIuYWRkKHRoaXMsIEluZmluaXR5KTtcclxuICB9XHJcblxyXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcclxuICAgIHZhciBwbGF5Q29udHJvbCA9IHRoaXMuX19wbGF5Q29udHJvbDtcclxuICAgIHZhciBlbmdpbmUgPSB0aGlzLl9fZW5naW5lO1xyXG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fX25leHRQb3NpdGlvbjtcclxuICAgIHZhciBuZXh0UG9zaXRpb24gPSBlbmdpbmUuYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBwbGF5Q29udHJvbC5fX3NwZWVkKTtcclxuICAgIHZhciBuZXh0VGltZSA9IHBsYXlDb250cm9sLl9fZ2V0VGltZUF0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcclxuXHJcbiAgICB0aGlzLl9fbmV4dFBvc2l0aW9uID0gbmV4dFBvc2l0aW9uO1xyXG4gICAgcmV0dXJuIG5leHRUaW1lO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19wbGF5Q29udHJvbC5jdXJyZW50VGltZTtcclxuICB9XHJcblxyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3BsYXlDb250cm9sLmN1cnJlbnRQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIHJlc2V0UG9zaXRpb24ocG9zaXRpb24gPSB0aGlzLl9fbmV4dFBvc2l0aW9uKSB7XHJcbiAgICB2YXIgdGltZSA9IHRoaXMuX19wbGF5Q29udHJvbC5fX2dldFRpbWVBdFBvc2l0aW9uKHBvc2l0aW9uKTtcclxuICAgIHRoaXMuX19uZXh0UG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIHRoaXMucmVzZXRUaW1lKHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX19wbGF5Q29udHJvbC5fX3NjaGVkdWxlci5yZW1vdmUodGhpcyk7XHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2wgPSBudWxsO1xyXG4gICAgdGhpcy5fX2VuZ2luZSA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBpbnRlcm5hbCBzY2hlZHVsaW5nIHF1ZXVlIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBwb3NpdGlvbiAoYW5kIHRpbWUpIG9mIHRoZSBwbGF5IGNvbnRyb2xcclxuY2xhc3MgUGxheUNvbnRyb2xsZWRTY2hlZHVsaW5nUXVldWUgZXh0ZW5kcyBTY2hlZHVsaW5nUXVldWUge1xyXG4gIGNvbnN0cnVjdG9yKHBsYXlDb250cm9sLCBlbmdpbmUpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2wgPSBwbGF5Q29udHJvbDtcclxuICAgIHRoaXMuX19lbmdpbmUgPSBlbmdpbmU7XHJcblxyXG4gICAgdGhpcy5hZGQoZW5naW5lLCBJbmZpbml0eSk7XHJcbiAgICBwbGF5Q29udHJvbC5fX3NjaGVkdWxlci5hZGQodGhpcywgSW5maW5pdHkpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19wbGF5Q29udHJvbC5jdXJyZW50VGltZTtcclxuICB9XHJcblxyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3BsYXlDb250cm9sLmN1cnJlbnRQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2wuX19zY2hlZHVsZXIucmVtb3ZlKHRoaXMpO1xyXG4gICAgdGhpcy5yZW1vdmUodGhpcy5fX2VuZ2luZSk7XHJcblxyXG4gICAgdGhpcy5fX3BsYXlDb250cm9sID0gbnVsbDtcclxuICAgIHRoaXMuX19lbmdpbmUgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBFeHRlbmRzIFRpbWUgRW5naW5lIHRvIHByb3ZpZGUgcGxheWJhY2sgY29udHJvbCBvZiBhIFRpbWUgRW5naW5lIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBbZXhhbXBsZV17QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3BsYXktY29udHJvbC5odG1sfVxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBUaW1lRW5naW5lXHJcbiAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gZW5naW5lIHRvIGNvbnRyb2xcclxuICpcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0ICogYXMgYXVkaW8gZnJvbSAnd2F2ZXMtYXVkaW8nO1xyXG4gKiBjb25zdCBwbGF5ZXJFbmdpbmUgPSBhdWRpby5QbGF5ZXJFbmdpbmUoKTtcclxuICogY29uc3QgcGxheUNvbnRyb2wgPSBuZXcgYXVkaW8uUGxheUNvbnRyb2wocGxheWVyRW5naW5lKTtcclxuICpcclxuICogcGxheUNvbnRyb2wuc3RhcnQoKTtcclxuICovXHJcbmNsYXNzIFBsYXlDb250cm9sIGV4dGVuZHMgVGltZUVuZ2luZSB7XHJcbiAgY29uc3RydWN0b3IoZW5naW5lLCBvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBvcHRpb25zLmF1ZGlvQ29udGV4dCB8fCBkZWZhdWx0QXVkaW9Db250ZXh0O1xyXG4gICAgdGhpcy5fX3NjaGVkdWxlciA9IGdldFNjaGVkdWxlcih0aGlzLmF1ZGlvQ29udGV4dCk7XHJcblxyXG4gICAgdGhpcy5fX3BsYXlDb250cm9sbGVkID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9fbG9vcENvbnRyb2wgPSBudWxsO1xyXG4gICAgdGhpcy5fX2xvb3BTdGFydCA9IDA7XHJcbiAgICB0aGlzLl9fbG9vcEVuZCA9IDE7XHJcblxyXG4gICAgLy8gc3luY2hyb25pemVkIHRpZSwgcG9zaXRpb24sIGFuZCBzcGVlZFxyXG4gICAgdGhpcy5fX3RpbWUgPSAwO1xyXG4gICAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcclxuICAgIHRoaXMuX19zcGVlZCA9IDA7XHJcblxyXG4gICAgLy8gbm9uLXplcm8gXCJ1c2VyXCIgc3BlZWRcclxuICAgIHRoaXMuX19wbGF5aW5nU3BlZWQgPSAxO1xyXG5cclxuICAgIGlmIChlbmdpbmUpXHJcbiAgICAgIHRoaXMuX19zZXRFbmdpbmUoZW5naW5lKTtcclxuICB9XHJcblxyXG4gIF9fc2V0RW5naW5lKGVuZ2luZSkge1xyXG4gICAgaWYgKGVuZ2luZS5tYXN0ZXIpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIGEgbWFzdGVyXCIpO1xyXG5cclxuICAgIGlmIChUaW1lRW5naW5lLmltcGxlbWVudHNTcGVlZENvbnRyb2xsZWQoZW5naW5lKSlcclxuICAgICAgdGhpcy5fX3BsYXlDb250cm9sbGVkID0gbmV3IFBsYXlDb250cm9sbGVkU3BlZWRDb250cm9sbGVkKHRoaXMsIGVuZ2luZSk7XHJcbiAgICBlbHNlIGlmIChUaW1lRW5naW5lLmltcGxlbWVudHNUcmFuc3BvcnRlZChlbmdpbmUpKVxyXG4gICAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQgPSBuZXcgUGxheUNvbnRyb2xsZWRUcmFuc3BvcnRlZCh0aGlzLCBlbmdpbmUpO1xyXG4gICAgZWxzZSBpZiAoVGltZUVuZ2luZS5pbXBsZW1lbnRzU2NoZWR1bGVkKGVuZ2luZSkpXHJcbiAgICAgIHRoaXMuX19wbGF5Q29udHJvbGxlZCA9IG5ldyBQbGF5Q29udHJvbGxlZFNjaGVkdWxlZCh0aGlzLCBlbmdpbmUpO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgY2Fubm90IGJlIGFkZGVkIHRvIHBsYXkgY29udHJvbFwiKTtcclxuICB9XHJcblxyXG4gIF9fcmVzZXRFbmdpbmUoKSB7XHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQuZGVzdHJveSgpO1xyXG4gICAgdGhpcy5fX3BsYXlDb250cm9sbGVkID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZS9leHRyYXBvbGF0ZSBwbGF5aW5nIHRpbWUgZm9yIGdpdmVuIHBvc2l0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gcG9zaXRpb25cclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGV4dHJhcG9sYXRlZCB0aW1lXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfX2dldFRpbWVBdFBvc2l0aW9uKHBvc2l0aW9uKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3RpbWUgKyAocG9zaXRpb24gLSB0aGlzLl9fcG9zaXRpb24pIC8gdGhpcy5fX3NwZWVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlL2V4dHJhcG9sYXRlIHBsYXlpbmcgcG9zaXRpb24gZm9yIGdpdmVuIHRpbWVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIHRpbWVcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGV4dHJhcG9sYXRlZCBwb3NpdGlvblxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX19nZXRQb3NpdGlvbkF0VGltZSh0aW1lKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uICsgKHRpbWUgLSB0aGlzLl9fdGltZSkgKiB0aGlzLl9fc3BlZWQ7XHJcbiAgfVxyXG5cclxuICBfX3N5bmMoKSB7XHJcbiAgICBjb25zdCBub3cgPSB0aGlzLmN1cnJlbnRUaW1lO1xyXG4gICAgdGhpcy5fX3Bvc2l0aW9uICs9IChub3cgLSB0aGlzLl9fdGltZSkgKiB0aGlzLl9fc3BlZWQ7XHJcbiAgICB0aGlzLl9fdGltZSA9IG5vdztcclxuICAgIHJldHVybiBub3c7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY3VycmVudCBtYXN0ZXIgdGltZS5cclxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcmVwbGFjZWQgd2hlbiB0aGUgcGxheS1jb250cm9sIGlzIGFkZGVkIHRvIGEgbWFzdGVyLlxyXG4gICAqXHJcbiAgICogQG5hbWUgY3VycmVudFRpbWVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBtZW1iZXJvZiBQbGF5Q29udHJvbFxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50VGltZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fc2NoZWR1bGVyLmN1cnJlbnRUaW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGN1cnJlbnQgbWFzdGVyIHBvc2l0aW9uLlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZXBsYWNlZCB3aGVuIHRoZSBwbGF5LWNvbnRyb2wgaXMgYWRkZWQgdG8gYSBtYXN0ZXIuXHJcbiAgICpcclxuICAgKiBAbmFtZSBjdXJyZW50UG9zaXRpb25cclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBtZW1iZXJvZiBQbGF5Q29udHJvbFxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3Bvc2l0aW9uICsgKHRoaXMuX19zY2hlZHVsZXIuY3VycmVudFRpbWUgLSB0aGlzLl9fdGltZSkgKiB0aGlzLl9fc3BlZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGlmIHRoZSBwbGF5IGNvbnRyb2wgaXMgcnVubmluIGcuXHJcbiAgICpcclxuICAgKiBAbmFtZSBydW5uaW5nXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHJ1bm5pbmcoKSB7XHJcbiAgICByZXR1cm4gISh0aGlzLl9fc3BlZWQgPT09IDApO1xyXG4gIH1cclxuXHJcbiAgc2V0KGVuZ2luZSA9IG51bGwpIHtcclxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xyXG4gICAgY29uc3Qgc3BlZWQgPSB0aGlzLl9fc3BlZWQ7XHJcblxyXG4gICAgaWYgKHRoaXMuX19wbGF5Q29udHJvbGxlZCAhPT0gbnVsbCAmJiB0aGlzLl9fcGxheUNvbnRyb2xsZWQuX19lbmdpbmUgIT09IGVuZ2luZSkge1xyXG5cclxuICAgICAgdGhpcy5zeW5jU3BlZWQodGltZSwgdGhpcy5fX3Bvc2l0aW9uLCAwKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9fcGxheUNvbnRyb2xsZWQpXHJcbiAgICAgICAgdGhpcy5fX3Jlc2V0RW5naW5lKCk7XHJcblxyXG5cclxuICAgICAgaWYgKHRoaXMuX19wbGF5Q29udHJvbGxlZCA9PT0gbnVsbCAmJiBlbmdpbmUgIT09IG51bGwpIHtcclxuICAgICAgICB0aGlzLl9fc2V0RW5naW5lKGVuZ2luZSk7XHJcblxyXG4gICAgICAgIGlmIChzcGVlZCAhPT0gMClcclxuICAgICAgICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIHRoaXMuX19wb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBwbGF5IGNvbnRyb2wgbG9vcCBiZWhhdmlvci5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAqIEBuYW1lIGxvb3BcclxuICAgKiBAbWVtYmVyb2YgUGxheUNvbnRyb2xcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKi9cclxuICBzZXQgbG9vcChlbmFibGUpIHtcclxuICAgIGlmIChlbmFibGUgJiYgdGhpcy5fX2xvb3BTdGFydCA+IC1JbmZpbml0eSAmJiB0aGlzLl9fbG9vcEVuZCA8IEluZmluaXR5KSB7XHJcbiAgICAgIGlmICghdGhpcy5fX2xvb3BDb250cm9sKSB7XHJcbiAgICAgICAgdGhpcy5fX2xvb3BDb250cm9sID0gbmV3IExvb3BDb250cm9sKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX19zY2hlZHVsZXIuYWRkKHRoaXMuX19sb29wQ29udHJvbCwgSW5maW5pdHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGhpcy5fX3NwZWVkICE9PSAwKSB7XHJcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmN1cnJlbnRQb3NpdGlvbjtcclxuICAgICAgICBjb25zdCBsb3dlciA9IE1hdGgubWluKHRoaXMuX19sb29wU3RhcnQsIHRoaXMuX19sb29wRW5kKTtcclxuICAgICAgICBjb25zdCB1cHBlciA9IE1hdGgubWF4KHRoaXMuX19sb29wU3RhcnQsIHRoaXMuX19sb29wRW5kKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX19zcGVlZCA+IDAgJiYgcG9zaXRpb24gPiB1cHBlcilcclxuICAgICAgICAgIHRoaXMuc2Vlayh1cHBlcik7XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fX3NwZWVkIDwgMCAmJiBwb3NpdGlvbiA8IGxvd2VyKVxyXG4gICAgICAgICAgdGhpcy5zZWVrKGxvd2VyKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0aGlzLl9fbG9vcENvbnRyb2wucmVzY2hlZHVsZSh0aGlzLl9fc3BlZWQpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHRoaXMuX19sb29wQ29udHJvbCkge1xyXG4gICAgICB0aGlzLl9fc2NoZWR1bGVyLnJlbW92ZSh0aGlzLl9fbG9vcENvbnRyb2wpO1xyXG4gICAgICB0aGlzLl9fbG9vcENvbnRyb2wgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IGxvb3AoKSB7XHJcbiAgICByZXR1cm4gKCEhdGhpcy5fX2xvb3BDb250cm9sKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbG9vcCBzdGFydCBhbmQgZW5kIHRpbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gbG9vcFN0YXJ0IC0gbG9vcCBzdGFydCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gbG9vcEVuZCAtIGxvb3AgZW5kIHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldExvb3BCb3VuZGFyaWVzKGxvb3BTdGFydCwgbG9vcEVuZCkge1xyXG4gICAgdGhpcy5fX2xvb3BTdGFydCA9IGxvb3BTdGFydDtcclxuICAgIHRoaXMuX19sb29wRW5kID0gbG9vcEVuZDtcclxuXHJcbiAgICB0aGlzLmxvb3AgPSB0aGlzLmxvb3A7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGxvb3Agc3RhcnQgdmFsdWVcclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG5hbWUgbG9vcFN0YXJ0XHJcbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcbiAgc2V0IGxvb3BTdGFydChsb29wU3RhcnQpIHtcclxuICAgIHRoaXMuc2V0TG9vcEJvdW5kYXJpZXMobG9vcFN0YXJ0LCB0aGlzLl9fbG9vcEVuZCk7XHJcbiAgfVxyXG5cclxuICBnZXQgbG9vcFN0YXJ0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19sb29wU3RhcnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGxvb3AgZW5kIHZhbHVlXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGxvb3BFbmRcclxuICAgKiBAbWVtYmVyb2YgUGxheUNvbnRyb2xcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKi9cclxuICBzZXQgbG9vcEVuZChsb29wRW5kKSB7XHJcbiAgICB0aGlzLnNldExvb3BCb3VuZGFyaWVzKHRoaXMuX19sb29wU3RhcnQsIGxvb3BFbmQpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGxvb3BFbmQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2xvb3BFbmQ7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAoc3BlZWQtY29udHJvbGxlZCBpbnRlcmZhY2UpXHJcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlayA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBsYXN0U3BlZWQgPSB0aGlzLl9fc3BlZWQ7XHJcblxyXG4gICAgaWYgKHNwZWVkICE9PSBsYXN0U3BlZWQgfHwgc2Vlaykge1xyXG4gICAgICBpZiAoKHNlZWsgfHwgbGFzdFNwZWVkID09PSAwKSAmJiB0aGlzLl9fbG9vcENvbnRyb2wpXHJcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLl9fbG9vcENvbnRyb2wuYXBwbHlMb29wQm91bmRhcmllcyhwb3NpdGlvbiwgc3BlZWQpO1xyXG5cclxuICAgICAgdGhpcy5fX3RpbWUgPSB0aW1lO1xyXG4gICAgICB0aGlzLl9fcG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgdGhpcy5fX3NwZWVkID0gc3BlZWQ7XHJcblxyXG4gICAgICBpZiAodGhpcy5fX3BsYXlDb250cm9sbGVkKVxyXG4gICAgICAgIHRoaXMuX19wbGF5Q29udHJvbGxlZC5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrLCBsYXN0U3BlZWQpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX19sb29wQ29udHJvbClcclxuICAgICAgICB0aGlzLl9fbG9vcENvbnRyb2wucmVzY2hlZHVsZShzcGVlZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgcGxheWJhY2tcclxuICAgKi9cclxuICBzdGFydCgpIHtcclxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xyXG4gICAgdGhpcy5zeW5jU3BlZWQodGltZSwgdGhpcy5fX3Bvc2l0aW9uLCB0aGlzLl9fcGxheWluZ1NwZWVkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlcyBwbGF5YmFjayBhbmQgc3RheXMgYXQgdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAgICovXHJcbiAgcGF1c2UoKSB7XHJcbiAgICBjb25zdCB0aW1lID0gdGhpcy5fX3N5bmMoKTtcclxuICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIHRoaXMuX19wb3NpdGlvbiwgMCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wcyBwbGF5YmFjayBhbmQgc2Vla3MgdG8gaW5pdGlhbCAoMCkgcG9zaXRpb24uXHJcbiAgICovXHJcbiAgc3RvcCgpIHtcclxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xyXG4gICAgdGhpcy5zeW5jU3BlZWQodGltZSwgMCwgMCwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJZiBzcGVlZCBpZiBwcm92aWRlZCwgc2V0cyB0aGUgcGxheWJhY2sgc3BlZWQuIFRoZSBzcGVlZCB2YWx1ZSBzaG91bGRcclxuICAgKiBiZSBub24temVybyBiZXR3ZWVuIC0xNiBhbmQgLTEvMTYgb3IgYmV0d2VlbiAxLzE2IGFuZCAxNi5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG5hbWUgc3BlZWRcclxuICAgKiBAbWVtYmVyb2YgUGxheUNvbnRyb2xcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKi9cclxuICBzZXQgc3BlZWQoc3BlZWQpIHtcclxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xyXG5cclxuICAgIGlmIChzcGVlZCA+PSAwKSB7XHJcbiAgICAgIGlmIChzcGVlZCA8IDAuMDEpXHJcbiAgICAgICAgc3BlZWQgPSAwLjAxO1xyXG4gICAgICBlbHNlIGlmIChzcGVlZCA+IDEwMClcclxuICAgICAgICBzcGVlZCA9IDEwMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChzcGVlZCA8IC0xMDApXHJcbiAgICAgICAgc3BlZWQgPSAtMTAwO1xyXG4gICAgICBlbHNlIGlmIChzcGVlZCA+IC0wLjAxKVxyXG4gICAgICAgIHNwZWVkID0gLTAuMDE7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fX3BsYXlpbmdTcGVlZCA9IHNwZWVkO1xyXG5cclxuICAgIGlmICghdGhpcy5tYXN0ZXIgJiYgdGhpcy5fX3NwZWVkICE9PSAwKVxyXG4gICAgICB0aGlzLnN5bmNTcGVlZCh0aW1lLCB0aGlzLl9fcG9zaXRpb24sIHNwZWVkKTtcclxuICB9XHJcblxyXG4gIGdldCBzcGVlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcGxheWluZ1NwZWVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IChqdW1wIHRvKSBwbGF5aW5nIHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIHRhcmdldCBwb3NpdGlvblxyXG4gICAqL1xyXG4gIHNlZWsocG9zaXRpb24pIHtcclxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xyXG4gICAgdGhpcy5fX3Bvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB0aGlzLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgdGhpcy5fX3NwZWVkLCB0cnVlKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBsYXlDb250cm9sO1xyXG4iLCJpbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xyXG5pbXBvcnQgZGVmYXVsdEF1ZGlvQ29udGV4dCBmcm9tICcuLi9jb3JlL2F1ZGlvLWNvbnRleHQnO1xyXG5pbXBvcnQgU2NoZWR1bGluZ1F1ZXVlIGZyb20gJy4uL2NvcmUvc2NoZWR1bGluZy1xdWV1ZSc7XHJcblxyXG5jb25zdCBsb2cgPSBkZWJ1Zygnd2F2ZXNqczphdWRpbycpO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBgU2NoZWR1bGVyYCBjbGFzcyBpbXBsZW1lbnRzIGEgbWFzdGVyIGZvciBgVGltZUVuZ2luZWAgb3IgYEF1ZGlvVGltZUVuZ2luZWBcclxuICogaW5zdGFuY2VzIHRoYXQgaW1wbGVtZW50IHRoZSAqc2NoZWR1bGVkKiBpbnRlcmZhY2Ugc3VjaCBhcyB0aGUgYE1ldHJvbm9tZWBcclxuICogYEdyYW51bGFyRW5naW5lYC5cclxuICpcclxuICogQSBgU2NoZWR1bGVyYCBjYW4gYWxzbyBzY2hlZHVsZSBzaW1wbGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxyXG4gKiBUaGUgY2xhc3MgaXMgYmFzZWQgb24gcmVjdXJzaXZlIGNhbGxzIHRvIGBzZXRUaW1lT3V0YCBhbmQgdXNlcyB0aGVcclxuICogYGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZWAgYXMgbG9naWNhbCBwYXNzZWQgdG8gdGhlIGBhZHZhbmNlVGltZWAgbWV0aG9kc1xyXG4gKiBvZiB0aGUgc2NoZWR1bGVkIGVuZ2luZXMgb3IgdG8gdGhlIHNjaGVkdWxlZCBjYWxsYmFjayBmdW5jdGlvbnMuXHJcbiAqIEl0IGV4dGVuZHMgdGhlIGBTY2hlZHVsaW5nUXVldWVgIGNsYXNzIHRoYXQgaXRzZWxmIGluY2x1ZGVzIGEgYFByaW9yaXR5UXVldWVgXHJcbiAqIHRvIGFzc3VyZSB0aGUgb3JkZXIgb2YgdGhlIHNjaGVkdWxlZCBlbmdpbmVzIChzZWUgYFNpbXBsZVNjaGVkdWxlcmAgZm9yIGFcclxuICogc2ltcGxpZmllZCBzY2hlZHVsZXIgaW1wbGVtZW50YXRpb24gd2l0aG91dCBgUHJpb3JpdHlRdWV1ZWApLlxyXG4gKlxyXG4gKiBUbyBnZXQgYSB1bmlxdWUgaW5zdGFuY2Ugb2YgYFNjaGVkdWxlcmAgYXMgdGhlIGdsb2JhbCBzY2hlZHVsZXIgb2YgYW5cclxuICogYXBwbGljYXRpb24sIHRoZSBgZ2V0U2NoZWR1bGVyYCBmYWN0b3J5IGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkLiBUaGVcclxuICogZnVuY3Rpb24gYWNjZXB0cyBhbiBhdWRpbyBjb250ZXh0IGFzIG9wdGlvbmFsIGFyZ3VtZW50IGFuZCB1c2VzIHRoZSBXYXZlc1xyXG4gKiBkZWZhdWx0IGF1ZGlvIGNvbnRleHQgKHNlZSBgYXVkaW9Db250ZXh0YCkgYXNcclxuICogZGVmYXVsdC4gVGhlIGZhY3RvcnkgY3JlYXRlcyBhIHNpbmdsZSBzY2hlZHVsZXIgZm9yIGVhY2ggYXVkaW8gY29udGV4dC5cclxuICpcclxuICogRXhhbXBsZSB0aGF0IHNob3dzIHRocmVlIE1ldHJvbm9tZSBlbmdpbmVzIHJ1bm5pbmcgaW4gYSBTY2hlZHVsZXI6XHJcbiAqIHtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvc2NoZWR1bGVyLmh0bWx9XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBkZWZhdWx0IG9wdGlvbnNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZD0wLjAyNV0gLSBwZXJpb2Qgb2YgdGhlIHNjaGVkdWxlci5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxvb2thaGVhZD0wLjFdIC0gbG9va2FoZWFkIG9mIHRoZSBzY2hlZHVsZXIuXHJcbiAqXHJcbiAqIEBzZWUgVGltZUVuZ2luZVxyXG4gKiBAc2VlIEF1ZGlvVGltZUVuZ2luZVxyXG4gKiBAc2VlIGdldFNjaGVkdWxlclxyXG4gKiBAc2VlIFNpbXBsZVNjaGVkdWxlclxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XHJcbiAqIGNvbnN0IHNjaGVkdWxlciA9IGF1ZGlvLmdldFNjaGVkdWxlcigpO1xyXG4gKlxyXG4gKiBzY2hlZHVsZXIuYWRkKG15RW5naW5lKTtcclxuICovXHJcbmNsYXNzIFNjaGVkdWxlciBleHRlbmRzIFNjaGVkdWxpbmdRdWV1ZSB7XHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gb3B0aW9ucy5hdWRpb0NvbnRleHQgfHwgwqBkZWZhdWx0QXVkaW9Db250ZXh0O1xyXG5cclxuICAgIHRoaXMuX19jdXJyZW50VGltZSA9IG51bGw7XHJcbiAgICB0aGlzLl9fbmV4dFRpbWUgPSBJbmZpbml0eTtcclxuICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNjaGVkdWxlciAoc2V0VGltZW91dCkgcGVyaW9kXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcGVyaW9kXHJcbiAgICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2QgPSBvcHRpb25zLnBlcmlvZCB8fCDCoDAuMDI1O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2NoZWR1bGVyIGxvb2thaGVhZCB0aW1lICg+IHBlcmlvZClcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBsb29rYWhlYWRcclxuICAgICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmxvb2thaGVhZCA9IG9wdGlvbnMubG9va2FoZWFkIHx8IMKgMC4xO1xyXG4gIH1cclxuXHJcbiAgLy8gc2V0VGltZW91dCBzY2hlZHVsaW5nIGxvb3BcclxuICBfX3RpY2soKSB7XHJcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcclxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xyXG4gICAgbGV0IHRpbWUgPSB0aGlzLl9fbmV4dFRpbWU7XHJcblxyXG4gICAgdGhpcy5fX3RpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIHdoaWxlICh0aW1lIDw9IGN1cnJlbnRUaW1lICsgdGhpcy5sb29rYWhlYWQpIHtcclxuICAgICAgdGhpcy5fX2N1cnJlbnRUaW1lID0gdGltZTtcclxuICAgICAgdGltZSA9IHRoaXMuYWR2YW5jZVRpbWUodGltZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fX2N1cnJlbnRUaW1lID0gbnVsbDtcclxuICAgIHRoaXMucmVzZXRUaW1lKHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRUaW1lKHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lKSB7XHJcbiAgICBpZiAodGhpcy5tYXN0ZXIpIHtcclxuICAgICAgdGhpcy5tYXN0ZXIucmVzZXQodGhpcywgdGltZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAodGhpcy5fX3RpbWVvdXQpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fX3RpbWVvdXQpO1xyXG4gICAgICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHRpbWUgIT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX19uZXh0VGltZSA9PT0gSW5maW5pdHkpXHJcbiAgICAgICAgICBsb2coJ1NjaGVkdWxlciBTdGFydCcpO1xyXG5cclxuICAgICAgICBjb25zdCB0aW1lT3V0RGVsYXkgPSBNYXRoLm1heCgodGltZSAtIHRoaXMubG9va2FoZWFkIC0gdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUpLCB0aGlzLnBlcmlvZCk7XHJcblxyXG4gICAgICAgIHRoaXMuX190aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLl9fdGljaygpO1xyXG4gICAgICAgIH0sIE1hdGguY2VpbCh0aW1lT3V0RGVsYXkgKiAxMDAwKSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fX25leHRUaW1lICE9PSBJbmZpbml0eSkge1xyXG4gICAgICAgIGxvZygnU2NoZWR1bGVyIFN0b3AnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fX25leHRUaW1lID0gdGltZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjaGVkdWxlciBjdXJyZW50IGxvZ2ljYWwgdGltZS5cclxuICAgKlxyXG4gICAqIEBuYW1lIGN1cnJlbnRUaW1lXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgaWYgKHRoaXMubWFzdGVyKVxyXG4gICAgICByZXR1cm4gdGhpcy5tYXN0ZXIuY3VycmVudFRpbWU7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX19jdXJyZW50VGltZSB8fCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMubG9va2FoZWFkO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcclxuICAgIGNvbnN0IG1hc3RlciA9IHRoaXMubWFzdGVyO1xyXG5cclxuICAgIGlmIChtYXN0ZXIgJiYgbWFzdGVyLmN1cnJlbnRQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICByZXR1cm4gbWFzdGVyLmN1cnJlbnRQb3NpdGlvbjtcclxuXHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgLy8gaW5oZXJpdGVkIGZyb20gc2NoZWR1bGluZyBxdWV1ZVxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIFRpbWVFbmdpbmUgb3IgYSBzaW1wbGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gdGhlIHNjaGVkdWxlciBhdCBhblxyXG4gICAqIG9wdGlvbmFsbHkgZ2l2ZW4gdGltZS4gV2hldGhlciB0aGUgYWRkIG1ldGhvZCBpcyBjYWxsZWQgd2l0aCBhIFRpbWVFbmdpbmVcclxuICAgKiBvciBhIGNhbGxiYWNrIGZ1bmN0aW9uIGl0IHJldHVybnMgYSBUaW1lRW5naW5lIHRoYXQgY2FuIGJlIHVzZWQgYXMgYXJndW1lbnRcclxuICAgKiBvZiB0aGUgbWV0aG9kcyByZW1vdmUgYW5kIHJlc2V0RW5naW5lVGltZS4gQSBUaW1lRW5naW5lIGFkZGVkIHRvIGEgc2NoZWR1bGVyXHJcbiAgICogaGFzIHRvIGltcGxlbWVudCB0aGUgc2NoZWR1bGVkIGludGVyZmFjZS4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGFkZGVkIHRvIGFcclxuICAgKiBzY2hlZHVsZXIgd2lsbCBiZSBjYWxsZWQgYXQgdGhlIGdpdmVuIHRpbWUgYW5kIHdpdGggdGhlIGdpdmVuIHRpbWUgYXNcclxuICAgKiBhcmd1bWVudC4gVGhlIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBuZXcgc2NoZWR1bGluZyB0aW1lIChpLmUuIHRoZSBuZXh0XHJcbiAgICogdGltZSB3aGVuIGl0IHdpbGwgYmUgY2FsbGVkKSBvciBpdCBjYW4gcmV0dXJuIEluZmluaXR5IHRvIHN1c3BlbmQgc2NoZWR1bGluZ1xyXG4gICAqIHdpdGhvdXQgcmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIGZyb20gdGhlIHNjaGVkdWxlci4gQSBmdW5jdGlvbiB0aGF0IGRvZXNcclxuICAgKiBub3QgcmV0dXJuIGEgdmFsdWUgKG9yIHJldHVybnMgbnVsbCBvciAwKSBpcyByZW1vdmVkIGZyb20gdGhlIHNjaGVkdWxlclxyXG4gICAqIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBhcmd1bWVudCBvZiB0aGUgbWV0aG9kcyByZW1vdmUgYW5kIHJlc2V0RW5naW5lVGltZVxyXG4gICAqIGFueW1vcmUuXHJcbiAgICpcclxuICAgKiBAbmFtZSBhZGRcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHtUaW1lRW5naW5lfEZ1bmN0aW9ufSBlbmdpbmUgLSBFbmdpbmUgdG8gYWRkIHRvIHRoZSBzY2hlZHVsZXJcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWU9dGhpcy5jdXJyZW50VGltZV0gLSBTY2hlZHVsZSB0aW1lXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEgVGltZUVuZ2luZSBmcm9tIHRoZSBzY2hlZHVsZXIgdGhhdCBoYXMgYmVlbiBhZGRlZCB0byB0aGVcclxuICAgKiBzY2hlZHVsZXIgdXNpbmcgdGhlIGFkZCBtZXRob2QuXHJcbiAgICpcclxuICAgKiBAbmFtZSBhZGRcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQHBhcmFtIHtUaW1lRW5naW5lfSBlbmdpbmUgLSBFbmdpbmUgdG8gcmVtb3ZlIGZyb20gdGhlIHNjaGVkdWxlclxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZT10aGlzLmN1cnJlbnRUaW1lXSAtIFNjaGVkdWxlIHRpbWVcclxuICAgKi9cclxuICAvKipcclxuICAgKiBSZXNjaGVkdWxlIGEgc2NoZWR1bGVkIHRpbWUgZW5naW5lIGF0IGEgZ2l2ZW4gdGltZS5cclxuICAgKlxyXG4gICAqIEBuYW1lIHJlc2V0RW5naW5lVGltZVxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV9IGVuZ2luZSAtIEVuZ2luZSB0byByZXNjaGVkdWxlXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBTY2hlZHVsZSB0aW1lXHJcbiAgICovXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFsbCBzY2hlZHVsZWQgY2FsbGJhY2tzIGFuZCBlbmdpbmVzIGZyb20gdGhlIHNjaGVkdWxlci5cclxuICAgKlxyXG4gICAqIEBuYW1lIGNsZWFyXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICogQG1lbWJlcm9mIFNjaGVkdWxlclxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2NoZWR1bGVyO1xyXG4iLCJpbXBvcnQgZGVidWcgZnJvbSAnZGVidWcnO1xyXG5pbXBvcnQgZGVmYXVsdEF1ZGlvQ29udGV4dCBmcm9tICcuLi9jb3JlL2F1ZGlvLWNvbnRleHQnO1xyXG5pbXBvcnQgVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL3RpbWUtZW5naW5lJztcclxuXHJcbmNvbnN0IGxvZyA9IGRlYnVnKCd3YXZlc2pzOmF1ZGlvJyk7XHJcblxyXG4vKipcclxuICpcclxuICpcclxuICpcclxuICogVGhlIFNpbXBsZVNjaGVkdWxlciBjbGFzcyBpbXBsZW1lbnRzIGEgc2ltcGxpZmllZCBtYXN0ZXIgZm9yIHRpbWUgZW5naW5lc1xyXG4gKiAoc2VlIFRpbWVFbmdpbmUgb3IgQXVkaW9UaW1lRW5naW5lKSB0aGF0IGltcGxlbWVudCB0aGUgc2NoZWR1bGVkIGludGVyZmFjZVxyXG4gKiBzdWNoIGFzIHRoZSBNZXRyb25vbWUgYW5kIHRoZSBHcmFudWxhckVuZ2luZS4gVGhlIEFQSSBhbmQgZnVudGlvbmFsaXRpZXMgb2ZcclxuICogdGhlIFNpbXBsZVNjaGVkdWxlciBjbGFzcyBhcmUgaWRlbnRpY2FsIHRvIHRoZSBTY2hlZHVsZXIgY2xhc3MuIEJ1dCwgb3RoZXJcclxuICogdGhhbiB0aGUgU2NoZWR1bGVyLCB0aGUgU2ltcGxlU2NoZWR1bGVyIGNsYXNzIGRvZXMgbm90IGd1YXJhbnRlZSB0aGUgb3JkZXJcclxuICogb2YgZXZlbnRzIChpLmUuIGNhbGxzIHRvIHRoZSBhZHZhbmNlVGltZSBtZXRob2Qgb2Ygc2NoZWR1bGVkIHRpbWUgZW5naW5lc1xyXG4gKiBhbmQgdG8gc2NoZWR1bGVkIGNhbGxiYWNrIGZ1bmN0aW9ucykgd2l0aGluIGEgc2NoZWR1bGluZyBwZXJpb2QgKHNlZSBwZXJpb2RcclxuICogYXR0cmlidXRlKS5cclxuICpcclxuICogVG8gZ2V0IGEgdW5pcXVlIGluc3RhbmNlIG9mIFNpbXBsZVNjaGVkdWxlciBhcyB0aGUgZ2xvYmFsIHNjaGVkdWxlciBvZiBhblxyXG4gKiBhcHBsaWNhdGlvbiwgdGhlIGdldFNpbXBsZVNjaGVkdWxlciBmYWN0b3J5IGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkLiBUaGVcclxuICogZnVuY3Rpb24gYWNjZXB0cyBhbiBhdWRpbyBjb250ZXh0IGFzIG9wdGlvbmFsIGFyZ3VtZW50IGFuZCB1c2VzIHRoZSBXYXZlc1xyXG4gKiBkZWZhdWx0IGF1ZGlvIGNvbnRleHQgKHNlZSBBdWRpbyBDb250ZXh0KSBhcyBkZWZhdWx0LiBUaGUgZmFjdG9yeSBjcmVhdGVzXHJcbiAqIGEgc2luZ2xlIChzaW1wbGUpIHNjaGVkdWxlciBmb3IgZWFjaCBhdWRpbyBjb250ZXh0LlxyXG4gKlxyXG4gKiBFeGFtcGxlIHRoYXQgc2hvd3MgdGhyZWUgTWV0cm9ub21lIGVuZ2luZXMgcnVubmluZyBpbiBhIFNpbXBsZVNjaGVkdWxlcjpcclxuICoge0BsaW5rIGh0dHBzOi8vcmF3Z2l0LmNvbS93YXZlc2pzL3dhdmVzLWF1ZGlvL21hc3Rlci9leGFtcGxlcy9zaW1wbGUtc2NoZWR1bGVyLmh0bWx9XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBkZWZhdWx0IG9wdGlvbnNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZD0wLjAyNV0gLSBwZXJpb2Qgb2YgdGhlIHNjaGVkdWxlci5cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmxvb2thaGVhZD0wLjFdIC0gbG9va2FoZWFkIG9mIHRoZSBzY2hlZHVsZXIuXHJcbiAqXHJcbiAqIEBzZWUgVGltZUVuZ2luZVxyXG4gKiBAc2VlIEF1ZGlvVGltZUVuZ2luZVxyXG4gKiBAc2VlIGdldFNpbXBsZVNjaGVkdWxlclxyXG4gKiBAc2VlIFNjaGVkdWxlclxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XHJcbiAqIGNvbnN0IHNjaGVkdWxlciA9IGF1ZGlvLmdldFNpbXBsZVNjaGVkdWxlcigpO1xyXG4gKlxyXG4gKiBzY2hlZHVsZXIuYWRkKG15RW5naW5lKTtcclxuICovXHJcbmNsYXNzIFNpbXBsZVNjaGVkdWxlciB7XHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IG9wdGlvbnMuYXVkaW9Db250ZXh0IHx8IMKgZGVmYXVsdEF1ZGlvQ29udGV4dDtcclxuXHJcbiAgICB0aGlzLl9fZW5naW5lcyA9IG5ldyBTZXQoKTtcclxuXHJcbiAgICB0aGlzLl9fc2NoZWRFbmdpbmVzID0gW107XHJcbiAgICB0aGlzLl9fc2NoZWRUaW1lcyA9IFtdO1xyXG5cclxuICAgIHRoaXMuX19jdXJyZW50VGltZSA9IG51bGw7XHJcbiAgICB0aGlzLl9fdGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzY2hlZHVsZXIgKHNldFRpbWVvdXQpIHBlcmlvZFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHBlcmlvZFxyXG4gICAgICogQG1lbWJlcm9mIFNjaGVkdWxlclxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGVyaW9kID0gb3B0aW9ucy5wZXJpb2QgfHwgMC4wMjU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzY2hlZHVsZXIgbG9va2FoZWFkIHRpbWUgKD4gcGVyaW9kKVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIGxvb2thaGVhZFxyXG4gICAgICogQG1lbWJlcm9mIFNjaGVkdWxlclxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubG9va2FoZWFkID0gb3B0aW9ucy5sb29rYWhlYWQgfHwgMC4xO1xyXG4gIH1cclxuXHJcbiAgX19zY2hlZHVsZUVuZ2luZShlbmdpbmUsIHRpbWUpIHtcclxuICAgIHRoaXMuX19zY2hlZEVuZ2luZXMucHVzaChlbmdpbmUpO1xyXG4gICAgdGhpcy5fX3NjaGVkVGltZXMucHVzaCh0aW1lKTtcclxuICB9XHJcblxyXG4gIF9fcmVzY2hlZHVsZUVuZ2luZShlbmdpbmUsIHRpbWUpIHtcclxuICAgIHZhciBpbmRleCA9IHRoaXMuX19zY2hlZEVuZ2luZXMuaW5kZXhPZihlbmdpbmUpO1xyXG5cclxuICAgIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICAgIGlmICh0aW1lICE9PSBJbmZpbml0eSkge1xyXG4gICAgICAgIHRoaXMuX19zY2hlZFRpbWVzW2luZGV4XSA9IHRpbWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fX3NjaGVkRW5naW5lcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIHRoaXMuX19zY2hlZFRpbWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGltZSA8IEluZmluaXR5KSB7XHJcbiAgICAgIHRoaXMuX19zY2hlZEVuZ2luZXMucHVzaChlbmdpbmUpO1xyXG4gICAgICB0aGlzLl9fc2NoZWRUaW1lcy5wdXNoKHRpbWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX191bnNjaGVkdWxlRW5naW5lKGVuZ2luZSkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fX3NjaGVkRW5naW5lcy5pbmRleE9mKGVuZ2luZSk7XHJcblxyXG4gICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgdGhpcy5fX3NjaGVkRW5naW5lcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB0aGlzLl9fc2NoZWRUaW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX19yZXNldFRpY2soKSB7XHJcbiAgICBpZiAodGhpcy5fX3NjaGVkRW5naW5lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGlmICghdGhpcy5fX3RpbWVvdXQpIHtcclxuICAgICAgICBsb2coJ1NpbXBsZVNjaGVkdWxlciBTdGFydCcpO1xyXG4gICAgICAgIHRoaXMuX190aWNrKCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5fX3RpbWVvdXQpIHtcclxuICAgICAgbG9nKCdTaW1wbGVTY2hlZHVsZXIgU3RvcCcpO1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fX3RpbWVvdXQpO1xyXG4gICAgICB0aGlzLl9fdGltZW91dCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfX3RpY2soKSB7XHJcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XHJcbiAgICB2YXIgY3VycmVudFRpbWUgPSBhdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XHJcbiAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgd2hpbGUgKGkgPCB0aGlzLl9fc2NoZWRFbmdpbmVzLmxlbmd0aCkge1xyXG4gICAgICB2YXIgZW5naW5lID0gdGhpcy5fX3NjaGVkRW5naW5lc1tpXTtcclxuICAgICAgdmFyIHRpbWUgPSB0aGlzLl9fc2NoZWRUaW1lc1tpXTtcclxuXHJcbiAgICAgIHdoaWxlICh0aW1lICYmIHRpbWUgPD0gY3VycmVudFRpbWUgKyB0aGlzLmxvb2thaGVhZCkge1xyXG4gICAgICAgIHRpbWUgPSBNYXRoLm1heCh0aW1lLCBjdXJyZW50VGltZSk7XHJcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRUaW1lID0gdGltZTtcclxuICAgICAgICB0aW1lID0gZW5naW5lLmFkdmFuY2VUaW1lKHRpbWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGltZSAmJiB0aW1lIDwgSW5maW5pdHkpIHtcclxuICAgICAgICB0aGlzLl9fc2NoZWRUaW1lc1tpKytdID0gdGltZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9fdW5zY2hlZHVsZUVuZ2luZShlbmdpbmUpO1xyXG5cclxuICAgICAgICAvLyByZW1vdmUgZW5naW5lIGZyb20gc2NoZWR1bGVyXHJcbiAgICAgICAgaWYgKCF0aW1lKSB7XHJcbiAgICAgICAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcclxuICAgICAgICAgIHRoaXMuX19lbmdpbmVzLmRlbGV0ZShlbmdpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX19jdXJyZW50VGltZSA9IG51bGw7XHJcbiAgICB0aGlzLl9fdGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgaWYgKHRoaXMuX19zY2hlZEVuZ2luZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLl9fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX190aWNrKCk7XHJcbiAgICAgIH0sIHRoaXMucGVyaW9kICogMTAwMCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY2hlZHVsZXIgY3VycmVudCBsb2dpY2FsIHRpbWUuXHJcbiAgICpcclxuICAgKiBAbmFtZSBjdXJyZW50VGltZVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG1lbWJlcm9mIFNjaGVkdWxlclxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50VGltZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fY3VycmVudFRpbWUgfHwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUgKyB0aGlzLmxvb2thaGVhZDtcclxuICB9XHJcblxyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgLy8gY2FsbCBhIGZ1bmN0aW9uIGF0IGEgZ2l2ZW4gdGltZVxyXG4gIC8qKlxyXG4gICAqIERlZmVyIHRoZSBleGVjdXRpb24gb2YgYSBmdW5jdGlvbiBhdCBhIGdpdmVuIHRpbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW4gLSBGdW5jdGlvbiB0byBkZWZlclxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZT10aGlzLmN1cnJlbnRUaW1lXSAtIFNjaGVkdWxlIHRpbWVcclxuICAgKi9cclxuICBkZWZlcihmdW4sIHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lKSB7XHJcbiAgICBpZiAoIShmdW4gaW5zdGFuY2VvZiBGdW5jdGlvbikpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBjYW5ub3QgYmUgZGVmZXJlZCBieSBzY2hlZHVsZXJcIik7XHJcblxyXG4gICAgdGhpcy5hZGQoe1xyXG4gICAgICBhZHZhbmNlVGltZTogZnVuY3Rpb24odGltZSkgeyBmdW4odGltZSk7IH0sIC8vIG1ha2Ugc3VyIHRoYXQgdGhlIGFkdmFuY2VUaW1lIG1ldGhvZCBkb2VzIG5vdCByZXR1cm0gYW55dGhpbmdcclxuICAgIH0sIHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgVGltZUVuZ2luZSBmdW5jdGlvbiB0byB0aGUgc2NoZWR1bGVyIGF0IGFuIG9wdGlvbmFsbHkgZ2l2ZW4gdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gRW5naW5lIHRvIGFkZCB0byB0aGUgc2NoZWR1bGVyXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lPXRoaXMuY3VycmVudFRpbWVdIC0gU2NoZWR1bGUgdGltZVxyXG4gICAqL1xyXG4gIGFkZChlbmdpbmUsIHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lKSB7XHJcbiAgICBpZiAoIVRpbWVFbmdpbmUuaW1wbGVtZW50c1NjaGVkdWxlZChlbmdpbmUpKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgY2Fubm90IGJlIGFkZGVkIHRvIHNjaGVkdWxlclwiKTtcclxuXHJcbiAgICBpZiAoZW5naW5lLm1hc3RlcilcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gYSBtYXN0ZXJcIik7XHJcblxyXG4gICAgLy8gc2V0IG1hc3RlciBhbmQgYWRkIHRvIGFycmF5XHJcbiAgICBlbmdpbmUubWFzdGVyID0gdGhpcztcclxuICAgIHRoaXMuX19lbmdpbmVzLmFkZChlbmdpbmUpO1xyXG5cclxuICAgIC8vIHNjaGVkdWxlIGVuZ2luZVxyXG4gICAgdGhpcy5fX3NjaGVkdWxlRW5naW5lKGVuZ2luZSwgdGltZSk7XHJcbiAgICB0aGlzLl9fcmVzZXRUaWNrKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgYSBUaW1lRW5naW5lIGZyb20gdGhlIHNjaGVkdWxlciB0aGF0IGhhcyBiZWVuIGFkZGVkIHRvIHRoZVxyXG4gICAqIHNjaGVkdWxlciB1c2luZyB0aGUgYWRkIG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gRW5naW5lIHRvIHJlbW92ZSBmcm9tIHRoZSBzY2hlZHVsZXJcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWU9dGhpcy5jdXJyZW50VGltZV0gLSBTY2hlZHVsZSB0aW1lXHJcbiAgICovXHJcbiAgcmVtb3ZlKGVuZ2luZSkge1xyXG4gICAgaWYgKCFlbmdpbmUubWFzdGVyIHx8IGVuZ2luZS5tYXN0ZXIgIT09IHRoaXMpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImVuZ2luZSBoYXMgbm90IGJlZW4gYWRkZWQgdG8gdGhpcyBzY2hlZHVsZXJcIik7XHJcblxyXG4gICAgLy8gcmVzZXQgbWFzdGVyIGFuZCByZW1vdmUgZnJvbSBhcnJheVxyXG4gICAgZW5naW5lLm1hc3RlciA9IG51bGw7XHJcbiAgICB0aGlzLl9fZW5naW5lcy5kZWxldGUoZW5naW5lKTtcclxuXHJcbiAgICAvLyB1bnNjaGVkdWxlIGVuZ2luZVxyXG4gICAgdGhpcy5fX3Vuc2NoZWR1bGVFbmdpbmUoZW5naW5lKTtcclxuICAgIHRoaXMuX19yZXNldFRpY2soKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2NoZWR1bGUgYSBzY2hlZHVsZWQgdGltZSBlbmdpbmUgYXQgYSBnaXZlbiB0aW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUaW1lRW5naW5lfSBlbmdpbmUgLSBFbmdpbmUgdG8gcmVzY2hlZHVsZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gU2NoZWR1bGUgdGltZVxyXG4gICAqL1xyXG4gIHJlc2V0RW5naW5lVGltZShlbmdpbmUsIHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lKSB7XHJcbiAgICB0aGlzLl9fcmVzY2hlZHVsZUVuZ2luZShlbmdpbmUsIHRpbWUpO1xyXG4gICAgdGhpcy5fX3Jlc2V0VGljaygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIGVuZ2luZSBpcyBzY2hlZHVsZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV9IGVuZ2luZSAtIEVuZ2luZSB0byBjaGVja1xyXG4gICAqL1xyXG4gIGhhcyhlbmdpbmUpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZW5naW5lcy5oYXMoZW5naW5lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbGwgZW5naW5lcyBmcm9tIHRoZSBzY2hlZHVsZXIuXHJcbiAgICovXHJcbiAgY2xlYXIoKSB7XHJcbiAgICBpZiAodGhpcy5fX3RpbWVvdXQpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX190aW1lb3V0KTtcclxuICAgICAgdGhpcy5fX3RpbWVvdXQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX19zY2hlZEVuZ2luZXMubGVuZ3RoID0gMDtcclxuICAgIHRoaXMuX19zY2hlZFRpbWVzLmxlbmd0aCA9IDA7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTaW1wbGVTY2hlZHVsZXI7XHJcbiIsImltcG9ydCBkZWZhdWx0QXVkaW9Db250ZXh0IGZyb20gJy4uL2NvcmUvYXVkaW8tY29udGV4dCc7XHJcbmltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gJy4uL2NvcmUvcHJpb3JpdHktcXVldWUnO1xyXG5pbXBvcnQgU2NoZWR1bGluZ1F1ZXVlIGZyb20gJy4uL2NvcmUvc2NoZWR1bGluZy1xdWV1ZSc7XHJcbmltcG9ydCBUaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvdGltZS1lbmdpbmUnO1xyXG5pbXBvcnQgeyBnZXRTY2hlZHVsZXIgfSBmcm9tICcuL2ZhY3Rvcmllcyc7XHJcblxyXG5cclxuZnVuY3Rpb24gYWRkRHVwbGV0KGZpcnN0QXJyYXksIHNlY29uZEFycmF5LCBmaXJzdEVsZW1lbnQsIHNlY29uZEVsZW1lbnQpIHtcclxuICBmaXJzdEFycmF5LnB1c2goZmlyc3RFbGVtZW50KTtcclxuICBzZWNvbmRBcnJheS5wdXNoKHNlY29uZEVsZW1lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByZW1vdmVEdXBsZXQoZmlyc3RBcnJheSwgc2Vjb25kQXJyYXksIGZpcnN0RWxlbWVudCkge1xyXG4gIGNvbnN0IGluZGV4ID0gZmlyc3RBcnJheS5pbmRleE9mKGZpcnN0RWxlbWVudCk7XHJcblxyXG4gIGlmIChpbmRleCA+PSAwKSB7XHJcbiAgICBjb25zdCBzZWNvbmRFbGVtZW50ID0gc2Vjb25kQXJyYXlbaW5kZXhdO1xyXG5cclxuICAgIGZpcnN0QXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIHNlY29uZEFycmF5LnNwbGljZShpbmRleCwgMSk7XHJcblxyXG4gICAgcmV0dXJuIHNlY29uZEVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLy8gVGhlIFRyYW5zcG9ydGVkIGNhbGwgaXMgdGhlIGJhc2UgY2xhc3Mgb2YgdGhlIGFkYXB0ZXJzIGJldHdlZW5cclxuLy8gZGlmZmVyZW50IHR5cGVzIG9mIGVuZ2luZXMgKGkuZS4gdHJhbnNwb3J0ZWQsIHNjaGVkdWxlZCwgcGxheS1jb250cm9sbGVkKVxyXG4vLyBUaGUgYWRhcHRlcnMgYXJlIGF0IHRoZSBzYW1lIHRpbWUgbWFzdGVycyBmb3IgdGhlIGVuZ2luZXMgYWRkZWQgdG8gdGhlIHRyYW5zcG9ydFxyXG4vLyBhbmQgdHJhbnNwb3J0ZWQgVGltZUVuZ2luZXMgaW5zZXJ0ZWQgaW50byB0aGUgdHJhbnNwb3J0J3MgcG9zaXRpb24tYmFzZWQgcHJpdG9yaXR5IHF1ZXVlLlxyXG5jbGFzcyBUcmFuc3BvcnRlZCBleHRlbmRzIFRpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCwgZW5naW5lLCBzdGFydCwgZHVyYXRpb24sIG9mZnNldCwgc3RyZXRjaCA9IDEpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm1hc3RlciA9IHRyYW5zcG9ydDtcclxuXHJcbiAgICB0aGlzLl9fZW5naW5lID0gZW5naW5lO1xyXG4gICAgZW5naW5lLm1hc3RlciA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5fX3N0YXJ0UG9zaXRpb24gPSBzdGFydDtcclxuICAgIHRoaXMuX19lbmRQb3NpdGlvbiA9ICFpc0Zpbml0ZShkdXJhdGlvbikgPyBJbmZpbml0eSA6IHN0YXJ0ICsgZHVyYXRpb247XHJcbiAgICB0aGlzLl9fb2Zmc2V0UG9zaXRpb24gPSBzdGFydCArIG9mZnNldDtcclxuICAgIHRoaXMuX19zdHJldGNoUG9zaXRpb24gPSBzdHJldGNoO1xyXG4gICAgdGhpcy5fX2lzUnVubmluZyA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgc2V0Qm91bmRhcmllcyhzdGFydCwgZHVyYXRpb24sIG9mZnNldCA9IDAsIHN0cmV0Y2ggPSAxKSB7XHJcbiAgICB0aGlzLl9fc3RhcnRQb3NpdGlvbiA9IHN0YXJ0O1xyXG4gICAgdGhpcy5fX2VuZFBvc2l0aW9uID0gc3RhcnQgKyBkdXJhdGlvbjtcclxuICAgIHRoaXMuX19vZmZzZXRQb3NpdGlvbiA9IHN0YXJ0ICsgb2Zmc2V0O1xyXG4gICAgdGhpcy5fX3N0cmV0Y2hQb3NpdGlvbiA9IHN0cmV0Y2g7XHJcbiAgICB0aGlzLnJlc2V0UG9zaXRpb24oKTtcclxuICB9XHJcblxyXG4gIHN0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge31cclxuICBzdG9wKHRpbWUsIHBvc2l0aW9uKSB7fVxyXG5cclxuICBnZXQgY3VycmVudFRpbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tYXN0ZXIuY3VycmVudFRpbWU7XHJcbiAgfVxyXG5cclxuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubWFzdGVyLmN1cnJlbnRQb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIHJlc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgIGlmIChwb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICBwb3NpdGlvbiArPSB0aGlzLl9fb2Zmc2V0UG9zaXRpb247XHJcblxyXG4gICAgdGhpcy5tYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XHJcbiAgfVxyXG5cclxuICBzeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICBpZiAoc3BlZWQgPiAwKSB7XHJcbiAgICAgIGlmIChwb3NpdGlvbiA8IHRoaXMuX19zdGFydFBvc2l0aW9uKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9faXNSdW5uaW5nKVxyXG4gICAgICAgICAgdGhpcy5zdG9wKHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy5fX2lzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhcnRQb3NpdGlvbjtcclxuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IHRoaXMuX19lbmRQb3NpdGlvbikge1xyXG4gICAgICAgIHRoaXMuc3RhcnQodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcclxuXHJcbiAgICAgICAgdGhpcy5fX2lzUnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19lbmRQb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHBvc2l0aW9uID4gdGhpcy5fX2VuZFBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX19pc1J1bm5pbmcpIC8vIGlmIGVuZ2luZSBpcyBydW5uaW5nXHJcbiAgICAgICAgICB0aGlzLnN0b3AodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24pO1xyXG5cclxuICAgICAgICB0aGlzLl9faXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19lbmRQb3NpdGlvbjtcclxuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA+IHRoaXMuX19zdGFydFBvc2l0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCh0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbiwgc3BlZWQpO1xyXG5cclxuICAgICAgICB0aGlzLl9faXNSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXJ0UG9zaXRpb247XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5fX2lzUnVubmluZykgLy8gaWYgZW5naW5lIGlzIHJ1bm5pbmdcclxuICAgICAgdGhpcy5zdG9wKHRpbWUsIHBvc2l0aW9uKTtcclxuXHJcbiAgICB0aGlzLl9faXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgICByZXR1cm4gSW5maW5pdHkgKiBzcGVlZDtcclxuICB9XHJcblxyXG4gIGFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGlmICghdGhpcy5fX2lzUnVubmluZykge1xyXG4gICAgICB0aGlzLnN0YXJ0KHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSB0cnVlO1xyXG5cclxuICAgICAgaWYgKHNwZWVkID4gMClcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2VuZFBvc2l0aW9uO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuX19zdGFydFBvc2l0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHN0b3AgZW5naW5lXHJcbiAgICB0aGlzLnN0b3AodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24pO1xyXG5cclxuICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgIHJldHVybiBJbmZpbml0eSAqIHNwZWVkO1xyXG4gIH1cclxuXHJcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgaWYgKHNwZWVkID09PSAwKSAvLyBzdG9wXHJcbiAgICAgIHRoaXMuc3RvcCh0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbik7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5tYXN0ZXIgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX19lbmdpbmUubWFzdGVyID0gbnVsbDtcclxuICAgIHRoaXMuX19lbmdpbmUgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gVHJhbnNwb3J0ZWRUcmFuc3BvcnRlZFxyXG4vLyBoYXMgdG8gc3dpdGNoIG9uIGFuZCBvZmYgdGhlIHNjaGVkdWxlZCBlbmdpbmVzIHdoZW4gdGhlIHRyYW5zcG9ydCBoaXRzIHRoZSBlbmdpbmUncyBzdGFydCBhbmQgZW5kIHBvc2l0aW9uXHJcbmNsYXNzIFRyYW5zcG9ydGVkVHJhbnNwb3J0ZWQgZXh0ZW5kcyBUcmFuc3BvcnRlZCB7XHJcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbikge1xyXG4gICAgc3VwZXIodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbik7XHJcbiAgfVxyXG5cclxuICBzeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICBpZiAoc3BlZWQgPiAwICYmIHBvc2l0aW9uIDwgdGhpcy5fX2VuZFBvc2l0aW9uKVxyXG4gICAgICBwb3NpdGlvbiA9IE1hdGgubWF4KHBvc2l0aW9uLCB0aGlzLl9fc3RhcnRQb3NpdGlvbik7XHJcbiAgICBlbHNlIGlmIChzcGVlZCA8IDAgJiYgcG9zaXRpb24gPj0gdGhpcy5fX3N0YXJ0UG9zaXRpb24pXHJcbiAgICAgIHBvc2l0aW9uID0gTWF0aC5taW4ocG9zaXRpb24sIHRoaXMuX19lbmRQb3NpdGlvbik7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX19vZmZzZXRQb3NpdGlvbiArIHRoaXMuX19lbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgfVxyXG5cclxuICBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICBwb3NpdGlvbiA9IHRoaXMuX19vZmZzZXRQb3NpdGlvbiArIHRoaXMuX19lbmdpbmUuYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XHJcblxyXG4gICAgaWYgKHNwZWVkID4gMCAmJiBwb3NpdGlvbiA8IHRoaXMuX19lbmRQb3NpdGlvbiB8fCBzcGVlZCA8IDAgJiYgcG9zaXRpb24gPj0gdGhpcy5fX3N0YXJ0UG9zaXRpb24pXHJcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcclxuXHJcbiAgICByZXR1cm4gSW5maW5pdHkgKiBzcGVlZDtcclxuICB9XHJcblxyXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGlmICh0aGlzLl9fZW5naW5lLnN5bmNTcGVlZClcclxuICAgICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICB9XHJcblxyXG4gIHJlc2V0RW5naW5lUG9zaXRpb24oZW5naW5lLCBwb3NpdGlvbiA9IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHBvc2l0aW9uICs9IHRoaXMuX19vZmZzZXRQb3NpdGlvbjtcclxuXHJcbiAgICB0aGlzLnJlc2V0UG9zaXRpb24ocG9zaXRpb24pO1xyXG4gIH1cclxufVxyXG5cclxuLy8gVHJhbnNwb3J0ZWRTcGVlZENvbnRyb2xsZWRcclxuLy8gaGFzIHRvIHN0YXJ0IGFuZCBzdG9wIHRoZSBzcGVlZC1jb250cm9sbGVkIGVuZ2luZXMgd2hlbiB0aGUgdHJhbnNwb3J0IGhpdHMgdGhlIGVuZ2luZSdzIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25cclxuY2xhc3MgVHJhbnNwb3J0ZWRTcGVlZENvbnRyb2xsZWQgZXh0ZW5kcyBUcmFuc3BvcnRlZCB7XHJcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbikge1xyXG4gICAgc3VwZXIodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbik7XHJcbiAgfVxyXG5cclxuICBzdGFydCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICBzdG9wKHRpbWUsIHBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgMCk7XHJcbiAgfVxyXG5cclxuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICBpZiAodGhpcy5fX2lzUnVubmluZylcclxuICAgICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aGlzLm1hc3Rlci5jdXJyZW50VGltZSwgdGhpcy5tYXN0ZXIuY3VycmVudFBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCAwKTtcclxuICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFRyYW5zcG9ydGVkU2NoZWR1bGVkXHJcbi8vIGhhcyB0byBzd2l0Y2ggb24gYW5kIG9mZiB0aGUgc2NoZWR1bGVkIGVuZ2luZXMgd2hlbiB0aGUgdHJhbnNwb3J0IGhpdHMgdGhlIGVuZ2luZSdzIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25cclxuY2xhc3MgVHJhbnNwb3J0ZWRTY2hlZHVsZWQgZXh0ZW5kcyBUcmFuc3BvcnRlZCB7XHJcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbikge1xyXG4gICAgc3VwZXIodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbik7XHJcblxyXG4gICAgLy8gc2NoZWR1bGluZyBxdWV1ZSBiZWNvbWVzIG1hc3RlciBvZiBlbmdpbmVcclxuICAgIGVuZ2luZS5tYXN0ZXIgPSBudWxsO1xyXG4gICAgdHJhbnNwb3J0Ll9fc2NoZWR1bGluZ1F1ZXVlLmFkZChlbmdpbmUsIEluZmluaXR5KTtcclxuICB9XHJcblxyXG4gIHN0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdGhpcy5tYXN0ZXIuX19zY2hlZHVsaW5nUXVldWUucmVzZXRFbmdpbmVUaW1lKHRoaXMuX19lbmdpbmUsIHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgc3RvcCh0aW1lLCBwb3NpdGlvbikge1xyXG4gICAgdGhpcy5tYXN0ZXIuX19zY2hlZHVsaW5nUXVldWUucmVzZXRFbmdpbmVUaW1lKHRoaXMuX19lbmdpbmUsIEluZmluaXR5KTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLm1hc3Rlci5fX3NjaGVkdWxpbmdRdWV1ZS5yZW1vdmUodGhpcy5fX2VuZ2luZSk7XHJcbiAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyB0cmFuc2xhdGVzIGFkdmFuY2VQb3NpdGlvbiBvZiAqdHJhbnNwb3J0ZWQqIGVuZ2luZXMgaW50byBnbG9iYWwgc2NoZWR1bGVyIHRpbWVzXHJcbmNsYXNzIFRyYW5zcG9ydFNjaGVkdWxlckhvb2sgZXh0ZW5kcyBUaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5fX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcclxuXHJcbiAgICB0aGlzLl9fbmV4dFBvc2l0aW9uID0gSW5maW5pdHk7XHJcbiAgICB0aGlzLl9fbmV4dFRpbWUgPSBJbmZpbml0eTtcclxuICAgIHRyYW5zcG9ydC5fX3NjaGVkdWxlci5hZGQodGhpcywgSW5maW5pdHkpO1xyXG4gIH1cclxuXHJcbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHNjaGVkdWxlZCBpbnRlcmZhY2UpXHJcbiAgYWR2YW5jZVRpbWUodGltZSkge1xyXG4gICAgY29uc3QgdHJhbnNwb3J0ID0gdGhpcy5fX3RyYW5zcG9ydDtcclxuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5fX25leHRQb3NpdGlvbjtcclxuICAgIGNvbnN0IHNwZWVkID0gdHJhbnNwb3J0Ll9fc3BlZWQ7XHJcbiAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB0cmFuc3BvcnQuYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICBjb25zdCBuZXh0VGltZSA9IHRyYW5zcG9ydC5fX2dldFRpbWVBdFBvc2l0aW9uKG5leHRQb3NpdGlvbik7XHJcblxyXG4gICAgdGhpcy5fX25leHRQb3NpdGlvbiA9IG5leHRQb3NpdGlvbjtcclxuICAgIHRoaXMuX19uZXh0VGltZSA9IG5leHRUaW1lO1xyXG5cclxuICAgIHJldHVybiBuZXh0VGltZTtcclxuICB9XHJcblxyXG4gIHJlc2V0UG9zaXRpb24ocG9zaXRpb24gPSB0aGlzLl9fbmV4dFBvc2l0aW9uKSB7XHJcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLl9fdHJhbnNwb3J0O1xyXG4gICAgY29uc3QgdGltZSA9IHRyYW5zcG9ydC5fX2dldFRpbWVBdFBvc2l0aW9uKHBvc2l0aW9uKTtcclxuXHJcbiAgICB0aGlzLl9fbmV4dFBvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB0aGlzLl9fbmV4dFRpbWUgPSB0aW1lO1xyXG5cclxuICAgIHRoaXMucmVzZXRUaW1lKHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX190cmFuc3BvcnQuX19zY2hlZHVsZXIucmVtb3ZlKHRoaXMpO1xyXG4gICAgdGhpcy5fX3RyYW5zcG9ydCA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBpbnRlcm5hbCBzY2hlZHVsaW5nIHF1ZXVlIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBwb3NpdGlvbiAoYW5kIHRpbWUpIG9mIHRoZSBwbGF5IGNvbnRyb2xcclxuY2xhc3MgVHJhbnNwb3J0U2NoZWR1bGluZ1F1ZXVlIGV4dGVuZHMgU2NoZWR1bGluZ1F1ZXVlIHtcclxuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5fX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcclxuICAgIHRyYW5zcG9ydC5fX3NjaGVkdWxlci5hZGQodGhpcywgSW5maW5pdHkpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX190cmFuc3BvcnQuY3VycmVudFRpbWU7XHJcbiAgfVxyXG5cclxuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX190cmFuc3BvcnQuY3VycmVudFBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX190cmFuc3BvcnQuX19zY2hlZHVsZXIucmVtb3ZlKHRoaXMpO1xyXG4gICAgdGhpcy5fX3RyYW5zcG9ydCA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgc3luY2hyb25pemVkIHNjaGVkdWxpbmcgb2YgVGltZSBFbmdpbmUgaW5zdGFuY2VzLlxyXG4gKlxyXG4gKiBbZXhhbXBsZV17QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3RyYW5zcG9ydC5odG1sfVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XHJcbiAqIGNvbnN0IHRyYW5zcG9ydCA9IGF1ZGlvLlRyYW5zcG9ydCgpO1xyXG4gKiBjb25zdCBwbGF5Q29udHJvbCA9IG5ldyBhdWRpby5QbGF5Q29udHJvbCh0cmFuc3BvcnQpO1xyXG4gKiBjb25zdCBteUVuZ2luZSA9IG5ldyBNeUVuZ2luZSgpO1xyXG4gKiBjb25zdCB5b3VyRW5naW5lID0gbmV3IHlvdXJFbmdpbmUoKTtcclxuICpcclxuICogdHJhbnNwb3J0LmFkZChteUVuZ2luZSk7XHJcbiAqIHRyYW5zcG9ydC5hZGQoeW91ckVuZ2luZSk7XHJcbiAqXHJcbiAqIHBsYXlDb250cm9sLnN0YXJ0KCk7XHJcbiAqL1xyXG5jbGFzcyBUcmFuc3BvcnQgZXh0ZW5kcyBUaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBvcHRpb25zLmF1ZGlvQ29udGV4dCB8fCBkZWZhdWx0QXVkaW9Db250ZXh0O1xyXG5cclxuICAgIHRoaXMuX19lbmdpbmVzID0gW107XHJcbiAgICB0aGlzLl9fdHJhbnNwb3J0ZWQgPSBbXTtcclxuXHJcbiAgICB0aGlzLl9fc2NoZWR1bGVyID0gZ2V0U2NoZWR1bGVyKHRoaXMuYXVkaW9Db250ZXh0KTtcclxuICAgIHRoaXMuX19zY2hlZHVsZXJIb29rID0gbmV3IFRyYW5zcG9ydFNjaGVkdWxlckhvb2sodGhpcyk7XHJcbiAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XHJcbiAgICB0aGlzLl9fc2NoZWR1bGluZ1F1ZXVlID0gbmV3IFRyYW5zcG9ydFNjaGVkdWxpbmdRdWV1ZSh0aGlzKTtcclxuXHJcbiAgICAvLyBzeW5jcm9uaXplZCB0aW1lLCBwb3NpdGlvbiwgYW5kIHNwZWVkXHJcbiAgICB0aGlzLl9fdGltZSA9IDA7XHJcbiAgICB0aGlzLl9fcG9zaXRpb24gPSAwO1xyXG4gICAgdGhpcy5fX3NwZWVkID0gMDtcclxuICB9XHJcblxyXG4gIF9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgIHJldHVybiB0aGlzLl9fdGltZSArIChwb3NpdGlvbiAtIHRoaXMuX19wb3NpdGlvbikgLyB0aGlzLl9fc3BlZWQ7XHJcbiAgfVxyXG5cclxuICBfX2dldFBvc2l0aW9uQXRUaW1lKHRpbWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcG9zaXRpb24gKyAodGltZSAtIHRoaXMuX190aW1lKSAqIHRoaXMuX19zcGVlZDtcclxuICB9XHJcblxyXG4gIF9fc3luY1RyYW5zcG9ydGVkUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICBjb25zdCBudW1UcmFuc3BvcnRlZEVuZ2luZXMgPSB0aGlzLl9fdHJhbnNwb3J0ZWQubGVuZ3RoO1xyXG4gICAgbGV0IG5leHRQb3NpdGlvbiA9IEluZmluaXR5ICogc3BlZWQ7XHJcblxyXG4gICAgaWYgKG51bVRyYW5zcG9ydGVkRW5naW5lcyA+IDApIHtcclxuICAgICAgdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUuY2xlYXIoKTtcclxuICAgICAgdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUucmV2ZXJzZSA9IChzcGVlZCA8IDApO1xyXG5cclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UcmFuc3BvcnRlZEVuZ2luZXM7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX190cmFuc3BvcnRlZFtpXTtcclxuICAgICAgICBjb25zdCBuZXh0RW5naW5lUG9zaXRpb24gPSBlbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgICAgdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUuaW5zZXJ0KGVuZ2luZSwgbmV4dEVuZ2luZVBvc2l0aW9uKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUudGltZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmV4dFBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgX19zeW5jVHJhbnNwb3J0ZWRTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGZvciAobGV0IHRyYW5zcG9ydGVkIG9mIHRoaXMuX190cmFuc3BvcnRlZClcclxuICAgICAgdHJhbnNwb3J0ZWQuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY3VycmVudCBtYXN0ZXIgdGltZS4gVGhpcyBnZXR0ZXIgd2lsbCBiZSByZXBsYWNlZCB3aGVuIHRoZSB0cmFuc3BvcnRcclxuICAgKiBpcyBhZGRlZCB0byBhIG1hc3RlciAoaS5lLiB0cmFuc3BvcnQgb3IgcGxheS1jb250cm9sKS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG5hbWUgY3VycmVudFRpbWVcclxuICAgKiBAbWVtYmVyb2YgVHJhbnNwb3J0XHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19zY2hlZHVsZXIuY3VycmVudFRpbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY3VycmVudCBtYXN0ZXIgcG9zaXRpb24uIFRoaXMgZ2V0dGVyIHdpbGwgYmUgcmVwbGFjZWQgd2hlbiB0aGUgdHJhbnNwb3J0XHJcbiAgICogaXMgYWRkZWQgdG8gYSBtYXN0ZXIgKGkuZS4gdHJhbnNwb3J0IG9yIHBsYXktY29udHJvbCkuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGN1cnJlbnRQb3NpdGlvblxyXG4gICAqIEBtZW1iZXJvZiBUcmFuc3BvcnRcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xyXG4gICAgY29uc3QgbWFzdGVyID0gdGhpcy5tYXN0ZXI7XHJcblxyXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9fcG9zaXRpb24gKyAodGhpcy5fX3NjaGVkdWxlci5jdXJyZW50VGltZSAtIHRoaXMuX190aW1lKSAqIHRoaXMuX19zcGVlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IG5leHQgdHJhbnNwb3J0IHBvc2l0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gbmV4dCAtIHRyYW5zcG9ydCBwb3NpdGlvblxyXG4gICAqL1xyXG4gIHJlc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgIGNvbnN0IG1hc3RlciA9IHRoaXMubWFzdGVyO1xyXG5cclxuICAgIGlmIChtYXN0ZXIgJiYgbWFzdGVyLnJlc2V0RW5naW5lUG9zaXRpb24gIT09IHVuZGVmaW5lZClcclxuICAgICAgbWFzdGVyLnJlc2V0RW5naW5lUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xyXG4gICAgZWxzZVxyXG4gICAgICB0aGlzLl9fc2NoZWR1bGVySG9vay5yZXNldFBvc2l0aW9uKHBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSB0cmFuc3BvcnRlZCB0aW1lIGVuZ2luZSBpbnRlcmZhY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVlZFxyXG4gICAqL1xyXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIHRoaXMuX190aW1lID0gdGltZTtcclxuICAgIHRoaXMuX19wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgdGhpcy5fX3NwZWVkID0gc3BlZWQ7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX19zeW5jVHJhbnNwb3J0ZWRQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIHRyYW5zcG9ydGVkIHRpbWUgZW5naW5lIGludGVyZmFjZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWVkXHJcbiAgICovXHJcbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgY29uc3QgZW5naW5lID0gdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUuaGVhZDtcclxuICAgIGNvbnN0IG5leHRFbmdpbmVQb3NpdGlvbiA9IGVuZ2luZS5hZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICAgIHJldHVybiB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5tb3ZlKGVuZ2luZSwgbmV4dEVuZ2luZVBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSB0cmFuc3BvcnRlZCB0aW1lIGVuZ2luZSBpbnRlcmZhY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvblxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzcGVlZFxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NlZWs9ZmFsc2VdXHJcbiAgICovXHJcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlayA9IGZhbHNlKSB7XHJcbiAgICBjb25zdCBsYXN0U3BlZWQgPSB0aGlzLl9fc3BlZWQ7XHJcblxyXG4gICAgdGhpcy5fX3RpbWUgPSB0aW1lO1xyXG4gICAgdGhpcy5fX3Bvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB0aGlzLl9fc3BlZWQgPSBzcGVlZDtcclxuXHJcbiAgICBpZiAoc3BlZWQgIT09IGxhc3RTcGVlZCB8fCAoc2VlayAmJiBzcGVlZCAhPT0gMCkpIHtcclxuICAgICAgbGV0IG5leHRQb3NpdGlvbjtcclxuXHJcbiAgICAgIC8vIHJlc3luYyB0cmFuc3BvcnRlZCBlbmdpbmVzXHJcbiAgICAgIGlmIChzZWVrIHx8IHNwZWVkICogbGFzdFNwZWVkIDwgMCkge1xyXG4gICAgICAgIC8vIHNlZWsgb3IgcmV2ZXJzZSBkaXJlY3Rpb25cclxuICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fc3luY1RyYW5zcG9ydGVkUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICAgICAgfSBlbHNlIGlmIChsYXN0U3BlZWQgPT09IDApIHtcclxuICAgICAgICAvLyBzdGFydFxyXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX19zeW5jVHJhbnNwb3J0ZWRQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNwZWVkID09PSAwKSB7XHJcbiAgICAgICAgLy8gc3RvcFxyXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IEluZmluaXR5O1xyXG4gICAgICAgIHRoaXMuX19zeW5jVHJhbnNwb3J0ZWRTcGVlZCh0aW1lLCBwb3NpdGlvbiwgMCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gY2hhbmdlIHNwZWVkIHdpdGhvdXQgcmV2ZXJzaW5nIGRpcmVjdGlvblxyXG4gICAgICAgIHRoaXMuX19zeW5jVHJhbnNwb3J0ZWRTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLnJlc2V0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIHRpbWUgZW5naW5lIHRvIHRoZSB0cmFuc3BvcnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gZW5naW5lIC0gZW5naW5lIHRvIGJlIGFkZGVkIHRvIHRoZSB0cmFuc3BvcnRcclxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBzdGFydCBwb3NpdGlvblxyXG4gICAqL1xyXG4gIGFkZChlbmdpbmUsIHN0YXJ0UG9zaXRpb24gPSAwLCBlbmRQb3NpdGlvbiA9IEluZmluaXR5LCBvZmZzZXRQb3NpdGlvbiA9IDApIHtcclxuICAgIGxldCB0cmFuc3BvcnRlZCA9IG51bGw7XHJcblxyXG4gICAgaWYgKG9mZnNldFBvc2l0aW9uID09PSAtSW5maW5pdHkpXHJcbiAgICAgIG9mZnNldFBvc2l0aW9uID0gMDtcclxuXHJcbiAgICBpZiAoZW5naW5lLm1hc3RlcilcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gYSBtYXN0ZXJcIik7XHJcblxyXG4gICAgaWYgKFRpbWVFbmdpbmUuaW1wbGVtZW50c1RyYW5zcG9ydGVkKGVuZ2luZSkpXHJcbiAgICAgIHRyYW5zcG9ydGVkID0gbmV3IFRyYW5zcG9ydGVkVHJhbnNwb3J0ZWQodGhpcywgZW5naW5lLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgb2Zmc2V0UG9zaXRpb24pO1xyXG4gICAgZWxzZSBpZiAoVGltZUVuZ2luZS5pbXBsZW1lbnRzU3BlZWRDb250cm9sbGVkKGVuZ2luZSkpXHJcbiAgICAgIHRyYW5zcG9ydGVkID0gbmV3IFRyYW5zcG9ydGVkU3BlZWRDb250cm9sbGVkKHRoaXMsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcclxuICAgIGVsc2UgaWYgKFRpbWVFbmdpbmUuaW1wbGVtZW50c1NjaGVkdWxlZChlbmdpbmUpKVxyXG4gICAgICB0cmFuc3BvcnRlZCA9IG5ldyBUcmFuc3BvcnRlZFNjaGVkdWxlZCh0aGlzLCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbik7XHJcbiAgICBlbHNlXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBjYW5ub3QgYmUgYWRkZWQgdG8gYSB0cmFuc3BvcnRcIik7XHJcblxyXG4gICAgaWYgKHRyYW5zcG9ydGVkKSB7XHJcbiAgICAgIGNvbnN0IHNwZWVkID0gdGhpcy5fX3NwZWVkO1xyXG5cclxuICAgICAgYWRkRHVwbGV0KHRoaXMuX19lbmdpbmVzLCB0aGlzLl9fdHJhbnNwb3J0ZWQsIGVuZ2luZSwgdHJhbnNwb3J0ZWQpO1xyXG5cclxuICAgICAgaWYgKHNwZWVkICE9PSAwKSB7XHJcbiAgICAgICAgLy8gc3luYyBhbmQgc3RhcnRcclxuICAgICAgICBjb25zdCBuZXh0RW5naW5lUG9zaXRpb24gPSB0cmFuc3BvcnRlZC5zeW5jUG9zaXRpb24odGhpcy5jdXJyZW50VGltZSwgdGhpcy5jdXJyZW50UG9zaXRpb24sIHNwZWVkKTtcclxuICAgICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5pbnNlcnQodHJhbnNwb3J0ZWQsIG5leHRFbmdpbmVQb3NpdGlvbik7XHJcblxyXG4gICAgICAgIHRoaXMucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRyYW5zcG9ydGVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEgdGltZSBlbmdpbmUgZnJvbSB0aGUgdHJhbnNwb3J0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGVuZ2luZU9yVHJhbnNwb3J0ZWQgLSBlbmdpbmUgb3IgdHJhbnNwb3J0ZWQgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSB0cmFuc3BvcnRcclxuICAgKi9cclxuICByZW1vdmUoZW5naW5lT3JUcmFuc3BvcnRlZCkge1xyXG4gICAgbGV0IGVuZ2luZSA9IGVuZ2luZU9yVHJhbnNwb3J0ZWQ7XHJcbiAgICBsZXQgdHJhbnNwb3J0ZWQgPSByZW1vdmVEdXBsZXQodGhpcy5fX2VuZ2luZXMsIHRoaXMuX190cmFuc3BvcnRlZCwgZW5naW5lT3JUcmFuc3BvcnRlZCk7XHJcblxyXG4gICAgaWYgKCF0cmFuc3BvcnRlZCkge1xyXG4gICAgICBlbmdpbmUgPSByZW1vdmVEdXBsZXQodGhpcy5fX3RyYW5zcG9ydGVkLCB0aGlzLl9fZW5naW5lcywgZW5naW5lT3JUcmFuc3BvcnRlZCk7XHJcbiAgICAgIHRyYW5zcG9ydGVkID0gZW5naW5lT3JUcmFuc3BvcnRlZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZW5naW5lICYmIHRyYW5zcG9ydGVkKSB7XHJcbiAgICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLnJlbW92ZSh0cmFuc3BvcnRlZCk7XHJcblxyXG4gICAgICB0cmFuc3BvcnRlZC5kZXN0cm95KCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5fX3NwZWVkICE9PSAwKVxyXG4gICAgICAgIHRoaXMucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGlzIHRyYW5zcG9ydFwiKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc2V0IHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBlbmdpbmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV9IHRyYW5zcG9ydGVkIC0gRW5naW5lIHRvIHJlc2V0XHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gTmV3IHBvc2l0aW9uXHJcbiAgICovXHJcbiAgcmVzZXRFbmdpbmVQb3NpdGlvbih0cmFuc3BvcnRlZCwgcG9zaXRpb24gPSB1bmRlZmluZWQpIHtcclxuICAgIGNvbnN0IHNwZWVkID0gdGhpcy5fX3NwZWVkO1xyXG5cclxuICAgIGlmIChzcGVlZCAhPT0gMCkge1xyXG4gICAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZClcclxuICAgICAgICBwb3NpdGlvbiA9IHRyYW5zcG9ydGVkLnN5bmNQb3NpdGlvbih0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmN1cnJlbnRQb3NpdGlvbiwgc3BlZWQpO1xyXG5cclxuICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0gdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUubW92ZSh0cmFuc3BvcnRlZCwgcG9zaXRpb24pO1xyXG4gICAgICB0aGlzLnJlc2V0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbGwgdGltZSBlbmdpbmVzIGZyb20gdGhlIHRyYW5zcG9ydC5cclxuICAgKi9cclxuICBjbGVhcigpIHtcclxuICAgIHRoaXMuc3luY1NwZWVkKHRoaXMuY3VycmVudFRpbWUsIHRoaXMuY3VycmVudFBvc2l0aW9uLCAwKTtcclxuXHJcbiAgICBmb3IgKGxldCB0cmFuc3BvcnRlZCBvZiB0aGlzLl9fdHJhbnNwb3J0ZWQpXHJcbiAgICAgIHRyYW5zcG9ydGVkLmRlc3Ryb3koKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRyYW5zcG9ydDtcclxuIiwiLyogIEZyb20gUGhhc2VWb2NvZGVyLmpzIChjKSAyMDE1IGJ5IEVjaG82NlxuICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9lY2hvNjYvUGhhc2VWb2NvZGVySlNcblxuICAgIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcblx0YWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5cbmltcG9ydCBDQnVmZmVyIGZyb20gJy4vY2J1ZmZlcic7XG5pbXBvcnQge0ZGVH0gZnJvbSAnLi9kc3AuanMnO1xuaW1wb3J0IERTUCBmcm9tICcuL2RzcCc7XG5cbmZ1bmN0aW9uIFBoYXNlVm9jb2Rlcih3aW5TaXplLCBzYW1wbGVSYXRlKSB7XG5cblx0dmFyIF9zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTsgdmFyIF9IcyA9IDA7IHZhciBfSGEgPSAwOyB2YXIgX29tZWdhO1xuXG5cdHZhciBfcHJldmlvdXNJbnB1dFBoYXNlOyB2YXIgX3ByZXZpb3VzT3V0cHV0UGhhc2U7IHZhciBfZnJhbWluZ1dpbmRvdztcblx0XG5cdHZhciBfc3F1YXJlZEZyYW1pbmdXaW5kb3c7IHZhciBfd2luU2l6ZSA9IHdpblNpemU7XG5cblx0dmFyIF9vdmVybGFwQnVmZmVyczsgdmFyIF9vd092ZXJsYXBCdWZmZXJzO1xuXG5cdHZhciBfZmlyc3QgPSB0cnVlO1xuXG5cdHZhciBfb3ZlcmxhcEZhY3RvciA9IDQ7XG5cblx0dmFyIF9sYXN0SW5wdXRBbHBoYSA9IDE7XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKiBkc3AuanMgRkZUICoqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHR2YXIgZmZ0ID0gbmV3IEZGVChfd2luU2l6ZSwgc2FtcGxlUmF0ZSk7XG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuXHR2YXIgc3FydCA9IE1hdGguc3FydDsgdmFyIGNvcyA9IE1hdGguY29zO1xuXHR2YXIgc2luID0gTWF0aC5zaW47IHZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG5cdHZhciByb3VuZCA9IE1hdGgucm91bmQ7IHZhciBtYXggPSBNYXRoLm1heDtcblx0dmFyIGNlaWwgPSBNYXRoLmNlaWw7IHZhciBwb3cgPSBNYXRoLnBvdztcblx0dmFyIFBJID0gTWF0aC5QSTtcblxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKlBSRS1BTExPQ0FURSBNRU1PUlkqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Ly9maW5kX3BlYWtzXG5cdHZhciBfaGxmU2l6ZSA9IHJvdW5kKF93aW5TaXplLzIpKzE7XG5cblx0Ly8gLy8gcHJvY2Vzc1xuXHR2YXIgX3Byb2Nlc3MgPSB7XG5cdFx0ZmZ0T2JqIDoge1xuXHRcdFx0cmVhbDogbmV3IEZsb2F0MzJBcnJheShfaGxmU2l6ZSksIFxuXHRcdFx0aW1hZzogbmV3IEZsb2F0MzJBcnJheShfaGxmU2l6ZSksIFxuXHRcdFx0bWFnbml0dWRlOiBuZXcgRmxvYXQzMkFycmF5KF9obGZTaXplKSwgXG5cdFx0XHRwaGFzZTogbmV3IEZsb2F0MzJBcnJheShfaGxmU2l6ZSlcblx0XHR9LCBcblx0XHRwdk91dCA6IHtcblx0XHRcdHJlYWw6IGNyZWF0ZV9jb25zdGFudF9hcnJheShfd2luU2l6ZSwgMCwgRmxvYXQzMkFycmF5KSwgXG5cdFx0XHRpbWFnOiBjcmVhdGVfY29uc3RhbnRfYXJyYXkoX3dpblNpemUsIDAsIEZsb2F0MzJBcnJheSksIFxuXHRcdFx0bWFnbml0dWRlOiBjcmVhdGVfY29uc3RhbnRfYXJyYXkoX3dpblNpemUsIDAsIEZsb2F0MzJBcnJheSksIFxuXHRcdFx0cGhhc2U6IGNyZWF0ZV9jb25zdGFudF9hcnJheShfd2luU2l6ZSwgMCwgRmxvYXQzMkFycmF5KVxuXHRcdH0sXG5cdFx0cHJvY2Vzc2VkRnJhbWUgOiBuZXcgRmxvYXQzMkFycmF5KF93aW5TaXplKVxuXHR9O1xuXG5cdHZhciBfcHZfc3RlcCA9IHtcblx0XHRpbnN0UGhhc2VBZHYgOiBuZXcgRmxvYXQzMkFycmF5KF9obGZTaXplKSwgXG5cdFx0cGhUaCA6IG5ldyBGbG9hdDMyQXJyYXkoX2hsZlNpemUpXG5cdH07XG5cblx0dmFyIF9TVEZUID0ge1xuXHRcdF9pbnB1dEZyYW1lIDogbmV3IEZsb2F0MzJBcnJheShfd2luU2l6ZSksXG5cdFx0X3plcm9zOiBuZXcgRmxvYXQzMkFycmF5KF93aW5TaXplKVxuXHR9XG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0dmFyIHBoVGhfaWR4ID0gMDtcblx0dmFyIHR3b1BJID0gMiAqIFBJO1xuXHR2YXIgZXhwZWN0ZWRQaGFzZUFkdiwgYXV4SGV0ZXJvZHluZWRQaGFzZUluY3IsIGhldGVyb2R5bmVkUGhhc2VJbmNyLCBcblx0XHRpbnN0UGhhc2VBZHZQZXJTYW1wbGVIb3AsIGluc3RQaGFzZUFkdl8sIHByZXZJbnN0UGhhc2VBZHZfO1xuXHRcblx0ZnVuY3Rpb24gb3ZlcmxhcF9hbmRfc2xpZGUoSHMsIGluRiwgc3F1YXJlZFdpbkYsIG9CdWYsIG93T0J1Ziwgd2luZG93U2l6ZSwgb3V0Rikge1xuXG5cdFx0dmFyIG93U2FtcGxlLCBvU2FtcGxlID0gMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBIczsgaSsrKSB7XG5cdCAgICAgIG93U2FtcGxlID0gb3dPQnVmLnNoaWZ0KCkgfHwgMDtcblx0ICAgICAgb1NhbXBsZSAgPSBvQnVmLnNoaWZ0KCkgfHwgMDtcblx0ICAgICAgb3V0Ri5wdXNoKG9TYW1wbGUgLyAoKG93U2FtcGxlPDEwZS0zKT8gMSA6IG93U2FtcGxlKSk7XG5cdCAgICAgIG9CdWYucHVzaCgwKTtcblx0ICAgICAgb3dPQnVmLnB1c2goMCk7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG5cdCAgICAgIG9TYW1wbGUgPSBvQnVmLnNoaWZ0KCk7XG5cdCAgICAgIG9CdWYucHVzaChpbkZbaV0gKyBvU2FtcGxlKTtcblx0ICAgICAgb3dTYW1wbGUgPSBvd09CdWYuc2hpZnQoKTtcblx0ICAgICAgb3dPQnVmLnB1c2goc3F1YXJlZFdpbkZbaV0gKyBvd1NhbXBsZSk7XG5cdCAgICB9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHB2X3N0ZXAoZmZ0T2JqLCBwcmV2SW5QaCwgcHJldk91dFBoLCBvbWVnYSwgSGEsIEhzLCBvdXQpIHtcblxuXHRcdHZhciBjdXJySW5QaCA9IGZmdE9iai5waGFzZTtcblx0XHR2YXIgbWFnID0gZmZ0T2JqLm1hZ25pdHVkZTtcblx0XHR2YXIgaW5zdFBoYXNlQWR2ID0gX3B2X3N0ZXAuaW5zdFBoYXNlQWR2O1xuXHRcdHZhciBwaFRoID0gX3B2X3N0ZXAucGhUaDtcblxuXHRcdHZhciBwZWFrLCBwcmV2UGVhaywgcmVnLCByZWdTdGFydCwgcHJldlJlZ0VuZCwgcHJldlJlZ1N0YXJ0LCBkLCBpO1xuXHRcdHBoVGhfaWR4ID0gMDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBvbWVnYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZXhwZWN0ZWRQaGFzZUFkdiA9IG9tZWdhW2ldICogSGE7XG5cblx0XHRcdGF1eEhldGVyb2R5bmVkUGhhc2VJbmNyID0gKGN1cnJJblBoW2ldIC0gcHJldkluUGhbaV0pIC0gZXhwZWN0ZWRQaGFzZUFkdjtcblx0XHRcdGhldGVyb2R5bmVkUGhhc2VJbmNyID0gYXV4SGV0ZXJvZHluZWRQaGFzZUluY3IgLSB0d29QSSAqIHJvdW5kKGF1eEhldGVyb2R5bmVkUGhhc2VJbmNyL3R3b1BJKTtcblxuXHRcdFx0aW5zdFBoYXNlQWR2UGVyU2FtcGxlSG9wID0gb21lZ2FbaV0gKyBoZXRlcm9keW5lZFBoYXNlSW5jciAvIEhhO1xuXG5cdFx0XHRpbnN0UGhhc2VBZHZfID0gaW5zdFBoYXNlQWR2UGVyU2FtcGxlSG9wICogSHM7XG5cblx0XHRcdGlmIChtYWdbaV0gPiBtYXgoKG1hZ1tpLTJdfDApLCAobWFnW2ktMV18MCksIChtYWdbaSsxXXwwKSwgKG1hZ1tpKzJdfDApKSkge1xuXHRcdFx0Ly8gaWYgKG1hZ1tpXSA+IChtYWdbaS0yXXwwKSAmJiBtYWdbaV0gPiAobWFnW2ktMV18MCkgJiYgbWFnW2ldID4gKG1hZ1tpKzFdfDApICYmIG1hZ1tpXSA+IChtYWdbaSsyXXwwKSkge1xuXHRcdFx0XHRwZWFrID0gaTtcblx0XHRcdFx0cmVnU3RhcnQgPSBjZWlsKChwcmV2UGVhayArIHBlYWspLzIpIHwgMDsgXG5cdFx0XHRcdHByZXZSZWdFbmQgPSByZWdTdGFydC0xO1xuXHRcdFx0XHRyZWcgPSBtYXgoMCwgcHJldlJlZ0VuZCAtIHByZXZSZWdTdGFydCArIDEpO1xuXHRcdFx0XHRwcmV2UmVnU3RhcnQgPSByZWdTdGFydDtcblx0XHRcdFx0Zm9yIChkID0gMDsgZCA8IHJlZzsgZCsrLCBwaFRoX2lkeCsrKSB7XG5cdFx0XHRcdFx0cGhUaFtwaFRoX2lkeF0gPSBwcmV2T3V0UGhbcHJldlBlYWtdICsgcHJldkluc3RQaGFzZUFkdl8gLSBjdXJySW5QaFtwcmV2UGVha107XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJldlBlYWsgPSBwZWFrO1xuXHRcdFx0XHRwcmV2SW5zdFBoYXNlQWR2XyA9IGluc3RQaGFzZUFkdl87XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGZvciAodmFyIGk9MDsgaTxwaFRoLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgdGhldGEgPSBwaFRoW2ldO1xuXG5cdFx0XHR2YXIgcGhUaFJlID0gY29zKHBoVGhbaV0pO1xuXHRcdFx0dmFyIHBoVGhJbSA9IHNpbihwaFRoW2ldKTtcblx0XHRcdFxuXHRcdFx0b3V0LnJlYWxbaV0gPSBwaFRoUmUgKiBmZnRPYmoucmVhbFtpXSAtIHBoVGhJbSAqIGZmdE9iai5pbWFnW2ldO1xuXHRcdFx0b3V0LmltYWdbaV0gPSBwaFRoUmUgKiBmZnRPYmouaW1hZ1tpXSArIHBoVGhJbSAqIGZmdE9iai5yZWFsW2ldO1xuXHRcdFx0b3V0LnBoYXNlW2ldID0gYXRhbjIob3V0LmltYWdbaV0sIG91dC5yZWFsW2ldKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuO1xuXHR9XG5cblxuXHR0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihpbnB1dEFycmF5LCBvdXRwdXRBcnJheSkge1xuXG5cdFx0dmFyIF8gPSB0aGlzO1xuXG5cdFx0dmFyIF9fSHMgPSBfSHM7XG5cdFx0dmFyIF9fSGEgPSBfSGE7XG5cblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0Ly8gLS0tLS0tLS0tLUFOQUxZU0lTIFNURVAtLS0tLS0tLS0tLVxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRcblx0XHR2YXIgcHJvY2Vzc2VkRnJhbWUgPSBfcHJvY2Vzcy5wcm9jZXNzZWRGcmFtZTs7XG5cdFx0dmFyIGZmdE9iaiA9IF9wcm9jZXNzLmZmdE9iajtcblx0XHQvLyBGT1IgU09NRSBSRUFTT04sIElGIEkgRE9OJ1QgQ1JFQVRFIEEgTkVXIFwicGhhc2VcIiBBUkhhWSwgSSBHRVQgQVJUSUZBQ1RTLlxuXHRcdC8vIGZmdE9iai5waGFzZSA9IG5ldyBGbG9hdDMyQXJyYXkoX2hsZlNpemUpOyBcblx0XHR2YXIgcHZPdXQgPSBfcHJvY2Vzcy5wdk91dDtcblx0XHRfLlNURlQoaW5wdXRBcnJheSwgX2ZyYW1pbmdXaW5kb3csIF9obGZTaXplLCBmZnRPYmopO1xuXHRcdHB2X3N0ZXAoZmZ0T2JqLCBfcHJldmlvdXNJbnB1dFBoYXNlLCBfcHJldmlvdXNPdXRwdXRQaGFzZSwgX29tZWdhLCBfX0hhLCBfX0hzLCBwdk91dCk7XG5cdFx0X3ByZXZpb3VzT3V0cHV0UGhhc2UgPSBwdk91dC5waGFzZTtcblx0XHQvLyBUaGUgXCJwaGFzZVwiIGlzc3VlIG1lbnRpb25lZCBhYm92ZSBpcyByZWxhdGVkIHRvIHRoaXMgbGluZS4gXG5cdFx0Ly8gSWYgSSBjcmVhdGUgYSBuZXcgRmxvYXQgYXJyYXkgdXNpbmcgdGhlIHBoYXNlIGFycmF5LCBJIGdldCBubyBpc3N1ZXMuXG5cdFx0X3ByZXZpb3VzSW5wdXRQaGFzZSA9IG5ldyBGbG9hdDMyQXJyYXkoZmZ0T2JqLnBoYXNlKTsgXG5cdFx0Xy5JU1RGVChwdk91dC5yZWFsLCBwdk91dC5pbWFnLCBfZnJhbWluZ1dpbmRvdywgZmFsc2UsIHByb2Nlc3NlZEZyYW1lKTtcblxuXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdC8vIC0tLS0tLU9WRVJMQVAgQU5EIFNMSURFIFNURVAtLS0tLS1cblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0Ly8gdmFyIG91dHB1dEZyYW1lID0gbmV3IEFycmF5KF9fSHMpO1xuXG5cdFx0b3ZlcmxhcF9hbmRfc2xpZGUoX19IcywgcHJvY2Vzc2VkRnJhbWUsIF9zcXVhcmVkRnJhbWluZ1dpbmRvdywgX292ZXJsYXBCdWZmZXJzLCBfb3dPdmVybGFwQnVmZmVycywgX3dpblNpemUsIG91dHB1dEFycmF5KTtcblxuXHRcdHJldHVybiBfX0hzO1xuXG5cdH1cblxuXHRcblx0dGhpcy5TVEZUID0gZnVuY3Rpb24oaW5wdXRGcmFtZSwgd2luZG93RnJhbWUsIHdhbnRlZFNpemUsIG91dCkge1xuXHRcdHRoaXMuU1RGVF9kcm9tKGlucHV0RnJhbWUsIHdpbmRvd0ZyYW1lLCB3YW50ZWRTaXplLCBvdXQpO1xuXHR9XG5cblx0dGhpcy5TVEZUX2Ryb20gPSBmdW5jdGlvbihpbnB1dEZyYW1lLCB3aW5kb3dGcmFtZSwgd2FudGVkU2l6ZSwgb3V0KSB7XG5cdFx0dmFyIHdpblNpemUgPSB3aW5kb3dGcmFtZS5sZW5ndGg7XG5cdFx0dmFyIF9pbnB1dEZyYW1lID0gX1NURlQuX2lucHV0RnJhbWU7XG5cblx0XHRmb3IgKHZhciBpPTA7IGk8d2luU2l6ZTsgaSsrKSB7XG5cdFx0XHRfaW5wdXRGcmFtZVtpXSA9IGlucHV0RnJhbWVbaV0gKiB3aW5kb3dGcmFtZVtpXTtcblx0XHR9XG5cdFx0XG5cdFx0ZmZ0LmZvcndhcmQoX2lucHV0RnJhbWUpO1xuXHRcdG91dC5yZWFsID0gZmZ0LnJlYWw7XG5cdFx0b3V0LmltYWcgPSBmZnQuaW1hZztcblx0XHRcblx0XHR2YXIgUiA9IG91dC5yZWFsOyB2YXIgSSA9IG91dC5pbWFnO1xuXHRcdHZhciBQID0gb3V0LnBoYXNlOyB2YXIgTSA9IG91dC5tYWduaXR1ZGU7XG5cblx0XHRmb3IgKHZhciBwPTA7IHA8d2luU2l6ZSAmJiBwPHdhbnRlZFNpemU7IHArKykge1x0XG5cdFx0XHRNW3BdID0gc3FydChJW3BdKklbcF0gKyBSW3BdKlJbcF0pICogMTAwMDtcblx0XHRcdFBbcF0gPSBhdGFuMihJW3BdLCBSW3BdKTtcblx0XHR9XG5cblx0XHRyZXR1cm47XG5cdH1cblxuXG5cblx0dGhpcy5JU1RGVCA9IGZ1bmN0aW9uKHJlYWwsIGltYWcsIHdpbmRvd0ZyYW1lLCByZXN0b3JlRW5lcmd5LCB0aW1lRnJhbWUpIHtcblx0XHR0aGlzLklTVEZUX2Ryb20ocmVhbCwgaW1hZywgd2luZG93RnJhbWUsIHJlc3RvcmVFbmVyZ3ksIHRpbWVGcmFtZSk7XG5cdH1cblxuXHR0aGlzLklTVEZUX2Ryb20gPSBmdW5jdGlvbihyZWFsLCBpbWFnLCB3aW5kb3dGcmFtZSwgcmVzdG9yZUVuZXJneSwgdGltZUZyYW1lKSB7XG5cblx0XHRmZnQuaW52ZXJzZShyZWFsLCBpbWFnLCB0aW1lRnJhbWUpO1xuXG5cdFx0cmV0dXJuO1xuXG5cdH1cblxuXG5cblx0dGhpcy5pbml0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHRfb21lZ2EgPSBjcmVhdGVfb21lZ2FfYXJyYXkod2luU2l6ZSk7XG5cblx0XHR0aGlzLnJlc2V0X3BoYXNlc19hbmRfb3ZlcmxhcF9idWZmZXJzKCk7XG5cblx0XHRfZnJhbWluZ1dpbmRvdyA9IGNyZWF0ZV9zaW5fYmV0YV93aW5kb3dfYXJyYXkod2luU2l6ZSwgMSk7XG5cblx0XHRfc3F1YXJlZEZyYW1pbmdXaW5kb3cgPSBfZnJhbWluZ1dpbmRvdy5tYXAoZnVuY3Rpb24oeCxpKXsgcmV0dXJuIHgqeDsgfSk7XG5cblx0XHR0aGlzLnNldF9hbHBoYSgxKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZV9vbWVnYV9hcnJheShzaXplKSB7XG5cdFx0cmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIEFycmF5KHNpemUvMiArIDEpKS5tYXAoZnVuY3Rpb24gKHgsIGkpIHsgXG5cdFx0XHRyZXR1cm4gdHdvUEkgKiBpIC8gc2l6ZTtcblx0XHR9KTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gY3JlYXRlX3Npbl9iZXRhX3dpbmRvd19hcnJheShzaXplLCBiZXRhKSB7XG5cdFx0cmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIEFycmF5KHNpemUpKS5tYXAoZnVuY3Rpb24oeCxpKXtcblx0XHRcdHJldHVybiBwb3coc2luKFBJICogaSAvIHNpemUpLCBiZXRhKTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZV9jb25zdGFudF9hcnJheShzaXplLCBjb25zdGFudCwgQXJyYXlUeXBlKSB7XG5cdFx0dmFyIGFyciA9IG5ldyAoKEFycmF5VHlwZSk/QXJyYXlUeXBlOkFycmF5KShzaXplKTtcblx0XHRmb3IgKHZhciBpPTA7IGk8c2l6ZTsgaSsrKSBcblx0XHRcdGFycltpXSA9IGNvbnN0YW50O1xuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHR0aGlzLnJlc2V0X3BoYXNlc19hbmRfb3ZlcmxhcF9idWZmZXJzID0gZnVuY3Rpb24oKSB7XG5cblx0XHRfcHJldmlvdXNJbnB1dFBoYXNlID0gY3JlYXRlX2NvbnN0YW50X2FycmF5KHdpblNpemUvMiwgMCk7XG5cdFx0X3ByZXZpb3VzT3V0cHV0UGhhc2UgPSBjcmVhdGVfY29uc3RhbnRfYXJyYXkod2luU2l6ZS8yLCAwKTtcblxuXHRcdF9vdmVybGFwQnVmZmVycyA9IG5ldyBDQnVmZmVyKHdpblNpemUpO1xuXHRcdF9vd092ZXJsYXBCdWZmZXJzID0gbmV3IENCdWZmZXIod2luU2l6ZSk7XG5cdFx0Zm9yICh2YXIgaT0wOyBpIDwgd2luU2l6ZTsgaSsrKSB7XG5cdFx0XHRfb3ZlcmxhcEJ1ZmZlcnMucHVzaCgwKTtcblx0XHRcdF9vd092ZXJsYXBCdWZmZXJzLnB1c2goMCk7XG5cdFx0fVxuXG5cdFx0X2ZpcnN0ID0gdHJ1ZTtcblx0fVxuXG5cdHRoaXMucmVzZXRfcGhhc2VzID0gZnVuY3Rpb24oKSB7XG5cblx0XHRfcHJldmlvdXNJbnB1dFBoYXNlID0gY3JlYXRlX2NvbnN0YW50X2FycmF5KHdpblNpemUvMiwgMCk7XG5cdFx0X3ByZXZpb3VzT3V0cHV0UGhhc2UgPSBjcmVhdGVfY29uc3RhbnRfYXJyYXkod2luU2l6ZS8yLCAwKTtcblxuXHRcdF9maXJzdCA9IHRydWU7XG5cdH1cblxuXG5cdHRoaXMuZ2V0X3ByZXZpb3VzX2lucHV0X3BoYXNlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF9wcmV2aW91c0lucHV0UGhhc2U7XG5cdH1cblxuXHR0aGlzLmdldF9wcmV2aW91c19vdXRwdXRfcGhhc2UgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX3ByZXZpb3VzT3V0cHV0UGhhc2U7XG5cdH1cblxuXHR0aGlzLmdldF9hbmFseXNpc19ob3AgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX0hhO1xuXHR9XG5cblx0dGhpcy5nZXRfc3ludGhlc2lzX2hvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfSHM7XG5cdH1cblxuXHR0aGlzLmdldF9hbHBoYSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfSHMgLyBfSGE7XG5cdH1cblxuXHR0aGlzLmdldF9mcmFtaW5nX3dpbmRvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfZnJhbWluZ1dpbmRvdztcblx0fVxuXG5cdHRoaXMuZ2V0X3NxdWFyZWRfZnJhbWluZ193aW5kb3cgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX3NxdWFyZWRGcmFtaW5nV2luZG93O1xuXHR9XG5cblx0dGhpcy5zZXRfYWxwaGEgPSBmdW5jdGlvbihuZXdBbHBoYSkge1xuXHRcdF9sYXN0SW5wdXRBbHBoYSA9IG5ld0FscGhhO1xuXHRcdGlmIChuZXdBbHBoYSA8PSAwLjgpXG5cdFx0XHRfb3ZlcmxhcEZhY3RvciA9IDI7XG5cdFx0ZWxzZSBpZiAobmV3QWxwaGEgPD0gMSlcblx0XHRcdF9vdmVybGFwRmFjdG9yID0gNDtcblx0XHRlbHNlXG5cdFx0XHRfb3ZlcmxhcEZhY3RvciA9IDU7XG5cblx0XHQvKiBcIkZpeGVkXCIgc3ludGhlc2lzIGhvcCBzaXplLiAqL1xuXHRcdF9IYSA9IHJvdW5kKF93aW5TaXplL19vdmVybGFwRmFjdG9yKTtcblx0XHRfSHMgPSByb3VuZChuZXdBbHBoYSAqIF9IYSk7XG5cdFx0XG5cdFx0Ly8gX0hzID0gX0hhO1xuXG5cdFx0Ly8gX0hzID0gcm91bmQoX3dpblNpemUvMik7XG5cdFx0Ly8gX0hhID0gcm91bmQoX0hzIC8gbmV3QWxwaGEpO1xuXHR9XG5cblx0dGhpcy5nZXRfYWxwaGFfc3RlcCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAxL19IYTtcblx0fVxuXG5cdHRoaXMuc2V0X2hvcHMgPSBmdW5jdGlvbihIYSwgSHMpIHtcblx0XHRfSGEgPSBIYTtcblx0XHRfSHMgPSBIcztcblx0fVxuXG5cdHRoaXMuZ2V0X3NwZWNpZmllZF9hbHBoYSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfbGFzdElucHV0QWxwaGE7XG5cdH1cblxuXHR0aGlzLnNldF9vdmVybGFwX2ZhY3RvciA9IGZ1bmN0aW9uKG92ZXJsYXBGYWN0b3IpIHtcblx0XHRfb3ZlcmxhcEZhY3RvciA9IG92ZXJsYXBGYWN0b3I7XG5cdFx0dGhpcy5zZXRfYWxwaGEoX2xhc3RJbnB1dEFscGhhKTtcblx0fVxufVxuXG5leHBvcnQgZGVmYXVsdCBQaGFzZVZvY29kZXI7IiwiLyogIEZyb20gUGhhc2VWb2NvZGVyLmpzIChjKSAyMDE1IGJ5IEVjaG82NlxuICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9lY2hvNjYvUGhhc2VWb2NvZGVySlNcblxuXHRUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG5cdGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IENCdWZmZXIgZnJvbSAnLi9jYnVmZmVyJztcbmltcG9ydCBQaGFzZVZvY29kZXIgZnJvbSAnLi9QVl9mYXN0XzUnO1xuaW1wb3J0IGF1ZGlvQ29udGV4dCBmcm9tICcuLi9jb3JlL2F1ZGlvLWNvbnRleHQnO1xuXG5mdW5jdGlvbiBCdWZmZXJlZFBWKGZyYW1lU2l6ZSkge1xuXG5cdHZhciBfZnJhbWVTaXplID0gZnJhbWVTaXplIHx8IDQwOTY7XG5cdHZhciBfcHZMID0gbmV3IFBoYXNlVm9jb2RlcihfZnJhbWVTaXplLCBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7IF9wdkwuaW5pdCgpO1xuXHR2YXIgX3B2UiA9IG5ldyBQaGFzZVZvY29kZXIoX2ZyYW1lU2l6ZSwgYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpOyBfcHZSLmluaXQoKTtcblx0dmFyIF9idWZmZXI7XG5cdHZhciBfcG9zaXRpb24gPSAwO1xuXHR2YXIgX25ld0FscGhhID0gMTtcblxuXHR2YXIgX21pZEJ1ZkwgPSBuZXcgQ0J1ZmZlcihNYXRoLnJvdW5kKF9mcmFtZVNpemUgKiAyKSk7XG5cdHZhciBfbWlkQnVmUiA9IG5ldyBDQnVmZmVyKE1hdGgucm91bmQoX2ZyYW1lU2l6ZSAqIDIpKTtcblxuXHR0aGlzLnByb2Nlc3NNb25vID0gZnVuY3Rpb24ob3V0cHV0QXVkaW9CdWZmZXIpIHtcblxuXHRcdGlmICghX2J1ZmZlcikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIk5vIGlucHV0IGJ1ZmZlclwiKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc2FtcGxlQ291bnRlciA9IDA7XG5cbiAgICAgICAgdmFyIGlsID0gX2J1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgICAgdmFyIGlyID0gX2J1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgICAgdmFyIG9sID0gb3V0cHV0QXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgIHZhciBvciA9IG91dHB1dEF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKDEpO1xuXG5cbiAgICAgICAgd2hpbGUgKF9taWRCdWZSLnNpemUgPiAwICYmIHNhbXBsZUNvdW50ZXIgPCBvdXRwdXRBdWRpb0J1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgaSA9IHNhbXBsZUNvdW50ZXIrKztcbiAgICAgICAgICBvbFtpXSA9IF9taWRCdWZMLnNoaWZ0KCk7XG4gICAgICAgICAgb3JbaV0gPSBfbWlkQnVmUi5zaGlmdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNhbXBsZUNvdW50ZXIgPT0gb3V0cHV0QXVkaW9CdWZmZXIubGVuZ3RoKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBkbyB7XG5cbiAgICAgICAgICB2YXIgYnVmTCA9IGlsLnN1YmFycmF5KF9wb3NpdGlvbiwgX3Bvc2l0aW9uICsgX2ZyYW1lU2l6ZSk7XG4gICAgICAgICAgdmFyIGJ1ZlIgPSBpci5zdWJhcnJheShfcG9zaXRpb24sIF9wb3NpdGlvbiArIF9mcmFtZVNpemUpO1xuXG4gICAgICAgICAgaWYgKF9uZXdBbHBoYSAhPSB1bmRlZmluZWQgJiYgX25ld0FscGhhICE9IF9wdkwuZ2V0X2FscGhhKCkpIHtcbiAgICAgICAgICAgIF9wdkwuc2V0X2FscGhhKF9uZXdBbHBoYSk7XG4gICAgICAgICAgICBfcHZSLnNldF9hbHBoYShfbmV3QWxwaGEpO1xuICAgICAgICAgICAgX25ld0FscGhhID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgLyogTEVGVCAqL1xuICAgICAgICAgIF9wdkwucHJvY2VzcyhidWZMLCBfbWlkQnVmTCk7XG4gICAgICAgICAgX3B2Ui5wcm9jZXNzKGJ1ZlIsIF9taWRCdWZSKTtcbiAgICAgICAgICBmb3IgKHZhciBpPXNhbXBsZUNvdW50ZXI7IF9taWRCdWZMLnNpemUgPiAwICYmIGkgPCBvdXRwdXRBdWRpb0J1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb2xbaV0gPSBfbWlkQnVmTC5zaGlmdCgpO1xuICAgICAgICAgICAgb3JbaV0gPSBfbWlkQnVmUi5zaGlmdCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNhbXBsZUNvdW50ZXIgKz0gX3B2TC5nZXRfc3ludGhlc2lzX2hvcCgpO1xuXG4gICAgICAgICAgX3Bvc2l0aW9uXG4gICAgICAgICAgICs9IF9wdkwuZ2V0X2FuYWx5c2lzX2hvcCgpO1xuXG4gICAgICAgIH0gd2hpbGUgKHNhbXBsZUNvdW50ZXIgPCBvdXRwdXRBdWRpb0J1ZmZlci5sZW5ndGgpO1xuXHR9XG5cblx0dGhpcy5wcm9jZXNzU3RlcmVvID0gZnVuY3Rpb24gKG91dHB1dEF1ZGlvQnVmZmVyKSB7XG5cblx0XHRpZiAoIV9idWZmZXIgfHwgX2J1ZmZlci5udW1iZXJPZkNoYW5uZWxzICE9IDIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJObyBpbnB1dCBidWZmZXIgb3Igd3JvbmcgbnVtYmVyIG9mIGNoYW5uZWxzXCIpXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIHNhbXBsZUNvdW50ZXIgPSAwO1xuXG5cdFx0dmFyIGlsID0gX2J1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcblx0XHR2YXIgaXIgPSBfYnVmZmVyLmdldENoYW5uZWxEYXRhKDEpO1xuXHRcdHZhciBvbCA9IG91dHB1dEF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuXHRcdHZhciBvciA9IG91dHB1dEF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKDEpO1xuXG5cblx0XHR3aGlsZSAoX21pZEJ1ZlIuc2l6ZSA+IDAgJiYgc2FtcGxlQ291bnRlciA8IG91dHB1dEF1ZGlvQnVmZmVyLmxlbmd0aCkge1xuXHRcdFx0dmFyIGkgPSBzYW1wbGVDb3VudGVyKys7XG5cdFx0XHRvbFtpXSA9IF9taWRCdWZMLnNoaWZ0KCk7XG5cdFx0XHRvcltpXSA9IF9taWRCdWZSLnNoaWZ0KCk7XG5cdFx0fVxuXG5cdFx0aWYgKHNhbXBsZUNvdW50ZXIgPT0gb3V0cHV0QXVkaW9CdWZmZXIubGVuZ3RoKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0ZG8ge1xuXG5cdFx0XHR2YXIgYnVmTCA9IGlsLnN1YmFycmF5KF9wb3NpdGlvbiwgX3Bvc2l0aW9uICsgX2ZyYW1lU2l6ZSk7XG5cdFx0XHR2YXIgYnVmUiA9IGlyLnN1YmFycmF5KF9wb3NpdGlvbiwgX3Bvc2l0aW9uICsgX2ZyYW1lU2l6ZSk7XG5cblx0XHRcdGlmIChfbmV3QWxwaGEgIT0gdW5kZWZpbmVkICYmIF9uZXdBbHBoYSAhPSBfcHZMLmdldF9hbHBoYSgpKSB7XG5cdFx0XHRcdF9wdkwuc2V0X2FscGhhKF9uZXdBbHBoYSk7XG5cdFx0XHRcdF9wdlIuc2V0X2FscGhhKF9uZXdBbHBoYSk7XG5cdFx0XHRcdF9uZXdBbHBoYSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXG5cdFx0XHQvKiBMRUZUICovXG5cdFx0XHRfcHZMLnByb2Nlc3MoYnVmTCwgX21pZEJ1ZkwpO1xuXHRcdFx0X3B2Ui5wcm9jZXNzKGJ1ZlIsIF9taWRCdWZSKTtcblx0XHRcdGZvciAodmFyIGkgPSBzYW1wbGVDb3VudGVyOyBfbWlkQnVmTC5zaXplID4gMCAmJiBpIDwgb3V0cHV0QXVkaW9CdWZmZXIubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0b2xbaV0gPSBfbWlkQnVmTC5zaGlmdCgpO1xuXHRcdFx0XHRvcltpXSA9IF9taWRCdWZSLnNoaWZ0KCk7XG5cdFx0XHR9XG5cblx0XHRcdHNhbXBsZUNvdW50ZXIgKz0gX3B2TC5nZXRfc3ludGhlc2lzX2hvcCgpO1xuXG5cdFx0XHRfcG9zaXRpb25cblx0XHRcdFx0Kz0gX3B2TC5nZXRfYW5hbHlzaXNfaG9wKCk7XG5cblx0XHR9IHdoaWxlIChzYW1wbGVDb3VudGVyIDwgb3V0cHV0QXVkaW9CdWZmZXIubGVuZ3RoKTtcblx0fVxuXG5cdHRoaXMucHJvY2VzcyA9IHRoaXMucHJvY2Vzc01vbm87XG5cblx0dGhpcy5zZXRfYXVkaW9fYnVmZmVyID0gZnVuY3Rpb24obmV3QnVmZmVyKSB7XG5cdFx0X2J1ZmZlciA9IG5ld0J1ZmZlcjtcblx0XHRpZiAoX2J1ZmZlci5udW1iZXJPZkNoYW5uZWxzID09IDIpXG5cdFx0XHR0aGlzLnByb2Nlc3MgPSB0aGlzLnByb2Nlc3NTdGVyZW87XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5wcm9jZXNzID0gdGhpcy5wcm9jZXNzTW9ubztcblxuXHRcdF9wb3NpdGlvbiA9IDA7XG5cdFx0X25ld0FscGhhID0gMTtcblx0fVxuXG5cdHRoaXMucmVzZXRQaGFzZSA9IGZ1bmN0aW9uKCkge1xuXHRcdF9wdkwucmVzZXRfcGhhc2VzKCk7XG5cdFx0X3B2Ui5yZXNldF9waGFzZXMoKTtcblx0fVxuXHRcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywge1xuXHRcdCdwb3NpdGlvbicgOiB7XG5cdFx0XHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIF9wb3NpdGlvbjtcblx0XHRcdH0sIFxuXHRcdFx0c2V0IDogZnVuY3Rpb24obmV3UG9zaXRpb24pIHtcblx0XHRcdFx0X3Bvc2l0aW9uID0gbmV3UG9zaXRpb247XG5cdFx0XHR9XG5cdFx0fSwgXG5cdFx0J2FscGhhJyA6IHtcblx0XHRcdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gX3B2TC5nZXRfYWxwaGEoKTtcblx0XHRcdH0sIFxuXHRcdFx0c2V0IDogZnVuY3Rpb24obmV3QWxwaGEpIHtcblx0XHRcdFx0X25ld0FscGhhID0gbmV3QWxwaGE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnVmZmVyZWRQVjsiLCIvKlxuXHRUaGUgTUlUIExpY2Vuc2UgKE1JVClcblx0Q29weXJpZ2h0IChjKSAyMDEzIFRyZXZvciBOb3JyaXMgPHRyZXYubm9ycmlzQGdtYWlsLmNvbT5cblxuXHRQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mXG5cdHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW5cblx0dGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xuXHR1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZlxuXHR0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG5cdHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5cdFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuXHRjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5cdFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcblx0SU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1Ncblx0Rk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SXG5cdENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUlxuXHRJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuXHRDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuKi9cblxuZnVuY3Rpb24gQ0J1ZmZlcigpIHtcblx0Ly8gaGFuZGxlIGNhc2VzIHdoZXJlIFwibmV3XCIga2V5d29yZCB3YXNuJ3QgdXNlZFxuXHRpZiAoISh0aGlzIGluc3RhbmNlb2YgQ0J1ZmZlcikpIHtcblx0XHQvLyBtdWx0aXBsZSBjb25kaXRpb25zIG5lZWQgdG8gYmUgY2hlY2tlZCB0byBwcm9wZXJseSBlbXVsYXRlIEFycmF5XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxIHx8IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdudW1iZXInKSB7XG5cdFx0XHRyZXR1cm4gQ0J1ZmZlci5hcHBseShuZXcgQ0J1ZmZlcihhcmd1bWVudHMubGVuZ3RoKSwgYXJndW1lbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIG5ldyBDQnVmZmVyKGFyZ3VtZW50c1swXSk7XG5cdFx0fVxuXHR9XG5cdC8vIGlmIG5vIGFyZ3VtZW50cywgdGhlbiBub3RoaW5nIG5lZWRzIHRvIGJlIHNldFxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcblx0dGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIEFyZ3VtZW50OiBZb3UgbXVzdCBwYXNzIGEgdmFsaWQgYnVmZmVyIGxlbmd0aCcpO1xuXHQvLyB0aGlzIGlzIHRoZSBzYW1lIGluIGVpdGhlciBzY2VuYXJpb1xuXHR0aGlzLnNpemUgPSB0aGlzLnN0YXJ0ID0gMDtcblx0Ly8gc2V0IHRvIGNhbGxiYWNrIGZuIGlmIGRhdGEgaXMgYWJvdXQgdG8gYmUgb3ZlcndyaXR0ZW5cblx0dGhpcy5vdmVyZmxvdyA9IG51bGw7XG5cdC8vIGVtdWxhdGUgQXJyYXkgYmFzZWQgb24gcGFzc2VkIGFyZ3VtZW50c1xuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgfHwgdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ251bWJlcicpIHtcblx0XHR0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXHRcdHRoaXMuZW5kID0gKHRoaXMubGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCkgLSAxO1xuXHRcdHRoaXMucHVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9IGVsc2Uge1xuXHRcdHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYXJndW1lbnRzWzBdKTtcblx0XHR0aGlzLmVuZCA9ICh0aGlzLmxlbmd0aCA9IGFyZ3VtZW50c1swXSkgLSAxO1xuXHR9XG5cdC8vIG5lZWQgdG8gYHJldHVybiB0aGlzYCBzbyBgcmV0dXJuIENCdWZmZXIuYXBwbHlgIHdvcmtzXG5cdHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyaXRvcihhLCBiKSB7XG5cdHJldHVybiBhID09IGIgPyAwIDogYSA+IGIgPyAxIDogLTE7XG59XG5cbkNCdWZmZXIucHJvdG90eXBlID0ge1xuXHQvLyBwcm9wZXJseSBzZXQgY29uc3RydWN0b3Jcblx0Y29uc3RydWN0b3IgOiBDQnVmZmVyLFxuXG5cdC8qIG11dGF0b3IgbWV0aG9kcyAqL1xuXHQvLyBwb3AgbGFzdCBpdGVtXG5cdHBvcCA6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaXRlbTtcblx0XHRpZiAodGhpcy5zaXplID09PSAwKSByZXR1cm47XG5cdFx0aXRlbSA9IHRoaXMuZGF0YVt0aGlzLmVuZF07XG5cdFx0Ly8gcmVtb3ZlIHRoZSByZWZlcmVuY2UgdG8gdGhlIG9iamVjdCBzbyBpdCBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcblx0XHRkZWxldGUgdGhpcy5kYXRhW3RoaXMuZW5kXTtcblx0XHR0aGlzLmVuZCA9ICh0aGlzLmVuZCAtIDEgKyB0aGlzLmxlbmd0aCkgJSB0aGlzLmxlbmd0aDtcblx0XHR0aGlzLnNpemUtLTtcblx0XHRyZXR1cm4gaXRlbTtcblx0fSxcblx0Ly8gcHVzaCBpdGVtIHRvIHRoZSBlbmRcblx0cHVzaCA6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Ly8gY2hlY2sgaWYgb3ZlcmZsb3cgaXMgc2V0LCBhbmQgaWYgZGF0YSBpcyBhYm91dCB0byBiZSBvdmVyd3JpdHRlblxuXHRcdGlmICh0aGlzLm92ZXJmbG93ICYmIHRoaXMuc2l6ZSArIGFyZ3VtZW50cy5sZW5ndGggPiB0aGlzLmxlbmd0aCkge1xuXHRcdFx0Ly8gY2FsbCBvdmVyZmxvdyBmdW5jdGlvbiBhbmQgc2VuZCBkYXRhIHRoYXQncyBhYm91dCB0byBiZSBvdmVyd3JpdHRlblxuXHRcdFx0Zm9yICg7IGkgPCB0aGlzLnNpemUgKyBhcmd1bWVudHMubGVuZ3RoIC0gdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLm92ZXJmbG93KHRoaXMuZGF0YVsodGhpcy5lbmQgKyBpICsgMSkgJSB0aGlzLmxlbmd0aF0sIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBwdXNoIGl0ZW1zIHRvIHRoZSBlbmQsIHdyYXBwaW5nIGFuZCBlcmFzaW5nIGV4aXN0aW5nIGl0ZW1zXG5cdFx0Ly8gdXNpbmcgYXJndW1lbnRzIHZhcmlhYmxlIGRpcmVjdGx5IHRvIHJlZHVjZSBnYyBmb290cHJpbnRcblx0XHRmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLmRhdGFbKHRoaXMuZW5kICsgaSArIDEpICUgdGhpcy5sZW5ndGhdID0gYXJndW1lbnRzW2ldO1xuXHRcdH1cblx0XHQvLyByZWNhbGN1bGF0ZSBzaXplXG5cdFx0aWYgKHRoaXMuc2l6ZSA8IHRoaXMubGVuZ3RoKSB7XG5cdFx0XHRpZiAodGhpcy5zaXplICsgaSA+IHRoaXMubGVuZ3RoKSB0aGlzLnNpemUgPSB0aGlzLmxlbmd0aDtcblx0XHRcdGVsc2UgdGhpcy5zaXplICs9IGk7XG5cdFx0fVxuXHRcdC8vIHJlY2FsY3VsYXRlIGVuZFxuXHRcdHRoaXMuZW5kID0gKHRoaXMuZW5kICsgaSkgJSB0aGlzLmxlbmd0aDtcblx0XHQvLyByZWNhbGN1bGF0ZSBzdGFydFxuXHRcdHRoaXMuc3RhcnQgPSAodGhpcy5sZW5ndGggKyB0aGlzLmVuZCAtIHRoaXMuc2l6ZSArIDEpICUgdGhpcy5sZW5ndGg7XG5cdFx0Ly8gcmV0dXJuIG51bWJlciBjdXJyZW50IG51bWJlciBvZiBpdGVtcyBpbiBDQnVmZmVyXG5cdFx0cmV0dXJuIHRoaXMuc2l6ZTtcblx0fSxcblx0Ly8gcmV2ZXJzZSBvcmRlciBvZiB0aGUgYnVmZmVyXG5cdHJldmVyc2UgOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0dG1wO1xuXHRcdGZvciAoOyBpIDwgfn4odGhpcy5zaXplIC8gMik7IGkrKykge1xuXHRcdFx0dG1wID0gdGhpcy5kYXRhWyh0aGlzLnN0YXJ0ICsgaSkgJSB0aGlzLmxlbmd0aF07XG5cdFx0XHR0aGlzLmRhdGFbKHRoaXMuc3RhcnQgKyBpKSAlIHRoaXMubGVuZ3RoXSA9IHRoaXMuZGF0YVsodGhpcy5zdGFydCArICh0aGlzLnNpemUgLSBpIC0gMSkpICUgdGhpcy5sZW5ndGhdO1xuXHRcdFx0dGhpcy5kYXRhWyh0aGlzLnN0YXJ0ICsgKHRoaXMuc2l6ZSAtIGkgLSAxKSkgJSB0aGlzLmxlbmd0aF0gPSB0bXA7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHQvLyByb3RhdGUgYnVmZmVyIHRvIHRoZSBsZWZ0IGJ5IGNudHIsIG9yIGJ5IDFcblx0cm90YXRlTGVmdCA6IGZ1bmN0aW9uIChjbnRyKSB7XG5cdFx0aWYgKHR5cGVvZiBjbnRyID09PSAndW5kZWZpbmVkJykgY250ciA9IDE7XG5cdFx0aWYgKHR5cGVvZiBjbnRyICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKTtcblx0XHR3aGlsZSAoLS1jbnRyID49IDApIHtcblx0XHRcdHRoaXMucHVzaCh0aGlzLnNoaWZ0KCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0Ly8gcm90YXRlIGJ1ZmZlciB0byB0aGUgcmlnaHQgYnkgY250ciwgb3IgYnkgMVxuXHRyb3RhdGVSaWdodCA6IGZ1bmN0aW9uIChjbnRyKSB7XG5cdFx0aWYgKHR5cGVvZiBjbnRyID09PSAndW5kZWZpbmVkJykgY250ciA9IDE7XG5cdFx0aWYgKHR5cGVvZiBjbnRyICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKTtcblx0XHR3aGlsZSAoLS1jbnRyID49IDApIHtcblx0XHRcdHRoaXMudW5zaGlmdCh0aGlzLnBvcCgpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdC8vIHJlbW92ZSBhbmQgcmV0dXJuIGZpcnN0IGl0ZW1cblx0c2hpZnQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGl0ZW07XG5cdFx0Ly8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBpdGVtcyBpbiBDQnVmZlxuXHRcdGlmICh0aGlzLnNpemUgPT09IDApIHJldHVybjtcblx0XHQvLyBzdG9yZSBmaXJzdCBpdGVtIGZvciByZXR1cm5cblx0XHRpdGVtID0gdGhpcy5kYXRhW3RoaXMuc3RhcnRdO1xuXHRcdC8vIHJlY2FsY3VsYXRlIHN0YXJ0IG9mIENCdWZmZXJcblx0XHR0aGlzLnN0YXJ0ID0gKHRoaXMuc3RhcnQgKyAxKSAlIHRoaXMubGVuZ3RoO1xuXHRcdC8vIGRlY3JlbWVudCBzaXplXG5cdFx0dGhpcy5zaXplLS07XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH0sXG5cdC8vIHNvcnQgaXRlbXNcblx0c29ydCA6IGZ1bmN0aW9uIChmbikge1xuXHRcdC8vIHRoaXMuZGF0YS5zb3J0KGZuIHx8IGRlZmF1bHRDb21wYXJpdG9yKTtcblx0XHQvLyB0aGlzLnN0YXJ0ID0gMDtcblx0XHQvLyB0aGlzLmVuZCA9IHRoaXMuc2l6ZSAtIDE7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdC8vIGFkZCBpdGVtIHRvIGJlZ2lubmluZyBvZiBidWZmZXJcblx0dW5zaGlmdCA6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Ly8gY2hlY2sgaWYgb3ZlcmZsb3cgaXMgc2V0LCBhbmQgaWYgZGF0YSBpcyBhYm91dCB0byBiZSBvdmVyd3JpdHRlblxuXHRcdGlmICh0aGlzLm92ZXJmbG93ICYmIHRoaXMuc2l6ZSArIGFyZ3VtZW50cy5sZW5ndGggPiB0aGlzLmxlbmd0aCkge1xuXHRcdFx0Ly8gY2FsbCBvdmVyZmxvdyBmdW5jdGlvbiBhbmQgc2VuZCBkYXRhIHRoYXQncyBhYm91dCB0byBiZSBvdmVyd3JpdHRlblxuXHRcdFx0Zm9yICg7IGkgPCB0aGlzLnNpemUgKyBhcmd1bWVudHMubGVuZ3RoIC0gdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR0aGlzLm92ZXJmbG93KHRoaXMuZGF0YVt0aGlzLmVuZCAtIChpICUgdGhpcy5sZW5ndGgpXSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuZGF0YVsodGhpcy5sZW5ndGggKyB0aGlzLnN0YXJ0IC0gKGkgJSB0aGlzLmxlbmd0aCkgLSAxKSAlIHRoaXMubGVuZ3RoXSA9IGFyZ3VtZW50c1tpXTtcblx0XHR9XG5cdFx0aWYgKHRoaXMubGVuZ3RoIC0gdGhpcy5zaXplIC0gaSA8IDApIHtcblx0XHRcdHRoaXMuZW5kICs9IHRoaXMubGVuZ3RoIC0gdGhpcy5zaXplIC0gaTtcblx0XHRcdGlmICh0aGlzLmVuZCA8IDApIHRoaXMuZW5kID0gdGhpcy5sZW5ndGggKyAodGhpcy5lbmQgJSB0aGlzLmxlbmd0aCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLnNpemUgPCB0aGlzLmxlbmd0aCkge1xuXHRcdFx0aWYgKHRoaXMuc2l6ZSArIGkgPiB0aGlzLmxlbmd0aCkgdGhpcy5zaXplID0gdGhpcy5sZW5ndGg7XG5cdFx0XHRlbHNlIHRoaXMuc2l6ZSArPSBpO1xuXHRcdH1cblx0XHR0aGlzLnN0YXJ0IC09IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKHRoaXMuc3RhcnQgPCAwKSB0aGlzLnN0YXJ0ID0gdGhpcy5sZW5ndGggKyAodGhpcy5zdGFydCAlIHRoaXMubGVuZ3RoKTtcblx0XHRyZXR1cm4gdGhpcy5zaXplO1xuXHR9LFxuXG5cdC8qIGFjY2Vzc29yIG1ldGhvZHMgKi9cblx0Ly8gcmV0dXJuIGluZGV4IG9mIGZpcnN0IG1hdGNoZWQgZWxlbWVudFxuXHRpbmRleE9mIDogZnVuY3Rpb24gKGFyZywgaWR4KSB7XG5cdFx0aWYgKCFpZHgpIGlkeCA9IDA7XG5cdFx0Zm9yICg7IGlkeCA8IHRoaXMuc2l6ZTsgaWR4KyspIHtcblx0XHRcdGlmICh0aGlzLmRhdGFbKHRoaXMuc3RhcnQgKyBpZHgpICUgdGhpcy5sZW5ndGhdID09PSBhcmcpIHJldHVybiBpZHg7XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblx0Ly8gcmV0dXJuIGxhc3QgaW5kZXggb2YgdGhlIGZpcnN0IG1hdGNoXG5cdGxhc3RJbmRleE9mIDogZnVuY3Rpb24gKGFyZywgaWR4KSB7XG5cdFx0aWYgKCFpZHgpIGlkeCA9IHRoaXMuc2l6ZSAtIDE7XG5cdFx0Zm9yICg7IGlkeCA+PSAwOyBpZHgtLSkge1xuXHRcdFx0aWYgKHRoaXMuZGF0YVsodGhpcy5zdGFydCArIGlkeCkgJSB0aGlzLmxlbmd0aF0gPT09IGFyZykgcmV0dXJuIGlkeDtcblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdC8vIHJldHVybiB0aGUgaW5kZXggYW4gaXRlbSB3b3VsZCBiZSBpbnNlcnRlZCB0byBpZiB0aGlzXG5cdC8vIGlzIGEgc29ydGVkIGNpcmN1bGFyIGJ1ZmZlclxuXHRzb3J0ZWRJbmRleCA6IGZ1bmN0aW9uKHZhbHVlLCBjb21wYXJpdG9yLCBjb250ZXh0KSB7XG5cdFx0Y29tcGFyaXRvciA9IGNvbXBhcml0b3IgfHwgZGVmYXVsdENvbXBhcml0b3I7XG5cdFx0dmFyIGxvdyA9IHRoaXMuc3RhcnQsXG5cdFx0XHRoaWdoID0gdGhpcy5zaXplIC0gMTtcblxuXHRcdC8vIFRyaWNreSBwYXJ0IGlzIGZpbmRpbmcgaWYgaXRzIGJlZm9yZSBvciBhZnRlciB0aGUgcGl2b3Rcblx0XHQvLyB3ZSBjYW4gZ2V0IHRoaXMgaW5mbyBieSBjaGVja2luZyBpZiB0aGUgdGFyZ2V0IGlzIGxlc3MgdGhhblxuXHRcdC8vIHRoZSBsYXN0IGl0ZW0uIEFmdGVyIHRoYXQgaXQncyBqdXN0IGEgdHlwaWNhbCBiaW5hcnkgc2VhcmNoLlxuXHRcdGlmIChsb3cgJiYgY29tcGFyaXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCB0aGlzLmRhdGFbaGlnaF0pID4gMCkge1xuXHRcdFx0bG93ID0gMCwgaGlnaCA9IHRoaXMuZW5kO1xuXHRcdH1cblxuXHRcdHdoaWxlIChsb3cgPCBoaWdoKSB7XG5cdFx0ICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuXHRcdCAgaWYgKGNvbXBhcml0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgdGhpcy5kYXRhW21pZF0pID4gMCkgbG93ID0gbWlkICsgMTtcblx0XHQgIGVsc2UgaGlnaCA9IG1pZDtcblx0XHR9XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTg2MTgyNzMvMTUxNzkxOVxuXHRcdHJldHVybiAoKChsb3cgLSB0aGlzLnN0YXJ0KSAlIHRoaXMuc2l6ZSkgKyB0aGlzLnNpemUpICUgdGhpcy5zaXplO1xuXHR9LFxuXG5cdC8qIGl0ZXJhdGlvbiBtZXRob2RzICovXG5cdC8vIGNoZWNrIGV2ZXJ5IGl0ZW0gaW4gdGhlIGFycmF5IGFnYWluc3QgYSB0ZXN0XG5cdGV2ZXJ5IDogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdGZvciAoOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcblx0XHRcdGlmICghY2FsbGJhY2suY2FsbChjb250ZXh0LCB0aGlzLmRhdGFbKHRoaXMuc3RhcnQgKyBpKSAlIHRoaXMubGVuZ3RoXSwgaSwgdGhpcykpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cdC8vIGxvb3AgdGhyb3VnaCBlYWNoIGl0ZW0gaW4gYnVmZmVyXG5cdC8vIFRPRE86IGZpZ3VyZSBvdXQgaG93IHRvIGVtdWxhdGUgQXJyYXkgdXNlIGJldHRlclxuXHRmb3JFYWNoIDogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdGZvciAoOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcblx0XHRcdGNhbGxiYWNrLmNhbGwoY29udGV4dCwgdGhpcy5kYXRhWyh0aGlzLnN0YXJ0ICsgaSkgJSB0aGlzLmxlbmd0aF0sIGksIHRoaXMpO1xuXHRcdH1cblx0fSxcblx0Ly8gY2hlY2sgaXRlbXMgYWdhaW5zIHRlc3QgdW50aWwgb25lIHJldHVybnMgdHJ1ZVxuXHQvLyBUT0RPOiBmaWd1cmUgb3V0IGhvdyB0byBlbXVsZGF0ZSBBcnJheSB1c2UgYmV0dGVyXG5cdHNvbWUgOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Zm9yICg7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuXHRcdFx0aWYgKGNhbGxiYWNrLmNhbGwoY29udGV4dCwgdGhpcy5kYXRhWyh0aGlzLnN0YXJ0ICsgaSkgJSB0aGlzLmxlbmd0aF0sIGksIHRoaXMpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXHQvLyBjYWxjdWxhdGUgdGhlIGF2ZXJhZ2UgdmFsdWUgb2YgYSBjaXJjdWxhciBidWZmZXJcblx0YXZnIDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNpemUgPT0gMCA/IDAgOiAodGhpcy5zdW0oKSAvIHRoaXMuc2l6ZSk7XG5cdH0sXG5cdC8vIGxvb3AgdGhyb3VnaCBlYWNoIGl0ZW0gaW4gYnVmZmVyIGFuZCBjYWxjdWxhdGUgc3VtXG5cdHN1bSA6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaW5kZXggPSB0aGlzLnNpemU7XG5cdFx0dmFyIHMgPSAwO1xuXHRcdHdoaWxlIChpbmRleC0tKSBzICs9IHRoaXMuZGF0YVtpbmRleF07XG5cdFx0cmV0dXJuIHM7XG5cdH0sXG5cdC8vIGxvb3AgdGhyb3VnaCBlYWNoIGl0ZW0gaW4gYnVmZmVyIGFuZCBjYWxjdWxhdGUgbWVkaWFuXG5cdG1lZGlhbiA6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5zaXplID09PSAwKVxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMuc2xpY2UoKS5zb3J0KGRlZmF1bHRDb21wYXJpdG9yKTtcblx0XHR2YXIgaGFsZiA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xuXHRcdGlmKHZhbHVlcy5sZW5ndGggJSAyKVxuXHRcdFx0cmV0dXJuIHZhbHVlc1toYWxmXTtcblx0XHRlbHNlXG5cdFx0XHRyZXR1cm4gKHZhbHVlc1toYWxmLTFdICsgdmFsdWVzW2hhbGZdKSAvIDIuMDtcblx0fSxcblx0LyogdXRpbGl0eSBtZXRob2RzICovXG5cdC8vIHJlc2V0IHBvaW50ZXJzIHRvIGJ1ZmZlciB3aXRoIHplcm8gaXRlbXNcblx0Ly8gbm90ZTogdGhpcyB3aWxsIG5vdCByZW1vdmUgdmFsdWVzIGluIGNidWZmZXIsIHNvIGlmIGZvciBzZWN1cml0eSB2YWx1ZXNcblx0Ly8gICAgICAgbmVlZCB0byBiZSBvdmVyd3JpdHRlbiwgcnVuIGAuZmlsbChudWxsKS5lbXB0eSgpYFxuXHRlbXB0eSA6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0dGhpcy5zaXplID0gdGhpcy5zdGFydCA9IDA7XG5cdFx0dGhpcy5lbmQgPSB0aGlzLmxlbmd0aCAtIDE7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdC8vIGZpbGwgYWxsIHBsYWNlcyB3aXRoIHBhc3NlZCB2YWx1ZSBvciBmdW5jdGlvblxuXHRmaWxsIDogZnVuY3Rpb24gKGFyZykge1xuXHRcdHZhciBpID0gMDtcblx0XHRpZiAodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0d2hpbGUodGhpcy5kYXRhW2ldID0gYXJnKCksICsraSA8IHRoaXMubGVuZ3RoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d2hpbGUodGhpcy5kYXRhW2ldID0gYXJnLCArK2kgPCB0aGlzLmxlbmd0aCk7XG5cdFx0fVxuXHRcdC8vIHJlcG9zaXRpb24gc3RhcnQvZW5kXG5cdFx0dGhpcy5zdGFydCA9IDA7XG5cdFx0dGhpcy5lbmQgPSB0aGlzLmxlbmd0aCAtIDE7XG5cdFx0dGhpcy5zaXplID0gdGhpcy5sZW5ndGg7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdC8vIHJldHVybiBmaXJzdCBpdGVtIGluIGJ1ZmZlclxuXHRmaXJzdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhW3RoaXMuc3RhcnRdO1xuXHR9LFxuXHQvLyByZXR1cm4gbGFzdCBpdGVtIGluIGJ1ZmZlclxuXHRsYXN0IDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGFbdGhpcy5lbmRdO1xuXHR9LFxuXHQvLyByZXR1cm4gc3BlY2lmaWMgaW5kZXggaW4gYnVmZmVyXG5cdGdldCA6IGZ1bmN0aW9uIChhcmcpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhWyh0aGlzLnN0YXJ0ICsgYXJnKSAlIHRoaXMubGVuZ3RoXTtcblx0fSxcblx0aXNGdWxsIDogZnVuY3Rpb24gKGFyZykge1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aCA9PT0gdGhpcy5zaXplO1xuXHR9LFxuXHQvLyBzZXQgdmFsdWUgYXQgc3BlY2lmaWVkIGluZGV4XG5cdHNldCA6IGZ1bmN0aW9uIChpZHgsIGFyZykge1xuXHRcdHJldHVybiB0aGlzLmRhdGFbKHRoaXMuc3RhcnQgKyBpZHgpICUgdGhpcy5sZW5ndGhdID0gYXJnO1xuXHR9LFxuXHQvLyByZXR1cm4gY2xlYW4gYXJyYXkgb2YgdmFsdWVzXG5cdHRvQXJyYXkgOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2xpY2UoKTtcblx0fSxcblx0Ly8gc2xpY2UgdGhlIGJ1ZmZlciB0byBhbiBhcnJhYXlcblx0c2xpY2UgOiBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLnNpemU7XG5cblx0XHRzdGFydCA9ICtzdGFydCB8fCAwO1xuXG5cdFx0aWYgKHN0YXJ0IDwgMCkge1xuXHRcdFx0aWYgKHN0YXJ0ID49IGVuZClcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0c3RhcnQgPSAoLXN0YXJ0ID4gbGVuZ3RoKSA/IDAgOiBsZW5ndGggKyBzdGFydDtcblx0XHR9XG5cblx0XHRpZiAoZW5kID09IG51bGwgfHwgZW5kID4gbGVuZ3RoKVxuXHRcdFx0ZW5kID0gbGVuZ3RoO1xuXHRcdGVsc2UgaWYgKGVuZCA8IDApXG5cdFx0XHRlbmQgKz0gbGVuZ3RoO1xuXHRcdGVsc2Vcblx0XHRcdGVuZCA9ICtlbmQgfHwgMDtcblxuXHRcdGxlbmd0aCA9IHN0YXJ0IDwgZW5kID8gZW5kIC0gc3RhcnQgOiAwO1xuXG5cdFx0dmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cdFx0Zm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuXHRcdFx0cmVzdWx0W2luZGV4XSA9IHRoaXMuZGF0YVsodGhpcy5zdGFydCArIHN0YXJ0ICsgaW5kZXgpICUgdGhpcy5sZW5ndGhdO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG59O1xuXG4vL2lmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykgbW9kdWxlLmV4cG9ydHMgPSBDQnVmZmVyO1xuLy9lbHNlIGdsb2JhbC5DQnVmZmVyID0gQ0J1ZmZlcjtcblxuZXhwb3J0IGRlZmF1bHQgQ0J1ZmZlcjsiLCIvKiBcbiAqICBEU1AuanMgLSBhIGNvbXByZWhlbnNpdmUgZGlnaXRhbCBzaWduYWwgcHJvY2Vzc2luZyAgbGlicmFyeSBmb3IgamF2YXNjcmlwdFxuICogXG4gKiAgQ3JlYXRlZCBieSBDb3JiYW4gQnJvb2sgPGNvcmJhbmJyb29rQGdtYWlsLmNvbT4gb24gMjAxMC0wMS0wMS5cbiAqICBDb3B5cmlnaHQgMjAxMCBDb3JiYW4gQnJvb2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuICogIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICogIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAqICBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAqICBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqICB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbiAqICBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG4gKiAgT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4gKiAgV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTlNUQU5UUyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIERTUCBpcyBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgZ2VuZXJhbCBwdXJwb3NlIHV0aWxpdHkgZnVuY3Rpb25zIGFuZCBjb25zdGFudHNcbiAqL1xudmFyIERTUCA9IHtcbiAgLy8gQ2hhbm5lbHNcbiAgTEVGVDogICAgICAgICAgIDAsXG4gIFJJR0hUOiAgICAgICAgICAxLFxuICBNSVg6ICAgICAgICAgICAgMixcblxuICAvLyBXYXZlZm9ybXNcbiAgU0lORTogICAgICAgICAgIDEsXG4gIFRSSUFOR0xFOiAgICAgICAyLFxuICBTQVc6ICAgICAgICAgICAgMyxcbiAgU1FVQVJFOiAgICAgICAgIDQsXG5cbiAgLy8gRmlsdGVyc1xuICBMT1dQQVNTOiAgICAgICAgMCxcbiAgSElHSFBBU1M6ICAgICAgIDEsXG4gIEJBTkRQQVNTOiAgICAgICAyLFxuICBOT1RDSDogICAgICAgICAgMyxcblxuICAvLyBXaW5kb3cgZnVuY3Rpb25zXG4gIEJBUlRMRVRUOiAgICAgICAxLFxuICBCQVJUTEVUVEhBTk46ICAgMixcbiAgQkxBQ0tNQU46ICAgICAgIDMsXG4gIENPU0lORTogICAgICAgICA0LFxuICBHQVVTUzogICAgICAgICAgNSxcbiAgSEFNTUlORzogICAgICAgIDYsXG4gIEhBTk46ICAgICAgICAgICA3LFxuICBMQU5DWk9TOiAgICAgICAgOCxcbiAgUkVDVEFOR1VMQVI6ICAgIDksXG4gIFRSSUFOR1VMQVI6ICAgICAxMCxcblxuICAvLyBMb29wIG1vZGVzXG4gIE9GRjogICAgICAgICAgICAwLFxuICBGVzogICAgICAgICAgICAgMSxcbiAgQlc6ICAgICAgICAgICAgIDIsXG4gIEZXQlc6ICAgICAgICAgICAzLFxuXG4gIC8vIE1hdGhcbiAgVFdPX1BJOiAgICAgICAgIDIqTWF0aC5QSVxufTtcblxuLy8gU2V0dXAgYXJyYXlzIGZvciBwbGF0Zm9ybXMgd2hpY2ggZG8gbm90IHN1cHBvcnQgYnl0ZSBhcnJheXNcbmZ1bmN0aW9uIHNldHVwVHlwZWRBcnJheShuYW1lLCBmYWxsYmFjaykge1xuICB2YXIgc2VsZiA9IHdpbmRvdztcbiAgLy8gY2hlY2sgaWYgVHlwZWRBcnJheSBleGlzdHNcbiAgLy8gdHlwZW9mIG9uIE1pbmVmaWVsZCBhbmQgQ2hyb21lIHJldHVybiBmdW5jdGlvbiwgdHlwZW9mIG9uIFdlYmtpdCByZXR1cm5zIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBzZWxmW25hbWVdICE9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHNlbGZbbmFtZV0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAvLyBub3BlLi4gY2hlY2sgaWYgV2ViR0xBcnJheSBleGlzdHNcbiAgICBpZiAodHlwZW9mIHNlbGZbZmFsbGJhY2tdID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHNlbGZbZmFsbGJhY2tdICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBzZWxmW25hbWVdID0gc2VsZltmYWxsYmFja107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vcGUuLiBzZXQgYXMgTmF0aXZlIEpTIGFycmF5XG4gICAgICBzZWxmW25hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIHJldHVybiBuZXcgQXJyYXkob2JqKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuc2V0dXBUeXBlZEFycmF5KFwiRmxvYXQzMkFycmF5XCIsIFwiV2ViR0xGbG9hdEFycmF5XCIpO1xuc2V0dXBUeXBlZEFycmF5KFwiSW50MzJBcnJheVwiLCAgIFwiV2ViR0xJbnRBcnJheVwiKTtcbnNldHVwVHlwZWRBcnJheShcIlVpbnQxNkFycmF5XCIsICBcIldlYkdMVW5zaWduZWRTaG9ydEFycmF5XCIpO1xuc2V0dXBUeXBlZEFycmF5KFwiVWludDhBcnJheVwiLCAgIFwiV2ViR0xVbnNpZ25lZEJ5dGVBcnJheVwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgRFNQIFVUSUxJVFkgRlVOQ1RJT05TICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogSW52ZXJ0cyB0aGUgcGhhc2Ugb2YgYSBzaWduYWxcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXIgQSBzYW1wbGUgYnVmZmVyXG4gKlxuICogQHJldHVybnMgVGhlIGludmVydGVkIHNhbXBsZSBidWZmZXJcbiAqL1xuRFNQLmludmVydCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmZmVyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmZmVyW2ldICo9IC0xO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgc3BsaXQtc3RlcmVvIChkdWFsIG1vbm8pIHNhbXBsZSBidWZmZXJzIGludG8gYSBzdGVyZW8gaW50ZXJsZWF2ZWQgc2FtcGxlIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGxlZnQgIEEgc2FtcGxlIGJ1ZmZlclxuICogQHBhcmFtIHtBcnJheX0gcmlnaHQgQSBzYW1wbGUgYnVmZmVyXG4gKlxuICogQHJldHVybnMgVGhlIHN0ZXJlbyBpbnRlcmxlYXZlZCBidWZmZXJcbiAqL1xuRFNQLmludGVybGVhdmUgPSBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aCkge1xuICAgIHRocm93IFwiQ2FuIG5vdCBpbnRlcmxlYXZlLiBDaGFubmVsIGxlbmd0aHMgZGlmZmVyLlwiO1xuICB9XG4gXG4gIHZhciBzdGVyZW9JbnRlcmxlYXZlZCA9IG5ldyBGbG9hdDMyQXJyYXkobGVmdC5sZW5ndGggKiAyKTtcbiBcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxlZnQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzdGVyZW9JbnRlcmxlYXZlZFsyKmldICAgPSBsZWZ0W2ldO1xuICAgIHN0ZXJlb0ludGVybGVhdmVkWzIqaSsxXSA9IHJpZ2h0W2ldO1xuICB9XG4gXG4gIHJldHVybiBzdGVyZW9JbnRlcmxlYXZlZDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzdGVyZW8taW50ZXJsZWF2ZWQgc2FtcGxlIGJ1ZmZlciBpbnRvIHNwbGl0LXN0ZXJlbyAoZHVhbCBtb25vKSBzYW1wbGUgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlciBBIHN0ZXJlby1pbnRlcmxlYXZlZCBzYW1wbGUgYnVmZmVyXG4gKlxuICogQHJldHVybnMgYW4gQXJyYXkgY29udGFpbmluZyBsZWZ0IGFuZCByaWdodCBjaGFubmVsc1xuICovXG5EU1AuZGVpbnRlcmxlYXZlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgbGVmdCwgcmlnaHQsIG1peCwgZGVpbnRlcmxlYXZlQ2hhbm5lbCA9IFtdOyBcblxuICBkZWludGVybGVhdmVDaGFubmVsW0RTUC5NSVhdID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1ZmZlci5sZW5ndGgvMjsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBtaXhbaV0gPSAoYnVmZmVyWzIqaV0gKyBidWZmZXJbMippKzFdKSAvIDI7XG4gICAgfVxuICAgIHJldHVybiBtaXg7XG4gIH07XG5cbiAgZGVpbnRlcmxlYXZlQ2hhbm5lbFtEU1AuTEVGVF0gPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmZmVyLmxlbmd0aC8yOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxlZnRbaV0gID0gYnVmZmVyWzIqaV07XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9O1xuXG4gIGRlaW50ZXJsZWF2ZUNoYW5uZWxbRFNQLlJJR0hUXSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWZmZXIubGVuZ3RoLzI7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmlnaHRbaV0gID0gYnVmZmVyWzIqaSsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbihjaGFubmVsLCBidWZmZXIpIHsgXG4gICAgbGVmdCAgPSBsZWZ0ICB8fCBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlci5sZW5ndGgvMik7XG4gICAgcmlnaHQgPSByaWdodCB8fCBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlci5sZW5ndGgvMik7XG4gICAgbWl4ICAgPSBtaXggICB8fCBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlci5sZW5ndGgvMik7XG5cbiAgICBpZiAoYnVmZmVyLmxlbmd0aC8yICE9PSBsZWZ0Lmxlbmd0aCkge1xuICAgICAgbGVmdCAgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlci5sZW5ndGgvMik7XG4gICAgICByaWdodCA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLmxlbmd0aC8yKTtcbiAgICAgIG1peCAgID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIubGVuZ3RoLzIpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWludGVybGVhdmVDaGFubmVsW2NoYW5uZWxdKGJ1ZmZlcik7XG4gIH07XG59KCkpO1xuXG4vKipcbiAqIFNlcGFyYXRlcyBhIGNoYW5uZWwgZnJvbSBhIHN0ZXJlby1pbnRlcmxlYXZlZCBzYW1wbGUgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gIGJ1ZmZlciBBIHN0ZXJlby1pbnRlcmxlYXZlZCBzYW1wbGUgYnVmZmVyXG4gKiBAcGFyYW0ge051bWJlcn0gY2hhbm5lbCBBIGNoYW5uZWwgY29uc3RhbnQgKExFRlQsIFJJR0hULCBNSVgpXG4gKlxuICogQHJldHVybnMgYW4gQXJyYXkgY29udGFpbmluZyBhIHNpZ25hbCBtb25vIHNhbXBsZSBidWZmZXJcbiAqL1xuRFNQLmdldENoYW5uZWwgPSBEU1AuZGVpbnRlcmxlYXZlO1xuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgKGZvciBSZXZlcmIpIHRvIG1peCB0d28gKGludGVybGVhdmVkKSBzYW1wbGVidWZmZXJzLiBJdCdzIHBvc3NpYmxlXG4gKiB0byBuZWdhdGUgdGhlIHNlY29uZCBidWZmZXIgd2hpbGUgbWl4aW5nIGFuZCB0byBwZXJmb3JtIGEgdm9sdW1lIGNvcnJlY3Rpb25cbiAqIG9uIHRoZSBmaW5hbCBzaWduYWwuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2FtcGxlQnVmZmVyMSBBcnJheSBjb250YWluaW5nIEZsb2F0IHZhbHVlcyBvciBhIEZsb2F0MzJBcnJheVxuICogQHBhcmFtIHtBcnJheX0gc2FtcGxlQnVmZmVyMiBBcnJheSBjb250YWluaW5nIEZsb2F0IHZhbHVlcyBvciBhIEZsb2F0MzJBcnJheVxuICogQHBhcmFtIHtCb29sZWFufSBuZWdhdGUgV2hlbiB0cnVlIGludmVydHMvZmxpcHMgdGhlIGF1ZGlvIHNpZ25hbFxuICogQHBhcmFtIHtOdW1iZXJ9IHZvbHVtZUNvcnJlY3Rpb24gV2hlbiB5b3UgYWRkIG11bHRpcGxlIHNhbXBsZSBidWZmZXJzLCB1c2UgdGhpcyB0byB0YW1lIHlvdXIgc2lnbmFsIDspXG4gKlxuICogQHJldHVybnMgQSBuZXcgRmxvYXQzMkFycmF5IGludGVybGVhdmVkIGJ1ZmZlci5cbiAqL1xuRFNQLm1peFNhbXBsZUJ1ZmZlcnMgPSBmdW5jdGlvbihzYW1wbGVCdWZmZXIxLCBzYW1wbGVCdWZmZXIyLCBuZWdhdGUsIHZvbHVtZUNvcnJlY3Rpb24pe1xuICB2YXIgb3V0cHV0U2FtcGxlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2FtcGxlQnVmZmVyMSk7XG5cbiAgZm9yKHZhciBpID0gMDsgaTxzYW1wbGVCdWZmZXIxLmxlbmd0aDsgaSsrKXtcbiAgICBvdXRwdXRTYW1wbGVzW2ldICs9IChuZWdhdGUgPyAtc2FtcGxlQnVmZmVyMltpXSA6IHNhbXBsZUJ1ZmZlcjJbaV0pIC8gdm9sdW1lQ29ycmVjdGlvbjtcbiAgfVxuIFxuICByZXR1cm4gb3V0cHV0U2FtcGxlcztcbn07IFxuXG4vLyBCaXF1YWQgZmlsdGVyIHR5cGVzXG5EU1AuTFBGID0gMDsgICAgICAgICAgICAgICAgLy8gSChzKSA9IDEgLyAoc14yICsgcy9RICsgMSlcbkRTUC5IUEYgPSAxOyAgICAgICAgICAgICAgICAvLyBIKHMpID0gc14yIC8gKHNeMiArIHMvUSArIDEpXG5EU1AuQlBGX0NPTlNUQU5UX1NLSVJUID0gMjsgLy8gSChzKSA9IHMgLyAoc14yICsgcy9RICsgMSkgIChjb25zdGFudCBza2lydCBnYWluLCBwZWFrIGdhaW4gPSBRKVxuRFNQLkJQRl9DT05TVEFOVF9QRUFLID0gMzsgIC8vIEgocykgPSAocy9RKSAvIChzXjIgKyBzL1EgKyAxKSAgICAgIChjb25zdGFudCAwIGRCIHBlYWsgZ2FpbilcbkRTUC5OT1RDSCA9IDQ7ICAgICAgICAgICAgICAvLyBIKHMpID0gKHNeMiArIDEpIC8gKHNeMiArIHMvUSArIDEpXG5EU1AuQVBGID0gNTsgICAgICAgICAgICAgICAgLy8gSChzKSA9IChzXjIgLSBzL1EgKyAxKSAvIChzXjIgKyBzL1EgKyAxKVxuRFNQLlBFQUtJTkdfRVEgPSA2OyAgICAgICAgIC8vIEgocykgPSAoc14yICsgcyooQS9RKSArIDEpIC8gKHNeMiArIHMvKEEqUSkgKyAxKVxuRFNQLkxPV19TSEVMRiA9IDc7ICAgICAgICAgIC8vIEgocykgPSBBICogKHNeMiArIChzcXJ0KEEpL1EpKnMgKyBBKS8oQSpzXjIgKyAoc3FydChBKS9RKSpzICsgMSlcbkRTUC5ISUdIX1NIRUxGID0gODsgICAgICAgICAvLyBIKHMpID0gQSAqIChBKnNeMiArIChzcXJ0KEEpL1EpKnMgKyAxKS8oc14yICsgKHNxcnQoQSkvUSkqcyArIEEpXG5cbi8vIEJpcXVhZCBmaWx0ZXIgcGFyYW1ldGVyIHR5cGVzXG5EU1AuUSA9IDE7XG5EU1AuQlcgPSAyOyAvLyBTSEFSRUQgd2l0aCBCQUNLV0FSRFMgTE9PUCBNT0RFXG5EU1AuUyA9IDM7XG5cbi8vIEZpbmQgUk1TIG9mIHNpZ25hbFxuRFNQLlJNUyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgdG90YWwgPSAwO1xuICBcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBidWZmZXIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgdG90YWwgKz0gYnVmZmVyW2ldICogYnVmZmVyW2ldO1xuICB9XG4gIFxuICByZXR1cm4gTWF0aC5zcXJ0KHRvdGFsIC8gbik7XG59O1xuXG4vLyBGaW5kIFBlYWsgb2Ygc2lnbmFsXG5EU1AuUGVhayA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcGVhayA9IDA7XG4gIFxuICBmb3IgKHZhciBpID0gMCwgbiA9IGJ1ZmZlci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICBwZWFrID0gKE1hdGguYWJzKGJ1ZmZlcltpXSkgPiBwZWFrKSA/IE1hdGguYWJzKGJ1ZmZlcltpXSkgOiBwZWFrOyBcbiAgfVxuICBcbiAgcmV0dXJuIHBlYWs7XG59O1xuXG4vLyBGb3VyaWVyIFRyYW5zZm9ybSBNb2R1bGUgdXNlZCBieSBERlQsIEZGVCwgUkZGVFxuZnVuY3Rpb24gRm91cmllclRyYW5zZm9ybShidWZmZXJTaXplLCBzYW1wbGVSYXRlKSB7XG4gIHRoaXMuYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemU7XG4gIHRoaXMuc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7XG4gIHRoaXMuYmFuZHdpZHRoICA9IDIgLyBidWZmZXJTaXplICogc2FtcGxlUmF0ZSAvIDI7XG5cbiAgdGhpcy5zcGVjdHJ1bSAgID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplLzIpO1xuICB0aGlzLnJlYWwgICAgICAgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUpO1xuICB0aGlzLmltYWcgICAgICAgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUpO1xuXG4gIHRoaXMucGVha0JhbmQgICA9IDA7XG4gIHRoaXMucGVhayAgICAgICA9IDA7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlICptaWRkbGUqIGZyZXF1ZW5jeSBvZiBhbiBGRlQgYmFuZC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgRkZUIGJhbmQuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSBtaWRkbGUgZnJlcXVlbmN5IGluIEh6LlxuICAgKi9cbiAgdGhpcy5nZXRCYW5kRnJlcXVlbmN5ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5iYW5kd2lkdGggKiBpbmRleCArIHRoaXMuYmFuZHdpZHRoIC8gMjtcbiAgfTtcblxuICB0aGlzLmNhbGN1bGF0ZVNwZWN0cnVtID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNwZWN0cnVtICA9IHRoaXMuc3BlY3RydW0sXG4gICAgICAgIHJlYWwgICAgICA9IHRoaXMucmVhbCxcbiAgICAgICAgaW1hZyAgICAgID0gdGhpcy5pbWFnLFxuICAgICAgICBiU2kgICAgICAgPSAyIC8gdGhpcy5idWZmZXJTaXplLFxuICAgICAgICBzcXJ0ICAgICAgPSBNYXRoLnNxcnQsXG4gICAgICAgIHJ2YWwsIFxuICAgICAgICBpdmFsLFxuICAgICAgICBtYWc7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgTiA9IGJ1ZmZlclNpemUvMjsgaSA8IE47IGkrKykge1xuICAgICAgcnZhbCA9IHJlYWxbaV07XG4gICAgICBpdmFsID0gaW1hZ1tpXTtcbiAgICAgIG1hZyA9IGJTaSAqIHNxcnQocnZhbCAqIHJ2YWwgKyBpdmFsICogaXZhbCk7XG5cbiAgICAgIGlmIChtYWcgPiB0aGlzLnBlYWspIHtcbiAgICAgICAgdGhpcy5wZWFrQmFuZCA9IGk7XG4gICAgICAgIHRoaXMucGVhayA9IG1hZztcbiAgICAgIH1cblxuICAgICAgc3BlY3RydW1baV0gPSBtYWc7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIERGVCBpcyBhIGNsYXNzIGZvciBjYWxjdWxhdGluZyB0aGUgRGlzY3JldGUgRm91cmllciBUcmFuc2Zvcm0gb2YgYSBzaWduYWwuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGJ1ZmZlclNpemUgVGhlIHNpemUgb2YgdGhlIHNhbXBsZSBidWZmZXIgdG8gYmUgY29tcHV0ZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzYW1wbGVSYXRlIFRoZSBzYW1wbGVSYXRlIG9mIHRoZSBidWZmZXIgKGVnLiA0NDEwMClcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gREZUKGJ1ZmZlclNpemUsIHNhbXBsZVJhdGUpIHtcbiAgRm91cmllclRyYW5zZm9ybS5jYWxsKHRoaXMsIGJ1ZmZlclNpemUsIHNhbXBsZVJhdGUpO1xuXG4gIHZhciBOID0gYnVmZmVyU2l6ZS8yICogYnVmZmVyU2l6ZTtcbiAgdmFyIFRXT19QSSA9IDIgKiBNYXRoLlBJO1xuXG4gIHRoaXMuc2luVGFibGUgPSBuZXcgRmxvYXQzMkFycmF5KE4pO1xuICB0aGlzLmNvc1RhYmxlID0gbmV3IEZsb2F0MzJBcnJheShOKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgIHRoaXMuc2luVGFibGVbaV0gPSBNYXRoLnNpbihpICogVFdPX1BJIC8gYnVmZmVyU2l6ZSk7XG4gICAgdGhpcy5jb3NUYWJsZVtpXSA9IE1hdGguY29zKGkgKiBUV09fUEkgLyBidWZmZXJTaXplKTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgZm9yd2FyZCB0cmFuc2Zvcm0gb24gdGhlIHNhbXBsZSBidWZmZXIuXG4gKiBDb252ZXJ0cyBhIHRpbWUgZG9tYWluIHNpZ25hbCB0byBmcmVxdWVuY3kgZG9tYWluIHNwZWN0cmEuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYnVmZmVyIFRoZSBzYW1wbGUgYnVmZmVyXG4gKlxuICogQHJldHVybnMgVGhlIGZyZXF1ZW5jeSBzcGVjdHJ1bSBhcnJheVxuICovXG5ERlQucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlYWwgPSB0aGlzLnJlYWwsIFxuICAgICAgaW1hZyA9IHRoaXMuaW1hZyxcbiAgICAgIHJ2YWwsXG4gICAgICBpdmFsO1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5idWZmZXJTaXplLzI7IGsrKykge1xuICAgIHJ2YWwgPSAwLjA7XG4gICAgaXZhbCA9IDAuMDtcblxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYnVmZmVyLmxlbmd0aDsgbisrKSB7XG4gICAgICBydmFsICs9IHRoaXMuY29zVGFibGVbaypuXSAqIGJ1ZmZlcltuXTtcbiAgICAgIGl2YWwgKz0gdGhpcy5zaW5UYWJsZVtrKm5dICogYnVmZmVyW25dO1xuICAgIH1cblxuICAgIHJlYWxba10gPSBydmFsO1xuICAgIGltYWdba10gPSBpdmFsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlU3BlY3RydW0oKTtcbn07XG5cblxuLyoqXG4gKiBGRlQgaXMgYSBjbGFzcyBmb3IgY2FsY3VsYXRpbmcgdGhlIERpc2NyZXRlIEZvdXJpZXIgVHJhbnNmb3JtIG9mIGEgc2lnbmFsXG4gKiB3aXRoIHRoZSBGYXN0IEZvdXJpZXIgVHJhbnNmb3JtIGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYnVmZmVyU2l6ZSBUaGUgc2l6ZSBvZiB0aGUgc2FtcGxlIGJ1ZmZlciB0byBiZSBjb21wdXRlZC4gTXVzdCBiZSBwb3dlciBvZiAyXG4gKiBAcGFyYW0ge051bWJlcn0gc2FtcGxlUmF0ZSBUaGUgc2FtcGxlUmF0ZSBvZiB0aGUgYnVmZmVyIChlZy4gNDQxMDApXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZGVChidWZmZXJTaXplLCBzYW1wbGVSYXRlKSB7XG4gIEZvdXJpZXJUcmFuc2Zvcm0uY2FsbCh0aGlzLCBidWZmZXJTaXplLCBzYW1wbGVSYXRlKTtcbiAgIFxuICB0aGlzLnJldmVyc2VUYWJsZSA9IG5ldyBVaW50MzJBcnJheShidWZmZXJTaXplKTtcblxuICB2YXIgbGltaXQgPSAxO1xuICB2YXIgYml0ID0gYnVmZmVyU2l6ZSA+PiAxO1xuXG4gIHZhciBpO1xuXG4gIHdoaWxlIChsaW1pdCA8IGJ1ZmZlclNpemUpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGltaXQ7IGkrKykge1xuICAgICAgdGhpcy5yZXZlcnNlVGFibGVbaSArIGxpbWl0XSA9IHRoaXMucmV2ZXJzZVRhYmxlW2ldICsgYml0O1xuICAgIH1cblxuICAgIGxpbWl0ID0gbGltaXQgPDwgMTtcbiAgICBiaXQgPSBiaXQgPj4gMTtcbiAgfVxuXG4gIHRoaXMuc2luVGFibGUgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUpO1xuICB0aGlzLmNvc1RhYmxlID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyU2l6ZTsgaSsrKSB7XG4gICAgdGhpcy5zaW5UYWJsZVtpXSA9IE1hdGguc2luKC1NYXRoLlBJL2kpO1xuICAgIHRoaXMuY29zVGFibGVbaV0gPSBNYXRoLmNvcygtTWF0aC5QSS9pKTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgZm9yd2FyZCB0cmFuc2Zvcm0gb24gdGhlIHNhbXBsZSBidWZmZXIuXG4gKiBDb252ZXJ0cyBhIHRpbWUgZG9tYWluIHNpZ25hbCB0byBmcmVxdWVuY3kgZG9tYWluIHNwZWN0cmEuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYnVmZmVyIFRoZSBzYW1wbGUgYnVmZmVyLiBCdWZmZXIgTGVuZ3RoIG11c3QgYmUgcG93ZXIgb2YgMlxuICpcbiAqIEByZXR1cm5zIFRoZSBmcmVxdWVuY3kgc3BlY3RydW0gYXJyYXlcbiAqL1xuRkZULnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIExvY2FsbHkgc2NvcGUgdmFyaWFibGVzIGZvciBzcGVlZCB1cFxuICB2YXIgYnVmZmVyU2l6ZSAgICAgID0gdGhpcy5idWZmZXJTaXplLFxuICAgICAgY29zVGFibGUgICAgICAgID0gdGhpcy5jb3NUYWJsZSxcbiAgICAgIHNpblRhYmxlICAgICAgICA9IHRoaXMuc2luVGFibGUsXG4gICAgICByZXZlcnNlVGFibGUgICAgPSB0aGlzLnJldmVyc2VUYWJsZSxcbiAgICAgIHJlYWwgICAgICAgICAgICA9IHRoaXMucmVhbCxcbiAgICAgIGltYWcgICAgICAgICAgICA9IHRoaXMuaW1hZyxcbiAgICAgIHNwZWN0cnVtICAgICAgICA9IHRoaXMuc3BlY3RydW07XG5cbiAgdmFyIGsgPSBNYXRoLmZsb29yKE1hdGgubG9nKGJ1ZmZlclNpemUpIC8gTWF0aC5MTjIpO1xuXG4gIGlmIChNYXRoLnBvdygyLCBrKSAhPT0gYnVmZmVyU2l6ZSkgeyB0aHJvdyBcIkludmFsaWQgYnVmZmVyIHNpemUsIG11c3QgYmUgYSBwb3dlciBvZiAyLlwiOyB9XG4gIGlmIChidWZmZXJTaXplICE9PSBidWZmZXIubGVuZ3RoKSAgeyB0aHJvdyBcIlN1cHBsaWVkIGJ1ZmZlciBpcyBub3QgdGhlIHNhbWUgc2l6ZSBhcyBkZWZpbmVkIEZGVC4gRkZUIFNpemU6IFwiICsgYnVmZmVyU2l6ZSArIFwiIEJ1ZmZlciBTaXplOiBcIiArIGJ1ZmZlci5sZW5ndGg7IH1cblxuICB2YXIgaGFsZlNpemUgPSAxLFxuICAgICAgcGhhc2VTaGlmdFN0ZXBSZWFsLFxuICAgICAgcGhhc2VTaGlmdFN0ZXBJbWFnLFxuICAgICAgY3VycmVudFBoYXNlU2hpZnRSZWFsLFxuICAgICAgY3VycmVudFBoYXNlU2hpZnRJbWFnLFxuICAgICAgb2ZmLFxuICAgICAgdHIsXG4gICAgICB0aSxcbiAgICAgIHRtcFJlYWwsXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBidWZmZXJTaXplOyBpKyspIHtcbiAgICByZWFsW2ldID0gYnVmZmVyW3JldmVyc2VUYWJsZVtpXV07XG4gICAgaW1hZ1tpXSA9IDA7XG4gIH1cblxuICB3aGlsZSAoaGFsZlNpemUgPCBidWZmZXJTaXplKSB7XG4gICAgLy9waGFzZVNoaWZ0U3RlcFJlYWwgPSBNYXRoLmNvcygtTWF0aC5QSS9oYWxmU2l6ZSk7XG4gICAgLy9waGFzZVNoaWZ0U3RlcEltYWcgPSBNYXRoLnNpbigtTWF0aC5QSS9oYWxmU2l6ZSk7XG4gICAgcGhhc2VTaGlmdFN0ZXBSZWFsID0gY29zVGFibGVbaGFsZlNpemVdO1xuICAgIHBoYXNlU2hpZnRTdGVwSW1hZyA9IHNpblRhYmxlW2hhbGZTaXplXTtcbiAgICBcbiAgICBjdXJyZW50UGhhc2VTaGlmdFJlYWwgPSAxO1xuICAgIGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyA9IDA7XG5cbiAgICBmb3IgKHZhciBmZnRTdGVwID0gMDsgZmZ0U3RlcCA8IGhhbGZTaXplOyBmZnRTdGVwKyspIHtcbiAgICAgIGkgPSBmZnRTdGVwO1xuXG4gICAgICB3aGlsZSAoaSA8IGJ1ZmZlclNpemUpIHtcbiAgICAgICAgb2ZmID0gaSArIGhhbGZTaXplO1xuICAgICAgICB0ciA9IChjdXJyZW50UGhhc2VTaGlmdFJlYWwgKiByZWFsW29mZl0pIC0gKGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyAqIGltYWdbb2ZmXSk7XG4gICAgICAgIHRpID0gKGN1cnJlbnRQaGFzZVNoaWZ0UmVhbCAqIGltYWdbb2ZmXSkgKyAoY3VycmVudFBoYXNlU2hpZnRJbWFnICogcmVhbFtvZmZdKTtcblxuICAgICAgICByZWFsW29mZl0gPSByZWFsW2ldIC0gdHI7XG4gICAgICAgIGltYWdbb2ZmXSA9IGltYWdbaV0gLSB0aTtcbiAgICAgICAgcmVhbFtpXSArPSB0cjtcbiAgICAgICAgaW1hZ1tpXSArPSB0aTtcblxuICAgICAgICBpICs9IGhhbGZTaXplIDw8IDE7XG4gICAgICB9XG5cbiAgICAgIHRtcFJlYWwgPSBjdXJyZW50UGhhc2VTaGlmdFJlYWw7XG4gICAgICBjdXJyZW50UGhhc2VTaGlmdFJlYWwgPSAodG1wUmVhbCAqIHBoYXNlU2hpZnRTdGVwUmVhbCkgLSAoY3VycmVudFBoYXNlU2hpZnRJbWFnICogcGhhc2VTaGlmdFN0ZXBJbWFnKTtcbiAgICAgIGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyA9ICh0bXBSZWFsICogcGhhc2VTaGlmdFN0ZXBJbWFnKSArIChjdXJyZW50UGhhc2VTaGlmdEltYWcgKiBwaGFzZVNoaWZ0U3RlcFJlYWwpO1xuICAgIH1cblxuICAgIGhhbGZTaXplID0gaGFsZlNpemUgPDwgMTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmNhbGN1bGF0ZVNwZWN0cnVtKCk7XG59O1xuXG5GRlQucHJvdG90eXBlLmludmVyc2UgPSBmdW5jdGlvbihyZWFsLCBpbWFnLCBidWZmZXIpIHtcbiAgLy8gTG9jYWxseSBzY29wZSB2YXJpYWJsZXMgZm9yIHNwZWVkIHVwXG4gIHZhciBidWZmZXJTaXplICAgICAgPSB0aGlzLmJ1ZmZlclNpemUsXG4gICAgICBjb3NUYWJsZSAgICAgICAgPSB0aGlzLmNvc1RhYmxlLFxuICAgICAgc2luVGFibGUgICAgICAgID0gdGhpcy5zaW5UYWJsZSxcbiAgICAgIHJldmVyc2VUYWJsZSAgICA9IHRoaXMucmV2ZXJzZVRhYmxlLFxuICAgICAgc3BlY3RydW0gICAgICAgID0gdGhpcy5zcGVjdHJ1bTtcbiAgICAgXG4gICAgICByZWFsID0gcmVhbCB8fCB0aGlzLnJlYWw7XG4gICAgICBpbWFnID0gaW1hZyB8fCB0aGlzLmltYWc7XG5cbiAgdmFyIGhhbGZTaXplID0gMSxcbiAgICAgIHBoYXNlU2hpZnRTdGVwUmVhbCxcbiAgICAgIHBoYXNlU2hpZnRTdGVwSW1hZyxcbiAgICAgIGN1cnJlbnRQaGFzZVNoaWZ0UmVhbCxcbiAgICAgIGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyxcbiAgICAgIG9mZixcbiAgICAgIHRyLFxuICAgICAgdGksXG4gICAgICB0bXBSZWFsLFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyU2l6ZTsgaSsrKSB7XG4gICAgaW1hZ1tpXSAqPSAtMTtcbiAgfVxuXG4gIHZhciByZXZSZWFsID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplKTtcbiAgdmFyIHJldkltYWcgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUpO1xuIFxuICBmb3IgKGkgPSAwOyBpIDwgcmVhbC5sZW5ndGg7IGkrKykge1xuICAgIHJldlJlYWxbaV0gPSByZWFsW3JldmVyc2VUYWJsZVtpXV07XG4gICAgcmV2SW1hZ1tpXSA9IGltYWdbcmV2ZXJzZVRhYmxlW2ldXTtcbiAgfVxuIFxuICByZWFsID0gcmV2UmVhbDtcbiAgaW1hZyA9IHJldkltYWc7XG5cbiAgd2hpbGUgKGhhbGZTaXplIDwgYnVmZmVyU2l6ZSkge1xuICAgIHBoYXNlU2hpZnRTdGVwUmVhbCA9IGNvc1RhYmxlW2hhbGZTaXplXTtcbiAgICBwaGFzZVNoaWZ0U3RlcEltYWcgPSBzaW5UYWJsZVtoYWxmU2l6ZV07XG4gICAgY3VycmVudFBoYXNlU2hpZnRSZWFsID0gMTtcbiAgICBjdXJyZW50UGhhc2VTaGlmdEltYWcgPSAwO1xuXG4gICAgZm9yICh2YXIgZmZ0U3RlcCA9IDA7IGZmdFN0ZXAgPCBoYWxmU2l6ZTsgZmZ0U3RlcCsrKSB7XG4gICAgICBpID0gZmZ0U3RlcDtcblxuICAgICAgd2hpbGUgKGkgPCBidWZmZXJTaXplKSB7XG4gICAgICAgIG9mZiA9IGkgKyBoYWxmU2l6ZTtcbiAgICAgICAgdHIgPSAoY3VycmVudFBoYXNlU2hpZnRSZWFsICogcmVhbFtvZmZdKSAtIChjdXJyZW50UGhhc2VTaGlmdEltYWcgKiBpbWFnW29mZl0pO1xuICAgICAgICB0aSA9IChjdXJyZW50UGhhc2VTaGlmdFJlYWwgKiBpbWFnW29mZl0pICsgKGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyAqIHJlYWxbb2ZmXSk7XG5cbiAgICAgICAgcmVhbFtvZmZdID0gcmVhbFtpXSAtIHRyO1xuICAgICAgICBpbWFnW29mZl0gPSBpbWFnW2ldIC0gdGk7XG4gICAgICAgIHJlYWxbaV0gKz0gdHI7XG4gICAgICAgIGltYWdbaV0gKz0gdGk7XG5cbiAgICAgICAgaSArPSBoYWxmU2l6ZSA8PCAxO1xuICAgICAgfVxuXG4gICAgICB0bXBSZWFsID0gY3VycmVudFBoYXNlU2hpZnRSZWFsO1xuICAgICAgY3VycmVudFBoYXNlU2hpZnRSZWFsID0gKHRtcFJlYWwgKiBwaGFzZVNoaWZ0U3RlcFJlYWwpIC0gKGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyAqIHBoYXNlU2hpZnRTdGVwSW1hZyk7XG4gICAgICBjdXJyZW50UGhhc2VTaGlmdEltYWcgPSAodG1wUmVhbCAqIHBoYXNlU2hpZnRTdGVwSW1hZykgKyAoY3VycmVudFBoYXNlU2hpZnRJbWFnICogcGhhc2VTaGlmdFN0ZXBSZWFsKTtcbiAgICB9XG5cbiAgICBoYWxmU2l6ZSA9IGhhbGZTaXplIDw8IDE7XG4gIH1cblxuICAvLyB2YXIgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplKTsgLy8gdGhpcyBzaG91bGQgYmUgcmV1c2VkIGluc3RlYWRcbiAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlclNpemU7IGkrKykge1xuICAgIGJ1ZmZlcltpXSA9IHJlYWxbaV0gLyBidWZmZXJTaXplO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbi8qKlxuICogUkZGVCBpcyBhIGNsYXNzIGZvciBjYWxjdWxhdGluZyB0aGUgRGlzY3JldGUgRm91cmllciBUcmFuc2Zvcm0gb2YgYSBzaWduYWxcbiAqIHdpdGggdGhlIEZhc3QgRm91cmllciBUcmFuc2Zvcm0gYWxnb3JpdGhtLlxuICpcbiAqIFRoaXMgbWV0aG9kIGN1cnJlbnRseSBvbmx5IGNvbnRhaW5zIGEgZm9yd2FyZCB0cmFuc2Zvcm0gYnV0IGlzIGhpZ2hseSBvcHRpbWl6ZWQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGJ1ZmZlclNpemUgVGhlIHNpemUgb2YgdGhlIHNhbXBsZSBidWZmZXIgdG8gYmUgY29tcHV0ZWQuIE11c3QgYmUgcG93ZXIgb2YgMlxuICogQHBhcmFtIHtOdW1iZXJ9IHNhbXBsZVJhdGUgVGhlIHNhbXBsZVJhdGUgb2YgdGhlIGJ1ZmZlciAoZWcuIDQ0MTAwKVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbi8vIGxvb2t1cCB0YWJsZXMgZG9uJ3QgcmVhbGx5IGdhaW4gdXMgYW55IHNwZWVkLCBidXQgdGhleSBkbyBpbmNyZWFzZVxuLy8gY2FjaGUgZm9vdHByaW50LCBzbyBkb24ndCB1c2UgdGhlbSBpbiBoZXJlXG5cbi8vIGFsc28gd2UgZG9uJ3QgdXNlIHNlcGVhcmF0ZSBhcnJheXMgZm9yIHJlYWwvaW1hZ2luYXJ5IHBhcnRzXG5cbi8vIHRoaXMgb25lIGEgbGl0dGxlIG1vcmUgdGhhbiB0d2ljZSBhcyBmYXN0IGFzIHRoZSBvbmUgaW4gRkZUXG4vLyBob3dldmVyIEkgb25seSBkaWQgdGhlIGZvcndhcmQgdHJhbnNmb3JtXG5cbi8vIHRoZSByZXN0IG9mIHRoaXMgd2FzIHRyYW5zbGF0ZWQgZnJvbSBDLCBzZWUgaHR0cDovL3d3dy5qamouZGUvZnh0L1xuLy8gdGhpcyBpcyB0aGUgcmVhbCBzcGxpdCByYWRpeCBGRlRcblxuZnVuY3Rpb24gUkZGVChidWZmZXJTaXplLCBzYW1wbGVSYXRlKSB7XG4gIEZvdXJpZXJUcmFuc2Zvcm0uY2FsbCh0aGlzLCBidWZmZXJTaXplLCBzYW1wbGVSYXRlKTtcblxuICB0aGlzLnRyYW5zID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplKTtcblxuICB0aGlzLnJldmVyc2VUYWJsZSA9IG5ldyBVaW50MzJBcnJheShidWZmZXJTaXplKTtcblxuICAvLyBkb24ndCB1c2UgYSBsb29rdXAgdGFibGUgdG8gZG8gdGhlIHBlcm11dGUsIHVzZSB0aGlzIGluc3RlYWRcbiAgdGhpcy5yZXZlcnNlQmluUGVybXV0ZSA9IGZ1bmN0aW9uIChkZXN0LCBzb3VyY2UpIHtcbiAgICB2YXIgYnVmZmVyU2l6ZSAgPSB0aGlzLmJ1ZmZlclNpemUsIFxuICAgICAgICBoYWxmU2l6ZSAgICA9IGJ1ZmZlclNpemUgPj4+IDEsIFxuICAgICAgICBubTEgICAgICAgICA9IGJ1ZmZlclNpemUgLSAxLCBcbiAgICAgICAgaSA9IDEsIHIgPSAwLCBoO1xuXG4gICAgZGVzdFswXSA9IHNvdXJjZVswXTtcblxuICAgIGRvIHtcbiAgICAgIHIgKz0gaGFsZlNpemU7XG4gICAgICBkZXN0W2ldID0gc291cmNlW3JdO1xuICAgICAgZGVzdFtyXSA9IHNvdXJjZVtpXTtcbiAgICAgIFxuICAgICAgaSsrO1xuXG4gICAgICBoID0gaGFsZlNpemUgPDwgMTtcbiAgICAgIHdoaWxlIChoID0gaCA+PiAxLCAhKChyIF49IGgpICYgaCkpO1xuXG4gICAgICBpZiAociA+PSBpKSB7IFxuICAgICAgICBkZXN0W2ldICAgICA9IHNvdXJjZVtyXTsgXG4gICAgICAgIGRlc3Rbcl0gICAgID0gc291cmNlW2ldO1xuXG4gICAgICAgIGRlc3Rbbm0xLWldID0gc291cmNlW25tMS1yXTsgXG4gICAgICAgIGRlc3Rbbm0xLXJdID0gc291cmNlW25tMS1pXTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9IHdoaWxlIChpIDwgaGFsZlNpemUpO1xuICAgIGRlc3Rbbm0xXSA9IHNvdXJjZVtubTFdO1xuICB9O1xuXG4gIHRoaXMuZ2VuZXJhdGVSZXZlcnNlVGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJ1ZmZlclNpemUgID0gdGhpcy5idWZmZXJTaXplLCBcbiAgICAgICAgaGFsZlNpemUgICAgPSBidWZmZXJTaXplID4+PiAxLCBcbiAgICAgICAgbm0xICAgICAgICAgPSBidWZmZXJTaXplIC0gMSwgXG4gICAgICAgIGkgPSAxLCByID0gMCwgaDtcblxuICAgIHRoaXMucmV2ZXJzZVRhYmxlWzBdID0gMDtcblxuICAgIGRvIHtcbiAgICAgIHIgKz0gaGFsZlNpemU7XG4gICAgICBcbiAgICAgIHRoaXMucmV2ZXJzZVRhYmxlW2ldID0gcjtcbiAgICAgIHRoaXMucmV2ZXJzZVRhYmxlW3JdID0gaTtcblxuICAgICAgaSsrO1xuXG4gICAgICBoID0gaGFsZlNpemUgPDwgMTtcbiAgICAgIHdoaWxlIChoID0gaCA+PiAxLCAhKChyIF49IGgpICYgaCkpO1xuXG4gICAgICBpZiAociA+PSBpKSB7IFxuICAgICAgICB0aGlzLnJldmVyc2VUYWJsZVtpXSA9IHI7XG4gICAgICAgIHRoaXMucmV2ZXJzZVRhYmxlW3JdID0gaTtcblxuICAgICAgICB0aGlzLnJldmVyc2VUYWJsZVtubTEtaV0gPSBubTEtcjtcbiAgICAgICAgdGhpcy5yZXZlcnNlVGFibGVbbm0xLXJdID0gbm0xLWk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfSB3aGlsZSAoaSA8IGhhbGZTaXplKTtcblxuICAgIHRoaXMucmV2ZXJzZVRhYmxlW25tMV0gPSBubTE7XG4gIH07XG5cbiAgdGhpcy5nZW5lcmF0ZVJldmVyc2VUYWJsZSgpO1xufVxuXG5cbi8vIE9yZGVyaW5nIG9mIG91dHB1dDpcbi8vXG4vLyB0cmFuc1swXSAgICAgPSByZVswXSAoPT16ZXJvIGZyZXF1ZW5jeSwgcHVyZWx5IHJlYWwpXG4vLyB0cmFuc1sxXSAgICAgPSByZVsxXVxuLy8gICAgICAgICAgICAgLi4uXG4vLyB0cmFuc1tuLzItMV0gPSByZVtuLzItMV1cbi8vIHRyYW5zW24vMl0gICA9IHJlW24vMl0gICAgKD09bnlxdWlzdCBmcmVxdWVuY3ksIHB1cmVseSByZWFsKVxuLy9cbi8vIHRyYW5zW24vMisxXSA9IGltW24vMi0xXVxuLy8gdHJhbnNbbi8yKzJdID0gaW1bbi8yLTJdXG4vLyAgICAgICAgICAgICAuLi5cbi8vIHRyYW5zW24tMV0gICA9IGltWzFdIFxuXG5SRkZULnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBuICAgICAgICAgPSB0aGlzLmJ1ZmZlclNpemUsIFxuICAgICAgc3BlY3RydW0gID0gdGhpcy5zcGVjdHJ1bSxcbiAgICAgIHggICAgICAgICA9IHRoaXMudHJhbnMsIFxuICAgICAgVFdPX1BJICAgID0gMipNYXRoLlBJLFxuICAgICAgc3FydCAgICAgID0gTWF0aC5zcXJ0LFxuICAgICAgaSAgICAgICAgID0gbiA+Pj4gMSxcbiAgICAgIGJTaSAgICAgICA9IDIgLyBuLFxuICAgICAgbjIsIG40LCBuOCwgbm4sIFxuICAgICAgdDEsIHQyLCB0MywgdDQsIFxuICAgICAgaTEsIGkyLCBpMywgaTQsIGk1LCBpNiwgaTcsIGk4LCBcbiAgICAgIHN0MSwgY2MxLCBzczEsIGNjMywgc3MzLFxuICAgICAgZSwgXG4gICAgICBhLFxuICAgICAgcnZhbCwgaXZhbCwgbWFnOyBcblxuICB0aGlzLnJldmVyc2VCaW5QZXJtdXRlKHgsIGJ1ZmZlcik7XG5cbiAgLypcbiAgdmFyIHJldmVyc2VUYWJsZSA9IHRoaXMucmV2ZXJzZVRhYmxlO1xuXG4gIGZvciAodmFyIGsgPSAwLCBsZW4gPSByZXZlcnNlVGFibGUubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICB4W2tdID0gYnVmZmVyW3JldmVyc2VUYWJsZVtrXV07XG4gIH1cbiAgKi9cblxuICBmb3IgKHZhciBpeCA9IDAsIGlkID0gNDsgaXggPCBuOyBpZCAqPSA0KSB7XG4gICAgZm9yICh2YXIgaTAgPSBpeDsgaTAgPCBuOyBpMCArPSBpZCkge1xuICAgICAgLy9zdW1kaWZmKHhbaTBdLCB4W2kwKzFdKTsgLy8ge2EsIGJ9ICA8LS18IHthK2IsIGEtYn1cbiAgICAgIHN0MSA9IHhbaTBdIC0geFtpMCsxXTtcbiAgICAgIHhbaTBdICs9IHhbaTArMV07XG4gICAgICB4W2kwKzFdID0gc3QxO1xuICAgIH0gXG4gICAgaXggPSAyKihpZC0xKTtcbiAgfVxuXG4gIG4yID0gMjtcbiAgbm4gPSBuID4+PiAxO1xuXG4gIHdoaWxlKChubiA9IG5uID4+PiAxKSkge1xuICAgIGl4ID0gMDtcbiAgICBuMiA9IG4yIDw8IDE7XG4gICAgaWQgPSBuMiA8PCAxO1xuICAgIG40ID0gbjIgPj4+IDI7XG4gICAgbjggPSBuMiA+Pj4gMztcbiAgICBkbyB7XG4gICAgICBpZihuNCAhPT0gMSkge1xuICAgICAgICBmb3IoaTAgPSBpeDsgaTAgPCBuOyBpMCArPSBpZCkge1xuICAgICAgICAgIGkxID0gaTA7XG4gICAgICAgICAgaTIgPSBpMSArIG40O1xuICAgICAgICAgIGkzID0gaTIgKyBuNDtcbiAgICAgICAgICBpNCA9IGkzICsgbjQ7XG4gICAgIFxuICAgICAgICAgIC8vZGlmZnN1bTNfcih4W2kzXSwgeFtpNF0sIHQxKTsgLy8ge2EsIGIsIHN9IDwtLXwge2EsIGItYSwgYStifVxuICAgICAgICAgIHQxID0geFtpM10gKyB4W2k0XTtcbiAgICAgICAgICB4W2k0XSAtPSB4W2kzXTtcbiAgICAgICAgICAvL3N1bWRpZmYzKHhbaTFdLCB0MSwgeFtpM10pOyAgIC8vIHthLCBiLCBkfSA8LS18IHthK2IsIGIsIGEtYn1cbiAgICAgICAgICB4W2kzXSA9IHhbaTFdIC0gdDE7IFxuICAgICAgICAgIHhbaTFdICs9IHQxO1xuICAgICBcbiAgICAgICAgICBpMSArPSBuODtcbiAgICAgICAgICBpMiArPSBuODtcbiAgICAgICAgICBpMyArPSBuODtcbiAgICAgICAgICBpNCArPSBuODtcbiAgICAgICAgIFxuICAgICAgICAgIC8vc3VtZGlmZih4W2kzXSwgeFtpNF0sIHQxLCB0Mik7IC8vIHtzLCBkfSAgPC0tfCB7YStiLCBhLWJ9XG4gICAgICAgICAgdDEgPSB4W2kzXSArIHhbaTRdO1xuICAgICAgICAgIHQyID0geFtpM10gLSB4W2k0XTtcbiAgICAgICAgIFxuICAgICAgICAgIHQxID0gLXQxICogTWF0aC5TUVJUMV8yO1xuICAgICAgICAgIHQyICo9IE1hdGguU1FSVDFfMjtcbiAgICAgXG4gICAgICAgICAgLy8gc3VtZGlmZih0MSwgeFtpMl0sIHhbaTRdLCB4W2kzXSk7IC8vIHtzLCBkfSAgPC0tfCB7YStiLCBhLWJ9XG4gICAgICAgICAgc3QxID0geFtpMl07XG4gICAgICAgICAgeFtpNF0gPSB0MSArIHN0MTsgXG4gICAgICAgICAgeFtpM10gPSB0MSAtIHN0MTtcbiAgICAgICAgICBcbiAgICAgICAgICAvL3N1bWRpZmYzKHhbaTFdLCB0MiwgeFtpMl0pOyAvLyB7YSwgYiwgZH0gPC0tfCB7YStiLCBiLCBhLWJ9XG4gICAgICAgICAgeFtpMl0gPSB4W2kxXSAtIHQyO1xuICAgICAgICAgIHhbaTFdICs9IHQyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IoaTAgPSBpeDsgaTAgPCBuOyBpMCArPSBpZCkge1xuICAgICAgICAgIGkxID0gaTA7XG4gICAgICAgICAgaTIgPSBpMSArIG40O1xuICAgICAgICAgIGkzID0gaTIgKyBuNDtcbiAgICAgICAgICBpNCA9IGkzICsgbjQ7XG4gICAgIFxuICAgICAgICAgIC8vZGlmZnN1bTNfcih4W2kzXSwgeFtpNF0sIHQxKTsgLy8ge2EsIGIsIHN9IDwtLXwge2EsIGItYSwgYStifVxuICAgICAgICAgIHQxID0geFtpM10gKyB4W2k0XTsgXG4gICAgICAgICAgeFtpNF0gLT0geFtpM107XG4gICAgICAgICAgXG4gICAgICAgICAgLy9zdW1kaWZmMyh4W2kxXSwgdDEsIHhbaTNdKTsgICAvLyB7YSwgYiwgZH0gPC0tfCB7YStiLCBiLCBhLWJ9XG4gICAgICAgICAgeFtpM10gPSB4W2kxXSAtIHQxOyBcbiAgICAgICAgICB4W2kxXSArPSB0MTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgXG4gICAgICBpeCA9IChpZCA8PCAxKSAtIG4yO1xuICAgICAgaWQgPSBpZCA8PCAyO1xuICAgIH0gd2hpbGUgKGl4IDwgbik7XG4gXG4gICAgZSA9IFRXT19QSSAvIG4yO1xuXG4gICAgZm9yICh2YXIgaiA9IDE7IGogPCBuODsgaisrKSB7XG4gICAgICBhID0gaiAqIGU7XG4gICAgICBzczEgPSBNYXRoLnNpbihhKTtcbiAgICAgIGNjMSA9IE1hdGguY29zKGEpO1xuXG4gICAgICAvL3NzMyA9IHNpbigzKmEpOyBjYzMgPSBjb3MoMyphKTtcbiAgICAgIGNjMyA9IDQqY2MxKihjYzEqY2MxLTAuNzUpO1xuICAgICAgc3MzID0gNCpzczEqKDAuNzUtc3MxKnNzMSk7XG4gICBcbiAgICAgIGl4ID0gMDsgaWQgPSBuMiA8PCAxO1xuICAgICAgZG8ge1xuICAgICAgICBmb3IgKGkwID0gaXg7IGkwIDwgbjsgaTAgKz0gaWQpIHtcbiAgICAgICAgICBpMSA9IGkwICsgajtcbiAgICAgICAgICBpMiA9IGkxICsgbjQ7XG4gICAgICAgICAgaTMgPSBpMiArIG40O1xuICAgICAgICAgIGk0ID0gaTMgKyBuNDtcbiAgICAgICBcbiAgICAgICAgICBpNSA9IGkwICsgbjQgLSBqO1xuICAgICAgICAgIGk2ID0gaTUgKyBuNDtcbiAgICAgICAgICBpNyA9IGk2ICsgbjQ7XG4gICAgICAgICAgaTggPSBpNyArIG40O1xuICAgICAgIFxuICAgICAgICAgIC8vY211bHQoYywgcywgeCwgeSwgJnUsICZ2KVxuICAgICAgICAgIC8vY211bHQoY2MxLCBzczEsIHhbaTddLCB4W2kzXSwgdDIsIHQxKTsgLy8ge3Usdn0gPC0tfCB7eCpjLXkqcywgeCpzK3kqY31cbiAgICAgICAgICB0MiA9IHhbaTddKmNjMSAtIHhbaTNdKnNzMTsgXG4gICAgICAgICAgdDEgPSB4W2k3XSpzczEgKyB4W2kzXSpjYzE7XG4gICAgICAgICAgXG4gICAgICAgICAgLy9jbXVsdChjYzMsIHNzMywgeFtpOF0sIHhbaTRdLCB0NCwgdDMpO1xuICAgICAgICAgIHQ0ID0geFtpOF0qY2MzIC0geFtpNF0qc3MzOyBcbiAgICAgICAgICB0MyA9IHhbaThdKnNzMyArIHhbaTRdKmNjMztcbiAgICAgICBcbiAgICAgICAgICAvL3N1bWRpZmYodDIsIHQ0KTsgICAvLyB7YSwgYn0gPC0tfCB7YStiLCBhLWJ9XG4gICAgICAgICAgc3QxID0gdDIgLSB0NDtcbiAgICAgICAgICB0MiArPSB0NDtcbiAgICAgICAgICB0NCA9IHN0MTtcbiAgICAgICAgICBcbiAgICAgICAgICAvL3N1bWRpZmYodDIsIHhbaTZdLCB4W2k4XSwgeFtpM10pOyAvLyB7cywgZH0gIDwtLXwge2ErYiwgYS1ifVxuICAgICAgICAgIC8vc3QxID0geFtpNl07IHhbaThdID0gdDIgKyBzdDE7IHhbaTNdID0gdDIgLSBzdDE7XG4gICAgICAgICAgeFtpOF0gPSB0MiArIHhbaTZdOyBcbiAgICAgICAgICB4W2kzXSA9IHQyIC0geFtpNl07XG4gICAgICAgICBcbiAgICAgICAgICAvL3N1bWRpZmZfcih0MSwgdDMpOyAvLyB7YSwgYn0gPC0tfCB7YStiLCBiLWF9XG4gICAgICAgICAgc3QxID0gdDMgLSB0MTtcbiAgICAgICAgICB0MSArPSB0MztcbiAgICAgICAgICB0MyA9IHN0MTtcbiAgICAgICAgICBcbiAgICAgICAgICAvL3N1bWRpZmYodDMsIHhbaTJdLCB4W2k0XSwgeFtpN10pOyAvLyB7cywgZH0gIDwtLXwge2ErYiwgYS1ifVxuICAgICAgICAgIC8vc3QxID0geFtpMl07IHhbaTRdID0gdDMgKyBzdDE7IHhbaTddID0gdDMgLSBzdDE7XG4gICAgICAgICAgeFtpNF0gPSB0MyArIHhbaTJdOyBcbiAgICAgICAgICB4W2k3XSA9IHQzIC0geFtpMl07XG4gICAgICAgICBcbiAgICAgICAgICAvL3N1bWRpZmYzKHhbaTFdLCB0MSwgeFtpNl0pOyAgIC8vIHthLCBiLCBkfSA8LS18IHthK2IsIGIsIGEtYn1cbiAgICAgICAgICB4W2k2XSA9IHhbaTFdIC0gdDE7IFxuICAgICAgICAgIHhbaTFdICs9IHQxO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vZGlmZnN1bTNfcih0NCwgeFtpNV0sIHhbaTJdKTsgLy8ge2EsIGIsIHN9IDwtLXwge2EsIGItYSwgYStifVxuICAgICAgICAgIHhbaTJdID0gdDQgKyB4W2k1XTsgXG4gICAgICAgICAgeFtpNV0gLT0gdDQ7XG4gICAgICAgIH1cbiAgICAgXG4gICAgICAgIGl4ID0gKGlkIDw8IDEpIC0gbjI7XG4gICAgICAgIGlkID0gaWQgPDwgMjtcbiAgIFxuICAgICAgfSB3aGlsZSAoaXggPCBuKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoLS1pKSB7XG4gICAgcnZhbCA9IHhbaV07XG4gICAgaXZhbCA9IHhbbi1pLTFdO1xuICAgIG1hZyA9IGJTaSAqIHNxcnQocnZhbCAqIHJ2YWwgKyBpdmFsICogaXZhbCk7XG5cbiAgICBpZiAobWFnID4gdGhpcy5wZWFrKSB7XG4gICAgICB0aGlzLnBlYWtCYW5kID0gaTtcbiAgICAgIHRoaXMucGVhayA9IG1hZztcbiAgICB9XG5cbiAgICBzcGVjdHJ1bVtpXSA9IG1hZztcbiAgfVxuXG4gIHNwZWN0cnVtWzBdID0gYlNpICogeFswXTtcblxuICByZXR1cm4gc3BlY3RydW07XG59O1xuXG5mdW5jdGlvbiBTYW1wbGVyKGZpbGUsIGJ1ZmZlclNpemUsIHNhbXBsZVJhdGUsIHBsYXlTdGFydCwgcGxheUVuZCwgbG9vcFN0YXJ0LCBsb29wRW5kLCBsb29wTW9kZSkge1xuICB0aGlzLmZpbGUgPSBmaWxlO1xuICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICB0aGlzLnNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xuICB0aGlzLnBsYXlTdGFydCAgPSBwbGF5U3RhcnQgfHwgMDsgLy8gMCVcbiAgdGhpcy5wbGF5RW5kICAgID0gcGxheUVuZCAgIHx8IDE7IC8vIDEwMCVcbiAgdGhpcy5sb29wU3RhcnQgID0gbG9vcFN0YXJ0IHx8IDA7XG4gIHRoaXMubG9vcEVuZCAgICA9IGxvb3BFbmQgICB8fCAxO1xuICB0aGlzLmxvb3BNb2RlICAgPSBsb29wTW9kZSAgfHwgRFNQLk9GRjtcbiAgdGhpcy5sb2FkZWQgICAgID0gZmFsc2U7XG4gIHRoaXMuc2FtcGxlcyAgICA9IFtdO1xuICB0aGlzLnNpZ25hbCAgICAgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUpO1xuICB0aGlzLmZyYW1lQ291bnQgPSAwO1xuICB0aGlzLmVudmVsb3BlICAgPSBudWxsO1xuICB0aGlzLmFtcGxpdHVkZSAgPSAxO1xuICB0aGlzLnJvb3RGcmVxdWVuY3kgPSAxMTA7IC8vIEEyIDExMFxuICB0aGlzLmZyZXF1ZW5jeSAgPSA1NTA7XG4gIHRoaXMuc3RlcCAgICAgICA9IHRoaXMuZnJlcXVlbmN5IC8gdGhpcy5yb290RnJlcXVlbmN5O1xuICB0aGlzLmR1cmF0aW9uICAgPSAwO1xuICB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPSAwO1xuICB0aGlzLnBsYXloZWFkICAgPSAwO1xuIFxuICB2YXIgYXVkaW8gPSAvKiBuZXcgQXVkaW8oKTsqLyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiQVVESU9cIik7XG4gIHZhciBzZWxmID0gdGhpcztcbiBcbiAgdGhpcy5sb2FkU2FtcGxlcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGJ1ZmZlciA9IERTUC5nZXRDaGFubmVsKERTUC5NSVgsIGV2ZW50LmZyYW1lQnVmZmVyKTtcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGYuc2FtcGxlcy5wdXNoKGJ1ZmZlcltpXSk7XG4gICAgfVxuICB9O1xuIFxuICB0aGlzLmxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGNvbnZlcnQgZmxleGlibGUganMgYXJyYXkgaW50byBhIGZhc3QgdHlwZWQgYXJyYXlcbiAgICBzZWxmLnNhbXBsZXMgPSBuZXcgRmxvYXQzMkFycmF5KHNlbGYuc2FtcGxlcyk7XG4gICAgc2VsZi5sb2FkZWQgPSB0cnVlO1xuICB9O1xuIFxuICB0aGlzLmxvYWRNZXRhRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZHVyYXRpb24gPSBhdWRpby5kdXJhdGlvbjtcbiAgfTtcbiBcbiAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcihcIk1vekF1ZGlvQXZhaWxhYmxlXCIsIHRoaXMubG9hZFNhbXBsZXMsIGZhbHNlKTtcbiAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsIHRoaXMubG9hZE1ldGFEYXRhLCBmYWxzZSk7XG4gIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoXCJlbmRlZFwiLCB0aGlzLmxvYWRDb21wbGV0ZSwgZmFsc2UpO1xuICBhdWRpby5tdXRlZCA9IHRydWU7XG4gIGF1ZGlvLnNyYyA9IGZpbGU7XG4gIGF1ZGlvLnBsYXkoKTtcbn1cblxuU2FtcGxlci5wcm90b3R5cGUuYXBwbHlFbnZlbG9wZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVudmVsb3BlLnByb2Nlc3ModGhpcy5zaWduYWwpO1xuICByZXR1cm4gdGhpcy5zaWduYWw7XG59O1xuXG5TYW1wbGVyLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZnJhbWVPZmZzZXQgPSB0aGlzLmZyYW1lQ291bnQgKiB0aGlzLmJ1ZmZlclNpemU7XG4gXG4gIHZhciBsb29wV2lkdGggPSB0aGlzLnBsYXlFbmQgKiB0aGlzLnNhbXBsZXMubGVuZ3RoIC0gdGhpcy5wbGF5U3RhcnQgKiB0aGlzLnNhbXBsZXMubGVuZ3RoO1xuICB2YXIgcGxheVN0YXJ0U2FtcGxlcyA9IHRoaXMucGxheVN0YXJ0ICogdGhpcy5zYW1wbGVzLmxlbmd0aDsgLy8gaWUgMC41IC0+IDUwJSBvZiB0aGUgbGVuZ3RoXG4gIHZhciBwbGF5RW5kU2FtcGxlcyA9IHRoaXMucGxheUVuZCAqIHRoaXMuc2FtcGxlcy5sZW5ndGg7IC8vIGllIDAuNSAtPiA1MCUgb2YgdGhlIGxlbmd0aFxuICB2YXIgb2Zmc2V0O1xuXG4gIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYnVmZmVyU2l6ZTsgaSsrICkge1xuICAgIHN3aXRjaCAodGhpcy5sb29wTW9kZSkge1xuICAgICAgY2FzZSBEU1AuT0ZGOlxuICAgICAgICB0aGlzLnBsYXloZWFkID0gTWF0aC5yb3VuZCh0aGlzLnNhbXBsZXNQcm9jZXNzZWQgKiB0aGlzLnN0ZXAgKyBwbGF5U3RhcnRTYW1wbGVzKTtcbiAgICAgICAgaWYgKHRoaXMucGxheWhlYWQgPCAodGhpcy5wbGF5RW5kICogdGhpcy5zYW1wbGVzLmxlbmd0aCkgKSB7XG4gICAgICAgICAgdGhpcy5zaWduYWxbaV0gPSB0aGlzLnNhbXBsZXNbdGhpcy5wbGF5aGVhZF0gKiB0aGlzLmFtcGxpdHVkZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNpZ25hbFtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgIFxuICAgICAgY2FzZSBEU1AuRlc6XG4gICAgICAgIHRoaXMucGxheWhlYWQgPSBNYXRoLnJvdW5kKCh0aGlzLnNhbXBsZXNQcm9jZXNzZWQgKiB0aGlzLnN0ZXApICUgbG9vcFdpZHRoICsgcGxheVN0YXJ0U2FtcGxlcyk7XG4gICAgICAgIGlmICh0aGlzLnBsYXloZWFkIDwgKHRoaXMucGxheUVuZCAqIHRoaXMuc2FtcGxlcy5sZW5ndGgpICkge1xuICAgICAgICAgIHRoaXMuc2lnbmFsW2ldID0gdGhpcy5zYW1wbGVzW3RoaXMucGxheWhlYWRdICogdGhpcy5hbXBsaXR1ZGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgXG4gICAgICBjYXNlIERTUC5CVzpcbiAgICAgICAgdGhpcy5wbGF5aGVhZCA9IHBsYXlFbmRTYW1wbGVzIC0gTWF0aC5yb3VuZCgodGhpcy5zYW1wbGVzUHJvY2Vzc2VkICogdGhpcy5zdGVwKSAlIGxvb3BXaWR0aCk7XG4gICAgICAgIGlmICh0aGlzLnBsYXloZWFkIDwgKHRoaXMucGxheUVuZCAqIHRoaXMuc2FtcGxlcy5sZW5ndGgpICkge1xuICAgICAgICAgIHRoaXMuc2lnbmFsW2ldID0gdGhpcy5zYW1wbGVzW3RoaXMucGxheWhlYWRdICogdGhpcy5hbXBsaXR1ZGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgXG4gICAgICBjYXNlIERTUC5GV0JXOlxuICAgICAgICBpZiAoIE1hdGguZmxvb3IodGhpcy5zYW1wbGVzUHJvY2Vzc2VkICogdGhpcy5zdGVwIC8gbG9vcFdpZHRoKSAlIDIgPT09IDAgKSB7XG4gICAgICAgICAgdGhpcy5wbGF5aGVhZCA9IE1hdGgucm91bmQoKHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAqIHRoaXMuc3RlcCkgJSBsb29wV2lkdGggKyBwbGF5U3RhcnRTYW1wbGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBsYXloZWFkID0gcGxheUVuZFNhbXBsZXMgLSBNYXRoLnJvdW5kKCh0aGlzLnNhbXBsZXNQcm9jZXNzZWQgKiB0aGlzLnN0ZXApICUgbG9vcFdpZHRoKTtcbiAgICAgICAgfSAgXG4gICAgICAgIGlmICh0aGlzLnBsYXloZWFkIDwgKHRoaXMucGxheUVuZCAqIHRoaXMuc2FtcGxlcy5sZW5ndGgpICkge1xuICAgICAgICAgIHRoaXMuc2lnbmFsW2ldID0gdGhpcy5zYW1wbGVzW3RoaXMucGxheWhlYWRdICogdGhpcy5hbXBsaXR1ZGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCsrO1xuICB9XG5cbiAgdGhpcy5mcmFtZUNvdW50Kys7XG5cbiAgcmV0dXJuIHRoaXMuc2lnbmFsO1xufTtcblxuU2FtcGxlci5wcm90b3R5cGUuc2V0RnJlcSA9IGZ1bmN0aW9uKGZyZXF1ZW5jeSkge1xuICAgIHZhciB0b3RhbFByb2Nlc3NlZCA9IHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAqIHRoaXMuc3RlcDtcbiAgICB0aGlzLmZyZXF1ZW5jeSA9IGZyZXF1ZW5jeTtcbiAgICB0aGlzLnN0ZXAgPSB0aGlzLmZyZXF1ZW5jeSAvIHRoaXMucm9vdEZyZXF1ZW5jeTtcbiAgICB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPSBNYXRoLnJvdW5kKHRvdGFsUHJvY2Vzc2VkL3RoaXMuc3RlcCk7XG59O1xuXG5TYW1wbGVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPSAwO1xuICB0aGlzLnBsYXloZWFkID0gMDtcbn07XG5cbi8qKlxuICogT3NjaWxsYXRvciBjbGFzcyBmb3IgZ2VuZXJhdGluZyBhbmQgbW9kaWZ5aW5nIHNpZ25hbHNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSAgICAgICBBIHdhdmVmb3JtIGNvbnN0YW50IChlZy4gRFNQLlNJTkUpXG4gKiBAcGFyYW0ge051bWJlcn0gZnJlcXVlbmN5ICBJbml0aWFsIGZyZXF1ZW5jeSBvZiB0aGUgc2lnbmFsXG4gKiBAcGFyYW0ge051bWJlcn0gYW1wbGl0dWRlICBJbml0aWFsIGFtcGxpdHVkZSBvZiB0aGUgc2lnbmFsXG4gKiBAcGFyYW0ge051bWJlcn0gYnVmZmVyU2l6ZSBTaXplIG9mIHRoZSBzYW1wbGUgYnVmZmVyIHRvIGdlbmVyYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gc2FtcGxlUmF0ZSBUaGUgc2FtcGxlIHJhdGUgb2YgdGhlIHNpZ25hbFxuICpcbiAqIEBjb250cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE9zY2lsbGF0b3IodHlwZSwgZnJlcXVlbmN5LCBhbXBsaXR1ZGUsIGJ1ZmZlclNpemUsIHNhbXBsZVJhdGUpIHtcbiAgdGhpcy5mcmVxdWVuY3kgID0gZnJlcXVlbmN5O1xuICB0aGlzLmFtcGxpdHVkZSAgPSBhbXBsaXR1ZGU7XG4gIHRoaXMuYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemU7XG4gIHRoaXMuc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7XG4gIC8vdGhpcy5wdWxzZVdpZHRoID0gcHVsc2VXaWR0aDtcbiAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiBcbiAgdGhpcy53YXZlVGFibGVMZW5ndGggPSAyMDQ4O1xuXG4gIHRoaXMuY3ljbGVzUGVyU2FtcGxlID0gZnJlcXVlbmN5IC8gc2FtcGxlUmF0ZTtcblxuICB0aGlzLnNpZ25hbCA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSk7XG4gIHRoaXMuZW52ZWxvcGUgPSBudWxsO1xuXG4gIHN3aXRjaChwYXJzZUludCh0eXBlLCAxMCkpIHtcbiAgICBjYXNlIERTUC5UUklBTkdMRTpcbiAgICAgIHRoaXMuZnVuYyA9IE9zY2lsbGF0b3IuVHJpYW5nbGU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRFNQLlNBVzpcbiAgICAgIHRoaXMuZnVuYyA9IE9zY2lsbGF0b3IuU2F3O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIERTUC5TUVVBUkU6XG4gICAgICB0aGlzLmZ1bmMgPSBPc2NpbGxhdG9yLlNxdWFyZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIERTUC5TSU5FOlxuICAgICAgdGhpcy5mdW5jID0gT3NjaWxsYXRvci5TaW5lO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB0aGlzLmdlbmVyYXRlV2F2ZVRhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgT3NjaWxsYXRvci53YXZlVGFibGVbdGhpcy5mdW5jXSA9IG5ldyBGbG9hdDMyQXJyYXkoMjA0OCk7XG4gICAgdmFyIHdhdmVUYWJsZVRpbWUgPSB0aGlzLndhdmVUYWJsZUxlbmd0aCAvIHRoaXMuc2FtcGxlUmF0ZTtcbiAgICB2YXIgd2F2ZVRhYmxlSHogPSAxIC8gd2F2ZVRhYmxlVGltZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy53YXZlVGFibGVMZW5ndGg7IGkrKykge1xuICAgICAgT3NjaWxsYXRvci53YXZlVGFibGVbdGhpcy5mdW5jXVtpXSA9IHRoaXMuZnVuYyhpICogd2F2ZVRhYmxlSHovdGhpcy5zYW1wbGVSYXRlKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKCB0eXBlb2YgT3NjaWxsYXRvci53YXZlVGFibGUgPT09ICd1bmRlZmluZWQnICkge1xuICAgIE9zY2lsbGF0b3Iud2F2ZVRhYmxlID0ge307XG4gIH1cblxuICBpZiAoIHR5cGVvZiBPc2NpbGxhdG9yLndhdmVUYWJsZVt0aGlzLmZ1bmNdID09PSAndW5kZWZpbmVkJyApIHtcbiAgICB0aGlzLmdlbmVyYXRlV2F2ZVRhYmxlKCk7XG4gIH1cbiBcbiAgdGhpcy53YXZlVGFibGUgPSBPc2NpbGxhdG9yLndhdmVUYWJsZVt0aGlzLmZ1bmNdO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYW1wbGl0dWRlIG9mIHRoZSBzaWduYWxcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYW1wbGl0dWRlIFRoZSBhbXBsaXR1ZGUgb2YgdGhlIHNpZ25hbCAoYmV0d2VlbiAwIGFuZCAxKVxuICovXG5Pc2NpbGxhdG9yLnByb3RvdHlwZS5zZXRBbXAgPSBmdW5jdGlvbihhbXBsaXR1ZGUpIHtcbiAgaWYgKGFtcGxpdHVkZSA+PSAwICYmIGFtcGxpdHVkZSA8PSAxKSB7XG4gICAgdGhpcy5hbXBsaXR1ZGUgPSBhbXBsaXR1ZGU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgXCJBbXBsaXR1ZGUgb3V0IG9mIHJhbmdlICgwLi4xKS5cIjtcbiAgfVxufTtcbiAgXG4vKipcbiAqIFNldCB0aGUgZnJlcXVlbmN5IG9mIHRoZSBzaWduYWxcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZnJlcXVlbmN5IFRoZSBmcmVxdWVuY3kgb2YgdGhlIHNpZ25hbFxuICovICBcbk9zY2lsbGF0b3IucHJvdG90eXBlLnNldEZyZXEgPSBmdW5jdGlvbihmcmVxdWVuY3kpIHtcbiAgdGhpcy5mcmVxdWVuY3kgPSBmcmVxdWVuY3k7XG4gIHRoaXMuY3ljbGVzUGVyU2FtcGxlID0gZnJlcXVlbmN5IC8gdGhpcy5zYW1wbGVSYXRlO1xufTtcbiAgICAgXG4vLyBBZGQgYW4gb3NjaWxsYXRvclxuT3NjaWxsYXRvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob3NjaWxsYXRvcikge1xuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlclNpemU7IGkrKyApIHtcbiAgICAvL3RoaXMuc2lnbmFsW2ldICs9IG9zY2lsbGF0b3IudmFsdWVBdChpKTtcbiAgICB0aGlzLnNpZ25hbFtpXSArPSBvc2NpbGxhdG9yLnNpZ25hbFtpXTtcbiAgfVxuIFxuICByZXR1cm4gdGhpcy5zaWduYWw7XG59O1xuICAgICBcbi8vIEFkZCBhIHNpZ25hbCB0byB0aGUgY3VycmVudCBnZW5lcmF0ZWQgb3NjIHNpZ25hbFxuT3NjaWxsYXRvci5wcm90b3R5cGUuYWRkU2lnbmFsID0gZnVuY3Rpb24oc2lnbmFsKSB7XG4gIGZvciAoIHZhciBpID0gMDsgaSA8IHNpZ25hbC5sZW5ndGg7IGkrKyApIHtcbiAgICBpZiAoIGkgPj0gdGhpcy5idWZmZXJTaXplICkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuc2lnbmFsW2ldICs9IHNpZ25hbFtpXTtcbiAgIFxuICAgIC8qXG4gICAgLy8gQ29uc3RyYWluIGFtcGxpdHVkZVxuICAgIGlmICggdGhpcy5zaWduYWxbaV0gPiAxICkge1xuICAgICAgdGhpcy5zaWduYWxbaV0gPSAxO1xuICAgIH0gZWxzZSBpZiAoIHRoaXMuc2lnbmFsW2ldIDwgLTEgKSB7XG4gICAgICB0aGlzLnNpZ25hbFtpXSA9IC0xO1xuICAgIH1cbiAgICAqL1xuICB9XG4gIHJldHVybiB0aGlzLnNpZ25hbDtcbn07XG4gICAgIFxuLy8gQWRkIGFuIGVudmVsb3BlIHRvIHRoZSBvc2NpbGxhdG9yXG5Pc2NpbGxhdG9yLnByb3RvdHlwZS5hZGRFbnZlbG9wZSA9IGZ1bmN0aW9uKGVudmVsb3BlKSB7XG4gIHRoaXMuZW52ZWxvcGUgPSBlbnZlbG9wZTtcbn07XG5cbk9zY2lsbGF0b3IucHJvdG90eXBlLmFwcGx5RW52ZWxvcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbnZlbG9wZS5wcm9jZXNzKHRoaXMuc2lnbmFsKTtcbn07XG4gICAgIFxuT3NjaWxsYXRvci5wcm90b3R5cGUudmFsdWVBdCA9IGZ1bmN0aW9uKG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53YXZlVGFibGVbb2Zmc2V0ICUgdGhpcy53YXZlVGFibGVMZW5ndGhdO1xufTtcbiAgICAgXG5Pc2NpbGxhdG9yLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZnJhbWVPZmZzZXQgPSB0aGlzLmZyYW1lQ291bnQgKiB0aGlzLmJ1ZmZlclNpemU7XG4gIHZhciBzdGVwID0gdGhpcy53YXZlVGFibGVMZW5ndGggKiB0aGlzLmZyZXF1ZW5jeSAvIHRoaXMuc2FtcGxlUmF0ZTtcbiAgdmFyIG9mZnNldDtcblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlclNpemU7IGkrKyApIHtcbiAgICAvL3ZhciBzdGVwID0gKGZyYW1lT2Zmc2V0ICsgaSkgKiB0aGlzLmN5Y2xlc1BlclNhbXBsZSAlIDE7XG4gICAgLy90aGlzLnNpZ25hbFtpXSA9IHRoaXMuZnVuYyhzdGVwKSAqIHRoaXMuYW1wbGl0dWRlO1xuICAgIC8vdGhpcy5zaWduYWxbaV0gPSB0aGlzLnZhbHVlQXQoTWF0aC5yb3VuZCgoZnJhbWVPZmZzZXQgKyBpKSAqIHN0ZXApKSAqIHRoaXMuYW1wbGl0dWRlO1xuICAgIG9mZnNldCA9IE1hdGgucm91bmQoKGZyYW1lT2Zmc2V0ICsgaSkgKiBzdGVwKTtcbiAgICB0aGlzLnNpZ25hbFtpXSA9IHRoaXMud2F2ZVRhYmxlW29mZnNldCAlIHRoaXMud2F2ZVRhYmxlTGVuZ3RoXSAqIHRoaXMuYW1wbGl0dWRlO1xuICB9XG5cbiAgdGhpcy5mcmFtZUNvdW50Kys7XG5cbiAgcmV0dXJuIHRoaXMuc2lnbmFsO1xufTtcblxuT3NjaWxsYXRvci5TaW5lID0gZnVuY3Rpb24oc3RlcCkge1xuICByZXR1cm4gTWF0aC5zaW4oRFNQLlRXT19QSSAqIHN0ZXApO1xufTtcblxuT3NjaWxsYXRvci5TcXVhcmUgPSBmdW5jdGlvbihzdGVwKSB7XG4gIHJldHVybiBzdGVwIDwgMC41ID8gMSA6IC0xO1xufTtcblxuT3NjaWxsYXRvci5TYXcgPSBmdW5jdGlvbihzdGVwKSB7XG4gIHJldHVybiAyICogKHN0ZXAgLSBNYXRoLnJvdW5kKHN0ZXApKTtcbn07XG5cbk9zY2lsbGF0b3IuVHJpYW5nbGUgPSBmdW5jdGlvbihzdGVwKSB7XG4gIHJldHVybiAxIC0gNCAqIE1hdGguYWJzKE1hdGgucm91bmQoc3RlcCkgLSBzdGVwKTtcbn07XG5cbk9zY2lsbGF0b3IuUHVsc2UgPSBmdW5jdGlvbihzdGVwKSB7XG4gIC8vIHN0dWJcbn07XG4gXG5mdW5jdGlvbiBBRFNSKGF0dGFja0xlbmd0aCwgZGVjYXlMZW5ndGgsIHN1c3RhaW5MZXZlbCwgc3VzdGFpbkxlbmd0aCwgcmVsZWFzZUxlbmd0aCwgc2FtcGxlUmF0ZSkge1xuICB0aGlzLnNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xuICAvLyBMZW5ndGggaW4gc2Vjb25kc1xuICB0aGlzLmF0dGFja0xlbmd0aCAgPSBhdHRhY2tMZW5ndGg7XG4gIHRoaXMuZGVjYXlMZW5ndGggICA9IGRlY2F5TGVuZ3RoO1xuICB0aGlzLnN1c3RhaW5MZXZlbCAgPSBzdXN0YWluTGV2ZWw7XG4gIHRoaXMuc3VzdGFpbkxlbmd0aCA9IHN1c3RhaW5MZW5ndGg7XG4gIHRoaXMucmVsZWFzZUxlbmd0aCA9IHJlbGVhc2VMZW5ndGg7XG4gIHRoaXMuc2FtcGxlUmF0ZSAgICA9IHNhbXBsZVJhdGU7XG4gXG4gIC8vIExlbmd0aCBpbiBzYW1wbGVzXG4gIHRoaXMuYXR0YWNrU2FtcGxlcyAgPSBhdHRhY2tMZW5ndGggICogc2FtcGxlUmF0ZTtcbiAgdGhpcy5kZWNheVNhbXBsZXMgICA9IGRlY2F5TGVuZ3RoICAgKiBzYW1wbGVSYXRlO1xuICB0aGlzLnN1c3RhaW5TYW1wbGVzID0gc3VzdGFpbkxlbmd0aCAqIHNhbXBsZVJhdGU7XG4gIHRoaXMucmVsZWFzZVNhbXBsZXMgPSByZWxlYXNlTGVuZ3RoICogc2FtcGxlUmF0ZTtcbiBcbiAgLy8gVXBkYXRlcyB0aGUgZW52ZWxvcGUgc2FtcGxlIHBvc2l0aW9uc1xuICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYXR0YWNrICAgICAgICAgPSAgICAgICAgICAgICAgICB0aGlzLmF0dGFja1NhbXBsZXM7XG4gICAgdGhpcy5kZWNheSAgICAgICAgICA9IHRoaXMuYXR0YWNrICArIHRoaXMuZGVjYXlTYW1wbGVzO1xuICAgIHRoaXMuc3VzdGFpbiAgICAgICAgPSB0aGlzLmRlY2F5ICAgKyB0aGlzLnN1c3RhaW5TYW1wbGVzO1xuICAgIHRoaXMucmVsZWFzZSAgICAgICAgPSB0aGlzLnN1c3RhaW4gKyB0aGlzLnJlbGVhc2VTYW1wbGVzO1xuICB9O1xuIFxuICB0aGlzLnVwZGF0ZSgpO1xuIFxuICB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPSAwO1xufVxuXG5BRFNSLnByb3RvdHlwZS5ub3RlT24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID0gMDtcbiAgdGhpcy5zdXN0YWluU2FtcGxlcyA9IHRoaXMuc3VzdGFpbkxlbmd0aCAqIHRoaXMuc2FtcGxlUmF0ZTtcbiAgdGhpcy51cGRhdGUoKTtcbn07XG5cbi8vIFNlbmQgYSBub3RlIG9mZiB3aGVuIHVzaW5nIGEgc3VzdGFpbiBvZiBpbmZpbml0eSB0byBsZXQgdGhlIGVudmVsb3BlIGVudGVyIHRoZSByZWxlYXNlIHBoYXNlXG5BRFNSLnByb3RvdHlwZS5ub3RlT2ZmID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc3VzdGFpblNhbXBsZXMgPSB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgLSB0aGlzLmRlY2F5U2FtcGxlcztcbiAgdGhpcy51cGRhdGUoKTtcbn07XG5cbkFEU1IucHJvdG90eXBlLnByb2Nlc3NTYW1wbGUgPSBmdW5jdGlvbihzYW1wbGUpIHtcbiAgdmFyIGFtcGxpdHVkZSA9IDA7XG5cbiAgaWYgKCB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPD0gdGhpcy5hdHRhY2sgKSB7XG4gICAgYW1wbGl0dWRlID0gMCArICgxIC0gMCkgKiAoKHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAtIDApIC8gKHRoaXMuYXR0YWNrIC0gMCkpO1xuICB9IGVsc2UgaWYgKCB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPiB0aGlzLmF0dGFjayAmJiB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPD0gdGhpcy5kZWNheSApIHtcbiAgICBhbXBsaXR1ZGUgPSAxICsgKHRoaXMuc3VzdGFpbkxldmVsIC0gMSkgKiAoKHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAtIHRoaXMuYXR0YWNrKSAvICh0aGlzLmRlY2F5IC0gdGhpcy5hdHRhY2spKTtcbiAgfSBlbHNlIGlmICggdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID4gdGhpcy5kZWNheSAmJiB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPD0gdGhpcy5zdXN0YWluICkge1xuICAgIGFtcGxpdHVkZSA9IHRoaXMuc3VzdGFpbkxldmVsO1xuICB9IGVsc2UgaWYgKCB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPiB0aGlzLnN1c3RhaW4gJiYgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkIDw9IHRoaXMucmVsZWFzZSApIHtcbiAgICBhbXBsaXR1ZGUgPSB0aGlzLnN1c3RhaW5MZXZlbCArICgwIC0gdGhpcy5zdXN0YWluTGV2ZWwpICogKCh0aGlzLnNhbXBsZXNQcm9jZXNzZWQgLSB0aGlzLnN1c3RhaW4pIC8gKHRoaXMucmVsZWFzZSAtIHRoaXMuc3VzdGFpbikpO1xuICB9XG4gXG4gIHJldHVybiBzYW1wbGUgKiBhbXBsaXR1ZGU7XG59O1xuXG5BRFNSLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYW1wbGl0dWRlID0gMDtcblxuICBpZiAoIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA8PSB0aGlzLmF0dGFjayApIHtcbiAgICBhbXBsaXR1ZGUgPSAwICsgKDEgLSAwKSAqICgodGhpcy5zYW1wbGVzUHJvY2Vzc2VkIC0gMCkgLyAodGhpcy5hdHRhY2sgLSAwKSk7XG4gIH0gZWxzZSBpZiAoIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA+IHRoaXMuYXR0YWNrICYmIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA8PSB0aGlzLmRlY2F5ICkge1xuICAgIGFtcGxpdHVkZSA9IDEgKyAodGhpcy5zdXN0YWluTGV2ZWwgLSAxKSAqICgodGhpcy5zYW1wbGVzUHJvY2Vzc2VkIC0gdGhpcy5hdHRhY2spIC8gKHRoaXMuZGVjYXkgLSB0aGlzLmF0dGFjaykpO1xuICB9IGVsc2UgaWYgKCB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPiB0aGlzLmRlY2F5ICYmIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA8PSB0aGlzLnN1c3RhaW4gKSB7XG4gICAgYW1wbGl0dWRlID0gdGhpcy5zdXN0YWluTGV2ZWw7XG4gIH0gZWxzZSBpZiAoIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA+IHRoaXMuc3VzdGFpbiAmJiB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPD0gdGhpcy5yZWxlYXNlICkge1xuICAgIGFtcGxpdHVkZSA9IHRoaXMuc3VzdGFpbkxldmVsICsgKDAgLSB0aGlzLnN1c3RhaW5MZXZlbCkgKiAoKHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAtIHRoaXMuc3VzdGFpbikgLyAodGhpcy5yZWxlYXNlIC0gdGhpcy5zdXN0YWluKSk7XG4gIH1cbiBcbiAgcmV0dXJuIGFtcGxpdHVkZTtcbn07XG4gICAgIFxuQURTUi5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKysgKSB7XG4gICAgYnVmZmVyW2ldICo9IHRoaXMudmFsdWUoKTtcblxuICAgIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCsrO1xuICB9XG4gXG4gIHJldHVybiBidWZmZXI7XG59O1xuICAgICBcbiAgICAgXG5BRFNSLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA+IHRoaXMucmVsZWFzZSB8fCB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPT09IC0xICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuQURTUi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPSAtMTtcbn07XG4gXG5mdW5jdGlvbiBJSVJGaWx0ZXIodHlwZSwgY3V0b2ZmLCByZXNvbmFuY2UsIHNhbXBsZVJhdGUpIHtcbiAgdGhpcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcblxuICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgRFNQLkxPV1BBU1M6XG4gICAgY2FzZSBEU1AuTFAxMjpcbiAgICAgIHRoaXMuZnVuYyA9IG5ldyBJSVJGaWx0ZXIuTFAxMihjdXRvZmYsIHJlc29uYW5jZSwgc2FtcGxlUmF0ZSk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5JSVJGaWx0ZXIucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oJ2N1dG9mZicsXG4gIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bmMuY3V0b2ZmO1xuICB9XG4pO1xuXG5JSVJGaWx0ZXIucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oJ3Jlc29uYW5jZScsXG4gIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZ1bmMucmVzb25hbmNlO1xuICB9XG4pO1xuXG5JSVJGaWx0ZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGN1dG9mZiwgcmVzb25hbmNlKSB7XG4gIHRoaXMuZnVuYy5jYWxjQ29lZmYoY3V0b2ZmLCByZXNvbmFuY2UpO1xufTtcblxuSUlSRmlsdGVyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHRoaXMuZnVuYy5wcm9jZXNzKGJ1ZmZlcik7XG59O1xuXG4vLyBBZGQgYW4gZW52ZWxvcGUgdG8gdGhlIGZpbHRlclxuSUlSRmlsdGVyLnByb3RvdHlwZS5hZGRFbnZlbG9wZSA9IGZ1bmN0aW9uKGVudmVsb3BlKSB7XG4gIGlmICggZW52ZWxvcGUgaW5zdGFuY2VvZiBBRFNSICkge1xuICAgIHRoaXMuZnVuYy5hZGRFbnZlbG9wZShlbnZlbG9wZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgXCJOb3QgYW4gZW52ZWxvcGUuXCI7XG4gIH1cbn07XG5cbklJUkZpbHRlci5MUDEyID0gZnVuY3Rpb24oY3V0b2ZmLCByZXNvbmFuY2UsIHNhbXBsZVJhdGUpIHtcbiAgdGhpcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcbiAgdGhpcy52aWJyYVBvcyAgID0gMDtcbiAgdGhpcy52aWJyYVNwZWVkID0gMDtcbiAgdGhpcy5lbnZlbG9wZSA9IGZhbHNlO1xuIFxuICB0aGlzLmNhbGNDb2VmZiA9IGZ1bmN0aW9uKGN1dG9mZiwgcmVzb25hbmNlKSB7XG4gICAgdGhpcy53ID0gMi4wICogTWF0aC5QSSAqIGN1dG9mZiAvIHRoaXMuc2FtcGxlUmF0ZTtcbiAgICB0aGlzLnEgPSAxLjAgLSB0aGlzLncgLyAoMi4wICogKHJlc29uYW5jZSArIDAuNSAvICgxLjAgKyB0aGlzLncpKSArIHRoaXMudyAtIDIuMCk7XG4gICAgdGhpcy5yID0gdGhpcy5xICogdGhpcy5xO1xuICAgIHRoaXMuYyA9IHRoaXMuciArIDEuMCAtIDIuMCAqIE1hdGguY29zKHRoaXMudykgKiB0aGlzLnE7XG4gICBcbiAgICB0aGlzLmN1dG9mZiA9IGN1dG9mZjtcbiAgICB0aGlzLnJlc29uYW5jZSA9IHJlc29uYW5jZTtcbiAgfTtcblxuICB0aGlzLmNhbGNDb2VmZihjdXRvZmYsIHJlc29uYW5jZSk7XG5cbiAgdGhpcy5wcm9jZXNzID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrICkge1xuICAgICAgdGhpcy52aWJyYVNwZWVkICs9IChidWZmZXJbaV0gLSB0aGlzLnZpYnJhUG9zKSAqIHRoaXMuYztcbiAgICAgIHRoaXMudmlicmFQb3MgICArPSB0aGlzLnZpYnJhU3BlZWQ7XG4gICAgICB0aGlzLnZpYnJhU3BlZWQgKj0gdGhpcy5yO1xuICAgXG4gICAgICAvKlxuICAgICAgdmFyIHRlbXAgPSB0aGlzLnZpYnJhUG9zO1xuICAgICBcbiAgICAgIGlmICggdGVtcCA+IDEuMCApIHtcbiAgICAgICAgdGVtcCA9IDEuMDtcbiAgICAgIH0gZWxzZSBpZiAoIHRlbXAgPCAtMS4wICkge1xuICAgICAgICB0ZW1wID0gLTEuMDtcbiAgICAgIH0gZWxzZSBpZiAoIHRlbXAgIT0gdGVtcCApIHtcbiAgICAgICAgdGVtcCA9IDE7XG4gICAgICB9XG4gICAgIFxuICAgICAgYnVmZmVyW2ldID0gdGVtcDtcbiAgICAgICovXG5cbiAgICAgIGlmICh0aGlzLmVudmVsb3BlKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IChidWZmZXJbaV0gKiAoMSAtIHRoaXMuZW52ZWxvcGUudmFsdWUoKSkpICsgKHRoaXMudmlicmFQb3MgKiB0aGlzLmVudmVsb3BlLnZhbHVlKCkpO1xuICAgICAgICB0aGlzLmVudmVsb3BlLnNhbXBsZXNQcm9jZXNzZWQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IHRoaXMudmlicmFQb3M7XG4gICAgICB9XG4gICAgfVxuICB9O1xufTsgXG5cbklJUkZpbHRlci5MUDEyLnByb3RvdHlwZS5hZGRFbnZlbG9wZSA9IGZ1bmN0aW9uKGVudmVsb3BlKSB7XG4gIHRoaXMuZW52ZWxvcGUgPSBlbnZlbG9wZTtcbn07XG5cbmZ1bmN0aW9uIElJUkZpbHRlcjIodHlwZSwgY3V0b2ZmLCByZXNvbmFuY2UsIHNhbXBsZVJhdGUpIHtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5jdXRvZmYgPSBjdXRvZmY7XG4gIHRoaXMucmVzb25hbmNlID0gcmVzb25hbmNlO1xuICB0aGlzLnNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xuXG4gIHRoaXMuZiA9IEZsb2F0MzJBcnJheSg0KTtcbiAgdGhpcy5mWzBdID0gMC4wOyAvLyBscFxuICB0aGlzLmZbMV0gPSAwLjA7IC8vIGhwXG4gIHRoaXMuZlsyXSA9IDAuMDsgLy8gYnBcbiAgdGhpcy5mWzNdID0gMC4wOyAvLyBiciBcbiBcbiAgdGhpcy5jYWxjQ29lZmYgPSBmdW5jdGlvbihjdXRvZmYsIHJlc29uYW5jZSkge1xuICAgIHRoaXMuZnJlcSA9IDIgKiBNYXRoLnNpbihNYXRoLlBJICogTWF0aC5taW4oMC4yNSwgY3V0b2ZmLyh0aGlzLnNhbXBsZVJhdGUqMikpKTsgIFxuICAgIHRoaXMuZGFtcCA9IE1hdGgubWluKDIgKiAoMSAtIE1hdGgucG93KHJlc29uYW5jZSwgMC4yNSkpLCBNYXRoLm1pbigyLCAyL3RoaXMuZnJlcSAtIHRoaXMuZnJlcSAqIDAuNSkpO1xuICB9O1xuXG4gIHRoaXMuY2FsY0NvZWZmKGN1dG9mZiwgcmVzb25hbmNlKTtcbn1cblxuSUlSRmlsdGVyMi5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgaW5wdXQsIG91dHB1dDtcbiAgdmFyIGYgPSB0aGlzLmY7XG5cbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrICkge1xuICAgIGlucHV0ID0gYnVmZmVyW2ldO1xuXG4gICAgLy8gZmlyc3QgcGFzc1xuICAgIGZbM10gPSBpbnB1dCAtIHRoaXMuZGFtcCAqIGZbMl07XG4gICAgZlswXSA9IGZbMF0gKyB0aGlzLmZyZXEgKiBmWzJdO1xuICAgIGZbMV0gPSBmWzNdIC0gZlswXTtcbiAgICBmWzJdID0gdGhpcy5mcmVxICogZlsxXSArIGZbMl07XG4gICAgb3V0cHV0ID0gMC41ICogZlt0aGlzLnR5cGVdO1xuXG4gICAgLy8gc2Vjb25kIHBhc3NcbiAgICBmWzNdID0gaW5wdXQgLSB0aGlzLmRhbXAgKiBmWzJdO1xuICAgIGZbMF0gPSBmWzBdICsgdGhpcy5mcmVxICogZlsyXTtcbiAgICBmWzFdID0gZlszXSAtIGZbMF07XG4gICAgZlsyXSA9IHRoaXMuZnJlcSAqIGZbMV0gKyBmWzJdO1xuICAgIG91dHB1dCArPSAwLjUgKiBmW3RoaXMudHlwZV07XG5cbiAgICBpZiAodGhpcy5lbnZlbG9wZSkge1xuICAgICAgYnVmZmVyW2ldID0gKGJ1ZmZlcltpXSAqICgxIC0gdGhpcy5lbnZlbG9wZS52YWx1ZSgpKSkgKyAob3V0cHV0ICogdGhpcy5lbnZlbG9wZS52YWx1ZSgpKTtcbiAgICAgIHRoaXMuZW52ZWxvcGUuc2FtcGxlc1Byb2Nlc3NlZCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXJbaV0gPSBvdXRwdXQ7XG4gICAgfVxuICB9XG59O1xuXG5JSVJGaWx0ZXIyLnByb3RvdHlwZS5hZGRFbnZlbG9wZSA9IGZ1bmN0aW9uKGVudmVsb3BlKSB7XG4gIGlmICggZW52ZWxvcGUgaW5zdGFuY2VvZiBBRFNSICkge1xuICAgIHRoaXMuZW52ZWxvcGUgPSBlbnZlbG9wZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBcIlRoaXMgaXMgbm90IGFuIGVudmVsb3BlLlwiO1xuICB9XG59O1xuXG5JSVJGaWx0ZXIyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihjdXRvZmYsIHJlc29uYW5jZSkge1xuICB0aGlzLmNhbGNDb2VmZihjdXRvZmYsIHJlc29uYW5jZSk7XG59O1xuXG5cblxuZnVuY3Rpb24gV2luZG93RnVuY3Rpb24odHlwZSwgYWxwaGEpIHtcbiAgdGhpcy5hbHBoYSA9IGFscGhhO1xuIFxuICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgRFNQLkJBUlRMRVRUOlxuICAgICAgdGhpcy5mdW5jID0gV2luZG93RnVuY3Rpb24uQmFydGxldHQ7XG4gICAgICBicmVhaztcbiAgICAgXG4gICAgY2FzZSBEU1AuQkFSVExFVFRIQU5OOlxuICAgICAgdGhpcy5mdW5jID0gV2luZG93RnVuY3Rpb24uQmFydGxldHRIYW5uO1xuICAgICAgYnJlYWs7XG4gICAgIFxuICAgIGNhc2UgRFNQLkJMQUNLTUFOOlxuICAgICAgdGhpcy5mdW5jID0gV2luZG93RnVuY3Rpb24uQmxhY2ttYW47XG4gICAgICB0aGlzLmFscGhhID0gdGhpcy5hbHBoYSB8fCAwLjE2O1xuICAgICAgYnJlYWs7XG4gICBcbiAgICBjYXNlIERTUC5DT1NJTkU6XG4gICAgICB0aGlzLmZ1bmMgPSBXaW5kb3dGdW5jdGlvbi5Db3NpbmU7XG4gICAgICBicmVhaztcbiAgICAgXG4gICAgY2FzZSBEU1AuR0FVU1M6XG4gICAgICB0aGlzLmZ1bmMgPSBXaW5kb3dGdW5jdGlvbi5HYXVzcztcbiAgICAgIHRoaXMuYWxwaGEgPSB0aGlzLmFscGhhIHx8IDAuMjU7XG4gICAgICBicmVhaztcbiAgICAgXG4gICAgY2FzZSBEU1AuSEFNTUlORzpcbiAgICAgIHRoaXMuZnVuYyA9IFdpbmRvd0Z1bmN0aW9uLkhhbW1pbmc7XG4gICAgICBicmVhaztcbiAgICAgXG4gICAgY2FzZSBEU1AuSEFOTjpcbiAgICAgIHRoaXMuZnVuYyA9IFdpbmRvd0Z1bmN0aW9uLkhhbm47XG4gICAgICBicmVhaztcbiAgIFxuICAgIGNhc2UgRFNQLkxBTkNaT1M6XG4gICAgICB0aGlzLmZ1bmMgPSBXaW5kb3dGdW5jdGlvbi5MYW5jem96O1xuICAgICAgYnJlYWs7XG4gICAgIFxuICAgIGNhc2UgRFNQLlJFQ1RBTkdVTEFSOlxuICAgICAgdGhpcy5mdW5jID0gV2luZG93RnVuY3Rpb24uUmVjdGFuZ3VsYXI7XG4gICAgICBicmVhaztcbiAgICAgXG4gICAgY2FzZSBEU1AuVFJJQU5HVUxBUjpcbiAgICAgIHRoaXMuZnVuYyA9IFdpbmRvd0Z1bmN0aW9uLlRyaWFuZ3VsYXI7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5XaW5kb3dGdW5jdGlvbi5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aDtcbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgYnVmZmVyW2ldICo9IHRoaXMuZnVuYyhsZW5ndGgsIGksIHRoaXMuYWxwaGEpO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG5XaW5kb3dGdW5jdGlvbi5CYXJ0bGV0dCA9IGZ1bmN0aW9uKGxlbmd0aCwgaW5kZXgpIHtcbiAgcmV0dXJuIDIgLyAobGVuZ3RoIC0gMSkgKiAoKGxlbmd0aCAtIDEpIC8gMiAtIE1hdGguYWJzKGluZGV4IC0gKGxlbmd0aCAtIDEpIC8gMikpO1xufTtcblxuV2luZG93RnVuY3Rpb24uQmFydGxldHRIYW5uID0gZnVuY3Rpb24obGVuZ3RoLCBpbmRleCkge1xuICByZXR1cm4gMC42MiAtIDAuNDggKiBNYXRoLmFicyhpbmRleCAvIChsZW5ndGggLSAxKSAtIDAuNSkgLSAwLjM4ICogTWF0aC5jb3MoRFNQLlRXT19QSSAqIGluZGV4IC8gKGxlbmd0aCAtIDEpKTtcbn07XG5cbldpbmRvd0Z1bmN0aW9uLkJsYWNrbWFuID0gZnVuY3Rpb24obGVuZ3RoLCBpbmRleCwgYWxwaGEpIHtcbiAgdmFyIGEwID0gKDEgLSBhbHBoYSkgLyAyO1xuICB2YXIgYTEgPSAwLjU7XG4gIHZhciBhMiA9IGFscGhhIC8gMjtcblxuICByZXR1cm4gYTAgLSBhMSAqIE1hdGguY29zKERTUC5UV09fUEkgKiBpbmRleCAvIChsZW5ndGggLSAxKSkgKyBhMiAqIE1hdGguY29zKDQgKiBNYXRoLlBJICogaW5kZXggLyAobGVuZ3RoIC0gMSkpO1xufTtcblxuV2luZG93RnVuY3Rpb24uQ29zaW5lID0gZnVuY3Rpb24obGVuZ3RoLCBpbmRleCkge1xuICByZXR1cm4gTWF0aC5jb3MoTWF0aC5QSSAqIGluZGV4IC8gKGxlbmd0aCAtIDEpIC0gTWF0aC5QSSAvIDIpO1xufTtcblxuV2luZG93RnVuY3Rpb24uR2F1c3MgPSBmdW5jdGlvbihsZW5ndGgsIGluZGV4LCBhbHBoYSkge1xuICByZXR1cm4gTWF0aC5wb3coTWF0aC5FLCAtMC41ICogTWF0aC5wb3coKGluZGV4IC0gKGxlbmd0aCAtIDEpIC8gMikgLyAoYWxwaGEgKiAobGVuZ3RoIC0gMSkgLyAyKSwgMikpO1xufTtcblxuV2luZG93RnVuY3Rpb24uSGFtbWluZyA9IGZ1bmN0aW9uKGxlbmd0aCwgaW5kZXgpIHtcbiAgcmV0dXJuIDAuNTQgLSAwLjQ2ICogTWF0aC5jb3MoRFNQLlRXT19QSSAqIGluZGV4IC8gKGxlbmd0aCAtIDEpKTtcbn07XG5cbldpbmRvd0Z1bmN0aW9uLkhhbm4gPSBmdW5jdGlvbihsZW5ndGgsIGluZGV4KSB7XG4gIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKERTUC5UV09fUEkgKiBpbmRleCAvIChsZW5ndGggLSAxKSkpO1xufTtcblxuV2luZG93RnVuY3Rpb24uTGFuY3pvcyA9IGZ1bmN0aW9uKGxlbmd0aCwgaW5kZXgpIHtcbiAgdmFyIHggPSAyICogaW5kZXggLyAobGVuZ3RoIC0gMSkgLSAxO1xuICByZXR1cm4gTWF0aC5zaW4oTWF0aC5QSSAqIHgpIC8gKE1hdGguUEkgKiB4KTtcbn07XG5cbldpbmRvd0Z1bmN0aW9uLlJlY3Rhbmd1bGFyID0gZnVuY3Rpb24obGVuZ3RoLCBpbmRleCkge1xuICByZXR1cm4gMTtcbn07XG5cbldpbmRvd0Z1bmN0aW9uLlRyaWFuZ3VsYXIgPSBmdW5jdGlvbihsZW5ndGgsIGluZGV4KSB7XG4gIHJldHVybiAyIC8gbGVuZ3RoICogKGxlbmd0aCAvIDIgLSBNYXRoLmFicyhpbmRleCAtIChsZW5ndGggLSAxKSAvIDIpKTtcbn07XG5cbmZ1bmN0aW9uIHNpbmggKGFyZykge1xuICAvLyBSZXR1cm5zIHRoZSBoeXBlcmJvbGljIHNpbmUgb2YgdGhlIG51bWJlciwgZGVmaW5lZCBhcyAoZXhwKG51bWJlcikgLSBleHAoLW51bWJlcikpLzIgXG4gIC8vXG4gIC8vIHZlcnNpb246IDEwMDQuMjMxNFxuICAvLyBkaXNjdXNzIGF0OiBodHRwOi8vcGhwanMub3JnL2Z1bmN0aW9ucy9zaW5oICAgIC8vICsgICBvcmlnaW5hbCBieTogT25ubyBNYXJzbWFuXG4gIC8vICogICAgIGV4YW1wbGUgMTogc2luaCgtMC45ODM0MzMwMzQ4ODI1OTA5KTtcbiAgLy8gKiAgICAgcmV0dXJucyAxOiAtMS4xNDk3OTcxNDAyNjM2NTAyXG4gIHJldHVybiAoTWF0aC5leHAoYXJnKSAtIE1hdGguZXhwKC1hcmcpKS8yO1xufVxuXG4vKiBcbiAqICBCaXF1YWQgZmlsdGVyXG4gKiBcbiAqICBDcmVhdGVkIGJ5IFJpY2FyZCBNYXJ4ZXIgPGVtYWlsQHJpY2FyZG1hcnhlci5jb20+IG9uIDIwMTAtMDUtMjMuXG4gKiAgQ29weXJpZ2h0IDIwMTAgUmljYXJkIE1hcnhlci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKi9cbi8vIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uOlxuLy8gaHR0cDovL3d3dy5tdXNpY2RzcC5vcmcvZmlsZXMvQXVkaW8tRVEtQ29va2Jvb2sudHh0XG5mdW5jdGlvbiBCaXF1YWQodHlwZSwgc2FtcGxlUmF0ZSkge1xuICB0aGlzLkZzID0gc2FtcGxlUmF0ZTtcbiAgdGhpcy50eXBlID0gdHlwZTsgIC8vIHR5cGUgb2YgdGhlIGZpbHRlclxuICB0aGlzLnBhcmFtZXRlclR5cGUgPSBEU1AuUTsgLy8gdHlwZSBvZiB0aGUgcGFyYW1ldGVyXG5cbiAgdGhpcy54XzFfbCA9IDA7XG4gIHRoaXMueF8yX2wgPSAwO1xuICB0aGlzLnlfMV9sID0gMDtcbiAgdGhpcy55XzJfbCA9IDA7XG5cbiAgdGhpcy54XzFfciA9IDA7XG4gIHRoaXMueF8yX3IgPSAwO1xuICB0aGlzLnlfMV9yID0gMDtcbiAgdGhpcy55XzJfciA9IDA7XG5cbiAgdGhpcy5iMCA9IDE7XG4gIHRoaXMuYTAgPSAxO1xuXG4gIHRoaXMuYjEgPSAwO1xuICB0aGlzLmExID0gMDtcblxuICB0aGlzLmIyID0gMDtcbiAgdGhpcy5hMiA9IDA7XG5cbiAgdGhpcy5iMGEwID0gdGhpcy5iMCAvIHRoaXMuYTA7XG4gIHRoaXMuYjFhMCA9IHRoaXMuYjEgLyB0aGlzLmEwO1xuICB0aGlzLmIyYTAgPSB0aGlzLmIyIC8gdGhpcy5hMDtcbiAgdGhpcy5hMWEwID0gdGhpcy5hMSAvIHRoaXMuYTA7XG4gIHRoaXMuYTJhMCA9IHRoaXMuYTIgLyB0aGlzLmEwO1xuXG4gIHRoaXMuZjAgPSAzMDAwOyAgIC8vIFwid2hlcmV2ZXIgaXQncyBoYXBwZW5pbicsIG1hbi5cIiAgQ2VudGVyIEZyZXF1ZW5jeSBvclxuICAgICAgICAgICAgICAgICAgICAvLyBDb3JuZXIgRnJlcXVlbmN5LCBvciBzaGVsZiBtaWRwb2ludCBmcmVxdWVuY3ksIGRlcGVuZGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBvbiB3aGljaCBmaWx0ZXIgdHlwZS4gIFRoZSBcInNpZ25pZmljYW50IGZyZXF1ZW5jeVwiLlxuXG4gIHRoaXMuZEJnYWluID0gMTI7IC8vIHVzZWQgb25seSBmb3IgcGVha2luZyBhbmQgc2hlbHZpbmcgZmlsdGVyc1xuXG4gIHRoaXMuUSA9IDE7ICAgICAgIC8vIHRoZSBFRSBraW5kIG9mIGRlZmluaXRpb24sIGV4Y2VwdCBmb3IgcGVha2luZ0VRIGluIHdoaWNoIEEqUSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY2xhc3NpYyBFRSBRLiAgVGhhdCBhZGp1c3RtZW50IGluIGRlZmluaXRpb24gd2FzIG1hZGUgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgICAvLyBhIGJvb3N0IG9mIE4gZEIgZm9sbG93ZWQgYnkgYSBjdXQgb2YgTiBkQiBmb3IgaWRlbnRpY2FsIFEgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGYwL0ZzIHJlc3VsdHMgaW4gYSBwcmVjaXNlbHkgZmxhdCB1bml0eSBnYWluIGZpbHRlciBvciBcIndpcmVcIi5cblxuICB0aGlzLkJXID0gLTM7ICAgICAvLyB0aGUgYmFuZHdpZHRoIGluIG9jdGF2ZXMgKGJldHdlZW4gLTMgZEIgZnJlcXVlbmNpZXMgZm9yIEJQRlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgbm90Y2ggb3IgYmV0d2VlbiBtaWRwb2ludCAoZEJnYWluLzIpIGdhaW4gZnJlcXVlbmNpZXMgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIHBlYWtpbmcgRVFcblxuICB0aGlzLlMgPSAxOyAgICAgICAvLyBhIFwic2hlbGYgc2xvcGVcIiBwYXJhbWV0ZXIgKGZvciBzaGVsdmluZyBFUSBvbmx5KS4gIFdoZW4gUyA9IDEsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzaGVsZiBzbG9wZSBpcyBhcyBzdGVlcCBhcyBpdCBjYW4gYmUgYW5kIHJlbWFpbiBtb25vdG9uaWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY3JlYXNpbmcgb3IgZGVjcmVhc2luZyBnYWluIHdpdGggZnJlcXVlbmN5LiAgVGhlIHNoZWxmIHNsb3BlLCBpblxuICAgICAgICAgICAgICAgICAgICAvLyBkQi9vY3RhdmUsIHJlbWFpbnMgcHJvcG9ydGlvbmFsIHRvIFMgZm9yIGFsbCBvdGhlciB2YWx1ZXMgZm9yIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gZml4ZWQgZjAvRnMgYW5kIGRCZ2Fpbi5cblxuICB0aGlzLmNvZWZmaWNpZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiID0gW3RoaXMuYjAsIHRoaXMuYjEsIHRoaXMuYjJdO1xuICAgIHZhciBhID0gW3RoaXMuYTAsIHRoaXMuYTEsIHRoaXMuYTJdO1xuICAgIHJldHVybiB7YjogYiwgYTphfTtcbiAgfTtcblxuICB0aGlzLnNldEZpbHRlclR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlQ29lZmZpY2llbnRzKCk7XG4gIH07XG5cbiAgdGhpcy5zZXRTYW1wbGVSYXRlID0gZnVuY3Rpb24ocmF0ZSkge1xuICAgIHRoaXMuRnMgPSByYXRlO1xuICAgIHRoaXMucmVjYWxjdWxhdGVDb2VmZmljaWVudHMoKTtcbiAgfTtcblxuICB0aGlzLnNldFEgPSBmdW5jdGlvbihxKSB7XG4gICAgdGhpcy5wYXJhbWV0ZXJUeXBlID0gRFNQLlE7XG4gICAgdGhpcy5RID0gTWF0aC5tYXgoTWF0aC5taW4ocSwgMTE1LjApLCAwLjAwMSk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUNvZWZmaWNpZW50cygpO1xuICB9O1xuXG4gIHRoaXMuc2V0QlcgPSBmdW5jdGlvbihidykge1xuICAgIHRoaXMucGFyYW1ldGVyVHlwZSA9IERTUC5CVztcbiAgICB0aGlzLkJXID0gYnc7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUNvZWZmaWNpZW50cygpO1xuICB9O1xuXG4gIHRoaXMuc2V0UyA9IGZ1bmN0aW9uKHMpIHtcbiAgICB0aGlzLnBhcmFtZXRlclR5cGUgPSBEU1AuUztcbiAgICB0aGlzLlMgPSBNYXRoLm1heChNYXRoLm1pbihzLCA1LjApLCAwLjAwMDEpO1xuICAgIHRoaXMucmVjYWxjdWxhdGVDb2VmZmljaWVudHMoKTtcbiAgfTtcblxuICB0aGlzLnNldEYwID0gZnVuY3Rpb24oZnJlcSkge1xuICAgIHRoaXMuZjAgPSBmcmVxO1xuICAgIHRoaXMucmVjYWxjdWxhdGVDb2VmZmljaWVudHMoKTtcbiAgfTsgXG4gXG4gIHRoaXMuc2V0RGJHYWluID0gZnVuY3Rpb24oZykge1xuICAgIHRoaXMuZEJnYWluID0gZztcbiAgICB0aGlzLnJlY2FsY3VsYXRlQ29lZmZpY2llbnRzKCk7XG4gIH07XG5cbiAgdGhpcy5yZWNhbGN1bGF0ZUNvZWZmaWNpZW50cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBBO1xuICAgIGlmICh0eXBlID09PSBEU1AuUEVBS0lOR19FUSB8fCB0eXBlID09PSBEU1AuTE9XX1NIRUxGIHx8IHR5cGUgPT09IERTUC5ISUdIX1NIRUxGICkge1xuICAgICAgQSA9IE1hdGgucG93KDEwLCAodGhpcy5kQmdhaW4vNDApKTsgIC8vIGZvciBwZWFraW5nIGFuZCBzaGVsdmluZyBFUSBmaWx0ZXJzIG9ubHlcbiAgICB9IGVsc2Uge1xuICAgICAgQSAgPSBNYXRoLnNxcnQoIE1hdGgucG93KDEwLCAodGhpcy5kQmdhaW4vMjApKSApOyAgIFxuICAgIH1cblxuICAgIHZhciB3MCA9IERTUC5UV09fUEkgKiB0aGlzLmYwIC8gdGhpcy5GcztcblxuICAgIHZhciBjb3N3MCA9IE1hdGguY29zKHcwKTtcbiAgICB2YXIgc2ludzAgPSBNYXRoLnNpbih3MCk7XG5cbiAgICB2YXIgYWxwaGEgPSAwO1xuICAgXG4gICAgc3dpdGNoICh0aGlzLnBhcmFtZXRlclR5cGUpIHtcbiAgICAgIGNhc2UgRFNQLlE6XG4gICAgICAgIGFscGhhID0gc2ludzAvKDIqdGhpcy5RKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIFxuICAgICAgY2FzZSBEU1AuQlc6XG4gICAgICAgIGFscGhhID0gc2ludzAgKiBzaW5oKCBNYXRoLkxOMi8yICogdGhpcy5CVyAqIHcwL3NpbncwICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERTUC5TOlxuICAgICAgICBhbHBoYSA9IHNpbncwLzIgKiBNYXRoLnNxcnQoIChBICsgMS9BKSooMS90aGlzLlMgLSAxKSArIDIgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgIEZZSTogVGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGJhbmR3aWR0aCBhbmQgUSBpc1xuICAgICAgICAgICAgIDEvUSA9IDIqc2luaChsbigyKS8yKkJXKncwL3Npbih3MCkpICAgICAoZGlnaXRhbCBmaWx0ZXIgdyBCTFQpXG4gICAgICAgIG9yICAgMS9RID0gMipzaW5oKGxuKDIpLzIqQlcpICAgICAgICAgICAgIChhbmFsb2cgZmlsdGVyIHByb3RvdHlwZSlcblxuICAgICAgICBUaGUgcmVsYXRpb25zaGlwIGJldHdlZW4gc2hlbGYgc2xvcGUgYW5kIFEgaXNcbiAgICAgICAgICAgICAxL1EgPSBzcXJ0KChBICsgMS9BKSooMS9TIC0gMSkgKyAyKVxuICAgICovXG5cbiAgICB2YXIgY29lZmY7XG5cbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSBEU1AuTFBGOiAgICAgICAvLyBIKHMpID0gMSAvIChzXjIgKyBzL1EgKyAxKVxuICAgICAgICB0aGlzLmIwID0gICgxIC0gY29zdzApLzI7XG4gICAgICAgIHRoaXMuYjEgPSAgIDEgLSBjb3N3MDtcbiAgICAgICAgdGhpcy5iMiA9ICAoMSAtIGNvc3cwKS8yO1xuICAgICAgICB0aGlzLmEwID0gICAxICsgYWxwaGE7XG4gICAgICAgIHRoaXMuYTEgPSAgLTIgKiBjb3N3MDtcbiAgICAgICAgdGhpcy5hMiA9ICAgMSAtIGFscGhhO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEU1AuSFBGOiAgICAgICAvLyBIKHMpID0gc14yIC8gKHNeMiArIHMvUSArIDEpXG4gICAgICAgIHRoaXMuYjAgPSAgKDEgKyBjb3N3MCkvMjtcbiAgICAgICAgdGhpcy5iMSA9IC0oMSArIGNvc3cwKTtcbiAgICAgICAgdGhpcy5iMiA9ICAoMSArIGNvc3cwKS8yO1xuICAgICAgICB0aGlzLmEwID0gICAxICsgYWxwaGE7XG4gICAgICAgIHRoaXMuYTEgPSAgLTIgKiBjb3N3MDtcbiAgICAgICAgdGhpcy5hMiA9ICAgMSAtIGFscGhhO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEU1AuQlBGX0NPTlNUQU5UX1NLSVJUOiAgICAgICAvLyBIKHMpID0gcyAvIChzXjIgKyBzL1EgKyAxKSAgKGNvbnN0YW50IHNraXJ0IGdhaW4sIHBlYWsgZ2FpbiA9IFEpXG4gICAgICAgIHRoaXMuYjAgPSAgIHNpbncwLzI7XG4gICAgICAgIHRoaXMuYjEgPSAgIDA7XG4gICAgICAgIHRoaXMuYjIgPSAgLXNpbncwLzI7XG4gICAgICAgIHRoaXMuYTAgPSAgIDEgKyBhbHBoYTtcbiAgICAgICAgdGhpcy5hMSA9ICAtMipjb3N3MDtcbiAgICAgICAgdGhpcy5hMiA9ICAgMSAtIGFscGhhO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEU1AuQlBGX0NPTlNUQU5UX1BFQUs6ICAgICAgIC8vIEgocykgPSAocy9RKSAvIChzXjIgKyBzL1EgKyAxKSAgICAgIChjb25zdGFudCAwIGRCIHBlYWsgZ2FpbilcbiAgICAgICAgdGhpcy5iMCA9ICAgYWxwaGE7XG4gICAgICAgIHRoaXMuYjEgPSAgIDA7XG4gICAgICAgIHRoaXMuYjIgPSAgLWFscGhhO1xuICAgICAgICB0aGlzLmEwID0gICAxICsgYWxwaGE7XG4gICAgICAgIHRoaXMuYTEgPSAgLTIqY29zdzA7XG4gICAgICAgIHRoaXMuYTIgPSAgIDEgLSBhbHBoYTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRFNQLk5PVENIOiAgICAgLy8gSChzKSA9IChzXjIgKyAxKSAvIChzXjIgKyBzL1EgKyAxKVxuICAgICAgICB0aGlzLmIwID0gICAxO1xuICAgICAgICB0aGlzLmIxID0gIC0yKmNvc3cwO1xuICAgICAgICB0aGlzLmIyID0gICAxO1xuICAgICAgICB0aGlzLmEwID0gICAxICsgYWxwaGE7XG4gICAgICAgIHRoaXMuYTEgPSAgLTIqY29zdzA7XG4gICAgICAgIHRoaXMuYTIgPSAgIDEgLSBhbHBoYTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRFNQLkFQRjogICAgICAgLy8gSChzKSA9IChzXjIgLSBzL1EgKyAxKSAvIChzXjIgKyBzL1EgKyAxKVxuICAgICAgICB0aGlzLmIwID0gICAxIC0gYWxwaGE7XG4gICAgICAgIHRoaXMuYjEgPSAgLTIqY29zdzA7XG4gICAgICAgIHRoaXMuYjIgPSAgIDEgKyBhbHBoYTtcbiAgICAgICAgdGhpcy5hMCA9ICAgMSArIGFscGhhO1xuICAgICAgICB0aGlzLmExID0gIC0yKmNvc3cwO1xuICAgICAgICB0aGlzLmEyID0gICAxIC0gYWxwaGE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERTUC5QRUFLSU5HX0VROiAgLy8gSChzKSA9IChzXjIgKyBzKihBL1EpICsgMSkgLyAoc14yICsgcy8oQSpRKSArIDEpXG4gICAgICAgIHRoaXMuYjAgPSAgIDEgKyBhbHBoYSpBO1xuICAgICAgICB0aGlzLmIxID0gIC0yKmNvc3cwO1xuICAgICAgICB0aGlzLmIyID0gICAxIC0gYWxwaGEqQTtcbiAgICAgICAgdGhpcy5hMCA9ICAgMSArIGFscGhhL0E7XG4gICAgICAgIHRoaXMuYTEgPSAgLTIqY29zdzA7XG4gICAgICAgIHRoaXMuYTIgPSAgIDEgLSBhbHBoYS9BO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEU1AuTE9XX1NIRUxGOiAgIC8vIEgocykgPSBBICogKHNeMiArIChzcXJ0KEEpL1EpKnMgKyBBKS8oQSpzXjIgKyAoc3FydChBKS9RKSpzICsgMSlcbiAgICAgICAgY29lZmYgPSBzaW53MCAqIE1hdGguc3FydCggKEFeMiArIDEpKigxL3RoaXMuUyAtIDEpICsgMipBICk7XG4gICAgICAgIHRoaXMuYjAgPSAgICBBKigoQSsxKSAtIChBLTEpKmNvc3cwICsgY29lZmYpO1xuICAgICAgICB0aGlzLmIxID0gIDIqQSooKEEtMSkgLSAoQSsxKSpjb3N3MCk7XG4gICAgICAgIHRoaXMuYjIgPSAgICBBKigoQSsxKSAtIChBLTEpKmNvc3cwIC0gY29lZmYpO1xuICAgICAgICB0aGlzLmEwID0gICAgICAgKEErMSkgKyAoQS0xKSpjb3N3MCArIGNvZWZmO1xuICAgICAgICB0aGlzLmExID0gICAtMiooKEEtMSkgKyAoQSsxKSpjb3N3MCk7XG4gICAgICAgIHRoaXMuYTIgPSAgICAgICAoQSsxKSArIChBLTEpKmNvc3cwIC0gY29lZmY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERTUC5ISUdIX1NIRUxGOiAgIC8vIEgocykgPSBBICogKEEqc14yICsgKHNxcnQoQSkvUSkqcyArIDEpLyhzXjIgKyAoc3FydChBKS9RKSpzICsgQSlcbiAgICAgICAgY29lZmYgPSBzaW53MCAqIE1hdGguc3FydCggKEFeMiArIDEpKigxL3RoaXMuUyAtIDEpICsgMipBICk7XG4gICAgICAgIHRoaXMuYjAgPSAgICBBKigoQSsxKSArIChBLTEpKmNvc3cwICsgY29lZmYpO1xuICAgICAgICB0aGlzLmIxID0gLTIqQSooKEEtMSkgKyAoQSsxKSpjb3N3MCk7XG4gICAgICAgIHRoaXMuYjIgPSAgICBBKigoQSsxKSArIChBLTEpKmNvc3cwIC0gY29lZmYpO1xuICAgICAgICB0aGlzLmEwID0gICAgICAgKEErMSkgLSAoQS0xKSpjb3N3MCArIGNvZWZmO1xuICAgICAgICB0aGlzLmExID0gICAgMiooKEEtMSkgLSAoQSsxKSpjb3N3MCk7XG4gICAgICAgIHRoaXMuYTIgPSAgICAgICAoQSsxKSAtIChBLTEpKmNvc3cwIC0gY29lZmY7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgIFxuICAgIHRoaXMuYjBhMCA9IHRoaXMuYjAvdGhpcy5hMDtcbiAgICB0aGlzLmIxYTAgPSB0aGlzLmIxL3RoaXMuYTA7XG4gICAgdGhpcy5iMmEwID0gdGhpcy5iMi90aGlzLmEwO1xuICAgIHRoaXMuYTFhMCA9IHRoaXMuYTEvdGhpcy5hMDtcbiAgICB0aGlzLmEyYTAgPSB0aGlzLmEyL3RoaXMuYTA7XG4gIH07XG5cbiAgdGhpcy5wcm9jZXNzID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAvL3lbbl0gPSAoYjAvYTApKnhbbl0gKyAoYjEvYTApKnhbbi0xXSArIChiMi9hMCkqeFtuLTJdXG4gICAgICAvLyAgICAgICAtIChhMS9hMCkqeVtuLTFdIC0gKGEyL2EwKSp5W24tMl1cblxuICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICB2YXIgb3V0cHV0ID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuXG4gICAgICBmb3IgKCB2YXIgaT0wOyBpPGJ1ZmZlci5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgb3V0cHV0W2ldID0gdGhpcy5iMGEwKmJ1ZmZlcltpXSArIHRoaXMuYjFhMCp0aGlzLnhfMV9sICsgdGhpcy5iMmEwKnRoaXMueF8yX2wgLSB0aGlzLmExYTAqdGhpcy55XzFfbCAtIHRoaXMuYTJhMCp0aGlzLnlfMl9sO1xuICAgICAgICB0aGlzLnlfMl9sID0gdGhpcy55XzFfbDtcbiAgICAgICAgdGhpcy55XzFfbCA9IG91dHB1dFtpXTtcbiAgICAgICAgdGhpcy54XzJfbCA9IHRoaXMueF8xX2w7XG4gICAgICAgIHRoaXMueF8xX2wgPSBidWZmZXJbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgdGhpcy5wcm9jZXNzU3RlcmVvID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAvL3lbbl0gPSAoYjAvYTApKnhbbl0gKyAoYjEvYTApKnhbbi0xXSArIChiMi9hMCkqeFtuLTJdXG4gICAgICAvLyAgICAgICAtIChhMS9hMCkqeVtuLTFdIC0gKGEyL2EwKSp5W24tMl1cblxuICAgICAgdmFyIGxlbiA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICB2YXIgb3V0cHV0ID0gbmV3IEZsb2F0MzJBcnJheShsZW4pO1xuICAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuLzI7IGkrKykge1xuICAgICAgICBvdXRwdXRbMippXSA9IHRoaXMuYjBhMCpidWZmZXJbMippXSArIHRoaXMuYjFhMCp0aGlzLnhfMV9sICsgdGhpcy5iMmEwKnRoaXMueF8yX2wgLSB0aGlzLmExYTAqdGhpcy55XzFfbCAtIHRoaXMuYTJhMCp0aGlzLnlfMl9sO1xuICAgICAgICB0aGlzLnlfMl9sID0gdGhpcy55XzFfbDtcbiAgICAgICAgdGhpcy55XzFfbCA9IG91dHB1dFsyKmldO1xuICAgICAgICB0aGlzLnhfMl9sID0gdGhpcy54XzFfbDtcbiAgICAgICAgdGhpcy54XzFfbCA9IGJ1ZmZlclsyKmldO1xuXG4gICAgICAgIG91dHB1dFsyKmkrMV0gPSB0aGlzLmIwYTAqYnVmZmVyWzIqaSsxXSArIHRoaXMuYjFhMCp0aGlzLnhfMV9yICsgdGhpcy5iMmEwKnRoaXMueF8yX3IgLSB0aGlzLmExYTAqdGhpcy55XzFfciAtIHRoaXMuYTJhMCp0aGlzLnlfMl9yO1xuICAgICAgICB0aGlzLnlfMl9yID0gdGhpcy55XzFfcjtcbiAgICAgICAgdGhpcy55XzFfciA9IG91dHB1dFsyKmkrMV07XG4gICAgICAgIHRoaXMueF8yX3IgPSB0aGlzLnhfMV9yO1xuICAgICAgICB0aGlzLnhfMV9yID0gYnVmZmVyWzIqaSsxXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn1cblxuLyogXG4gKiAgTWFnbml0dWRlIHRvIGRlY2liZWxzXG4gKiBcbiAqICBDcmVhdGVkIGJ5IFJpY2FyZCBNYXJ4ZXIgPGVtYWlsQHJpY2FyZG1hcnhlci5jb20+IG9uIDIwMTAtMDUtMjMuXG4gKiAgQ29weXJpZ2h0IDIwMTAgUmljYXJkIE1hcnhlci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiAgQGJ1ZmZlciBhcnJheSBvZiBtYWduaXR1ZGVzIHRvIGNvbnZlcnQgdG8gZGVjaWJlbHNcbiAqXG4gKiAgQHJldHVybnMgdGhlIGFycmF5IGluIGRlY2liZWxzXG4gKlxuICovXG5EU1AubWFnMmRiID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBtaW5EYiA9IC0xMjA7XG4gIHZhciBtaW5NYWcgPSBNYXRoLnBvdygxMC4wLCBtaW5EYiAvIDIwLjApO1xuXG4gIHZhciBsb2cgPSBNYXRoLmxvZztcbiAgdmFyIG1heCA9IE1hdGgubWF4O1xuIFxuICB2YXIgcmVzdWx0ID0gRmxvYXQzMkFycmF5KGJ1ZmZlci5sZW5ndGgpO1xuICBmb3IgKHZhciBpPTA7IGk8YnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gMjAuMCpsb2cobWF4KGJ1ZmZlcltpXSwgbWluTWFnKSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyogXG4gKiAgRnJlcXVlbmN5IHJlc3BvbnNlXG4gKiBcbiAqICBDcmVhdGVkIGJ5IFJpY2FyZCBNYXJ4ZXIgPGVtYWlsQHJpY2FyZG1hcnhlci5jb20+IG9uIDIwMTAtMDUtMjMuXG4gKiAgQ29weXJpZ2h0IDIwMTAgUmljYXJkIE1hcnhlci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiAgQ2FsY3VsYXRlcyB0aGUgZnJlcXVlbmN5IHJlc3BvbnNlIGF0IHRoZSBnaXZlbiBwb2ludHMuXG4gKlxuICogIEBiIGIgY29lZmZpY2llbnRzIG9mIHRoZSBmaWx0ZXJcbiAqICBAYSBhIGNvZWZmaWNpZW50cyBvZiB0aGUgZmlsdGVyXG4gKiAgQHcgdyBwb2ludHMgKG5vcm1hbGx5IGJldHdlZW4gLVBJIGFuZCBQSSkgd2hlcmUgdG8gY2FsY3VsYXRlIHRoZSBmcmVxdWVuY3kgcmVzcG9uc2VcbiAqXG4gKiAgQHJldHVybnMgdGhlIGZyZXF1ZW5jeSByZXNwb25zZSBpbiBtYWduaXR1ZGVcbiAqXG4gKi9cbkRTUC5mcmVxeiA9IGZ1bmN0aW9uKGIsIGEsIHcpIHtcbiAgdmFyIGksIGo7XG5cbiAgaWYgKCF3KSB7XG4gICAgdyA9IEZsb2F0MzJBcnJheSgyMDApO1xuICAgIGZvciAoaT0wO2k8dy5sZW5ndGg7IGkrKykge1xuICAgICAgd1tpXSA9IERTUC5UV09fUEkvdy5sZW5ndGggKiBpIC0gTWF0aC5QSTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gRmxvYXQzMkFycmF5KHcubGVuZ3RoKTtcbiBcbiAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG4gIHZhciBjb3MgPSBNYXRoLmNvcztcbiAgdmFyIHNpbiA9IE1hdGguc2luO1xuIFxuICBmb3IgKGk9MDsgaTx3Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG51bWVyYXRvciA9IHtyZWFsOjAuMCwgaW1hZzowLjB9O1xuICAgIGZvciAoaj0wOyBqPGIubGVuZ3RoOyBqKyspIHtcbiAgICAgIG51bWVyYXRvci5yZWFsICs9IGJbal0gKiBjb3MoLWoqd1tpXSk7XG4gICAgICBudW1lcmF0b3IuaW1hZyArPSBiW2pdICogc2luKC1qKndbaV0pO1xuICAgIH1cblxuICAgIHZhciBkZW5vbWluYXRvciA9IHtyZWFsOjAuMCwgaW1hZzowLjB9O1xuICAgIGZvciAoaj0wOyBqPGEubGVuZ3RoOyBqKyspIHtcbiAgICAgIGRlbm9taW5hdG9yLnJlYWwgKz0gYVtqXSAqIGNvcygtaip3W2ldKTtcbiAgICAgIGRlbm9taW5hdG9yLmltYWcgKz0gYVtqXSAqIHNpbigtaip3W2ldKTtcbiAgICB9XG4gXG4gICAgcmVzdWx0W2ldID0gIHNxcnQobnVtZXJhdG9yLnJlYWwqbnVtZXJhdG9yLnJlYWwgKyBudW1lcmF0b3IuaW1hZypudW1lcmF0b3IuaW1hZykgLyBzcXJ0KGRlbm9taW5hdG9yLnJlYWwqZGVub21pbmF0b3IucmVhbCArIGRlbm9taW5hdG9yLmltYWcqZGVub21pbmF0b3IuaW1hZyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyogXG4gKiAgR3JhcGhpY2FsIEVxdWFsaXplclxuICpcbiAqICBJbXBsZW1lbnRhdGlvbiBvZiBhIGdyYXBoaWMgZXF1YWxpemVyIHdpdGggYSBjb25maWd1cmFibGUgYmFuZHMtcGVyLW9jdGF2ZVxuICogIGFuZCBtaW5pbXVtIGFuZCBtYXhpbXVtIGZyZXF1ZW5jaWVzXG4gKiBcbiAqICBDcmVhdGVkIGJ5IFJpY2FyZCBNYXJ4ZXIgPGVtYWlsQHJpY2FyZG1hcnhlci5jb20+IG9uIDIwMTAtMDUtMjMuXG4gKiAgQ29weXJpZ2h0IDIwMTAgUmljYXJkIE1hcnhlci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKi9cbmZ1bmN0aW9uIEdyYXBoaWNhbEVxKHNhbXBsZVJhdGUpIHtcbiAgdGhpcy5GUyA9IHNhbXBsZVJhdGU7XG4gIHRoaXMubWluRnJlcSA9IDQwLjA7XG4gIHRoaXMubWF4RnJlcSA9IDE2MDAwLjA7XG5cbiAgdGhpcy5iYW5kc1Blck9jdGF2ZSA9IDEuMDtcblxuICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgdGhpcy5mcmVxenMgPSBbXTtcblxuICB0aGlzLmNhbGN1bGF0ZUZyZXF6cyA9IHRydWU7XG5cbiAgdGhpcy5yZWNhbGN1bGF0ZUZpbHRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYmFuZENvdW50ID0gTWF0aC5yb3VuZChNYXRoLmxvZyh0aGlzLm1heEZyZXEvdGhpcy5taW5GcmVxKSAqIHRoaXMuYmFuZHNQZXJPY3RhdmUvIE1hdGguTE4yKTtcblxuICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgIGZvciAodmFyIGk9MDsgaTxiYW5kQ291bnQ7IGkrKykge1xuICAgICAgdmFyIGZyZXEgPSB0aGlzLm1pbkZyZXEqKE1hdGgucG93KDIsIGkvdGhpcy5iYW5kc1Blck9jdGF2ZSkpO1xuICAgICAgdmFyIG5ld0ZpbHRlciA9IG5ldyBCaXF1YWQoRFNQLlBFQUtJTkdfRVEsIHRoaXMuRlMpO1xuICAgICAgbmV3RmlsdGVyLnNldERiR2FpbigwKTtcbiAgICAgIG5ld0ZpbHRlci5zZXRCVygxL3RoaXMuYmFuZHNQZXJPY3RhdmUpO1xuICAgICAgbmV3RmlsdGVyLnNldEYwKGZyZXEpO1xuICAgICAgdGhpcy5maWx0ZXJzW2ldID0gbmV3RmlsdGVyO1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZUZyZXF6KGkpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLnNldE1pbmltdW1GcmVxdWVuY3kgPSBmdW5jdGlvbihmcmVxKSB7XG4gICAgdGhpcy5taW5GcmVxID0gZnJlcTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlRmlsdGVycygpO1xuICB9O1xuXG4gIHRoaXMuc2V0TWF4aW11bUZyZXF1ZW5jeSA9IGZ1bmN0aW9uKGZyZXEpIHtcbiAgICB0aGlzLm1heEZyZXEgPSBmcmVxO1xuICAgIHRoaXMucmVjYWxjdWxhdGVGaWx0ZXJzKCk7XG4gIH07XG5cbiAgdGhpcy5zZXRCYW5kc1Blck9jdGF2ZSA9IGZ1bmN0aW9uKGJhbmRzKSB7XG4gICAgdGhpcy5iYW5kc1Blck9jdGF2ZSA9IGJhbmRzO1xuICAgIHRoaXMucmVjYWxjdWxhdGVGaWx0ZXJzKCk7XG4gIH07XG5cbiAgdGhpcy5zZXRCYW5kR2FpbiA9IGZ1bmN0aW9uKGJhbmRJbmRleCwgZ2Fpbikge1xuICAgIGlmIChiYW5kSW5kZXggPCAwIHx8IGJhbmRJbmRleCA+ICh0aGlzLmZpbHRlcnMubGVuZ3RoLTEpKSB7XG4gICAgICB0aHJvdyBcIlRoZSBiYW5kIGluZGV4IG9mIHRoZSBncmFwaGljYWwgZXF1YWxpemVyIGlzIG91dCBvZiBib3VuZHMuXCI7XG4gICAgfVxuXG4gICAgaWYgKCFnYWluKSB7XG4gICAgICB0aHJvdyBcIkEgZ2FpbiBtdXN0IGJlIHBhc3NlZC5cIjtcbiAgICB9XG4gICBcbiAgICB0aGlzLmZpbHRlcnNbYmFuZEluZGV4XS5zZXREYkdhaW4oZ2Fpbik7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUZyZXF6KGJhbmRJbmRleCk7XG4gIH07XG4gXG4gIHRoaXMucmVjYWxjdWxhdGVGcmVxeiA9IGZ1bmN0aW9uKGJhbmRJbmRleCkge1xuICAgIGlmICghdGhpcy5jYWxjdWxhdGVGcmVxenMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYmFuZEluZGV4IDwgMCB8fCBiYW5kSW5kZXggPiAodGhpcy5maWx0ZXJzLmxlbmd0aC0xKSkge1xuICAgICAgdGhyb3cgXCJUaGUgYmFuZCBpbmRleCBvZiB0aGUgZ3JhcGhpY2FsIGVxdWFsaXplciBpcyBvdXQgb2YgYm91bmRzLiBcIiArIGJhbmRJbmRleCArIFwiIGlzIG91dCBvZiBbXCIgKyAwICsgXCIsIFwiICsgdGhpcy5maWx0ZXJzLmxlbmd0aC0xICsgXCJdXCI7XG4gICAgfVxuICAgICAgIFxuICAgIGlmICghdGhpcy53KSB7XG4gICAgICB0aGlzLncgPSBGbG9hdDMyQXJyYXkoNDAwKTtcbiAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLncubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHRoaXMud1tpXSA9IE1hdGguUEkvdGhpcy53Lmxlbmd0aCAqIGk7XG4gICAgICB9XG4gICAgfVxuICAgXG4gICAgdmFyIGIgPSBbdGhpcy5maWx0ZXJzW2JhbmRJbmRleF0uYjAsIHRoaXMuZmlsdGVyc1tiYW5kSW5kZXhdLmIxLCB0aGlzLmZpbHRlcnNbYmFuZEluZGV4XS5iMl07XG4gICAgdmFyIGEgPSBbdGhpcy5maWx0ZXJzW2JhbmRJbmRleF0uYTAsIHRoaXMuZmlsdGVyc1tiYW5kSW5kZXhdLmExLCB0aGlzLmZpbHRlcnNbYmFuZEluZGV4XS5hMl07XG5cbiAgICB0aGlzLmZyZXF6c1tiYW5kSW5kZXhdID0gRFNQLm1hZzJkYihEU1AuZnJlcXooYiwgYSwgdGhpcy53KSk7XG4gIH07XG5cbiAgdGhpcy5wcm9jZXNzID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgdmFyIG91dHB1dCA9IGJ1ZmZlcjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXRwdXQgPSB0aGlzLmZpbHRlcnNbaV0ucHJvY2VzcyhvdXRwdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgdGhpcy5wcm9jZXNzU3RlcmVvID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgdmFyIG91dHB1dCA9IGJ1ZmZlcjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXRwdXQgPSB0aGlzLmZpbHRlcnNbaV0ucHJvY2Vzc1N0ZXJlbyhvdXRwdXQpO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG5cbi8qKlxuICogTXVsdGlEZWxheSBlZmZlY3QgYnkgQWxtZXIgVGhpZSAoaHR0cDovL2NvZGUuYWxtZXJvcy5jb20pLlxuICogQ29weXJpZ2h0IDIwMTAgQWxtZXIgVGhpZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEV4YW1wbGU6IGh0dHA6Ly9jb2RlLmFsbWVyb3MuY29tL2NvZGUtZXhhbXBsZXMvZGVsYXktZmlyZWZveC1hdWRpby1hcGkvXG4gKlxuICogVGhpcyBpcyBhIGRlbGF5IHRoYXQgZmVlZHMgaXQncyBvd24gZGVsYXllZCBzaWduYWwgYmFjayBpbnRvIGl0cyBjaXJjdWxhclxuICogYnVmZmVyLiBBbHNvIGtub3duIGFzIGEgQ29tYkZpbHRlci5cbiAqXG4gKiBDb21wYXRpYmxlIHdpdGggaW50ZXJsZWF2ZWQgc3RlcmVvIChvciBtb3JlIGNoYW5uZWwpIGJ1ZmZlcnMgYW5kXG4gKiBub24taW50ZXJsZWF2ZWQgbW9ubyBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhEZWxheUluU2FtcGxlc1NpemUgTWF4aW11bSBwb3NzaWJsZSBkZWxheSBpbiBzYW1wbGVzIChzaXplIG9mIGNpcmN1bGFyIGJ1ZmZlcilcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheUluU2FtcGxlcyBJbml0aWFsIGRlbGF5IGluIHNhbXBsZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXN0ZXJWb2x1bWUgSW5pdGlhbCBtYXN0ZXIgdm9sdW1lLiBGbG9hdCB2YWx1ZTogMC4wIChzaWxlbmNlKSwgMS4wIChub3JtYWwpLCA+MS4wIChhbXBsaWZ5KVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5Vm9sdW1lIEluaXRpYWwgZmVlZGJhY2sgZGVsYXkgdm9sdW1lLiBGbG9hdCB2YWx1ZTogMC4wIChzaWxlbmNlKSwgMS4wIChub3JtYWwpLCA+MS4wIChhbXBsaWZ5KVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNdWx0aURlbGF5KG1heERlbGF5SW5TYW1wbGVzU2l6ZSwgZGVsYXlJblNhbXBsZXMsIG1hc3RlclZvbHVtZSwgZGVsYXlWb2x1bWUpIHtcbiAgdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXMgICA9IG5ldyBGbG9hdDMyQXJyYXkobWF4RGVsYXlJblNhbXBsZXNTaXplKTsgLy8gVGhlIG1heGltdW0gc2l6ZSBvZiBkZWxheVxuICB0aGlzLmRlbGF5SW5wdXRQb2ludGVyICAgICA9IGRlbGF5SW5TYW1wbGVzO1xuICB0aGlzLmRlbGF5T3V0cHV0UG9pbnRlciAgID0gMDtcbiBcbiAgdGhpcy5kZWxheUluU2FtcGxlcyAgID0gZGVsYXlJblNhbXBsZXM7XG4gIHRoaXMubWFzdGVyVm9sdW1lICAgICA9IG1hc3RlclZvbHVtZTtcbiAgdGhpcy5kZWxheVZvbHVtZSAgICAgPSBkZWxheVZvbHVtZTtcbn1cblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGRlbGF5IHRpbWUgaW4gc2FtcGxlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlJblNhbXBsZXMgRGVsYXkgaW4gc2FtcGxlc1xuICovXG5NdWx0aURlbGF5LnByb3RvdHlwZS5zZXREZWxheUluU2FtcGxlcyA9IGZ1bmN0aW9uIChkZWxheUluU2FtcGxlcykge1xuICB0aGlzLmRlbGF5SW5TYW1wbGVzID0gZGVsYXlJblNhbXBsZXM7XG4gXG4gIHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgPSB0aGlzLmRlbGF5T3V0cHV0UG9pbnRlciArIGRlbGF5SW5TYW1wbGVzO1xuXG4gIGlmICh0aGlzLmRlbGF5SW5wdXRQb2ludGVyID49IHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzLmxlbmd0aC0xKSB7XG4gICAgdGhpcy5kZWxheUlucHV0UG9pbnRlciA9IHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgLSB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlcy5sZW5ndGg7IFxuICB9XG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgbWFzdGVyIHZvbHVtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWFzdGVyVm9sdW1lIEZsb2F0IHZhbHVlOiAwLjAgKHNpbGVuY2UpLCAxLjAgKG5vcm1hbCksID4xLjAgKGFtcGxpZnkpXG4gKi9cbk11bHRpRGVsYXkucHJvdG90eXBlLnNldE1hc3RlclZvbHVtZSA9IGZ1bmN0aW9uKG1hc3RlclZvbHVtZSkge1xuICB0aGlzLm1hc3RlclZvbHVtZSA9IG1hc3RlclZvbHVtZTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBkZWxheSBmZWVkYmFjayB2b2x1bWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5Vm9sdW1lIEZsb2F0IHZhbHVlOiAwLjAgKHNpbGVuY2UpLCAxLjAgKG5vcm1hbCksID4xLjAgKGFtcGxpZnkpXG4gKi9cbk11bHRpRGVsYXkucHJvdG90eXBlLnNldERlbGF5Vm9sdW1lID0gZnVuY3Rpb24oZGVsYXlWb2x1bWUpIHtcbiAgdGhpcy5kZWxheVZvbHVtZSA9IGRlbGF5Vm9sdW1lO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzIGEgZ2l2ZW4gaW50ZXJsZWF2ZWQgb3IgbW9ubyBub24taW50ZXJsZWF2ZWQgZmxvYXQgdmFsdWUgQXJyYXkgYW5kIGFkZHMgdGhlIGRlbGF5ZWQgYXVkaW8uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2FtcGxlcyBBcnJheSBjb250YWluaW5nIEZsb2F0IHZhbHVlcyBvciBhIEZsb2F0MzJBcnJheVxuICpcbiAqIEByZXR1cm5zIEEgbmV3IEZsb2F0MzJBcnJheSBpbnRlcmxlYXZlZCBvciBtb25vIG5vbi1pbnRlcmxlYXZlZCBhcyB3YXMgZmVkIHRvIHRoaXMgZnVuY3Rpb24uXG4gKi9cbk11bHRpRGVsYXkucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbihzYW1wbGVzKSB7XG4gIC8vIE5CLiBNYWtlIGEgY29weSB0byBwdXQgaW4gdGhlIG91dHB1dCBzYW1wbGVzIHRvIHJldHVybi5cbiAgdmFyIG91dHB1dFNhbXBsZXMgPSBuZXcgRmxvYXQzMkFycmF5KHNhbXBsZXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpPTA7IGk8c2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGRlbGF5QnVmZmVyU2FtcGxlcyBjb3VsZCBjb250YWluIGluaXRpYWwgTlVMTCdzLCByZXR1cm4gc2lsZW5jZSBpbiB0aGF0IGNhc2VcbiAgICB2YXIgZGVsYXlTYW1wbGUgPSAodGhpcy5kZWxheUJ1ZmZlclNhbXBsZXNbdGhpcy5kZWxheU91dHB1dFBvaW50ZXJdID09PSBudWxsID8gMC4wIDogdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXNbdGhpcy5kZWxheU91dHB1dFBvaW50ZXJdKTtcbiAgIFxuICAgIC8vIE1peCBub3JtYWwgYXVkaW8gZGF0YSB3aXRoIGRlbGF5ZWQgYXVkaW9cbiAgICB2YXIgc2FtcGxlID0gKGRlbGF5U2FtcGxlICogdGhpcy5kZWxheVZvbHVtZSkgKyBzYW1wbGVzW2ldO1xuICAgXG4gICAgLy8gQWRkIGF1ZGlvIGRhdGEgd2l0aCB0aGUgZGVsYXkgaW4gdGhlIGRlbGF5IGJ1ZmZlclxuICAgIHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzW3RoaXMuZGVsYXlJbnB1dFBvaW50ZXJdID0gc2FtcGxlO1xuICAgXG4gICAgLy8gUmV0dXJuIHRoZSBhdWRpbyB3aXRoIGRlbGF5IG1peFxuICAgIG91dHB1dFNhbXBsZXNbaV0gPSBzYW1wbGUgKiB0aGlzLm1hc3RlclZvbHVtZTtcbiAgIFxuICAgIC8vIE1hbmFnZSBjaXJjdWxhaXIgZGVsYXkgYnVmZmVyIHBvaW50ZXJzXG4gICAgdGhpcy5kZWxheUlucHV0UG9pbnRlcisrO1xuICAgIGlmICh0aGlzLmRlbGF5SW5wdXRQb2ludGVyID49IHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzLmxlbmd0aC0xKSB7XG4gICAgICB0aGlzLmRlbGF5SW5wdXRQb2ludGVyID0gMDtcbiAgICB9XG4gICAgIFxuICAgIHRoaXMuZGVsYXlPdXRwdXRQb2ludGVyKys7XG4gICAgaWYgKHRoaXMuZGVsYXlPdXRwdXRQb2ludGVyID49IHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzLmxlbmd0aC0xKSB7XG4gICAgICB0aGlzLmRlbGF5T3V0cHV0UG9pbnRlciA9IDA7IFxuICAgIH0gXG4gIH1cbiBcbiAgcmV0dXJuIG91dHB1dFNhbXBsZXM7XG59O1xuXG4vKipcbiAqIFNpbmdsZURlbGF5IGVmZmVjdCBieSBBbG1lciBUaGllIChodHRwOi8vY29kZS5hbG1lcm9zLmNvbSkuXG4gKiBDb3B5cmlnaHQgMjAxMCBBbG1lciBUaGllLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRXhhbXBsZTogU2VlIHVzYWdlIGluIFJldmVyYiBjbGFzc1xuICpcbiAqIFRoaXMgaXMgYSBkZWxheSB0aGF0IGRvZXMgTk9UIGZlZWRzIGl0J3Mgb3duIGRlbGF5ZWQgc2lnbmFsIGJhY2sgaW50byBpdHMgXG4gKiBjaXJjdWxhciBidWZmZXIsIG5laXRoZXIgZG9lcyBpdCByZXR1cm4gdGhlIG9yaWdpbmFsIHNpZ25hbC4gQWxzbyBrbm93biBhc1xuICogYW4gQWxsUGFzc0ZpbHRlcig/KS5cbiAqXG4gKiBDb21wYXRpYmxlIHdpdGggaW50ZXJsZWF2ZWQgc3RlcmVvIChvciBtb3JlIGNoYW5uZWwpIGJ1ZmZlcnMgYW5kXG4gKiBub24taW50ZXJsZWF2ZWQgbW9ubyBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhEZWxheUluU2FtcGxlc1NpemUgTWF4aW11bSBwb3NzaWJsZSBkZWxheSBpbiBzYW1wbGVzIChzaXplIG9mIGNpcmN1bGFyIGJ1ZmZlcilcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheUluU2FtcGxlcyBJbml0aWFsIGRlbGF5IGluIHNhbXBsZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVZvbHVtZSBJbml0aWFsIGZlZWRiYWNrIGRlbGF5IHZvbHVtZS4gRmxvYXQgdmFsdWU6IDAuMCAoc2lsZW5jZSksIDEuMCAobm9ybWFsKSwgPjEuMCAoYW1wbGlmeSlcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5mdW5jdGlvbiBTaW5nbGVEZWxheShtYXhEZWxheUluU2FtcGxlc1NpemUsIGRlbGF5SW5TYW1wbGVzLCBkZWxheVZvbHVtZSkge1xuICB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlcyA9IG5ldyBGbG9hdDMyQXJyYXkobWF4RGVsYXlJblNhbXBsZXNTaXplKTsgLy8gVGhlIG1heGltdW0gc2l6ZSBvZiBkZWxheVxuICB0aGlzLmRlbGF5SW5wdXRQb2ludGVyICA9IGRlbGF5SW5TYW1wbGVzO1xuICB0aGlzLmRlbGF5T3V0cHV0UG9pbnRlciA9IDA7XG4gXG4gIHRoaXMuZGVsYXlJblNhbXBsZXMgICAgID0gZGVsYXlJblNhbXBsZXM7XG4gIHRoaXMuZGVsYXlWb2x1bWUgICAgICAgID0gZGVsYXlWb2x1bWU7XG59XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBkZWxheSB0aW1lIGluIHNhbXBsZXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5SW5TYW1wbGVzIERlbGF5IGluIHNhbXBsZXNcbiAqL1xuU2luZ2xlRGVsYXkucHJvdG90eXBlLnNldERlbGF5SW5TYW1wbGVzID0gZnVuY3Rpb24oZGVsYXlJblNhbXBsZXMpIHtcbiAgdGhpcy5kZWxheUluU2FtcGxlcyA9IGRlbGF5SW5TYW1wbGVzO1xuICB0aGlzLmRlbGF5SW5wdXRQb2ludGVyID0gdGhpcy5kZWxheU91dHB1dFBvaW50ZXIgKyBkZWxheUluU2FtcGxlcztcblxuICBpZiAodGhpcy5kZWxheUlucHV0UG9pbnRlciA+PSB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlcy5sZW5ndGgtMSkge1xuICAgIHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgPSB0aGlzLmRlbGF5SW5wdXRQb2ludGVyIC0gdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXMubGVuZ3RoOyBcbiAgfVxufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHJldHVybiBzaWduYWwgdm9sdW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVZvbHVtZSBGbG9hdCB2YWx1ZTogMC4wIChzaWxlbmNlKSwgMS4wIChub3JtYWwpLCA+MS4wIChhbXBsaWZ5KVxuICovXG5TaW5nbGVEZWxheS5wcm90b3R5cGUuc2V0RGVsYXlWb2x1bWUgPSBmdW5jdGlvbihkZWxheVZvbHVtZSkge1xuICB0aGlzLmRlbGF5Vm9sdW1lID0gZGVsYXlWb2x1bWU7XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgYSBnaXZlbiBpbnRlcmxlYXZlZCBvciBtb25vIG5vbi1pbnRlcmxlYXZlZCBmbG9hdCB2YWx1ZSBBcnJheSBhbmRcbiAqIHJldHVybnMgdGhlIGRlbGF5ZWQgYXVkaW8uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2FtcGxlcyBBcnJheSBjb250YWluaW5nIEZsb2F0IHZhbHVlcyBvciBhIEZsb2F0MzJBcnJheVxuICpcbiAqIEByZXR1cm5zIEEgbmV3IEZsb2F0MzJBcnJheSBpbnRlcmxlYXZlZCBvciBtb25vIG5vbi1pbnRlcmxlYXZlZCBhcyB3YXMgZmVkIHRvIHRoaXMgZnVuY3Rpb24uXG4gKi9cblNpbmdsZURlbGF5LnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oc2FtcGxlcykge1xuICAvLyBOQi4gTWFrZSBhIGNvcHkgdG8gcHV0IGluIHRoZSBvdXRwdXQgc2FtcGxlcyB0byByZXR1cm4uXG4gIHZhciBvdXRwdXRTYW1wbGVzID0gbmV3IEZsb2F0MzJBcnJheShzYW1wbGVzLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaT0wOyBpPHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcblxuICAgIC8vIEFkZCBhdWRpbyBkYXRhIHdpdGggdGhlIGRlbGF5IGluIHRoZSBkZWxheSBidWZmZXJcbiAgICB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlc1t0aGlzLmRlbGF5SW5wdXRQb2ludGVyXSA9IHNhbXBsZXNbaV07XG4gICBcbiAgICAvLyBkZWxheUJ1ZmZlclNhbXBsZXMgY291bGQgY29udGFpbiBpbml0aWFsIE5VTEwncywgcmV0dXJuIHNpbGVuY2UgaW4gdGhhdCBjYXNlXG4gICAgdmFyIGRlbGF5U2FtcGxlID0gdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXNbdGhpcy5kZWxheU91dHB1dFBvaW50ZXJdO1xuXG4gICAgLy8gUmV0dXJuIHRoZSBhdWRpbyB3aXRoIGRlbGF5IG1peFxuICAgIG91dHB1dFNhbXBsZXNbaV0gPSBkZWxheVNhbXBsZSAqIHRoaXMuZGVsYXlWb2x1bWU7XG5cbiAgICAvLyBNYW5hZ2UgY2lyY3VsYWlyIGRlbGF5IGJ1ZmZlciBwb2ludGVyc1xuICAgIHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIrKztcblxuICAgIGlmICh0aGlzLmRlbGF5SW5wdXRQb2ludGVyID49IHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzLmxlbmd0aC0xKSB7XG4gICAgICB0aGlzLmRlbGF5SW5wdXRQb2ludGVyID0gMDtcbiAgICB9XG4gICAgIFxuICAgIHRoaXMuZGVsYXlPdXRwdXRQb2ludGVyKys7XG5cbiAgICBpZiAodGhpcy5kZWxheU91dHB1dFBvaW50ZXIgPj0gdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXMubGVuZ3RoLTEpIHtcbiAgICAgIHRoaXMuZGVsYXlPdXRwdXRQb2ludGVyID0gMDsgXG4gICAgfSBcbiAgfVxuIFxuICByZXR1cm4gb3V0cHV0U2FtcGxlcztcbn07XG5cbi8qKlxuICogUmV2ZXJiIGVmZmVjdCBieSBBbG1lciBUaGllIChodHRwOi8vY29kZS5hbG1lcm9zLmNvbSkuXG4gKiBDb3B5cmlnaHQgMjAxMCBBbG1lciBUaGllLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRXhhbXBsZTogaHR0cDovL2NvZGUuYWxtZXJvcy5jb20vY29kZS1leGFtcGxlcy9yZXZlcmItZmlyZWZveC1hdWRpby1hcGkvXG4gKlxuICogVGhpcyByZXZlcmIgY29uc2lzdHMgb2YgNiBTaW5nbGVEZWxheXMsIDYgTXVsdGlEZWxheXMgYW5kIGFuIElJUkZpbHRlcjJcbiAqIGZvciBlYWNoIG9mIHRoZSB0d28gc3RlcmVvIGNoYW5uZWxzLlxuICpcbiAqIENvbXBhdGlibGUgd2l0aCBpbnRlcmxlYXZlZCBzdGVyZW8gYnVmZmVycyBvbmx5IVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhEZWxheUluU2FtcGxlc1NpemUgTWF4aW11bSBwb3NzaWJsZSBkZWxheSBpbiBzYW1wbGVzIChzaXplIG9mIGNpcmN1bGFyIGJ1ZmZlcnMpXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlJblNhbXBsZXMgSW5pdGlhbCBkZWxheSBpbiBzYW1wbGVzIGZvciBpbnRlcm5hbCAoU2luZ2xlL011bHRpKWRlbGF5c1xuICogQHBhcmFtIHtOdW1iZXJ9IG1hc3RlclZvbHVtZSBJbml0aWFsIG1hc3RlciB2b2x1bWUuIEZsb2F0IHZhbHVlOiAwLjAgKHNpbGVuY2UpLCAxLjAgKG5vcm1hbCksID4xLjAgKGFtcGxpZnkpXG4gKiBAcGFyYW0ge051bWJlcn0gbWl4Vm9sdW1lIEluaXRpYWwgcmV2ZXJiIHNpZ25hbCBtaXggdm9sdW1lLiBGbG9hdCB2YWx1ZTogMC4wIChzaWxlbmNlKSwgMS4wIChub3JtYWwpLCA+MS4wIChhbXBsaWZ5KVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5Vm9sdW1lIEluaXRpYWwgZmVlZGJhY2sgZGVsYXkgdm9sdW1lIGZvciBpbnRlcm5hbCAoU2luZ2xlL011bHRpKWRlbGF5cy4gRmxvYXQgdmFsdWU6IDAuMCAoc2lsZW5jZSksIDEuMCAobm9ybWFsKSwgPjEuMCAoYW1wbGlmeSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBkYW1wRnJlcXVlbmN5IEluaXRpYWwgbG93IHBhc3MgZmlsdGVyIGZyZXF1ZW5jeS4gMCB0byA0NDEwMCAoZGVwZW5kaW5nIG9uIHlvdXIgbWF4aW11bSBzYW1wbGluZyBmcmVxdWVuY3kpXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJldmVyYihtYXhEZWxheUluU2FtcGxlc1NpemUsIGRlbGF5SW5TYW1wbGVzLCBtYXN0ZXJWb2x1bWUsIG1peFZvbHVtZSwgZGVsYXlWb2x1bWUsIGRhbXBGcmVxdWVuY3kpIHtcbiAgdGhpcy5kZWxheUluU2FtcGxlcyAgID0gZGVsYXlJblNhbXBsZXM7XG4gIHRoaXMubWFzdGVyVm9sdW1lICAgICA9IG1hc3RlclZvbHVtZTtcbiAgdGhpcy5taXhWb2x1bWUgICAgICAgPSBtaXhWb2x1bWU7XG4gIHRoaXMuZGVsYXlWb2x1bWUgICAgID0gZGVsYXlWb2x1bWU7XG4gIHRoaXMuZGFtcEZyZXF1ZW5jeSAgICAgPSBkYW1wRnJlcXVlbmN5O1xuIFxuICB0aGlzLk5SX09GX01VTFRJREVMQVlTID0gNjtcbiAgdGhpcy5OUl9PRl9TSU5HTEVERUxBWVMgPSA2O1xuIFxuICB0aGlzLkxPV1BBU1NMID0gbmV3IElJUkZpbHRlcjIoRFNQLkxPV1BBU1MsIGRhbXBGcmVxdWVuY3ksIDAsIDQ0MTAwKTtcbiAgdGhpcy5MT1dQQVNTUiA9IG5ldyBJSVJGaWx0ZXIyKERTUC5MT1dQQVNTLCBkYW1wRnJlcXVlbmN5LCAwLCA0NDEwMCk7XG4gXG4gIHRoaXMuc2luZ2xlRGVsYXlzID0gW107XG4gIFxuICB2YXIgaSwgZGVsYXlNdWx0aXBseTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5OUl9PRl9TSU5HTEVERUxBWVM7IGkrKykge1xuICAgIGRlbGF5TXVsdGlwbHkgPSAxLjAgKyAoaS83LjApOyAvLyAxLjAsIDEuMSwgMS4yLi4uXG4gICAgdGhpcy5zaW5nbGVEZWxheXNbaV0gPSBuZXcgU2luZ2xlRGVsYXkobWF4RGVsYXlJblNhbXBsZXNTaXplLCBNYXRoLnJvdW5kKHRoaXMuZGVsYXlJblNhbXBsZXMgKiBkZWxheU11bHRpcGx5KSwgdGhpcy5kZWxheVZvbHVtZSk7XG4gIH1cbiBcbiAgdGhpcy5tdWx0aURlbGF5cyA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLk5SX09GX01VTFRJREVMQVlTOyBpKyspIHtcbiAgICBkZWxheU11bHRpcGx5ID0gMS4wICsgKGkvMTAuMCk7IC8vIDEuMCwgMS4xLCAxLjIuLi4gXG4gICAgdGhpcy5tdWx0aURlbGF5c1tpXSA9IG5ldyBNdWx0aURlbGF5KG1heERlbGF5SW5TYW1wbGVzU2l6ZSwgTWF0aC5yb3VuZCh0aGlzLmRlbGF5SW5TYW1wbGVzICogZGVsYXlNdWx0aXBseSksIHRoaXMubWFzdGVyVm9sdW1lLCB0aGlzLmRlbGF5Vm9sdW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIENoYW5nZSB0aGUgZGVsYXkgdGltZSBpbiBzYW1wbGVzIGFzIGEgYmFzZSBmb3IgYWxsIGRlbGF5cy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlJblNhbXBsZXMgRGVsYXkgaW4gc2FtcGxlc1xuICovXG5SZXZlcmIucHJvdG90eXBlLnNldERlbGF5SW5TYW1wbGVzID0gZnVuY3Rpb24gKGRlbGF5SW5TYW1wbGVzKXtcbiAgdGhpcy5kZWxheUluU2FtcGxlcyA9IGRlbGF5SW5TYW1wbGVzO1xuXG4gIHZhciBpLCBkZWxheU11bHRpcGx5O1xuIFxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5OUl9PRl9TSU5HTEVERUxBWVM7IGkrKykge1xuICAgIGRlbGF5TXVsdGlwbHkgPSAxLjAgKyAoaS83LjApOyAvLyAxLjAsIDEuMSwgMS4yLi4uXG4gICAgdGhpcy5zaW5nbGVEZWxheXNbaV0uc2V0RGVsYXlJblNhbXBsZXMoIE1hdGgucm91bmQodGhpcy5kZWxheUluU2FtcGxlcyAqIGRlbGF5TXVsdGlwbHkpICk7XG4gIH1cbiAgIFxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5OUl9PRl9NVUxUSURFTEFZUzsgaSsrKSB7XG4gICAgZGVsYXlNdWx0aXBseSA9IDEuMCArIChpLzEwLjApOyAvLyAxLjAsIDEuMSwgMS4yLi4uXG4gICAgdGhpcy5tdWx0aURlbGF5c1tpXS5zZXREZWxheUluU2FtcGxlcyggTWF0aC5yb3VuZCh0aGlzLmRlbGF5SW5TYW1wbGVzICogZGVsYXlNdWx0aXBseSkgKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIG1hc3RlciB2b2x1bWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1hc3RlclZvbHVtZSBGbG9hdCB2YWx1ZTogMC4wIChzaWxlbmNlKSwgMS4wIChub3JtYWwpLCA+MS4wIChhbXBsaWZ5KVxuICovXG5SZXZlcmIucHJvdG90eXBlLnNldE1hc3RlclZvbHVtZSA9IGZ1bmN0aW9uIChtYXN0ZXJWb2x1bWUpe1xuICB0aGlzLm1hc3RlclZvbHVtZSA9IG1hc3RlclZvbHVtZTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSByZXZlcmIgc2lnbmFsIG1peCBsZXZlbC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWl4Vm9sdW1lIEZsb2F0IHZhbHVlOiAwLjAgKHNpbGVuY2UpLCAxLjAgKG5vcm1hbCksID4xLjAgKGFtcGxpZnkpXG4gKi9cblJldmVyYi5wcm90b3R5cGUuc2V0TWl4Vm9sdW1lID0gZnVuY3Rpb24gKG1peFZvbHVtZSl7XG4gIHRoaXMubWl4Vm9sdW1lID0gbWl4Vm9sdW1lO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgYWxsIGRlbGF5cyBmZWVkYmFjayB2b2x1bWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5Vm9sdW1lIEZsb2F0IHZhbHVlOiAwLjAgKHNpbGVuY2UpLCAxLjAgKG5vcm1hbCksID4xLjAgKGFtcGxpZnkpXG4gKi9cblJldmVyYi5wcm90b3R5cGUuc2V0RGVsYXlWb2x1bWUgPSBmdW5jdGlvbiAoZGVsYXlWb2x1bWUpe1xuICB0aGlzLmRlbGF5Vm9sdW1lID0gZGVsYXlWb2x1bWU7XG4gXG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IDA7IGk8dGhpcy5OUl9PRl9TSU5HTEVERUxBWVM7IGkrKykge1xuICAgIHRoaXMuc2luZ2xlRGVsYXlzW2ldLnNldERlbGF5Vm9sdW1lKHRoaXMuZGVsYXlWb2x1bWUpO1xuICB9IFxuIFxuICBmb3IgKGkgPSAwOyBpPHRoaXMuTlJfT0ZfTVVMVElERUxBWVM7IGkrKykge1xuICAgIHRoaXMubXVsdGlEZWxheXNbaV0uc2V0RGVsYXlWb2x1bWUodGhpcy5kZWxheVZvbHVtZSk7XG4gIH0gXG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgTG93IFBhc3MgZmlsdGVyIGZyZXF1ZW5jeS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGFtcEZyZXF1ZW5jeSBsb3cgcGFzcyBmaWx0ZXIgZnJlcXVlbmN5LiAwIHRvIDQ0MTAwIChkZXBlbmRpbmcgb24geW91ciBtYXhpbXVtIHNhbXBsaW5nIGZyZXF1ZW5jeSlcbiAqL1xuUmV2ZXJiLnByb3RvdHlwZS5zZXREYW1wRnJlcXVlbmN5ID0gZnVuY3Rpb24gKGRhbXBGcmVxdWVuY3kpe1xuICB0aGlzLmRhbXBGcmVxdWVuY3kgPSBkYW1wRnJlcXVlbmN5O1xuIFxuICB0aGlzLkxPV1BBU1NMLnNldChkYW1wRnJlcXVlbmN5LCAwKTtcbiAgdGhpcy5MT1dQQVNTUi5zZXQoZGFtcEZyZXF1ZW5jeSwgMCk7IFxufTtcblxuLyoqXG4gKiBQcm9jZXNzIGEgZ2l2ZW4gaW50ZXJsZWF2ZWQgZmxvYXQgdmFsdWUgQXJyYXkgYW5kIGNvcGllcyBhbmQgYWRkcyB0aGUgcmV2ZXJiIHNpZ25hbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzYW1wbGVzIEFycmF5IGNvbnRhaW5pbmcgRmxvYXQgdmFsdWVzIG9yIGEgRmxvYXQzMkFycmF5XG4gKlxuICogQHJldHVybnMgQSBuZXcgRmxvYXQzMkFycmF5IGludGVybGVhdmVkIGJ1ZmZlci5cbiAqL1xuUmV2ZXJiLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24gKGludGVybGVhdmVkU2FtcGxlcyl7IFxuICAvLyBOQi4gTWFrZSBhIGNvcHkgdG8gcHV0IGluIHRoZSBvdXRwdXQgc2FtcGxlcyB0byByZXR1cm4uXG4gIHZhciBvdXRwdXRTYW1wbGVzID0gbmV3IEZsb2F0MzJBcnJheShpbnRlcmxlYXZlZFNhbXBsZXMubGVuZ3RoKTtcbiBcbiAgLy8gUGVyZm9ybSBsb3cgcGFzcyBvbiB0aGUgaW5wdXQgc2FtcGxlcyB0byBtaW1pY2sgZGFtcFxuICB2YXIgbGVmdFJpZ2h0TWl4ID0gRFNQLmRlaW50ZXJsZWF2ZShpbnRlcmxlYXZlZFNhbXBsZXMpO1xuICB0aGlzLkxPV1BBU1NMLnByb2Nlc3MoIGxlZnRSaWdodE1peFtEU1AuTEVGVF0gKTtcbiAgdGhpcy5MT1dQQVNTUi5wcm9jZXNzKCBsZWZ0UmlnaHRNaXhbRFNQLlJJR0hUXSApOyBcbiAgdmFyIGZpbHRlcmVkU2FtcGxlcyA9IERTUC5pbnRlcmxlYXZlKGxlZnRSaWdodE1peFtEU1AuTEVGVF0sIGxlZnRSaWdodE1peFtEU1AuUklHSFRdKTtcblxuICB2YXIgaTtcblxuICAvLyBQcm9jZXNzIE11bHRpRGVsYXlzIGluIHBhcmFsbGVsXG4gIGZvciAoaSA9IDA7IGk8dGhpcy5OUl9PRl9NVUxUSURFTEFZUzsgaSsrKSB7XG4gICAgLy8gSW52ZXJ0IHRoZSBzaWduYWwgb2YgZXZlcnkgZXZlbiBtdWx0aURlbGF5XG4gICAgb3V0cHV0U2FtcGxlcyA9IERTUC5taXhTYW1wbGVCdWZmZXJzKG91dHB1dFNhbXBsZXMsIHRoaXMubXVsdGlEZWxheXNbaV0ucHJvY2VzcyhmaWx0ZXJlZFNhbXBsZXMpLCAyJWkgPT09IDAsIHRoaXMuTlJfT0ZfTVVMVElERUxBWVMpO1xuICB9XG4gXG4gIC8vIFByb2Nlc3MgU2luZ2xlRGVsYXlzIGluIHNlcmllc1xuICB2YXIgc2luZ2xlRGVsYXlTYW1wbGVzID0gbmV3IEZsb2F0MzJBcnJheShvdXRwdXRTYW1wbGVzLmxlbmd0aCk7XG4gIGZvciAoaSA9IDA7IGk8dGhpcy5OUl9PRl9TSU5HTEVERUxBWVM7IGkrKykge1xuICAgIC8vIEludmVydCB0aGUgc2lnbmFsIG9mIGV2ZXJ5IGV2ZW4gc2luZ2xlRGVsYXlcbiAgICBzaW5nbGVEZWxheVNhbXBsZXMgPSBEU1AubWl4U2FtcGxlQnVmZmVycyhzaW5nbGVEZWxheVNhbXBsZXMsIHRoaXMuc2luZ2xlRGVsYXlzW2ldLnByb2Nlc3Mob3V0cHV0U2FtcGxlcyksIDIlaSA9PT0gMCwgMSk7XG4gIH1cblxuICAvLyBBcHBseSB0aGUgdm9sdW1lIG9mIHRoZSByZXZlcmIgc2lnbmFsXG4gIGZvciAoaSA9IDA7IGk8c2luZ2xlRGVsYXlTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgc2luZ2xlRGVsYXlTYW1wbGVzW2ldICo9IHRoaXMubWl4Vm9sdW1lO1xuICB9XG4gXG4gIC8vIE1peCB0aGUgb3JpZ2luYWwgc2lnbmFsIHdpdGggdGhlIHJldmVyYiBzaWduYWxcbiAgb3V0cHV0U2FtcGxlcyA9IERTUC5taXhTYW1wbGVCdWZmZXJzKHNpbmdsZURlbGF5U2FtcGxlcywgaW50ZXJsZWF2ZWRTYW1wbGVzLCAwLCAxKTtcblxuICAvLyBBcHBseSB0aGUgbWFzdGVyIHZvbHVtZSB0byB0aGUgY29tcGxldGUgc2lnbmFsXG4gIGZvciAoaSA9IDA7IGk8b3V0cHV0U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFNhbXBsZXNbaV0gKj0gdGhpcy5tYXN0ZXJWb2x1bWU7XG4gIH1cbiAgIFxuICByZXR1cm4gb3V0cHV0U2FtcGxlcztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERTUDtcbmV4cG9ydCB7IEZGVCBhcyBGRlQgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0aWVzXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zZXRcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi93ZWFrLW1hcFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIik7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVmaW5lUHJvcGVydHkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9nZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX2dldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFByb3RvdHlwZU9mKTtcblxudmFyIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpO1xuXG52YXIgX2dldE93blByb3BlcnR5RGVzY3JpcHRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuICB2YXIgZGVzYyA9ICgwLCBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yMi5kZWZhdWx0KShvYmplY3QsIHByb3BlcnR5KTtcblxuICBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHBhcmVudCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKG9iamVjdCk7XG5cbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHtcbiAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7XG5cbiAgICBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTtcbiAgfVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9zZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpO1xuXG52YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTtcblxudmFyIF9jcmVhdGUgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlXCIpO1xuXG52YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgKHR5cGVvZiBzdXBlckNsYXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShzdXBlckNsYXNzKSkpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gKDAsIF9jcmVhdGUyLmRlZmF1bHQpKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQgPyAoMCwgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0KShzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2l0ZXJhdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sL2l0ZXJhdG9yXCIpO1xuXG52YXIgX2l0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2l0ZXJhdG9yKTtcblxudmFyIF9zeW1ib2wgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2xcIik7XG5cbnZhciBfc3ltYm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3N5bWJvbCk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iaiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKG9iaik7XG59OyIsInJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlKFAsIEQpIHtcbiAgcmV0dXJuICRPYmplY3QuY3JlYXRlKFAsIEQpO1xufTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKFQsIEQpIHtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhULCBEKTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpIHtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICByZXR1cm4gJE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcuc2V0Lm9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuU2V0O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LndlYWstbWFwLm9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5XZWFrTWFwO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyLCBJVEVSQVRPUikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0laRSA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICB2YXIgZW50cnk7XG4gIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IgKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgIGlmIChlbnRyeS5rID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGZvciAodmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKSwgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wKSBlbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubjtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYgKHRoYXQuX2YgPT0gZW50cnkpIHRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmICh0aGF0Ll9sID09IGVudHJ5KSB0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKSB7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTkFNRSksIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHRoaXMsIE5BTUUpW1NJWkVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICB2YXIgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZiAoIXRoYXQuX2YpIHRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDLCBOQU1FLCBJU19NQVApIHtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICB0aGlzLl90ID0gdmFsaWRhdGUoaXRlcmF0ZWQsIE5BTUUpOyAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7ICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGtpbmQgPSB0aGF0Ll9rO1xuICAgICAgdmFyIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIGZyb20gPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgaWYgKGNsYXNzb2YodGhpcykgIT0gTkFNRSkgdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBnZXRXZWFrID0gcmVxdWlyZSgnLi9fbWV0YScpLmdldFdlYWs7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG52YXIgJGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xudmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG52YXIgaWQgPSAwO1xuXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcbn07XG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIGVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBpbmRleCA9IGFycmF5RmluZEluZGV4KHRoaXMuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAofmluZGV4KSB0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSBnZXRXZWFrKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICBpZiAoIURFU0NSSVBUT1JTIHx8IHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBDID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUsICdfYycpO1xuICAgICAgdGFyZ2V0Ll9jID0gbmV3IEJhc2UoKTtcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRhcmdldFtBRERFUl0sIHRhcmdldCk7XG4gICAgfSk7XG4gICAgZWFjaCgnYWRkLGNsZWFyLGRlbGV0ZSxmb3JFYWNoLGdldCxoYXMsc2V0LGtleXMsdmFsdWVzLGVudHJpZXMsdG9KU09OJy5zcGxpdCgnLCcpLCBmdW5jdGlvbiAoS0VZKSB7XG4gICAgICB2YXIgSVNfQURERVIgPSBLRVkgPT0gJ2FkZCcgfHwgS0VZID09ICdzZXQnO1xuICAgICAgaWYgKEtFWSBpbiBwcm90byAmJiAhKElTX1dFQUsgJiYgS0VZID09ICdjbGVhcicpKSBoaWRlKEMucHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhpcywgQywgS0VZKTtcbiAgICAgICAgaWYgKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSkgcmV0dXJuIEtFWSA9PSAnZ2V0JyA/IHVuZGVmaW5lZCA6IGZhbHNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fY1tLRVldKGEgPT09IDAgPyAwIDogYSwgYik7XG4gICAgICAgIHJldHVybiBJU19BRERFUiA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBJU19XRUFLIHx8IGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYy5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GLCBPKTtcblxuICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjQnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYgaGFzKGV4cG9ydHMsIGtleSkpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge307XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG4iLCJ2YXIgTUVUQSA9IHJlcXVpcmUoJy4vX3VpZCcpKCdtZXRhJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBzZXREZXNjID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBpZCA9IDA7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZSB8fCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBGUkVFWkUgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcbnZhciBzZXRNZXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHtcbiAgICBpOiAnTycgKyArK2lkLCAvLyBvYmplY3QgSURcbiAgICB3OiB7fSAgICAgICAgICAvLyB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IH0pO1xufTtcbnZhciBmYXN0S2V5ID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gb2JqZWN0IElEXG4gIH0gcmV0dXJuIGl0W01FVEFdLmk7XG59O1xudmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBoYXNoIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gcmV0dXJuIGl0W01FVEFdLnc7XG59O1xuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaRSAmJiBtZXRhLk5FRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBKSkgc2V0TWV0YShpdCk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgbWV0YSA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBLRVk6IE1FVEEsXG4gIE5FRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrOiBnZXRXZWFrLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyAxOS4xLjIuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlLCAuLi4pXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciAkYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIFMgPSBTeW1ib2woKTtcbiAgdmFyIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgd2hpbGUgKGFMZW4gPiBpbmRleCkge1xuICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHZhciBrZXlzID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIGlmIChpc0VudW0uY2FsbChTLCBrZXkgPSBrZXlzW2orK10pKSBUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcbiIsIi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZFBzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgY3JlYXRlRGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7XG4gIHZhciBpID0gZW51bUJ1Z0tleXMubGVuZ3RoO1xuICB2YXIgbHQgPSAnPCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChPICE9PSBudWxsKSB7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eSgpO1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsO1xuICAgIC8vIGFkZCBcIl9fcHJvdG9fX1wiIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGxcbiAgICByZXN1bHRbSUVfUFJPVE9dID0gTztcbiAgfSBlbHNlIHJlc3VsdCA9IGNyZWF0ZURpY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgPSBnZXRLZXlzKFByb3BlcnRpZXMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIFA7XG4gIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07XG4iLCJ2YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhcyhPLCBQKSkgcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsIi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgZ09QTiA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuJykuZjtcbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGdPUE4oaXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7XG59O1xuIiwiLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGhpZGRlbktleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG4iLCIvLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgT2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG8gOiBudWxsO1xufTtcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcbiIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKHNhZmUgJiYgdGFyZ2V0W2tleV0pIHRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBoaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgZnJvbTogZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBGbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBtYXBGbiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWFwcGluZywgQSwgbiwgY2I7XG4gICAgYUZ1bmN0aW9uKHRoaXMpO1xuICAgIG1hcHBpbmcgPSBtYXBGbiAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChtYXBwaW5nKSBhRnVuY3Rpb24obWFwRm4pO1xuICAgIGlmIChzb3VyY2UgPT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IHRoaXMoKTtcbiAgICBBID0gW107XG4gICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgIG4gPSAwO1xuICAgICAgY2IgPSBjdHgobWFwRm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBmdW5jdGlvbiAobmV4dEl0ZW0pIHtcbiAgICAgICAgQS5wdXNoKGNiKG5leHRJdGVtLCBuKyspKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBBLnB1c2gsIEEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIEEgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIEFbbGVuZ3RoXSA9IGFyZ3VtZW50c1tsZW5ndGhdO1xuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gdHlwZW9mIGNvcmVbS0VZXSA9PSAnZnVuY3Rpb24nID8gY29yZVtLRVldIDogZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVFlQRSkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSB8fCBpdC5fdCAhPT0gVFlQRSkgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcbiIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXQgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG4iLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0lPYmplY3QoaXQpLCBrZXkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuIiwiIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0VUID0gJ1NldCc7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBXRUFLX01BUCA9ICdXZWFrTWFwJztcbnZhciBnZXRXZWFrID0gbWV0YS5nZXRXZWFrO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZTtcbnZhciB0bXAgPSB7fTtcbnZhciBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCkpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19NQVApLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfTUFQLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDc7IH0pKSB7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBXRUFLX01BUCk7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcHJvdG8gPSAkV2Vha01hcC5wcm90b3R5cGU7XG4gICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mKSB0aGlzLl9mID0gbmV3IEludGVybmFsTWFwKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdTZXQnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnU2V0Jyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHsgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0JykgfSk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtNYXAnKTtcbiIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG4iLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdfQ==
