(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.wavesAudio = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var AudioContext = window.AudioContext || window.webkitAudioContext;

/**
 * Expose a unique audio context singleton as the default audio
 * context used by the components of the Waves Audio library and
 * applications using the library.
 *
 * @type AudioContext
 * @name audioContext
 * @constant
 * @global
 * @instance
 *
 * @example
 * import * as audio from 'waves-audio';
 * const audioContext = audio.audioContext;
 */
var audioContext = null;

if (AudioContext) {
  audioContext = new AudioContext();

  if (/(iPhone|iPad)/i.test(navigator.userAgent) && audioContext.sampleRate < 44100) {
    var buffer = audioContext.createBuffer(1, 1, 44100);
    var dummy = audioContext.createBufferSource();
    dummy.buffer = buffer;
    dummy.connect(audioContext.destination);
    dummy.start(0);
    dummy.disconnect();
  }
}

exports.default = audioContext;

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _timeEngine = require('./time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _audioContext = require('./audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This is the base class for all audio related time engine components. It is
 * used to handle audio related events such as the playback of a media stream.
 * It extends the TimeEngine class by the standard web audio node methods
 * connect and disconnect.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/audio-time-engine.html}
 *
 * @extends TimeEngine
 * @example
 * import audio from 'waves-audio';
 *
 * class MyEngine extends audio.AudioTimeEngine {
 *   constructor() {
 *     super();
 *     // ...
 *   }
 * }
 */
var AudioTimeEngine = function (_TimeEngine) {
  (0, _inherits3.default)(AudioTimeEngine, _TimeEngine);

  function AudioTimeEngine() {
    var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;
    (0, _classCallCheck3.default)(this, AudioTimeEngine);

    /**
     * Audio context used by the TimeEngine, default to the global audioContext
     *
     * @name audioContext
     * @type AudioContext
     * @memberof AudioTimeEngine
     * @see audioContext
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (AudioTimeEngine.__proto__ || (0, _getPrototypeOf2.default)(AudioTimeEngine)).call(this));

    _this.audioContext = audioContext;

    /**
     * Output audio node. By default the connect method connects a given node
     * to this output node.
     *
     * @name outputNode
     * @type AudioNode
     * @memberof AudioTimeEngine
     * @default null
     */
    _this.outputNode = null;
    return _this;
  }

  /**
   * Connect to an audio node (e.g. audioContext.destination)
   *
   * @param {AudioNode} target - Target audio node
   */


  (0, _createClass3.default)(AudioTimeEngine, [{
    key: 'connect',
    value: function connect(target) {
      this.outputNode.connect(target);
      return this;
    }

    /**
     * Disconnect from an audio node (e.g. audioContext.destination). If undefined
     * disconnect from all target nodes.
     *
     * @param {AudioNode} target - Target audio node.
     */

  }, {
    key: 'disconnect',
    value: function disconnect(connection) {
      this.outputNode.disconnect(connection);
      return this;
    }
  }]);
  return AudioTimeEngine;
}(_timeEngine2.default);

exports.default = AudioTimeEngine;

},{"./audio-context":1,"./time-engine":5,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// works by reference
function swap(arr, i1, i2) {
  var tmp = arr[i1];
  arr[i1] = arr[i2];
  arr[i2] = tmp;
}

// https://jsperf.com/js-for-loop-vs-array-indexof/346
function indexOf(arr, el) {
  var l = arr.length;
  // ignore first element as it can't be a entry
  for (var i = 1; i < l; i++) {
    if (arr[i] === el) {
      return i;
    }
  }

  return -1;
}

/**
 * Define if `time1` should be lower in the topography than `time2`.
 * Is dynamically affected to the priority queue according to handle `min` and `max` heap.
 *
 * @private
 * @param {Number} time1
 * @param {Number} time2
 * @return {Boolean}
 */
var _isLowerMaxHeap = function _isLowerMaxHeap(time1, time2) {
  return time1 < time2;
};

var _isLowerMinHeap = function _isLowerMinHeap(time1, time2) {
  return time1 > time2;
};

/**
 * Define if `time1` should be higher in the topography than `time2`.
 * Is dynamically affected to the priority queue according to handle `min` and `max` heap.
 *
 * @private
 * @param {Number} time1
 * @param {Number} time2
 * @return {Boolean}
 */
var _isHigherMaxHeap = function _isHigherMaxHeap(time1, time2) {
  return time1 > time2;
};

var _isHigherMinHeap = function _isHigherMinHeap(time1, time2) {
  return time1 < time2;
};

var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

/**
 * Priority queue implementing a binary heap.
 * Acts as a min heap by default, can be dynamically changed to a max heap
 * by setting `reverse` to true.
 *
 * _note_: the queue creates and maintains a new property (i.e. `queueTime`)
 * to each object added.
 *
 * @param {Number} [heapLength=100] - Default size of the array used to create the heap.
 */

var PriorityQueue = function () {
  function PriorityQueue() {
    var heapLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
    (0, _classCallCheck3.default)(this, PriorityQueue);

    /**
     * Pointer to the first empty index of the heap.
     * @type {Number}
     * @memberof PriorityQueue
     * @name _currentLength
     * @private
     */
    this._currentLength = 1;

    /**
     * Array of the sorted indexes of the entries, the actual heap. Ignore the index 0.
     * @type {Array}
     * @memberof PriorityQueue
     * @name _heap
     * @private
     */
    this._heap = new Array(heapLength + 1);

    /**
     * Type of the queue: `min` heap if `false`, `max` heap if `true`
     * @type {Boolean}
     * @memberof PriorityQueue
     * @name _reverse
     * @private
     */
    this._reverse = null;

    // initialize compare functions
    this.reverse = false;
  }

  /**
   * Time of the first element in the binary heap.
   * @returns {Number}
   */


  (0, _createClass3.default)(PriorityQueue, [{
    key: "_bubbleUp",


    /**
     * Fix the heap by moving an entry to a new upper position.
     *
     * @private
     * @param {Number} startIndex - The index of the entry to move.
     */
    value: function _bubbleUp(startIndex) {
      var entry = this._heap[startIndex];

      var index = startIndex;
      var parentIndex = Math.floor(index / 2);
      var parent = this._heap[parentIndex];

      while (parent && this._isHigher(entry.queueTime, parent.queueTime)) {
        swap(this._heap, index, parentIndex);

        index = parentIndex;
        parentIndex = Math.floor(index / 2);
        parent = this._heap[parentIndex];
      }
    }

    /**
     * Fix the heap by moving an entry to a new lower position.
     *
     * @private
     * @param {Number} startIndex - The index of the entry to move.
     */

  }, {
    key: "_bubbleDown",
    value: function _bubbleDown(startIndex) {
      var entry = this._heap[startIndex];

      var index = startIndex;
      var c1index = index * 2;
      var c2index = c1index + 1;
      var child1 = this._heap[c1index];
      var child2 = this._heap[c2index];

      while (child1 && this._isLower(entry.queueTime, child1.queueTime) || child2 && this._isLower(entry.queueTime, child2.queueTime)) {
        // swap with the minimum child
        var targetIndex = void 0;

        if (child2) targetIndex = this._isHigher(child1.queueTime, child2.queueTime) ? c1index : c2index;else targetIndex = c1index;

        swap(this._heap, index, targetIndex);

        // update to find next children
        index = targetIndex;
        c1index = index * 2;
        c2index = c1index + 1;
        child1 = this._heap[c1index];
        child2 = this._heap[c2index];
      }
    }

    /**
     * Build the heap (from bottom up).
     */

  }, {
    key: "buildHeap",
    value: function buildHeap() {
      // find the index of the last internal node
      // @todo - make sure that's the right way to do.
      var maxIndex = Math.floor((this._currentLength - 1) / 2);

      for (var i = maxIndex; i > 0; i--) {
        this._bubbleDown(i);
      }
    }

    /**
     * Insert a new object in the binary heap and sort it.
     *
     * @param {Object} entry - Entry to insert.
     * @param {Number} time - Time at which the entry should be orderer.
     * @returns {Number} - Time of the first entry in the heap.
     */

  }, {
    key: "insert",
    value: function insert(entry, time) {
      if (Math.abs(time) !== POSITIVE_INFINITY) {
        entry.queueTime = time;
        // add the new entry at the end of the heap
        this._heap[this._currentLength] = entry;
        // bubble it up
        this._bubbleUp(this._currentLength);
        this._currentLength += 1;

        return this.time;
      }

      entry.queueTime = undefined;
      return this.remove(entry);
    }

    /**
     * Move a given entry to a new position.
     *
     * @param {Object} entry - Entry to move.
     * @param {Number} time - Time at which the entry should be orderer.
     * @return {Number} - Time of first entry in the heap.
     */

  }, {
    key: "move",
    value: function move(entry, time) {
      if (Math.abs(time) !== POSITIVE_INFINITY) {
        var index = indexOf(this._heap, entry);

        if (index !== -1) {
          entry.queueTime = time;
          // define if the entry should be bubbled up or down
          var parent = this._heap[Math.floor(index / 2)];

          if (parent && this._isHigher(time, parent.queueTime)) this._bubbleUp(index);else this._bubbleDown(index);
        }

        return this.time;
      }

      entry.queueTime = undefined;
      return this.remove(entry);
    }

    /**
     * Remove an entry from the heap and fix the heap.
     *
     * @param {Object} entry - Entry to remove.
     * @return {Number} - Time of first entry in the heap.
     */

  }, {
    key: "remove",
    value: function remove(entry) {
      // find the index of the entry
      var index = indexOf(this._heap, entry);

      if (index !== -1) {
        var lastIndex = this._currentLength - 1;

        // if the entry is the last one
        if (index === lastIndex) {
          // remove the element from heap
          this._heap[lastIndex] = undefined;
          // update current length
          this._currentLength = lastIndex;

          return this.time;
        } else {
          // swap with the last element of the heap
          swap(this._heap, index, lastIndex);
          // remove the element from heap
          this._heap[lastIndex] = undefined;

          if (index === 1) {
            this._bubbleDown(1);
          } else {
            // bubble the (ex last) element up or down according to its new context
            var _entry = this._heap[index];
            var parent = this._heap[Math.floor(index / 2)];

            if (parent && this._isHigher(_entry.queueTime, parent.queueTime)) this._bubbleUp(index);else this._bubbleDown(index);
          }
        }

        // update current length
        this._currentLength = lastIndex;
      }

      return this.time;
    }

    /**
     * Clear the queue.
     */

  }, {
    key: "clear",
    value: function clear() {
      this._currentLength = 1;
      this._heap = new Array(this._heap.length);
    }

    /**
     * Defines if the queue contains the given `entry`.
     *
     * @param {Object} entry - Entry to be checked
     * @return {Boolean}
     */

  }, {
    key: "has",
    value: function has(entry) {
      return this._heap.indexOf(entry) !== -1;
    }
  }, {
    key: "time",
    get: function get() {
      if (this._currentLength > 1) return this._heap[1].queueTime;

      return Infinity;
    }

    /**
     * First element in the binary heap.
     * @returns {Number}
     * @readonly
     */

  }, {
    key: "head",
    get: function get() {
      return this._heap[1];
    }

    /**
     * Change the order of the queue (max heap if true, min heap if false),
     * rebuild the heap with the existing entries.
     *
     * @type {Boolean}
     */

  }, {
    key: "reverse",
    set: function set(value) {
      if (value !== this._reverse) {
        this._reverse = value;

        if (this._reverse === true) {
          this._isLower = _isLowerMaxHeap;
          this._isHigher = _isHigherMaxHeap;
        } else {
          this._isLower = _isLowerMinHeap;
          this._isHigher = _isHigherMinHeap;
        }

        this.buildHeap();
      }
    },
    get: function get() {
      return this._reverse;
    }
  }]);
  return PriorityQueue;
}();

exports.default = PriorityQueue;

},{"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _priorityQueue = require('./priority-queue');

var _priorityQueue2 = _interopRequireDefault(_priorityQueue);

var _timeEngine = require('./time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class SchedulingQueue
 * @extends TimeEngine
 */
/**
 * SchedulingQueue base class
 * http://wavesjs.github.io/audio/#audio-scheduling-queue
 *
 * Norbert.Schnell@ircam.fr
 * Copyright 2014, 2015 IRCAM – Centre Pompidou
 */

var SchedulingQueue = function (_TimeEngine) {
  (0, _inherits3.default)(SchedulingQueue, _TimeEngine);

  function SchedulingQueue() {
    (0, _classCallCheck3.default)(this, SchedulingQueue);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(SchedulingQueue)).call(this));

    _this.__queue = new _priorityQueue2.default();
    _this.__engines = new _set2.default();
    return _this;
  }

  // TimeEngine 'scheduled' interface


  (0, _createClass3.default)(SchedulingQueue, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var engine = this.__queue.head;
      var nextEngineTime = engine.advanceTime(time);

      if (!nextEngineTime) {
        engine.master = null;
        this.__engines.delete(engine);
        this.__queue.remove(engine);
      } else {
        this.__queue.move(engine, nextEngineTime);
      }

      return this.__queue.time;
    }

    // TimeEngine master method to be implemented by derived class

  }, {
    key: 'defer',


    // call a function at a given time
    value: function defer(fun) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!(fun instanceof Function)) throw new Error("object cannot be defered by scheduler");

      this.add({
        advanceTime: function advanceTime(time) {
          fun(time);
        } // make sur that the advanceTime method does not returm anything
      }, time);
    }

    // add a time engine to the scheduler

  }, {
    key: 'add',
    value: function add(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!_timeEngine2.default.implementsScheduled(engine)) throw new Error("object cannot be added to scheduler");

      if (engine.master) throw new Error("object has already been added to a master");

      engine.master = this;

      // add to engines and queue
      this.__engines.add(engine);
      var nextTime = this.__queue.insert(engine, time);

      // reschedule queue
      this.resetTime(nextTime);
    }

    // remove a time engine from the queue

  }, {
    key: 'remove',
    value: function remove(engine) {
      if (engine.master !== this) throw new Error("object has not been added to this scheduler");

      engine.master = null;

      // remove from array and queue
      this.__engines.delete(engine);
      var nextTime = this.__queue.remove(engine);

      // reschedule queue
      this.resetTime(nextTime);
    }

    // reset next engine time

  }, {
    key: 'resetEngineTime',
    value: function resetEngineTime(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (engine.master !== this) throw new Error("object has not been added to this scheduler");

      var nextTime = void 0;

      if (this.__queue.has(engine)) nextTime = this.__queue.move(engine, time);else nextTime = this.__queue.insert(engine, time);

      this.resetTime(nextTime);
    }

    // check whether a given engine is scheduled

  }, {
    key: 'has',
    value: function has(engine) {
      return this.__engines.has(engine);
    }

    // clear queue

  }, {
    key: 'clear',
    value: function clear() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.__engines), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var engine = _step.value;

          engine.master = null;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.__queue.clear();
      this.__engines.clear();
      this.resetTime(Infinity);
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return 0;
    }
  }]);
  return SchedulingQueue;
}(_timeEngine2.default);

exports.default = SchedulingQueue;

},{"./priority-queue":3,"./time-engine":5,"babel-runtime/core-js/get-iterator":22,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/core-js/set":29,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Base class for time engines
 *
 * A time engine generates more or less regular events and/or plays back a
 * media stream. It implements one or multiple interfaces to be driven by a
 * master (i.e. a Scheduler, a Transport or a PlayControl) in synchronization
 * with other engines. The provided interfaces are scheduled, transported,
 * and play-controlled.
 *
 *
 * #### The `scheduled` interface
 *
 * The scheduled interface allows for synchronizing an engine to a monotonous time
 * as it is provided by the Scheduler master.
 *
 * ###### `advanceTime(time :Number) -> {Number}`
 *
 * The `advanceTime` method has to be implemented by an `TimeEngine` as part of the
 * scheduled interface. The method is called by the master (e.g. the scheduler).
 * It generates an event and to returns the time of the next event (i.e. the next
 * call of advanceTime). The returned time has to be greater than the time
 * received as argument of the method. In case that a TimeEngine has to generate
 * multiple events at the same time, the engine has to implement its own loop
 * while(event.time <= time) and return the time of the next event (if any).
 *
 * ###### `resetTime(time=undefined :Number)`
 *
 * The `resetTime` method is provided by the `TimeEngine` base class. An engine may
 * call this method to reset its next event time (e.g. when a parameter is
 * changed that influences the engine's temporal behavior). When no argument
 * is given, the time is reset to the current master time. When calling the
 * method with Infinity the engine is suspended without being removed from the
 * master.
 *
 *
 * #### The `transported` interface
 *
 * The transported interface allows for synchronizing an engine to a position
 * (i.e. media playback time) that can run forward and backward and jump as it
 * is provided by the Transport master.
 *
 * ###### `syncPosition(time :Number, position :Number, speed :Number) -> {Number}`
 *
 * The `syncPositon` method has to be implemented by a `TimeEngine` as part of the
 * transported interface. The method syncPositon is called whenever the master
 * of a transported engine has to (re-)synchronize the engine's position. This
 * is for example required when the master (re-)starts playback, jumps to an
 * arbitrary position, and when reversing playback direction. The method returns
 * the next position of the engine in the given playback direction
 * (i.e. `speed < 0` or `speed > 0`).
 *
 * ###### `advancePosition(time :Number, position :Number, speed :Number) -> {Number}`
 *
 * The `advancePosition` method has to be implemented by a `TimeEngine` as part
 * of the transported interface. The master calls the advancePositon method when
 * the engine's event position is reached. The method generates an event and
 * returns the next position in the given playback direction (i.e. speed < 0 or
 * speed > 0). The returned position has to be greater (i.e. when speed > 0)
 * or less (i.e. when speed < 0) than the position received as argument of the
 * method.
 *
 * ###### `resetPosition(position=undefined :Number)`
 *
 * The resetPosition method is provided by the TimeEngine base class. An engine
 * may call this method to reset its next event position. When no argument
 * is given, the time is reset to the current master time. When calling the
 * method with Infinity the engine is suspended without being removed from
 * the master.
 *
 *
 * #### The speed-controlled interface
 *
 * The "speed-controlled" interface allows for syncronizing an engine that is
 * neither driven through the scheduled nor the transported interface. The
 * interface allows in particular to synchronize engines that assure their own
 * scheduling (i.e. audio player or an oscillator) to the event-based scheduled
 * and transported engines.
 *
 * ###### `syncSpeed(time :Number, position :Number, speed :Number, seek=false :Boolean)`
 *
 * The syncSpeed method has to be implemented by a TimeEngine as part of the
 * speed-controlled interface. The method is called by the master whenever the
 * playback speed changes or the position jumps arbitarily (i.e. on a seek).
 *
 *
 * <hr />
 *
 * Example that shows a `TimeEngine` running in a `Scheduler` that counts up
 * at a given frequency:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/time-engine.html}
 *
 * @example
 * import * as audio from 'waves-audio';
 *
 * class MyEngine extends audio.TimeEngine {
 *   constructor() {
 *     super();
 *     // ...
 *   }
 * }
 *
 */
var TimeEngine = function () {
  function TimeEngine() {
    (0, _classCallCheck3.default)(this, TimeEngine);

    /**
     * The engine's master.
     *
     * @type {Mixed}
     * @name master
     * @memberof TimeEngine
     */
    this.master = null;
  }

  /**
   * The time engine's current (master) time.
   *
   * @type {Number}
   * @memberof TimeEngine
   * @readonly
   */


  (0, _createClass3.default)(TimeEngine, [{
    key: "resetTime",
    value: function resetTime() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      if (this.master) this.master.resetEngineTime(this, time);
    }

    /**
     * Transported interface
     *   - syncPosition(time, position, speed), called to reposition TimeEngine, returns next position
     *   - advancePosition(time, position, speed), called to generate next event at given time and position, returns next position
     *
     * @static
     * @memberof TimeEngine
     */

  }, {
    key: "resetPosition",
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      if (this.master) this.master.resetEnginePosition(this, position);
    }

    /**
     * Speed-controlled interface
     *   - syncSpeed(time, position, speed, ), called to
     *
     * @static
     * @memberof TimeEngine
     */

  }, {
    key: "currentTime",
    get: function get() {
      if (this.master) return this.master.currentTime;

      return undefined;
    }

    /**
     * The time engine's current (master) position.
     *
     * @type {Number}
     * @memberof TimeEngine
     * @readonly
     */

  }, {
    key: "currentPosition",
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return undefined;
    }

    /**
     * Scheduled interface
     *   - advanceTime(time), called to generate next event at given time, returns next time
     *
     * @static
     * @memberof TimeEngine
     */

  }], [{
    key: "implementsScheduled",
    value: function implementsScheduled(engine) {
      return engine.advanceTime && engine.advanceTime instanceof Function;
    }
  }, {
    key: "implementsTransported",
    value: function implementsTransported(engine) {
      return engine.syncPosition && engine.syncPosition instanceof Function && engine.advancePosition && engine.advancePosition instanceof Function;
    }
  }, {
    key: "implementsSpeedControlled",
    value: function implementsSpeedControlled(engine) {
      return engine.syncSpeed && engine.syncSpeed instanceof Function;
    }
  }]);
  return TimeEngine;
}();

exports.default = TimeEngine;

},{"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Granular synthesis TimeEngine implementing the scheduled interface.
 * The grain position (grain onset or center time in the audio buffer) is
 * optionally determined by the engine's currentPosition attribute.
 *
 * Example that shows a `GranularEngine` (with a few parameter controls) driven
 * by a `Scheduler` and a `PlayControl`:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/granular-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const granularEngine = new audio.GranularEngine();
 *
 * scheduler.add(granularEngine);
 *
 *
 * @param {Object} options={} - Parameters
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0.01] - Absolute grain period in sec
 * @param {Number} [options.periodRel=0] - Grain period relative to absolute
 *  duration
 * @param {Number} [options.periodVar=0] - Amout of random grain period
 *  variation relative to grain period
 * @param {Number} [options.periodMin=0.001] - Minimum grain period
 * @param {Number} [options.position=0] - Grain position (onset time in audio
 *  buffer) in sec
 * @param {Number} [options.positionVar=0.003] - Amout of random grain position
 *  variation in sec
 * @param {Number} [options.durationAbs=0.1] - Absolute grain duration in sec
 * @param {Number} [options.durationRel=0] - Grain duration relative to grain
 * @param {Number} [options.durationVar=0] - Amout of random grain duration
 *  period (overlap)
 * @param {Number} [options.attackAbs=0] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0.5] - Attack time relative to grain duration
 * @param {String} [options.attackShape='lin'] - Shape of attack
 * @param {Number} [options.releaseAbs=0] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0.5] - Release time relative to grain duration
 * @param {Number} [options.releaseShape='lin'] - Shape of release
 * @param {String} [options.expRampOffset=0.0001] - Offset (start/end value)
 *  for exponential attack/release
 * @param {Number} [options.resampling=0] - Grain resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Boolean} [options.centered=true] - Whether the grain position refers
 *  to the center of the grain (or the beginning)
 * @param {Boolean} [options.cyclic=false] - Whether the audio buffer and grain
 *  position are considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the
 *  audio buffer that has been copied from the beginning to assure cyclic behavior
 */

var GranularEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(GranularEngine, _AudioTimeEngine);

  function GranularEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, GranularEngine);

    /**
     * Audio buffer
     *
     * @type {AudioBuffer}
     * @name buffer
     * @default null
     * @memberof GranularEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (GranularEngine.__proto__ || (0, _getPrototypeOf2.default)(GranularEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute grain period in sec
     *
     * @type {Number}
     * @name periodAbs
     * @default 0.01
     * @memberof GranularEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0.01);

    /**
     * Grain period relative to absolute duration
     *
     * @type {Number}
     * @name periodRel
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 0);

    /**
     * Amout of random grain period variation relative to grain period
     *
     * @type {Number}
     * @name periodVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum grain period
     *
     * @type {Number}
     * @name periodMin
     * @default 0.001
     * @memberof GranularEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Grain position (onset time in audio buffer) in sec
     *
     * @type {Number}
     * @name position
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.position = optOrDef(options.position, 0);

    /**
     * Amout of random grain position variation in sec
     *
     * @type {Number}
     * @name positionVar
     * @default 0.003
     * @memberof GranularEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0.003);

    /**
     * Absolute grain duration in sec
     *
     * @type {Number}
     * @name durationAbs
     * @default 0.1
     * @memberof GranularEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0.1); // absolute grain duration

    /**
     * Grain duration relative to grain period (overlap)
     *
     * @type {Number}
     * @name durationRel
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 0);

    /**
     * Amout of random grain duration variation in sec
     *
     * @type {Number}
     * @name durationVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.durationVar = optOrDef(options.durationVar, 0);

    /**
     * Absolute attack time in sec
     *
     * @type {Number}
     * @name attackAbs
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0);

    /**
     * Attack time relative to grain duration
     *
     * @type {Number}
     * @name attackRel
     * @default 0.5
     * @memberof GranularEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0.5);

    /**
     * Shape of attack ('lin' for linear ramp, 'exp' for exponential ramp)
     *
     * @type {String}
     * @name attackShape
     * @default 'lin'
     * @memberof GranularEngine
     * @instance
     */
    _this.attackShape = optOrDef(options.attackShape, 'lin');

    /**
     * Absolute release time in sec
     *
     * @type {Number}
     * @name releaseAbs
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0);

    /**
     * Release time relative to grain duration
     *
     * @type {Number}
     * @name releaseRel
     * @default 0.5
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0.5);

    /**
     * Shape of release ('lin' for linear ramp, 'exp' for exponential ramp)
     *
     * @type {String}
     * @name releaseShape
     * @default 'lin'
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseShape = optOrDef(options.releaseShape, 'lin');

    /**
     * Offset (start/end value) for exponential attack/release
     *
     * @type {Number}
     * @name expRampOffset
     * @default 0.0001
     * @memberof GranularEngine
     * @instance
     */
    _this.expRampOffset = optOrDef(options.expRampOffset, 0.0001);

    /**
     * Grain resampling in cent
     *
     * @type {Number}
     * @name resampling
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     *
     * @type {Number}
     * @name resamplingVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     *
     * @type {Number}
     * @name gain
     * @default 1
     * @memberof GranularEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Whether the grain position refers to the center of the grain (or the beginning)
     *
     * @type {Boolean}
     * @name centered
     * @default true
     * @memberof GranularEngine
     * @instance
     */
    _this.centered = optOrDef(options.centered, true);

    /**
     * Whether the audio buffer and grain position are considered as cyclic
     *
     * @type {Boolean}
     * @name cyclic
     * @default false
     * @memberof GranularEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);

    /**
     * Portion at the end of the audio buffer that has been copied from the
     * beginning to assure cyclic behavior
     *
     * @type {Number}
     * @name wrapAroundExtension
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();
    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @name bufferDuration
   * @memberof GranularEngine
   * @instance
   * @readonly
   */


  (0, _createClass3.default)(GranularEngine, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    /**
     * Trigger a grain. This function can be called at any time (whether the
     * engine is scheduled or not) to generate a single grain according to the
     * current grain parameters.
     *
     * @param {Number} time - grain synthesis audio time
     * @return {Number} - period to next grain
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var grainTime = time || audioContext.currentTime;
      var grainPeriod = this.periodAbs;
      var grainPosition = this.currentPosition;
      var grainDuration = this.durationAbs;

      if (this.buffer) {
        var resamplingRate = 1.0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        // randomize grain duration
        if (this.durationVar > 0) grainDuration += (2.0 * Math.random() - 1) * this.durationVar;

        grainPeriod += this.periodRel * grainDuration;
        grainDuration += this.durationRel * grainPeriod;

        // grain period randon variation
        if (this.periodVar > 0.0) grainPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

        // center grain
        if (this.centered) grainPosition -= 0.5 * grainDuration;

        // randomize grain position
        if (this.positionVar > 0) grainPosition += (2.0 * Math.random() - 1) * this.positionVar;

        var bufferDuration = this.bufferDuration;

        // wrap or clip grain position and duration into buffer duration
        if (grainPosition < 0 || grainPosition >= bufferDuration) {
          if (this.cyclic) {
            var cycles = grainPosition / bufferDuration;
            grainPosition = (cycles - Math.floor(cycles)) * bufferDuration;

            if (grainPosition + grainDuration > this.buffer.duration) grainDuration = this.buffer.duration - grainPosition;
          } else {
            if (grainPosition < 0) {
              grainTime -= grainPosition;
              grainDuration += grainPosition;
              grainPosition = 0;
            }

            if (grainPosition + grainDuration > bufferDuration) grainDuration = bufferDuration - grainPosition;
          }
        }

        // make grain
        if (this.gain > 0 && grainDuration >= 0.001) {
          // make grain envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * grainDuration;
          var release = this.releaseAbs + this.releaseRel * grainDuration;

          if (attack + release > grainDuration) {
            var factor = grainDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = grainTime + attack;
          var grainEndTime = grainTime + grainDuration / resamplingRate;
          var releaseStartTime = grainEndTime - release;

          envelope.gain.value = 0;

          if (this.attackShape === 'lin') {
            envelope.gain.setValueAtTime(0.0, grainTime);
            envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);
          } else {
            envelope.gain.setValueAtTime(this.expRampOffset, grainTime);
            envelope.gain.exponentialRampToValueAtTime(this.gain, attackEndTime);
          }

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          if (this.releaseShape === 'lin') {
            envelope.gain.linearRampToValueAtTime(0.0, grainEndTime);
          } else {
            envelope.gain.exponentialRampToValueAtTime(this.expRampOffset, grainEndTime);
          }

          envelope.connect(this.outputNode);

          // make source
          var source = audioContext.createBufferSource();

          source.buffer = this.buffer;
          source.playbackRate.value = resamplingRate;
          source.connect(envelope);

          source.start(grainTime, grainPosition);
          source.stop(grainEndTime);
        }
      }

      return Math.max(this.periodMin, grainPeriod);
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }

    /**
     * Current position
     *
     * @type {Number}
     * @name currentPosition
     * @memberof GranularEngine
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return this.position;
    }
  }]);
  return GranularEngine;
}(_audioTimeEngine2.default);

exports.default = GranularEngine;

},{"../core/audio-time-engine":2,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Metronome audio engine. It extends Time Engine as a transported interface.
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/metronome.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const metronome = new audio.Metronome({period: 0.333});
 *
 * scheduler.add(metronome);
 *
 * @param {Object} [options={}] - Default options
 * @param {Number} [options.period=1] - Metronome period
 * @param {Number} [options.clickFreq=600] - Metronome click frequency
 * @param {Number} [options.clickAttack=0.002] - Metronome click attack time
 * @param {Number} [options.clickRelease=0.098] - Metronome click release time
 * @param {Number} [options.gain=1] - Gain
 */

var Metronome = function (_AudioTimeEngine) {
  (0, _inherits3.default)(Metronome, _AudioTimeEngine);

  function Metronome() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Metronome);

    /**
     * Metronome period
     * @type {Number}
     * @private
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (Metronome.__proto__ || (0, _getPrototypeOf2.default)(Metronome)).call(this, options.audioContext));

    _this.__period = optOrDef(options.period, 1);

    /**
     * Metronome click frequency
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickFreq
     * @instance
     */
    _this.clickFreq = optOrDef(options.clickFreq, 600);

    /**
     * Metronome click attack time
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickAttack
     * @instance
     */
    _this.clickAttack = optOrDef(options.clickAttack, 0.002);

    /**
     * Metronome click release time
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickRelease
     * @instance
     */
    _this.clickRelease = optOrDef(options.clickRelease, 0.098);

    _this.__lastTime = 0;
    _this.__phase = 0;

    _this.__gainNode = _this.audioContext.createGain();
    _this.__gainNode.gain.value = optOrDef(options.gain, 1);

    _this.outputNode = _this.__gainNode;
    return _this;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(Metronome, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      this.trigger(time);
      this.__lastTime = time;
      return time + this.__period;
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (this.__period > 0) {
        var nextPosition = (Math.floor(position / this.__period) + this.__phase) * this.__period;

        if (speed > 0 && nextPosition < position) nextPosition += this.__period;else if (speed < 0 && nextPosition > position) nextPosition -= this.__period;

        return nextPosition;
      }

      return Infinity * speed;
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      this.trigger(time);

      if (speed < 0) return position - this.__period;

      return position + this.__period;
    }

    /**
     * Trigger metronome click
     * @param {Number} time metronome click synthesis audio time
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var clickAttack = this.clickAttack;
      var clickRelease = this.clickRelease;

      var env = audioContext.createGain();
      env.gain.value = 0.0;
      env.gain.setValueAtTime(0, time);
      env.gain.linearRampToValueAtTime(1.0, time + clickAttack);
      env.gain.exponentialRampToValueAtTime(0.0000001, time + clickAttack + clickRelease);
      env.gain.setValueAtTime(0, time);
      env.connect(this.outputNode);

      var osc = audioContext.createOscillator();
      osc.frequency.value = this.clickFreq;
      osc.start(time);
      osc.stop(time + clickAttack + clickRelease);
      osc.connect(env);
    }

    /**
     * linear gain factor
     *
     * @type {Number}
     * @name gain
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'gain',
    set: function set(value) {
      this.__gainNode.gain.value = value;
    },
    get: function get() {
      return this.__gainNode.gain.value;
    }

    /**
     * metronome period
     *
     * @type {Number}
     * @name period
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'period',
    set: function set(period) {
      this.__period = period;

      var master = this.master;

      if (master) {
        if (master.resetEngineTime) master.resetEngineTime(this, this.__lastTime + period);else if (master.resetEnginePosition) master.resetEnginePosition(this);
      }
    },
    get: function get() {
      return this.__period;
    }

    /**
     * Set phase parameter (available only when 'transported'), should be
     * between [0, 1[
     *
     * @type {Number}
     * @name phase
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'phase',
    set: function set(phase) {
      this.__phase = phase - Math.floor(phase);

      var master = this.master;

      if (master && master.resetEnginePosition !== undefined) master.resetEnginePosition(this);
    },
    get: function get() {
      return this.__phase;
    }
  }]);
  return Metronome;
}(_audioTimeEngine2.default);

exports.default = Metronome;

},{"../core/audio-time-engine":2,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

var _PV_fast_ = require('../utils/PV_fast_5');

var _PV_fast_2 = _interopRequireDefault(_PV_fast_);

var _bufferedPv = require('../utils/buffered-pv');

var _bufferedPv2 = _interopRequireDefault(_bufferedPv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

function getCurrentOrPreviousIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value < firstVal) index = -1;else if (value >= lastVal) index = size - 1;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] > value) {
        index--;
      }while (sortedArray[index + 1] <= value) {
        index++;
      }
    }
  }

  return index;
}

function getCurrentOrNextIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value <= firstVal) index = 0;else if (value >= lastVal) index = size;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] < value) {
        index++;
      }while (sortedArray[index - 1] >= value) {
        index--;
      }
    }
  }

  return index;
}

/**
 * Used with a buffer to serve audio files via granular synthesis.
 *
 * The engine implements the "scheduled" and "transported" interfaces.
 * When "scheduled", the engine  generates segments more or less periodically
 * (controlled by the periodAbs, periodRel, and perioVar attributes).
 * When "transported", the engine generates segments at the position of their onset time.
 *
 * Example that shows a `PhasevocoderEngine` with a few parameter controls running in a `Scheduler`.
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/phasevocoder-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const PhasevocoderEngine = new audio.PhasevocoderEngine();
 *
 * scheduler.add(PhasevocoderEngine);
 *
 * @param {Object} [options={}] - Default options
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0] - Absolute segment period in sec
 * @param {Number} [options.periodRel=1] - Segment period relative to inter-segment distance
 * @param {Number} [options.periodVar=0] - Amout of random segment period variation relative
 *  to segment period
 * @param {Number} [options.periodMin=0.001] - Minimum segment period
 * @param {Number} [options.positionArray=[0.0]] - Array of segment positions (onset times
 *  in audio buffer) in sec
 * @param {Number} [options.positionVar=0] - Amout of random segment position variation in sec
 * @param {Number} [options.durationArray=[0.0]] - Array of segment durations in sec
 * @param {Number} [options.durationAbs=0] - Absolute segment duration in sec
 * @param {Number} [options.durationRel=1] - Segment duration relative to given segment
 *  duration or inter-segment distance
 * @param {Array} [options.offsetArray=[0.0]] - Array of segment offsets in sec
 * @param {Number} [options.offsetAbs=-0.005] - Absolute segment offset in sec
 * @param {Number} [options.offsetRel=0] - Segment offset relative to segment duration
 * @param {Number} [options.delay=0.005] - Time by which all segments are delayed (especially
 *  to realize segment offsets)
 * @param {Number} [options.attackAbs=0.005] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0] - Attack time relative to segment duration
 * @param {Number} [options.releaseAbs=0.005] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0] - Release time relative to segment duration
 * @param {Number} [options.resampling=0] - Segment resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Number} [options.abortTime=0.005] - fade-out time when aborted
 * @param {Number} [options.segmentIndex=0] - Index of the segment to synthesize (i.e. of
 *  this.positionArray/durationArray/offsetArray)
 * @param {Bool} [options.cyclic=false] - Whether the audio buffer and segment indices are
 *  considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the audio buffer
 *  that has been copied from the beginning to assure cyclic behavior
 */

var PhasevocoderEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(PhasevocoderEngine, _AudioTimeEngine);

  function PhasevocoderEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, PhasevocoderEngine);

    /**
     * Audio buffer
     * @name buffer
     * @type {AudioBuffer}
     * @default null
     * @memberof PhasevocoderEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (PhasevocoderEngine.__proto__ || (0, _getPrototypeOf2.default)(PhasevocoderEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute segment period in sec
     * @name periodAbs
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0);

    /**
     * Segment period relative to inter-segment distance
     * @name periodRel
     * @type {Number}
     * @default 1
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 1);

    /**
     * Amout of random segment period variation relative to segment period
     * @name periodVar
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum segment period
     * @name periodMin
     * @type {Number}
     * @default 0.001
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Array of segment positions (onset times in audio buffer) in sec
     * @name positionArray
     * @type {Number}
     * @default [0.0]
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.positionArray = optOrDef(options.positionArray, [0.0]);

    /**
     * Amout of random segment position variation in sec
     * @name positionVar
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0);

    /**
     * Array of segment durations in sec
     * @name durationArray
     * @type {Number}
     * @default [0.0]
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.durationArray = optOrDef(options.durationArray, [0.0]);

    /**
     * Absolute segment duration in sec
     * @name durationAbs
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0);

    /**
     * Segment duration relative to given segment duration or inter-segment distance
     * @name durationRel
     * @type {Number}
     * @default 1
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 1);

    /**
     * Array of segment offsets in sec
     *
     * offset > 0: the segment's reference position is after the given segment position
     * offset < 0: the given segment position is the segment's reference position
     * and the duration has to be corrected by the offset
     *
     * @name offsetArray
     * @type {Array}
     * @default [0.0]
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.offsetArray = optOrDef(options.offsetArray, [0.0]);

    /**
     * Absolute segment offset in sec
     * @name offsetAbs
     * @type {Number}
     * @default -0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.offsetAbs = optOrDef(options.offsetAbs, -0.005);

    /**
     * Segment offset relative to segment duration
     * @name offsetRel
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.offsetRel = optOrDef(options.offsetRel, 0);

    /**
     * Time by which all segments are delayed (especially to realize segment offsets)
     * @name delay
     * @type {Number}
     * @default 0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.delay = optOrDef(options.delay, 0.005);

    /**
     * Absolute attack time in sec
     * @name attackAbs
     * @type {Number}
     * @default 0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0.005);

    /**
     * Attack time relative to segment duration
     * @name attackRel
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0);

    /**
     * Absolute release time in sec
     * @name releaseAbs
     * @type {Number}
     * @default 0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0.005);

    /**
     * Release time relative to segment duration
     * @name releaseRel
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0);

    /**
     * Segment resampling in cent
     * @name resampling
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     * @name resamplingVar
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     * @name gain
     * @type {Number}
     * @default 1
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Index of the segment to synthesize (i.e. of this.positionArray/durationArray/offsetArray)
     * @name segmentIndex
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.segmentIndex = optOrDef(options.segmentIndex, 0);

    /**
     * Whether the audio buffer and segment indices are considered as cyclic
     * @name cyclic
     * @type {Bool}
     * @default false
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);
    _this.__cyclicOffset = 0;

    /**
     * Whether the last segment is aborted when triggering the next
     * @name monophonic
     * @type {Number}
     * @default false
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.monophonic = optOrDef(options.monophonic, false);
    _this.__currentSrc = null;
    _this.__currentEnv = null;
    _this.__releaseStartTime = 0;
    _this.__currentGain = 0;
    _this.__currentEndTime = 0;

    /**
     * Fade-out time (when aborted)
     * @name abortTime
     * @type {Number}
     * @default 0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.abortTime = optOrDef(options.abortTime, 0.005);

    /**
     * Portion at the end of the audio buffer that has been copied from the beginning to assure cyclic behavior
     * @name wrapAroundExtension
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();

    // Buffered PhaseVocoder 
    _this.BUFFER_SIZE = 4096;
    _this.FRAME_SIZE = 2048;
    _this._pv = new _bufferedPv2.default(_this.FRAME_SIZE);
    _this._pv.set_audio_buffer(_this.buffer);
    _this._pv.alpha = 2; // Stretch factor
    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @default 0
   * @memberof PhasevocoderEngine
   * @instance
   */


  (0, _createClass3.default)(PhasevocoderEngine, [{
    key: 'advanceTime',


    // TimeEngine method (transported interface)
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = 0;
      var bufferDuration = this.bufferDuration;

      if (this.cyclic) {
        var cycles = position / bufferDuration;

        cyclicOffset = Math.floor(cycles) * bufferDuration;
        position -= cyclicOffset;
      }

      if (speed > 0) {
        index = getCurrentOrNextIndex(this.positionArray, position);

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else if (speed < 0) {
        index = getCurrentOrPreviousIndex(this.positionArray, position);

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      } else {
        return Infinity;
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = this.__cyclicOffset;

      this.trigger(time);

      if (speed > 0) {
        index++;

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += this.bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else {
        index--;

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= this.bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    /**
     * Trigger a segment.
     * This function can be called at any time (whether the engine is scheduled/transported or not)
     * to generate a single segment according to the current segment parameters.
     *
     * @param {Number} time segment synthesis audio time
     * @return {Number} period to next segment
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var segmentTime = (time || audioContext.currentTime) + this.delay;
      var segmentPeriod = this.periodAbs;
      var segmentIndex = this.segmentIndex;

      if (this.buffer) {
        var segmentPosition = 0.0;
        var segmentDuration = 0.0;
        var segmentOffset = 0.0;
        var resamplingRate = 1.0;
        var bufferDuration = this.bufferDuration;

        if (this.cyclic) segmentIndex = segmentIndex % this.positionArray.length;else segmentIndex = Math.max(0, Math.min(segmentIndex, this.positionArray.length - 1));

        if (this.positionArray) segmentPosition = this.positionArray[segmentIndex] || 0;

        if (this.durationArray) segmentDuration = this.durationArray[segmentIndex] || 0;

        if (this.offsetArray) segmentOffset = this.offsetArray[segmentIndex] || 0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        // calculate inter-segment distance
        if (segmentDuration === 0 || this.periodRel > 0) {
          var nextSegmentIndex = segmentIndex + 1;
          var nextPosition, nextOffset;

          if (nextSegmentIndex === this.positionArray.length) {
            if (this.cyclic) {
              nextPosition = this.positionArray[0] + bufferDuration;
              nextOffset = this.offsetArray[0];
            } else {
              nextPosition = bufferDuration;
              nextOffset = 0;
            }
          } else {
            nextPosition = this.positionArray[nextSegmentIndex];
            nextOffset = this.offsetArray[nextSegmentIndex];
          }

          var interSegmentDistance = nextPosition - segmentPosition;

          // correct inter-segment distance by offsets
          //   offset > 0: the segment's reference position is after the given segment position
          if (segmentOffset > 0) interSegmentDistance -= segmentOffset;

          if (nextOffset > 0) interSegmentDistance += nextOffset;

          if (interSegmentDistance < 0) interSegmentDistance = 0;

          // use inter-segment distance instead of segment duration
          if (segmentDuration === 0) segmentDuration = interSegmentDistance;

          // calculate period relative to inter marker distance
          segmentPeriod += this.periodRel * interSegmentDistance;
        }

        // add relative and absolute segment duration
        segmentDuration *= this.durationRel;
        segmentDuration += this.durationAbs;

        // add relative and absolute segment offset
        segmentOffset *= this.offsetRel;
        segmentOffset += this.offsetAbs;

        // apply segment offset
        //   offset > 0: the segment's reference position is after the given segment position
        //   offset < 0: the given segment position is the segment's reference position and the duration has to be corrected by the offset
        if (segmentOffset < 0) {
          segmentDuration -= segmentOffset;
          segmentPosition += segmentOffset;
          segmentTime += segmentOffset / resamplingRate;
        } else {
          segmentTime -= segmentOffset / resamplingRate;
        }

        // randomize segment position
        if (this.positionVar > 0) segmentPosition += 2.0 * (Math.random() - 0.5) * this.positionVar;

        // shorten duration of segments over the edges of the buffer
        if (segmentPosition < 0) {
          //segmentTime -= grainPosition; hm, not sure if we want to do this
          segmentDuration += segmentPosition;
          segmentPosition = 0;
        }

        if (segmentPosition + segmentDuration > this.buffer.duration) segmentDuration = this.buffer.duration - segmentPosition;

        segmentDuration /= resamplingRate;

        if (this.monophonic) this.abort(segmentTime);

        // make segment
        if (this.gain > 0 && segmentDuration > 0) {
          // make segment envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * segmentDuration;
          var release = this.releaseAbs + this.releaseRel * segmentDuration;

          if (attack + release > segmentDuration) {
            var factor = segmentDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = segmentTime + attack;
          var segmentEndTime = segmentTime + segmentDuration;
          var releaseStartTime = segmentEndTime - release;

          envelope.gain.value = 0;
          envelope.gain.setValueAtTime(0.0, segmentTime);
          envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          envelope.gain.linearRampToValueAtTime(0.0, segmentEndTime);
          envelope.connect(this.outputNode);

          this.__currentEnv = envelope;

          // make source
          var source = audioContext.createBufferSource();

          // Buffer to save the stretch audio into
          var stretchedBuffer = audioContext.createBuffer(2, segmentDuration * audioContext.sampleRate, audioContext.sampleRate);

          // This preserves attack transients on segment offsets
          this._pv.resetPhase();

          // Set the phasevocoder's position in source buffer (ie this.buffer).
          this._pv.position = segmentPosition * audioContext.sampleRate;

          this._pv.process(stretchedBuffer);

          source.buffer = stretchedBuffer;
          source.playbackRate.value = resamplingRate;
          source.connect(envelope);

          source.start(segmentTime);
          source.stop(segmentTime + segmentDuration);

          this.__currentSrc = source;
          this.__releaseStartTime = releaseStartTime;
          this.__currentGain = this.gain;
          this.__currentEndTime = segmentEndTime;
        }
      }

      // grain period randon variation
      if (this.periodVar > 0.0) segmentPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

      return Math.max(this.periodMin, segmentPeriod);
    }

    /**
     * Abort the current segment at given time, fade out duration
     *
     * @param {Number} time - abort time
     */

  }, {
    key: 'abort',
    value: function abort(time) {
      var audioContext = this.audioContext;
      var endTime = this.__currentEndTime;
      var abortTime = time || audioContext.currentTime;

      if (abortTime < endTime) {
        var segmentEndTime = Math.min(abortTime + this.abortTime, endTime);
        var envelope = this.__currentEnv;
        var currentGainValue = this.__currentGain;

        if (abortTime > this.__releaseStartTime) {
          var releaseStart = this.__releaseStartTime;
          currentGainValue *= (abortTime - releaseStart) / (endTime - releaseStart);
        }

        envelope.gain.cancelScheduledValues(abortTime);
        envelope.gain.setValueAtTime(currentGainValue, abortTime);
        envelope.gain.linearRampToValueAtTime(0, segmentEndTime);

        this.__currentSrc = null;
        this.__currentEnv = null;
        this.__releaseStartTime = 0;
        this.__currentGain = 0;
        this.__currentEndTime = 0;
      }
    }
  }, {
    key: 'stretchFactor',
    value: function stretchFactor(newAlpha) {
      this._pv.alpha = newAlpha;
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }
  }]);
  return PhasevocoderEngine;
}(_audioTimeEngine2.default);

exports.default = PhasevocoderEngine;

},{"../core/audio-time-engine":2,"../utils/PV_fast_5":18,"../utils/buffered-pv":19,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Used with a buffer to serve audio files.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/player-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const playerEngine = audio.PlayerEngine();
 * const playControl = new audio.PlayControl(playerEngine);
 *
 * playControl.start();
 *
 * @param {Object} [options={}] - Default options
 * @param {Number} [options.buffer=1] - Audio buffer
 * @param {Number} [options.fadeTime=600] - Fade time for chaining segments
 * @param {Number} [options.cyclic=false] - Loop mode
 * @param {Number} [options.gain=1] - Gain
 */

var PlayerEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(PlayerEngine, _AudioTimeEngine);

  function PlayerEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, PlayerEngine);

    var _this = (0, _possibleConstructorReturn3.default)(this, (PlayerEngine.__proto__ || (0, _getPrototypeOf2.default)(PlayerEngine)).call(this, options.audioContext));

    _this.transport = null; // set when added to transporter

    /**
     * Audio buffer
     *
     * @type {AudioBuffer}
     * @name buffer
     * @memberof PlayerEngine
     * @instance
     * @default null
     */
    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Fade time for chaining segments (e.g. in start, stop, and seek)
     *
     * @type {Number}
     * @name fadeTime
     * @memberof PlayerEngine
     * @instance
     * @default 0.005
     */
    _this.fadeTime = optOrDef(options.fadeTime, 0.005);

    _this.__time = 0;
    _this.__position = 0;
    _this.__speed = 0;

    _this.__bufferSource = null;
    _this.__envNode = null;

    _this.__gainNode = _this.audioContext.createGain();
    _this.__gainNode.gain.value = optOrDef(options.gain, 1);

    _this.__cyclic = optOrDef(options.cyclic, false);

    _this.outputNode = _this.__gainNode;
    return _this;
  }

  (0, _createClass3.default)(PlayerEngine, [{
    key: '__start',
    value: function __start(time, position, speed) {
      var audioContext = this.audioContext;

      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.__cyclic && (position < 0 || position >= bufferDuration)) {
          var phase = position / bufferDuration;
          position = (phase - Math.floor(phase)) * bufferDuration;
        }

        if (position >= 0 && position < bufferDuration && speed > 0) {
          this.__envNode = audioContext.createGain();
          this.__envNode.gain.setValueAtTime(0, time);
          this.__envNode.gain.linearRampToValueAtTime(1, time + this.fadeTime);
          this.__envNode.connect(this.__gainNode);

          this.__bufferSource = audioContext.createBufferSource();
          this.__bufferSource.buffer = this.buffer;
          this.__bufferSource.playbackRate.value = speed;
          this.__bufferSource.loop = this.__cyclic;
          this.__bufferSource.loopStart = 0;
          this.__bufferSource.loopEnd = bufferDuration;
          this.__bufferSource.start(time, position);
          this.__bufferSource.connect(this.__envNode);
        }
      }
    }
  }, {
    key: '__halt',
    value: function __halt(time) {
      if (this.__bufferSource) {
        this.__envNode.gain.cancelScheduledValues(time);
        this.__envNode.gain.setValueAtTime(this.__envNode.gain.value, time);
        this.__envNode.gain.linearRampToValueAtTime(0, time + this.fadeTime);
        this.__bufferSource.stop(time + this.fadeTime);

        this.__bufferSource = null;
        this.__envNode = null;
      }
    }

    // TimeEngine method (speed-controlled interface)

  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      if (speed !== lastSpeed || seek) {
        if (seek || lastSpeed * speed < 0) {
          this.__halt(time);
          this.__start(time, position, speed);
        } else if (lastSpeed === 0 || seek) {
          this.__start(time, position, speed);
        } else if (speed === 0) {
          this.__halt(time);
        } else if (this.__bufferSource) {
          this.__bufferSource.playbackRate.setValueAtTime(speed, time);
        }

        this.__speed = speed;
      }
    }

    /**
     * Set whether the audio buffer is considered as cyclic
     * @type {Bool}
     * @name cyclic
     * @memberof PlayerEngine
     * @instance
     */

  }, {
    key: 'cyclic',
    set: function set(cyclic) {
      if (cyclic !== this.__cyclic) {
        var time = this.currentTime;
        var position = this.currentosition;

        this.__halt(time);
        this.__cyclic = cyclic;

        if (this.__speed !== 0) this.__start(time, position, this.__speed);
      }
    },
    get: function get() {
      return this.__cyclic;
    }

    /**
     * Linear gain factor
     * @type {Number}
     * @name gain
     * @memberof PlayerEngine
     * @instance
     */

  }, {
    key: 'gain',
    set: function set(value) {
      var time = this.currentTime;
      this.__gainNode.cancelScheduledValues(time);
      this.__gainNode.setValueAtTime(this.__gainNode.gain.value, time);
      this.__gainNode.linearRampToValueAtTime(0, time + this.fadeTime);
    },
    get: function get() {
      return this.__gainNode.gain.value;
    }

    /**
     * Get buffer duration
     * @type {Number}
     * @name bufferDuration
     * @memberof PlayerEngine
     * @instance
     * @readonly
     */

  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) return this.buffer.duration;

      return 0;
    }
  }]);
  return PlayerEngine;
}(_audioTimeEngine2.default);

exports.default = PlayerEngine;

},{"../core/audio-time-engine":2,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

function getCurrentOrPreviousIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value < firstVal) index = -1;else if (value >= lastVal) index = size - 1;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] > value) {
        index--;
      }while (sortedArray[index + 1] <= value) {
        index++;
      }
    }
  }

  return index;
}

function getCurrentOrNextIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value <= firstVal) index = 0;else if (value >= lastVal) index = size;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] < value) {
        index++;
      }while (sortedArray[index - 1] >= value) {
        index--;
      }
    }
  }

  return index;
}

/**
 * Used with a buffer to serve audio files via granular synthesis.
 *
 * The engine implements the "scheduled" and "transported" interfaces.
 * When "scheduled", the engine  generates segments more or less periodically
 * (controlled by the periodAbs, periodRel, and perioVar attributes).
 * When "transported", the engine generates segments at the position of their onset time.
 *
 * Example that shows a `SegmentEngine` with a few parameter controls running in a `Scheduler`.
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/segment-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const segmentEngine = new audio.SegmentEngine();
 *
 * scheduler.add(segmentEngine);
 *
 * @param {Object} [options={}] - Default options
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0] - Absolute segment period in sec
 * @param {Number} [options.periodRel=1] - Segment period relative to inter-segment distance
 * @param {Number} [options.periodVar=0] - Amout of random segment period variation relative
 *  to segment period
 * @param {Number} [options.periodMin=0.001] - Minimum segment period
 * @param {Number} [options.positionArray=[0.0]] - Array of segment positions (onset times
 *  in audio buffer) in sec
 * @param {Number} [options.positionVar=0] - Amout of random segment position variation in sec
 * @param {Number} [options.durationArray=[0.0]] - Array of segment durations in sec
 * @param {Number} [options.durationAbs=0] - Absolute segment duration in sec
 * @param {Number} [options.durationRel=1] - Segment duration relative to given segment
 *  duration or inter-segment distance
 * @param {Array} [options.offsetArray=[0.0]] - Array of segment offsets in sec
 * @param {Number} [options.offsetAbs=-0.005] - Absolute segment offset in sec
 * @param {Number} [options.offsetRel=0] - Segment offset relative to segment duration
 * @param {Number} [options.delay=0.005] - Time by which all segments are delayed (especially
 *  to realize segment offsets)
 * @param {Number} [options.attackAbs=0.005] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0] - Attack time relative to segment duration
 * @param {Number} [options.releaseAbs=0.005] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0] - Release time relative to segment duration
 * @param {Number} [options.resampling=0] - Segment resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Number} [options.abortTime=0.005] - fade-out time when aborted
 * @param {Number} [options.segmentIndex=0] - Index of the segment to synthesize (i.e. of
 *  this.positionArray/durationArray/offsetArray)
 * @param {Bool} [options.cyclic=false] - Whether the audio buffer and segment indices are
 *  considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the audio buffer
 *  that has been copied from the beginning to assure cyclic behavior
 */

var SegmentEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(SegmentEngine, _AudioTimeEngine);

  function SegmentEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SegmentEngine);

    /**
     * Audio buffer
     * @name buffer
     * @type {AudioBuffer}
     * @default null
     * @memberof SegmentEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (SegmentEngine.__proto__ || (0, _getPrototypeOf2.default)(SegmentEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute segment period in sec
     * @name periodAbs
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0);

    /**
     * Segment period relative to inter-segment distance
     * @name periodRel
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 1);

    /**
     * Amout of random segment period variation relative to segment period
     * @name periodVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum segment period
     * @name periodMin
     * @type {Number}
     * @default 0.001
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Array of segment positions (onset times in audio buffer) in sec
     * @name positionArray
     * @type {Number}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.positionArray = optOrDef(options.positionArray, [0.0]);

    /**
     * Amout of random segment position variation in sec
     * @name positionVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0);

    /**
     * Array of segment durations in sec
     * @name durationArray
     * @type {Number}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationArray = optOrDef(options.durationArray, [0.0]);

    /**
     * Absolute segment duration in sec
     * @name durationAbs
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0);

    /**
     * Segment duration relative to given segment duration or inter-segment distance
     * @name durationRel
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 1);

    /**
     * Array of segment offsets in sec
     *
     * offset > 0: the segment's reference position is after the given segment position
     * offset < 0: the given segment position is the segment's reference position
     * and the duration has to be corrected by the offset
     *
     * @name offsetArray
     * @type {Array}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetArray = optOrDef(options.offsetArray, [0.0]);

    /**
     * Absolute segment offset in sec
     * @name offsetAbs
     * @type {Number}
     * @default -0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetAbs = optOrDef(options.offsetAbs, -0.005);

    /**
     * Segment offset relative to segment duration
     * @name offsetRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetRel = optOrDef(options.offsetRel, 0);

    /**
     * Time by which all segments are delayed (especially to realize segment offsets)
     * @name delay
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.delay = optOrDef(options.delay, 0.005);

    /**
     * Absolute attack time in sec
     * @name attackAbs
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0.005);

    /**
     * Attack time relative to segment duration
     * @name attackRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0);

    /**
     * Absolute release time in sec
     * @name releaseAbs
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0.005);

    /**
     * Release time relative to segment duration
     * @name releaseRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0);

    /**
     * Segment resampling in cent
     * @name resampling
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     * @name resamplingVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     * @name gain
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Index of the segment to synthesize (i.e. of this.positionArray/durationArray/offsetArray)
     * @name segmentIndex
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.segmentIndex = optOrDef(options.segmentIndex, 0);

    /**
     * Whether the audio buffer and segment indices are considered as cyclic
     * @name cyclic
     * @type {Bool}
     * @default false
     * @memberof SegmentEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);
    _this.__cyclicOffset = 0;

    /**
     * Whether the last segment is aborted when triggering the next
     * @name monophonic
     * @type {Number}
     * @default false
     * @memberof SegmentEngine
     * @instance
     */
    _this.monophonic = optOrDef(options.monophonic, false);
    _this.__currentSrc = null;
    _this.__currentEnv = null;
    _this.__releaseStartTime = 0;
    _this.__currentGain = 0;
    _this.__currentEndTime = 0;

    /**
     * Fade-out time (when aborted)
     * @name abortTime
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.abortTime = optOrDef(options.abortTime, 0.005);

    /**
     * Portion at the end of the audio buffer that has been copied from the beginning to assure cyclic behavior
     * @name wrapAroundExtension
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();
    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @default 0
   * @memberof SegmentEngine
   * @instance
   */


  (0, _createClass3.default)(SegmentEngine, [{
    key: 'advanceTime',


    // TimeEngine method (transported interface)
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = 0;
      var bufferDuration = this.bufferDuration;

      if (this.cyclic) {
        var cycles = position / bufferDuration;

        cyclicOffset = Math.floor(cycles) * bufferDuration;
        position -= cyclicOffset;
      }

      if (speed > 0) {
        index = getCurrentOrNextIndex(this.positionArray, position);

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else if (speed < 0) {
        index = getCurrentOrPreviousIndex(this.positionArray, position);

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      } else {
        return Infinity;
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = this.__cyclicOffset;

      this.trigger(time);

      if (speed > 0) {
        index++;

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += this.bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else {
        index--;

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= this.bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    /**
     * Trigger a segment.
     * This function can be called at any time (whether the engine is scheduled/transported or not)
     * to generate a single segment according to the current segment parameters.
     *
     * @param {Number} time segment synthesis audio time
     * @return {Number} period to next segment
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var segmentTime = (time || audioContext.currentTime) + this.delay;
      var segmentPeriod = this.periodAbs;
      var segmentIndex = this.segmentIndex;

      if (this.buffer) {
        var segmentPosition = 0.0;
        var segmentDuration = 0.0;
        var segmentOffset = 0.0;
        var resamplingRate = 1.0;
        var bufferDuration = this.bufferDuration;

        if (this.cyclic) segmentIndex = segmentIndex % this.positionArray.length;else segmentIndex = Math.max(0, Math.min(segmentIndex, this.positionArray.length - 1));

        if (this.positionArray) segmentPosition = this.positionArray[segmentIndex] || 0;

        if (this.durationArray) segmentDuration = this.durationArray[segmentIndex] || 0;

        if (this.offsetArray) segmentOffset = this.offsetArray[segmentIndex] || 0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        // calculate inter-segment distance
        if (segmentDuration === 0 || this.periodRel > 0) {
          var nextSegmentIndex = segmentIndex + 1;
          var nextPosition, nextOffset;

          if (nextSegmentIndex === this.positionArray.length) {
            if (this.cyclic) {
              nextPosition = this.positionArray[0] + bufferDuration;
              nextOffset = this.offsetArray[0];
            } else {
              nextPosition = bufferDuration;
              nextOffset = 0;
            }
          } else {
            nextPosition = this.positionArray[nextSegmentIndex];
            nextOffset = this.offsetArray[nextSegmentIndex];
          }

          var interSegmentDistance = nextPosition - segmentPosition;

          // correct inter-segment distance by offsets
          //   offset > 0: the segment's reference position is after the given segment position
          if (segmentOffset > 0) interSegmentDistance -= segmentOffset;

          if (nextOffset > 0) interSegmentDistance += nextOffset;

          if (interSegmentDistance < 0) interSegmentDistance = 0;

          // use inter-segment distance instead of segment duration
          if (segmentDuration === 0) segmentDuration = interSegmentDistance;

          // calculate period relative to inter marker distance
          segmentPeriod += this.periodRel * interSegmentDistance;
        }

        // add relative and absolute segment duration
        segmentDuration *= this.durationRel;
        segmentDuration += this.durationAbs;

        // add relative and absolute segment offset
        segmentOffset *= this.offsetRel;
        segmentOffset += this.offsetAbs;

        // apply segment offset
        //   offset > 0: the segment's reference position is after the given segment position
        //   offset < 0: the given segment position is the segment's reference position and the duration has to be corrected by the offset
        if (segmentOffset < 0) {
          segmentDuration -= segmentOffset;
          segmentPosition += segmentOffset;
          segmentTime += segmentOffset / resamplingRate;
        } else {
          segmentTime -= segmentOffset / resamplingRate;
        }

        // randomize segment position
        if (this.positionVar > 0) segmentPosition += 2.0 * (Math.random() - 0.5) * this.positionVar;

        // shorten duration of segments over the edges of the buffer
        if (segmentPosition < 0) {
          //segmentTime -= grainPosition; hm, not sure if we want to do this
          segmentDuration += segmentPosition;
          segmentPosition = 0;
        }

        if (segmentPosition + segmentDuration > this.buffer.duration) segmentDuration = this.buffer.duration - segmentPosition;

        segmentDuration /= resamplingRate;

        if (this.monophonic) this.abort(segmentTime);

        // make segment
        if (this.gain > 0 && segmentDuration > 0) {
          // make segment envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * segmentDuration;
          var release = this.releaseAbs + this.releaseRel * segmentDuration;

          if (attack + release > segmentDuration) {
            var factor = segmentDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = segmentTime + attack;
          var segmentEndTime = segmentTime + segmentDuration;
          var releaseStartTime = segmentEndTime - release;

          envelope.gain.value = 0;
          envelope.gain.setValueAtTime(0.0, segmentTime);
          envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          envelope.gain.linearRampToValueAtTime(0.0, segmentEndTime);
          envelope.connect(this.outputNode);

          this.__currentEnv = envelope;

          // make source
          var source = audioContext.createBufferSource();

          source.buffer = this.buffer;
          source.playbackRate.value = resamplingRate;
          source.connect(envelope);

          source.start(segmentTime, segmentPosition);
          source.stop(segmentTime + segmentDuration);

          this.__currentSrc = source;
          this.__releaseStartTime = releaseStartTime;
          this.__currentGain = this.gain;
          this.__currentEndTime = segmentEndTime;
        }
      }

      // grain period randon variation
      if (this.periodVar > 0.0) segmentPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

      return Math.max(this.periodMin, segmentPeriod);
    }

    /**
     * Abort the current segment at given time, fade out duration
     *
     * @param {Number} time - abort time
     */

  }, {
    key: 'abort',
    value: function abort(time) {
      var audioContext = this.audioContext;
      var endTime = this.__currentEndTime;
      var abortTime = time || audioContext.currentTime;

      if (abortTime < endTime) {
        var segmentEndTime = Math.min(abortTime + this.abortTime, endTime);
        var envelope = this.__currentEnv;
        var currentGainValue = this.__currentGain;

        if (abortTime > this.__releaseStartTime) {
          var releaseStart = this.__releaseStartTime;
          currentGainValue *= (abortTime - releaseStart) / (endTime - releaseStart);
        }

        envelope.gain.cancelScheduledValues(abortTime);
        envelope.gain.setValueAtTime(currentGainValue, abortTime);
        envelope.gain.linearRampToValueAtTime(0, segmentEndTime);

        this.__currentSrc = null;
        this.__currentEnv = null;
        this.__releaseStartTime = 0;
        this.__currentGain = 0;
        this.__currentEndTime = 0;
      }
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }
  }]);
  return SegmentEngine;
}(_audioTimeEngine2.default);

exports.default = SegmentEngine;

},{"../core/audio-time-engine":2,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

var _segmentEngine = require('./segment-engine');

var _segmentEngine2 = _interopRequireDefault(_segmentEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
    if (opt !== undefined) return opt;

    return def;
}

function getCurrentOrPreviousIndex(sortedArray, value) {
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

    var size = sortedArray.length;

    if (size > 0) {
        var firstVal = sortedArray[0];
        var lastVal = sortedArray[size - 1];

        if (value < firstVal) index = -1;else if (value >= lastVal) index = size - 1;else {
            if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

            while (sortedArray[index] > value) {
                index--;
            }while (sortedArray[index + 1] <= value) {
                index++;
            }
        }
    }

    return index;
}

function getCurrentOrNextIndex(sortedArray, value) {
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

    var size = sortedArray.length;

    if (size > 0) {
        var firstVal = sortedArray[0];
        var lastVal = sortedArray[size - 1];

        if (value <= firstVal) index = 0;else if (value >= lastVal) index = size;else {
            if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

            while (sortedArray[index] < value) {
                index++;
            }while (sortedArray[index - 1] >= value) {
                index--;
            }
        }
    }

    return index;
}

/**
 * @class SequencerEngine
 */

var SequencerEngine = function (_SegmentEngine) {
    (0, _inherits3.default)(SequencerEngine, _SegmentEngine);

    /**
     * @constructor
     * @param {AudioBuffer} buffer initial audio buffer for granular synthesis
     *
     * The engine implements the "scheduled" and "transported" interfaces.
     * When "scheduled", the engine  generates segments more or less periodically
     * (controlled by the periodAbs, periodRel, and perioVar attributes).
     * When "transported", the engine generates segments at the position of their onset time.
     */
    function SequencerEngine() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck3.default)(this, SequencerEngine);

        /**
         * A function callback that gets called from trigger().
         * This lets you set up events to be triggered by the sequencer.
         * @type {Function}
         */
        var _this = (0, _possibleConstructorReturn3.default)(this, (SequencerEngine.__proto__ || (0, _getPrototypeOf2.default)(SequencerEngine)).call(this, options));

        _this.callback = optOrDef(options.callback, null);

        return _this;
    }

    /**
     * Trigger a segment
     * @param {Number} time segment synthesis audio time
     * @return {Number} period to next segment
     *
     * This function can be called at any time (whether the engine is scheduled/transported or not)
     * to generate a single segment according to the current segment parameters.
     */


    (0, _createClass3.default)(SequencerEngine, [{
        key: 'trigger',
        value: function trigger(time) {
            var audioContext = this.audioContext;
            var segmentTime = (time || audioContext.currentTime) + this.delay;
            var segmentPeriod = this.periodAbs;
            var segmentIndex = this.segmentIndex;

            // Ignore buffer for now, this is a sequncer... no audio produced.
            if ( /*this.buffer*/true) {
                var segmentPosition = 0.0;
                var segmentDuration = 0.0;
                var segmentOffset = 0.0;
                var resamplingRate = 1.0;
                var bufferDuration = this.bufferDuration;

                if (this.cyclic) segmentIndex = segmentIndex % this.positionArray.length;else segmentIndex = Math.max(0, Math.min(segmentIndex, this.positionArray.length - 1));

                if (this.positionArray) segmentPosition = this.positionArray[segmentIndex] || 0;

                if (this.durationArray) segmentDuration = this.durationArray[segmentIndex] || 0;

                if (this.offsetArray) segmentOffset = this.offsetArray[segmentIndex] || 0;

                // calculate resampling
                if (this.resampling !== 0 || this.resamplingVar > 0) {
                    var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
                    resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
                }

                // calculate inter-segment distance
                if (segmentDuration === 0 || this.periodRel > 0) {
                    var nextSegmentIndex = segmentIndex + 1;
                    var nextPosition, nextOffset;

                    if (nextSegmentIndex === this.positionArray.length) {
                        if (this.cyclic) {
                            nextPosition = this.positionArray[0] + bufferDuration;
                            nextOffset = this.offsetArray[0];
                        } else {
                            nextPosition = bufferDuration;
                            nextOffset = 0;
                        }
                    } else {
                        nextPosition = this.positionArray[nextSegmentIndex];
                        nextOffset = this.offsetArray[nextSegmentIndex];
                    }

                    var interSegmentDistance = nextPosition - segmentPosition;

                    // correct inter-segment distance by offsets
                    //   offset > 0: the segment's reference position is after the given segment position
                    if (segmentOffset > 0) interSegmentDistance -= segmentOffset;

                    if (nextOffset > 0) interSegmentDistance += nextOffset;

                    if (interSegmentDistance < 0) interSegmentDistance = 0;

                    // use inter-segment distance instead of segment duration
                    if (segmentDuration === 0) segmentDuration = interSegmentDistance;

                    // calculate period relative to inter marker distance
                    segmentPeriod += this.periodRel * interSegmentDistance;
                }
                /*
                // add relative and absolute segment duration
                segmentDuration *= this.durationRel;
                segmentDuration += this.durationAbs;
                  // add relative and absolute segment offset
                segmentOffset *= this.offsetRel;
                segmentOffset += this.offsetAbs;
                  // apply segment offset
                //   offset > 0: the segment's reference position is after the given segment position
                //   offset < 0: the given segment position is the segment's reference position and the duration has to be corrected by the offset
                if (segmentOffset < 0) {
                    segmentDuration -= segmentOffset;
                    segmentPosition += segmentOffset;
                    segmentTime += (segmentOffset / resamplingRate);
                } else {
                    segmentTime -= (segmentOffset / resamplingRate);
                }
                  // randomize segment position
                if (this.positionVar > 0)
                    segmentPosition += 2.0 * (Math.random() - 0.5) * this.positionVar;
                  // shorten duration of segments over the edges of the buffer
                if (segmentPosition < 0) {
                    //segmentTime -= grainPosition; hm, not sure if we want to do this
                    segmentDuration += segmentPosition;
                    segmentPosition = 0;
                }
                  if (segmentPosition + segmentDuration > this.buffer.duration)
                    segmentDuration = this.buffer.duration - segmentPosition;
                  segmentDuration /= resamplingRate;
                  // make segment
                if (this.gain > 0 && segmentDuration > 0) {
                  // make segment envelope
                  var envelope = audioContext.createGain();
                  var attack = this.attackAbs + this.attackRel * segmentDuration;
                  var release = this.releaseAbs + this.releaseRel * segmentDuration;
                    if (attack + release > segmentDuration) {
                    var factor = segmentDuration / (attack + release);
                    attack *= factor;
                    release *= factor;
                  }
                    var attackEndTime = segmentTime + attack;
                  var segmentEndTime = segmentTime + segmentDuration;
                  var releaseStartTime = segmentEndTime - release;
                    envelope.gain.value = 0;
                  envelope.gain.setValueAtTime(0.0, segmentTime);
                  envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);
                    if (releaseStartTime > attackEndTime)
                    envelope.gain.setValueAtTime(this.gain, releaseStartTime);
                    envelope.gain.linearRampToValueAtTime(0.0, segmentEndTime);
                  envelope.connect(this.outputNode);
                    // make source
                  var source = audioContext.createBufferSource();
                    source.buffer = this.buffer;
                  source.playbackRate.value = resamplingRate;
                  source.connect(envelope);
                    source.start(segmentTime, segmentPosition);
                  source.stop(segmentTime + segmentDuration);
                }*/
            }

            if (this.callback && Object.prototype.toString.call(this.callback) == '[object Function]') {
                var result = this.callback(segmentIndex);
                //if (result)
                //    console.log(result);
            }

            //console.log("Sequencer.Trigger: " + segmentIndex + " Position: " + segmentPosition);

            // grain period randon variation
            if (this.periodVar > 0.0) segmentPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

            return Math.max(this.periodMin, segmentPeriod);
        }
    }]);
    return SequencerEngine;
}(_segmentEngine2.default);

exports.default = SequencerEngine;

},{"../core/audio-time-engine":2,"./segment-engine":10,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _audioContext = require('./core/audio-context');

Object.defineProperty(exports, 'audioContext', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioContext).default;
  }
});

var _timeEngine = require('./core/time-engine');

Object.defineProperty(exports, 'TimeEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_timeEngine).default;
  }
});

var _audioTimeEngine = require('./core/audio-time-engine');

Object.defineProperty(exports, 'AudioTimeEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioTimeEngine).default;
  }
});

var _priorityQueue = require('./core/priority-queue');

Object.defineProperty(exports, 'PriorityQueue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_priorityQueue).default;
  }
});

var _schedulingQueue = require('./core/scheduling-queue');

Object.defineProperty(exports, 'SchedulingQueue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_schedulingQueue).default;
  }
});

var _granularEngine = require('./engines/granular-engine');

Object.defineProperty(exports, 'GranularEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_granularEngine).default;
  }
});

var _metronome = require('./engines/metronome');

Object.defineProperty(exports, 'Metronome', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_metronome).default;
  }
});

var _playerEngine = require('./engines/player-engine');

Object.defineProperty(exports, 'PlayerEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_playerEngine).default;
  }
});

var _segmentEngine = require('./engines/segment-engine');

Object.defineProperty(exports, 'SegmentEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_segmentEngine).default;
  }
});

var _sequencerEngine = require('./engines/sequencer-engine');

Object.defineProperty(exports, 'SequencerEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sequencerEngine).default;
  }
});

var _phasevocoderEngine = require('./engines/phasevocoder-engine');

Object.defineProperty(exports, 'PhasevocoderEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_phasevocoderEngine).default;
  }
});

var _playControl = require('./masters/play-control');

Object.defineProperty(exports, 'PlayControl', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_playControl).default;
  }
});

var _transport = require('./masters/transport');

Object.defineProperty(exports, 'Transport', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_transport).default;
  }
});

var _scheduler = require('./masters/scheduler');

Object.defineProperty(exports, 'Scheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_scheduler).default;
  }
});

var _simpleScheduler = require('./masters/simple-scheduler');

Object.defineProperty(exports, 'SimpleScheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_simpleScheduler).default;
  }
});

var _factories = require('./masters/factories');

Object.defineProperty(exports, 'getScheduler', {
  enumerable: true,
  get: function get() {
    return _factories.getScheduler;
  }
});
Object.defineProperty(exports, 'getSimpleScheduler', {
  enumerable: true,
  get: function get() {
    return _factories.getSimpleScheduler;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./core/audio-context":1,"./core/audio-time-engine":2,"./core/priority-queue":3,"./core/scheduling-queue":4,"./core/time-engine":5,"./engines/granular-engine":6,"./engines/metronome":7,"./engines/phasevocoder-engine":8,"./engines/player-engine":9,"./engines/segment-engine":10,"./engines/sequencer-engine":11,"./masters/factories":13,"./masters/play-control":14,"./masters/scheduler":15,"./masters/simple-scheduler":16,"./masters/transport":17}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSimpleScheduler = exports.getScheduler = undefined;

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _scheduler = require('./scheduler');

var _scheduler2 = _interopRequireDefault(_scheduler);

var _simpleScheduler = require('./simple-scheduler');

var _simpleScheduler2 = _interopRequireDefault(_simpleScheduler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var schedulerMap = new _weakMap2.default(); // schedulers should be singletons

var simpleSchedulerMap = new _weakMap2.default();

/**
 * Returns a unique instance of `Scheduler`
 *
 * @global
 * @function
 * @returns {Scheduler}
 * @see Scheduler
 */
var getScheduler = exports.getScheduler = function getScheduler() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;

  var scheduler = schedulerMap.get(audioContext);

  if (!scheduler) {
    scheduler = new _scheduler2.default({ audioContext: audioContext });
    schedulerMap.set(audioContext, scheduler);
  }

  return scheduler;
};

/**
 * Returns a unique instance of `SimpleScheduler`
 *
 * @global
 * @function
 * @returns {SimpleScheduler}
 * @see SimpleScheduler
 */
var getSimpleScheduler = exports.getSimpleScheduler = function getSimpleScheduler() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;

  var simpleScheduler = simpleSchedulerMap.get(audioContext);

  if (!simpleScheduler) {
    simpleScheduler = new _simpleScheduler2.default({ audioContext: audioContext });
    simpleSchedulerMap.set(audioContext, simpleScheduler);
  }

  return simpleScheduler;
};

},{"../core/audio-context":1,"./scheduler":15,"./simple-scheduler":16,"babel-runtime/core-js/weak-map":32}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _factories = require('./factories');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EPSILON = 1e-8;

var LoopControl = function (_TimeEngine) {
  (0, _inherits3.default)(LoopControl, _TimeEngine);

  function LoopControl(playControl) {
    (0, _classCallCheck3.default)(this, LoopControl);

    var _this = (0, _possibleConstructorReturn3.default)(this, (LoopControl.__proto__ || (0, _getPrototypeOf2.default)(LoopControl)).call(this));

    _this.__playControl = playControl;
    _this.speed = 1;
    _this.lower = -Infinity;
    _this.upper = Infinity;
    return _this;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(LoopControl, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var playControl = this.__playControl;
      var speed = this.speed;
      var lower = this.lower;
      var upper = this.upper;

      if (speed > 0) time += EPSILON;else time -= EPSILON;

      if (speed > 0) {
        playControl.syncSpeed(time, lower, speed, true);
        return playControl.__getTimeAtPosition(upper) - EPSILON;
      } else if (speed < 0) {
        playControl.syncSpeed(time, upper, speed, true);
        return playControl.__getTimeAtPosition(lower) + EPSILON;
      }

      return Infinity;
    }
  }, {
    key: 'reschedule',
    value: function reschedule(speed) {
      var playControl = this.__playControl;
      var lower = Math.min(playControl.__loopStart, playControl.__loopEnd);
      var upper = Math.max(playControl.__loopStart, playControl.__loopEnd);

      this.speed = speed;
      this.lower = lower;
      this.upper = upper;

      if (lower === upper) speed = 0;

      if (speed > 0) this.resetTime(playControl.__getTimeAtPosition(upper) - EPSILON);else if (speed < 0) this.resetTime(playControl.__getTimeAtPosition(lower) + EPSILON);else this.resetTime(Infinity);
    }
  }, {
    key: 'applyLoopBoundaries',
    value: function applyLoopBoundaries(position, speed) {
      var lower = this.lower;
      var upper = this.upper;

      if (speed > 0 && position >= upper) return lower + (position - lower) % (upper - lower);else if (speed < 0 && position < lower) return upper - (upper - position) % (upper - lower);

      return position;
    }
  }]);
  return LoopControl;
}(_timeEngine2.default);

// play controlled base class


var PlayControlled = function () {
  function PlayControlled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlled);

    this.__playControl = playControl;

    engine.master = this;
    this.__engine = engine;
  }

  (0, _createClass3.default)(PlayControlled, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      this.__engine.syncSpeed(time, position, speed, seek);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__playControl = null;

      this.__engine.master = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlled;
}();

// play control for engines implementing the *speed-controlled* interface


var PlayControlledSpeedControlled = function (_PlayControlled) {
  (0, _inherits3.default)(PlayControlledSpeedControlled, _PlayControlled);

  function PlayControlledSpeedControlled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSpeedControlled);
    return (0, _possibleConstructorReturn3.default)(this, (PlayControlledSpeedControlled.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSpeedControlled)).call(this, playControl, engine));
  }

  return PlayControlledSpeedControlled;
}(PlayControlled);

// play control for engines implmenting the *transported* interface


var PlayControlledTransported = function (_PlayControlled2) {
  (0, _inherits3.default)(PlayControlledTransported, _PlayControlled2);

  function PlayControlledTransported(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledTransported);

    var _this3 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledTransported.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledTransported)).call(this, playControl, engine));

    _this3.__schedulerHook = new PlayControlledSchedulerHook(playControl, engine);
    return _this3;
  }

  (0, _createClass3.default)(PlayControlledTransported, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      if (speed !== lastSpeed || seek && speed !== 0) {
        var nextPosition;

        // resync transported engines
        if (seek || speed * lastSpeed < 0) {
          // seek or reverse direction
          nextPosition = this.__engine.syncPosition(time, position, speed);
        } else if (lastSpeed === 0) {
          // start
          nextPosition = this.__engine.syncPosition(time, position, speed);
        } else if (speed === 0) {
          // stop
          nextPosition = Infinity;

          if (this.__engine.syncSpeed) this.__engine.syncSpeed(time, position, 0);
        } else if (this.__engine.syncSpeed) {
          // change speed without reversing direction
          this.__engine.syncSpeed(time, position, speed);
        }

        this.__schedulerHook.resetPosition(nextPosition);
      }
    }
  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(engine) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (position === undefined) {
        var playControl = this.__playControl;
        var time = playControl.__sync();

        position = this.__engine.syncPosition(time, playControl.__position, playControl.__speed);
      }

      this.__schedulerHook.resetPosition(position);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__schedulerHook.destroy();
      this.__schedulerHook = null;

      (0, _get3.default)(PlayControlledTransported.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledTransported.prototype), 'destroy', this).call(this);
    }
  }]);
  return PlayControlledTransported;
}(PlayControlled);

// play control for time engines implementing the *scheduled* interface


var PlayControlledScheduled = function (_PlayControlled3) {
  (0, _inherits3.default)(PlayControlledScheduled, _PlayControlled3);

  function PlayControlledScheduled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledScheduled);

    // scheduling queue becomes master of engine
    var _this4 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledScheduled.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledScheduled)).call(this, playControl, engine));

    engine.master = null;
    _this4.__schedulingQueue = new PlayControlledSchedulingQueue(playControl, engine);
    return _this4;
  }

  (0, _createClass3.default)(PlayControlledScheduled, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      if (lastSpeed === 0 && speed !== 0) // start or seek
        this.__engine.resetTime();else if (lastSpeed !== 0 && speed === 0) // stop
        this.__engine.resetTime(Infinity);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__schedulingQueue.destroy();
      (0, _get3.default)(PlayControlledScheduled.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledScheduled.prototype), 'destroy', this).call(this);
    }
  }]);
  return PlayControlledScheduled;
}(PlayControlled);

// translates transported engine advancePosition into global scheduler times


var PlayControlledSchedulerHook = function (_TimeEngine2) {
  (0, _inherits3.default)(PlayControlledSchedulerHook, _TimeEngine2);

  function PlayControlledSchedulerHook(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSchedulerHook);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledSchedulerHook.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSchedulerHook)).call(this));

    _this5.__playControl = playControl;
    _this5.__engine = engine;

    _this5.__nextPosition = Infinity;
    playControl.__scheduler.add(_this5, Infinity);
    return _this5;
  }

  (0, _createClass3.default)(PlayControlledSchedulerHook, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var playControl = this.__playControl;
      var engine = this.__engine;
      var position = this.__nextPosition;
      var nextPosition = engine.advancePosition(time, position, playControl.__speed);
      var nextTime = playControl.__getTimeAtPosition(nextPosition);

      this.__nextPosition = nextPosition;
      return nextTime;
    }
  }, {
    key: 'resetPosition',
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__nextPosition;

      var time = this.__playControl.__getTimeAtPosition(position);
      this.__nextPosition = position;
      this.resetTime(time);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__playControl.__scheduler.remove(this);
      this.__playControl = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlledSchedulerHook;
}(_timeEngine2.default);

// internal scheduling queue that returns the current position (and time) of the play control


var PlayControlledSchedulingQueue = function (_SchedulingQueue) {
  (0, _inherits3.default)(PlayControlledSchedulingQueue, _SchedulingQueue);

  function PlayControlledSchedulingQueue(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSchedulingQueue);

    var _this6 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledSchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSchedulingQueue)).call(this));

    _this6.__playControl = playControl;
    _this6.__engine = engine;

    _this6.add(engine, Infinity);
    playControl.__scheduler.add(_this6, Infinity);
    return _this6;
  }

  (0, _createClass3.default)(PlayControlledSchedulingQueue, [{
    key: 'destroy',
    value: function destroy() {
      this.__playControl.__scheduler.remove(this);
      this.remove(this.__engine);

      this.__playControl = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlledSchedulingQueue;
}(_schedulingQueue2.default);

/**
 * Extends Time Engine to provide playback control of a Time Engine instance.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/play-control.html}
 *
 * @extends TimeEngine
 * @param {TimeEngine} engine - engine to control
 *
 * @example
 * import * as audio from 'waves-audio';
 * const playerEngine = audio.PlayerEngine();
 * const playControl = new audio.PlayControl(playerEngine);
 *
 * playControl.start();
 */


var PlayControl = function (_TimeEngine3) {
  (0, _inherits3.default)(PlayControl, _TimeEngine3);

  function PlayControl(engine) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, PlayControl);

    var _this7 = (0, _possibleConstructorReturn3.default)(this, (PlayControl.__proto__ || (0, _getPrototypeOf2.default)(PlayControl)).call(this));

    _this7.audioContext = options.audioContext || _audioContext2.default;
    _this7.__scheduler = (0, _factories.getScheduler)(_this7.audioContext);

    _this7.__playControlled = null;

    _this7.__loopControl = null;
    _this7.__loopStart = 0;
    _this7.__loopEnd = 1;

    // synchronized tie, position, and speed
    _this7.__time = 0;
    _this7.__position = 0;
    _this7.__speed = 0;

    // non-zero "user" speed
    _this7.__playingSpeed = 1;

    if (engine) _this7.__setEngine(engine);
    return _this7;
  }

  (0, _createClass3.default)(PlayControl, [{
    key: '__setEngine',
    value: function __setEngine(engine) {
      if (engine.master) throw new Error("object has already been added to a master");

      if (_timeEngine2.default.implementsSpeedControlled(engine)) this.__playControlled = new PlayControlledSpeedControlled(this, engine);else if (_timeEngine2.default.implementsTransported(engine)) this.__playControlled = new PlayControlledTransported(this, engine);else if (_timeEngine2.default.implementsScheduled(engine)) this.__playControlled = new PlayControlledScheduled(this, engine);else throw new Error("object cannot be added to play control");
    }
  }, {
    key: '__resetEngine',
    value: function __resetEngine() {
      this.__playControlled.destroy();
      this.__playControlled = null;
    }

    /**
     * Calculate/extrapolate playing time for given position
     *
     * @param {Number} position position
     * @return {Number} extrapolated time
     * @private
     */

  }, {
    key: '__getTimeAtPosition',
    value: function __getTimeAtPosition(position) {
      return this.__time + (position - this.__position) / this.__speed;
    }

    /**
     * Calculate/extrapolate playing position for given time
     *
     * @param {Number} time time
     * @return {Number} extrapolated position
     * @private
     */

  }, {
    key: '__getPositionAtTime',
    value: function __getPositionAtTime(time) {
      return this.__position + (time - this.__time) * this.__speed;
    }
  }, {
    key: '__sync',
    value: function __sync() {
      var now = this.currentTime;
      this.__position += (now - this.__time) * this.__speed;
      this.__time = now;
      return now;
    }

    /**
     * Get current master time.
     * This function will be replaced when the play-control is added to a master.
     *
     * @name currentTime
     * @type {Number}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'set',
    value: function set() {
      var engine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var time = this.__sync();
      var speed = this.__speed;

      if (this.__playControlled !== null && this.__playControlled.__engine !== engine) {

        this.syncSpeed(time, this.__position, 0);

        if (this.__playControlled) this.__resetEngine();

        if (this.__playControlled === null && engine !== null) {
          this.__setEngine(engine);

          if (speed !== 0) this.syncSpeed(time, this.__position, speed);
        }
      }
    }

    /**
     * Sets the play control loop behavior.
     *
     * @type {Boolean}
     * @name loop
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'setLoopBoundaries',


    /**
     * Sets loop start and end time.
     *
     * @param {Number} loopStart - loop start value.
     * @param {Number} loopEnd - loop end value.
     */
    value: function setLoopBoundaries(loopStart, loopEnd) {
      this.__loopStart = loopStart;
      this.__loopEnd = loopEnd;

      this.loop = this.loop;
    }

    /**
     * Sets loop start value
     *
     * @type {Number}
     * @name loopStart
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'syncSpeed',


    // TimeEngine method (speed-controlled interface)
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      if (speed !== lastSpeed || seek) {
        if ((seek || lastSpeed === 0) && this.__loopControl) position = this.__loopControl.applyLoopBoundaries(position, speed);

        this.__time = time;
        this.__position = position;
        this.__speed = speed;

        if (this.__playControlled) this.__playControlled.syncSpeed(time, position, speed, seek, lastSpeed);

        if (this.__loopControl) this.__loopControl.reschedule(speed);
      }
    }

    /**
     * Starts playback
     */

  }, {
    key: 'start',
    value: function start() {
      var time = this.__sync();
      this.syncSpeed(time, this.__position, this.__playingSpeed);
    }

    /**
     * Pauses playback and stays at the same position.
     */

  }, {
    key: 'pause',
    value: function pause() {
      var time = this.__sync();
      this.syncSpeed(time, this.__position, 0);
    }

    /**
     * Stops playback and seeks to initial (0) position.
     */

  }, {
    key: 'stop',
    value: function stop() {
      var time = this.__sync();
      this.syncSpeed(time, 0, 0, true);
    }

    /**
     * If speed if provided, sets the playback speed. The speed value should
     * be non-zero between -16 and -1/16 or between 1/16 and 16.
     *
     * @type {Number}
     * @name speed
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'seek',


    /**
     * Set (jump to) playing position.
     *
     * @param {Number} position target position
     */
    value: function seek(position) {
      var time = this.__sync();
      this.__position = position;
      this.syncSpeed(time, position, this.__speed, true);
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__scheduler.currentTime;
    }

    /**
     * Get current master position.
     * This function will be replaced when the play-control is added to a master.
     *
     * @name currentPosition
     * @type {Number}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__position + (this.__scheduler.currentTime - this.__time) * this.__speed;
    }

    /**
     * Returns if the play control is runnin g.
     *
     * @name running
     * @type {Boolean}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'running',
    get: function get() {
      return !(this.__speed === 0);
    }
  }, {
    key: 'loop',
    set: function set(enable) {
      if (enable && this.__loopStart > -Infinity && this.__loopEnd < Infinity) {
        if (!this.__loopControl) {
          this.__loopControl = new LoopControl(this);
          this.__scheduler.add(this.__loopControl, Infinity);
        }

        if (this.__speed !== 0) {
          var position = this.currentPosition;
          var lower = Math.min(this.__loopStart, this.__loopEnd);
          var upper = Math.max(this.__loopStart, this.__loopEnd);

          if (this.__speed > 0 && position > upper) this.seek(upper);else if (this.__speed < 0 && position < lower) this.seek(lower);else this.__loopControl.reschedule(this.__speed);
        }
      } else if (this.__loopControl) {
        this.__scheduler.remove(this.__loopControl);
        this.__loopControl = null;
      }
    },
    get: function get() {
      return !!this.__loopControl;
    }
  }, {
    key: 'loopStart',
    set: function set(loopStart) {
      this.setLoopBoundaries(loopStart, this.__loopEnd);
    },
    get: function get() {
      return this.__loopStart;
    }

    /**
     * Sets loop end value
     *
     * @type {Number}
     * @name loopEnd
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'loopEnd',
    set: function set(loopEnd) {
      this.setLoopBoundaries(this.__loopStart, loopEnd);
    },
    get: function get() {
      return this.__loopEnd;
    }
  }, {
    key: 'speed',
    set: function set(speed) {
      var time = this.__sync();

      if (speed >= 0) {
        if (speed < 0.01) speed = 0.01;else if (speed > 100) speed = 100;
      } else {
        if (speed < -100) speed = -100;else if (speed > -0.01) speed = -0.01;
      }

      this.__playingSpeed = speed;

      if (!this.master && this.__speed !== 0) this.syncSpeed(time, this.__position, speed);
    },
    get: function get() {
      return this.__playingSpeed;
    }
  }]);
  return PlayControl;
}(_timeEngine2.default);

exports.default = PlayControl;

},{"../core/audio-context":1,"../core/scheduling-queue":4,"../core/time-engine":5,"./factories":13,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('wavesjs:audio');

/**
 * The `Scheduler` class implements a master for `TimeEngine` or `AudioTimeEngine`
 * instances that implement the *scheduled* interface such as the `Metronome`
 * `GranularEngine`.
 *
 * A `Scheduler` can also schedule simple callback functions.
 * The class is based on recursive calls to `setTimeOut` and uses the
 * `audioContext.currentTime` as logical passed to the `advanceTime` methods
 * of the scheduled engines or to the scheduled callback functions.
 * It extends the `SchedulingQueue` class that itself includes a `PriorityQueue`
 * to assure the order of the scheduled engines (see `SimpleScheduler` for a
 * simplified scheduler implementation without `PriorityQueue`).
 *
 * To get a unique instance of `Scheduler` as the global scheduler of an
 * application, the `getScheduler` factory function should be used. The
 * function accepts an audio context as optional argument and uses the Waves
 * default audio context (see `audioContext`) as
 * default. The factory creates a single scheduler for each audio context.
 *
 * Example that shows three Metronome engines running in a Scheduler:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/scheduler.html}
 *
 * @param {Object} [options={}] - default options
 * @param {Number} [options.period=0.025] - period of the scheduler.
 * @param {Number} [options.lookahead=0.1] - lookahead of the scheduler.
 *
 * @see TimeEngine
 * @see AudioTimeEngine
 * @see getScheduler
 * @see SimpleScheduler
 *
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 *
 * scheduler.add(myEngine);
 */

var Scheduler = function (_SchedulingQueue) {
  (0, _inherits3.default)(Scheduler, _SchedulingQueue);

  function Scheduler() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Scheduler);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Scheduler.__proto__ || (0, _getPrototypeOf2.default)(Scheduler)).call(this));

    _this.audioContext = options.audioContext || _audioContext2.default;

    _this.__currentTime = null;
    _this.__nextTime = Infinity;
    _this.__timeout = null;

    /**
     * scheduler (setTimeout) period
     * @type {Number}
     * @name period
     * @memberof Scheduler
     * @instance
     */
    _this.period = options.period || 0.025;

    /**
     * scheduler lookahead time (> period)
     * @type {Number}
     * @name lookahead
     * @memberof Scheduler
     * @instance
     */
    _this.lookahead = options.lookahead || 0.1;
    return _this;
  }

  // setTimeout scheduling loop


  (0, _createClass3.default)(Scheduler, [{
    key: '__tick',
    value: function __tick() {
      var audioContext = this.audioContext;
      var currentTime = audioContext.currentTime;
      var time = this.__nextTime;

      this.__timeout = null;

      while (time <= currentTime + this.lookahead) {
        this.__currentTime = time;
        time = this.advanceTime(time);
      }

      this.__currentTime = null;
      this.resetTime(time);
    }
  }, {
    key: 'resetTime',
    value: function resetTime() {
      var _this2 = this;

      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentTime;

      if (this.master) {
        this.master.reset(this, time);
      } else {
        if (this.__timeout) {
          clearTimeout(this.__timeout);
          this.__timeout = null;
        }

        if (time !== Infinity) {
          if (this.__nextTime === Infinity) log('Scheduler Start');

          var timeOutDelay = Math.max(time - this.lookahead - this.audioContext.currentTime, this.period);

          this.__timeout = setTimeout(function () {
            _this2.__tick();
          }, Math.ceil(timeOutDelay * 1000));
        } else if (this.__nextTime !== Infinity) {
          log('Scheduler Stop');
        }

        this.__nextTime = time;
      }
    }

    /**
     * Scheduler current logical time.
     *
     * @name currentTime
     * @type {Number}
     * @memberof Scheduler
     * @instance
     */

  }, {
    key: 'currentTime',
    get: function get() {
      if (this.master) return this.master.currentTime;

      return this.__currentTime || this.audioContext.currentTime + this.lookahead;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return undefined;
    }

    // inherited from scheduling queue
    /**
     * Add a TimeEngine or a simple callback function to the scheduler at an
     * optionally given time. Whether the add method is called with a TimeEngine
     * or a callback function it returns a TimeEngine that can be used as argument
     * of the methods remove and resetEngineTime. A TimeEngine added to a scheduler
     * has to implement the scheduled interface. The callback function added to a
     * scheduler will be called at the given time and with the given time as
     * argument. The callback can return a new scheduling time (i.e. the next
     * time when it will be called) or it can return Infinity to suspend scheduling
     * without removing the function from the scheduler. A function that does
     * not return a value (or returns null or 0) is removed from the scheduler
     * and cannot be used as argument of the methods remove and resetEngineTime
     * anymore.
     *
     * @name add
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine|Function} engine - Engine to add to the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    /**
     * Remove a TimeEngine from the scheduler that has been added to the
     * scheduler using the add method.
     *
     * @name add
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine} engine - Engine to remove from the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    /**
     * Reschedule a scheduled time engine at a given time.
     *
     * @name resetEngineTime
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine} engine - Engine to reschedule
     * @param {Number} time - Schedule time
     */
    /**
     * Remove all scheduled callbacks and engines from the scheduler.
     *
     * @name clear
     * @function
     * @memberof Scheduler
     * @instance
     */

  }]);
  return Scheduler;
}(_schedulingQueue2.default);

exports.default = Scheduler;

},{"../core/audio-context":1,"../core/scheduling-queue":4,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37,"debug":148}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('wavesjs:audio');

/**
 *
 *
 *
 * The SimpleScheduler class implements a simplified master for time engines
 * (see TimeEngine or AudioTimeEngine) that implement the scheduled interface
 * such as the Metronome and the GranularEngine. The API and funtionalities of
 * the SimpleScheduler class are identical to the Scheduler class. But, other
 * than the Scheduler, the SimpleScheduler class does not guarantee the order
 * of events (i.e. calls to the advanceTime method of scheduled time engines
 * and to scheduled callback functions) within a scheduling period (see period
 * attribute).
 *
 * To get a unique instance of SimpleScheduler as the global scheduler of an
 * application, the getSimpleScheduler factory function should be used. The
 * function accepts an audio context as optional argument and uses the Waves
 * default audio context (see Audio Context) as default. The factory creates
 * a single (simple) scheduler for each audio context.
 *
 * Example that shows three Metronome engines running in a SimpleScheduler:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/simple-scheduler.html}
 *
 * @param {Object} [options={}] - default options
 * @param {Number} [options.period=0.025] - period of the scheduler.
 * @param {Number} [options.lookahead=0.1] - lookahead of the scheduler.
 *
 * @see TimeEngine
 * @see AudioTimeEngine
 * @see getSimpleScheduler
 * @see Scheduler
 *
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getSimpleScheduler();
 *
 * scheduler.add(myEngine);
 */

var SimpleScheduler = function () {
  function SimpleScheduler() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SimpleScheduler);

    this.audioContext = options.audioContext || _audioContext2.default;

    this.__engines = new _set2.default();

    this.__schedEngines = [];
    this.__schedTimes = [];

    this.__currentTime = null;
    this.__timeout = null;

    /**
     * scheduler (setTimeout) period
     * @type {Number}
     * @name period
     * @memberof Scheduler
     * @instance
     */
    this.period = options.period || 0.025;

    /**
     * scheduler lookahead time (> period)
     * @type {Number}
     * @name lookahead
     * @memberof Scheduler
     * @instance
     */
    this.lookahead = options.lookahead || 0.1;
  }

  (0, _createClass3.default)(SimpleScheduler, [{
    key: '__scheduleEngine',
    value: function __scheduleEngine(engine, time) {
      this.__schedEngines.push(engine);
      this.__schedTimes.push(time);
    }
  }, {
    key: '__rescheduleEngine',
    value: function __rescheduleEngine(engine, time) {
      var index = this.__schedEngines.indexOf(engine);

      if (index >= 0) {
        if (time !== Infinity) {
          this.__schedTimes[index] = time;
        } else {
          this.__schedEngines.splice(index, 1);
          this.__schedTimes.splice(index, 1);
        }
      } else if (time < Infinity) {
        this.__schedEngines.push(engine);
        this.__schedTimes.push(time);
      }
    }
  }, {
    key: '__unscheduleEngine',
    value: function __unscheduleEngine(engine) {
      var index = this.__schedEngines.indexOf(engine);

      if (index >= 0) {
        this.__schedEngines.splice(index, 1);
        this.__schedTimes.splice(index, 1);
      }
    }
  }, {
    key: '__resetTick',
    value: function __resetTick() {
      if (this.__schedEngines.length > 0) {
        if (!this.__timeout) {
          log('SimpleScheduler Start');
          this.__tick();
        }
      } else if (this.__timeout) {
        log('SimpleScheduler Stop');
        clearTimeout(this.__timeout);
        this.__timeout = null;
      }
    }
  }, {
    key: '__tick',
    value: function __tick() {
      var _this = this;

      var audioContext = this.audioContext;
      var currentTime = audioContext.currentTime;
      var i = 0;

      while (i < this.__schedEngines.length) {
        var engine = this.__schedEngines[i];
        var time = this.__schedTimes[i];

        while (time && time <= currentTime + this.lookahead) {
          time = Math.max(time, currentTime);
          this.__currentTime = time;
          time = engine.advanceTime(time);
        }

        if (time && time < Infinity) {
          this.__schedTimes[i++] = time;
        } else {
          this.__unscheduleEngine(engine);

          // remove engine from scheduler
          if (!time) {
            engine.master = null;
            this.__engines.delete(engine);
          }
        }
      }

      this.__currentTime = null;
      this.__timeout = null;

      if (this.__schedEngines.length > 0) {
        this.__timeout = setTimeout(function () {
          _this.__tick();
        }, this.period * 1000);
      }
    }

    /**
     * Scheduler current logical time.
     *
     * @name currentTime
     * @type {Number}
     * @memberof Scheduler
     * @instance
     */

  }, {
    key: 'defer',


    // call a function at a given time
    /**
     * Defer the execution of a function at a given time.
     *
     * @param {Function} fun - Function to defer
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    value: function defer(fun) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!(fun instanceof Function)) throw new Error("object cannot be defered by scheduler");

      this.add({
        advanceTime: function advanceTime(time) {
          fun(time);
        } // make sur that the advanceTime method does not returm anything
      }, time);
    }

    /**
     * Add a TimeEngine function to the scheduler at an optionally given time.
     *
     * @param {TimeEngine} engine - Engine to add to the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */

  }, {
    key: 'add',
    value: function add(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!_timeEngine2.default.implementsScheduled(engine)) throw new Error("object cannot be added to scheduler");

      if (engine.master) throw new Error("object has already been added to a master");

      // set master and add to array
      engine.master = this;
      this.__engines.add(engine);

      // schedule engine
      this.__scheduleEngine(engine, time);
      this.__resetTick();
    }

    /**
     * Remove a TimeEngine from the scheduler that has been added to the
     * scheduler using the add method.
     *
     * @param {TimeEngine} engine - Engine to remove from the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */

  }, {
    key: 'remove',
    value: function remove(engine) {
      if (!engine.master || engine.master !== this) throw new Error("engine has not been added to this scheduler");

      // reset master and remove from array
      engine.master = null;
      this.__engines.delete(engine);

      // unschedule engine
      this.__unscheduleEngine(engine);
      this.__resetTick();
    }

    /**
     * Reschedule a scheduled time engine at a given time.
     *
     * @param {TimeEngine} engine - Engine to reschedule
     * @param {Number} time - Schedule time
     */

  }, {
    key: 'resetEngineTime',
    value: function resetEngineTime(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      this.__rescheduleEngine(engine, time);
      this.__resetTick();
    }

    /**
     * Check whether a given engine is scheduled.
     *
     * @param {TimeEngine} engine - Engine to check
     */

  }, {
    key: 'has',
    value: function has(engine) {
      return this.__engines.has(engine);
    }

    /**
     * Remove all engines from the scheduler.
     */

  }, {
    key: 'clear',
    value: function clear() {
      if (this.__timeout) {
        clearTimeout(this.__timeout);
        this.__timeout = null;
      }

      this.__schedEngines.length = 0;
      this.__schedTimes.length = 0;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__currentTime || this.audioContext.currentTime + this.lookahead;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return undefined;
    }
  }]);
  return SimpleScheduler;
}();

exports.default = SimpleScheduler;

},{"../core/audio-context":1,"../core/time-engine":5,"babel-runtime/core-js/set":29,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"debug":148}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _priorityQueue = require('../core/priority-queue');

var _priorityQueue2 = _interopRequireDefault(_priorityQueue);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _factories = require('./factories');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addDuplet(firstArray, secondArray, firstElement, secondElement) {
  firstArray.push(firstElement);
  secondArray.push(secondElement);
}

function removeDuplet(firstArray, secondArray, firstElement) {
  var index = firstArray.indexOf(firstElement);

  if (index >= 0) {
    var secondElement = secondArray[index];

    firstArray.splice(index, 1);
    secondArray.splice(index, 1);

    return secondElement;
  }

  return null;
}

// The Transported call is the base class of the adapters between
// different types of engines (i.e. transported, scheduled, play-controlled)
// The adapters are at the same time masters for the engines added to the transport
// and transported TimeEngines inserted into the transport's position-based pritority queue.

var Transported = function (_TimeEngine) {
  (0, _inherits3.default)(Transported, _TimeEngine);

  function Transported(transport, engine, start, duration, offset) {
    var stretch = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    (0, _classCallCheck3.default)(this, Transported);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Transported.__proto__ || (0, _getPrototypeOf2.default)(Transported)).call(this));

    _this.master = transport;

    _this.__engine = engine;
    engine.master = _this;

    _this.__startPosition = start;
    _this.__endPosition = !isFinite(duration) ? Infinity : start + duration;
    _this.__offsetPosition = start + offset;
    _this.__stretchPosition = stretch;
    _this.__isRunning = false;
    return _this;
  }

  (0, _createClass3.default)(Transported, [{
    key: 'setBoundaries',
    value: function setBoundaries(start, duration) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var stretch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      this.__startPosition = start;
      this.__endPosition = start + duration;
      this.__offsetPosition = start + offset;
      this.__stretchPosition = stretch;
      this.resetPosition();
    }
  }, {
    key: 'start',
    value: function start(time, position, speed) {}
  }, {
    key: 'stop',
    value: function stop(time, position) {}
  }, {
    key: 'resetPosition',
    value: function resetPosition(position) {
      if (position !== undefined) position += this.__offsetPosition;

      this.master.resetEnginePosition(this, position);
    }
  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (speed > 0) {
        if (position < this.__startPosition) {

          if (this.__isRunning) this.stop(time, position - this.__offsetPosition);

          this.__isRunning = false;
          return this.__startPosition;
        } else if (position < this.__endPosition) {
          this.start(time, position - this.__offsetPosition, speed);

          this.__isRunning = true;
          return this.__endPosition;
        }
      } else {
        if (position > this.__endPosition) {
          if (this.__isRunning) // if engine is running
            this.stop(time, position - this.__offsetPosition);

          this.__isRunning = false;
          return this.__endPosition;
        } else if (position > this.__startPosition) {
          this.start(time, position - this.__offsetPosition, speed);

          this.__isRunning = true;
          return this.__startPosition;
        }
      }

      if (this.__isRunning) // if engine is running
        this.stop(time, position);

      this.__isRunning = false;
      return Infinity * speed;
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      if (!this.__isRunning) {
        this.start(time, position - this.__offsetPosition, speed);
        this.__isRunning = true;

        if (speed > 0) return this.__endPosition;

        return this.__startPosition;
      }

      // stop engine
      this.stop(time, position - this.__offsetPosition);

      this.__isRunning = false;
      return Infinity * speed;
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (speed === 0) // stop
        this.stop(time, position - this.__offsetPosition);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.master = null;

      this.__engine.master = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.master.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.master.currentPosition - this.__offsetPosition;
    }
  }]);
  return Transported;
}(_timeEngine2.default);

// TransportedTransported
// has to switch on and off the scheduled engines when the transport hits the engine's start and end position


var TransportedTransported = function (_Transported) {
  (0, _inherits3.default)(TransportedTransported, _Transported);

  function TransportedTransported(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedTransported);
    return (0, _possibleConstructorReturn3.default)(this, (TransportedTransported.__proto__ || (0, _getPrototypeOf2.default)(TransportedTransported)).call(this, transport, engine, startPosition, endPosition, offsetPosition));
  }

  (0, _createClass3.default)(TransportedTransported, [{
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (speed > 0 && position < this.__endPosition) position = Math.max(position, this.__startPosition);else if (speed < 0 && position >= this.__startPosition) position = Math.min(position, this.__endPosition);

      return this.__offsetPosition + this.__engine.syncPosition(time, position - this.__offsetPosition, speed);
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      position = this.__offsetPosition + this.__engine.advancePosition(time, position - this.__offsetPosition, speed);

      if (speed > 0 && position < this.__endPosition || speed < 0 && position >= this.__startPosition) return position;

      return Infinity * speed;
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (this.__engine.syncSpeed) this.__engine.syncSpeed(time, position, speed);
    }
  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(engine) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (position !== undefined) position += this.__offsetPosition;

      this.resetPosition(position);
    }
  }]);
  return TransportedTransported;
}(Transported);

// TransportedSpeedControlled
// has to start and stop the speed-controlled engines when the transport hits the engine's start and end position


var TransportedSpeedControlled = function (_Transported2) {
  (0, _inherits3.default)(TransportedSpeedControlled, _Transported2);

  function TransportedSpeedControlled(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedSpeedControlled);
    return (0, _possibleConstructorReturn3.default)(this, (TransportedSpeedControlled.__proto__ || (0, _getPrototypeOf2.default)(TransportedSpeedControlled)).call(this, transport, engine, startPosition, endPosition, offsetPosition));
  }

  (0, _createClass3.default)(TransportedSpeedControlled, [{
    key: 'start',
    value: function start(time, position, speed) {
      this.__engine.syncSpeed(time, position, speed, true);
    }
  }, {
    key: 'stop',
    value: function stop(time, position) {
      this.__engine.syncSpeed(time, position, 0);
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (this.__isRunning) this.__engine.syncSpeed(time, position, speed);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__engine.syncSpeed(this.master.currentTime, this.master.currentPosition - this.__offsetPosition, 0);
      (0, _get3.default)(TransportedSpeedControlled.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedSpeedControlled.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedSpeedControlled;
}(Transported);

// TransportedScheduled
// has to switch on and off the scheduled engines when the transport hits the engine's start and end position


var TransportedScheduled = function (_Transported3) {
  (0, _inherits3.default)(TransportedScheduled, _Transported3);

  function TransportedScheduled(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedScheduled);

    // scheduling queue becomes master of engine
    var _this4 = (0, _possibleConstructorReturn3.default)(this, (TransportedScheduled.__proto__ || (0, _getPrototypeOf2.default)(TransportedScheduled)).call(this, transport, engine, startPosition, endPosition, offsetPosition));

    engine.master = null;
    transport.__schedulingQueue.add(engine, Infinity);
    return _this4;
  }

  (0, _createClass3.default)(TransportedScheduled, [{
    key: 'start',
    value: function start(time, position, speed) {
      this.master.__schedulingQueue.resetEngineTime(this.__engine, time);
    }
  }, {
    key: 'stop',
    value: function stop(time, position) {
      this.master.__schedulingQueue.resetEngineTime(this.__engine, Infinity);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.master.__schedulingQueue.remove(this.__engine);
      (0, _get3.default)(TransportedScheduled.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedScheduled.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedScheduled;
}(Transported);

// translates advancePosition of *transported* engines into global scheduler times


var TransportSchedulerHook = function (_TimeEngine2) {
  (0, _inherits3.default)(TransportSchedulerHook, _TimeEngine2);

  function TransportSchedulerHook(transport) {
    (0, _classCallCheck3.default)(this, TransportSchedulerHook);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (TransportSchedulerHook.__proto__ || (0, _getPrototypeOf2.default)(TransportSchedulerHook)).call(this));

    _this5.__transport = transport;

    _this5.__nextPosition = Infinity;
    _this5.__nextTime = Infinity;
    transport.__scheduler.add(_this5, Infinity);
    return _this5;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(TransportSchedulerHook, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var transport = this.__transport;
      var position = this.__nextPosition;
      var speed = transport.__speed;
      var nextPosition = transport.advancePosition(time, position, speed);
      var nextTime = transport.__getTimeAtPosition(nextPosition);

      this.__nextPosition = nextPosition;
      this.__nextTime = nextTime;

      return nextTime;
    }
  }, {
    key: 'resetPosition',
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__nextPosition;

      var transport = this.__transport;
      var time = transport.__getTimeAtPosition(position);

      this.__nextPosition = position;
      this.__nextTime = time;

      this.resetTime(time);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__transport.__scheduler.remove(this);
      this.__transport = null;
    }
  }]);
  return TransportSchedulerHook;
}(_timeEngine2.default);

// internal scheduling queue that returns the current position (and time) of the play control


var TransportSchedulingQueue = function (_SchedulingQueue) {
  (0, _inherits3.default)(TransportSchedulingQueue, _SchedulingQueue);

  function TransportSchedulingQueue(transport) {
    (0, _classCallCheck3.default)(this, TransportSchedulingQueue);

    var _this6 = (0, _possibleConstructorReturn3.default)(this, (TransportSchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(TransportSchedulingQueue)).call(this));

    _this6.__transport = transport;
    transport.__scheduler.add(_this6, Infinity);
    return _this6;
  }

  (0, _createClass3.default)(TransportSchedulingQueue, [{
    key: 'destroy',
    value: function destroy() {
      this.__transport.__scheduler.remove(this);
      this.__transport = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__transport.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__transport.currentPosition;
    }
  }]);
  return TransportSchedulingQueue;
}(_schedulingQueue2.default);

/**
 * Provides synchronized scheduling of Time Engine instances.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/transport.html}
 *
 * @example
 * import * as audio from 'waves-audio';
 * const transport = audio.Transport();
 * const playControl = new audio.PlayControl(transport);
 * const myEngine = new MyEngine();
 * const yourEngine = new yourEngine();
 *
 * transport.add(myEngine);
 * transport.add(yourEngine);
 *
 * playControl.start();
 */


var Transport = function (_TimeEngine3) {
  (0, _inherits3.default)(Transport, _TimeEngine3);

  function Transport() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Transport);

    var _this7 = (0, _possibleConstructorReturn3.default)(this, (Transport.__proto__ || (0, _getPrototypeOf2.default)(Transport)).call(this));

    _this7.audioContext = options.audioContext || _audioContext2.default;

    _this7.__engines = [];
    _this7.__transported = [];

    _this7.__scheduler = (0, _factories.getScheduler)(_this7.audioContext);
    _this7.__schedulerHook = new TransportSchedulerHook(_this7);
    _this7.__transportedQueue = new _priorityQueue2.default();
    _this7.__schedulingQueue = new TransportSchedulingQueue(_this7);

    // syncronized time, position, and speed
    _this7.__time = 0;
    _this7.__position = 0;
    _this7.__speed = 0;
    return _this7;
  }

  (0, _createClass3.default)(Transport, [{
    key: '__getTimeAtPosition',
    value: function __getTimeAtPosition(position) {
      return this.__time + (position - this.__position) / this.__speed;
    }
  }, {
    key: '__getPositionAtTime',
    value: function __getPositionAtTime(time) {
      return this.__position + (time - this.__time) * this.__speed;
    }
  }, {
    key: '__syncTransportedPosition',
    value: function __syncTransportedPosition(time, position, speed) {
      var numTransportedEngines = this.__transported.length;
      var nextPosition = Infinity * speed;

      if (numTransportedEngines > 0) {
        this.__transportedQueue.clear();
        this.__transportedQueue.reverse = speed < 0;

        for (var i = 0; i < numTransportedEngines; i++) {
          var engine = this.__transported[i];
          var nextEnginePosition = engine.syncPosition(time, position, speed);
          this.__transportedQueue.insert(engine, nextEnginePosition);
        }

        nextPosition = this.__transportedQueue.time;
      }

      return nextPosition;
    }
  }, {
    key: '__syncTransportedSpeed',
    value: function __syncTransportedSpeed(time, position, speed) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.__transported), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var transported = _step.value;

          transported.syncSpeed(time, position, speed);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Get current master time. This getter will be replaced when the transport
     * is added to a master (i.e. transport or play-control).
     *
     * @type {Number}
     * @name currentTime
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'resetPosition',


    /**
     * Reset next transport position
     *
     * @param {Number} next - transport position
     */
    value: function resetPosition(position) {
      var master = this.master;

      if (master && master.resetEnginePosition !== undefined) master.resetEnginePosition(this, position);else this.__schedulerHook.resetPosition(position);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     */

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      this.__time = time;
      this.__position = position;
      this.__speed = speed;

      return this.__syncTransportedPosition(time, position, speed);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     */

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var engine = this.__transportedQueue.head;
      var nextEnginePosition = engine.advancePosition(time, position, speed);
      return this.__transportedQueue.move(engine, nextEnginePosition);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     * @param {Boolean} [seek=false]
     */

  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      this.__time = time;
      this.__position = position;
      this.__speed = speed;

      if (speed !== lastSpeed || seek && speed !== 0) {
        var nextPosition = void 0;

        // resync transported engines
        if (seek || speed * lastSpeed < 0) {
          // seek or reverse direction
          nextPosition = this.__syncTransportedPosition(time, position, speed);
        } else if (lastSpeed === 0) {
          // start
          nextPosition = this.__syncTransportedPosition(time, position, speed);
        } else if (speed === 0) {
          // stop
          nextPosition = Infinity;
          this.__syncTransportedSpeed(time, position, 0);
        } else {
          // change speed without reversing direction
          this.__syncTransportedSpeed(time, position, speed);
        }

        this.resetPosition(nextPosition);
      }
    }

    /**
     * Add a time engine to the transport.
     *
     * @param {Object} engine - engine to be added to the transport
     * @param {Number} position - start position
     */

  }, {
    key: 'add',
    value: function add(engine) {
      var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var endPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
      var offsetPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      var transported = null;

      if (offsetPosition === -Infinity) offsetPosition = 0;

      if (engine.master) throw new Error("object has already been added to a master");

      if (_timeEngine2.default.implementsTransported(engine)) transported = new TransportedTransported(this, engine, startPosition, endPosition, offsetPosition);else if (_timeEngine2.default.implementsSpeedControlled(engine)) transported = new TransportedSpeedControlled(this, engine, startPosition, endPosition, offsetPosition);else if (_timeEngine2.default.implementsScheduled(engine)) transported = new TransportedScheduled(this, engine, startPosition, endPosition, offsetPosition);else throw new Error("object cannot be added to a transport");

      if (transported) {
        var speed = this.__speed;

        addDuplet(this.__engines, this.__transported, engine, transported);

        if (speed !== 0) {
          // sync and start
          var nextEnginePosition = transported.syncPosition(this.currentTime, this.currentPosition, speed);
          var nextPosition = this.__transportedQueue.insert(transported, nextEnginePosition);

          this.resetPosition(nextPosition);
        }
      }

      return transported;
    }

    /**
     * Remove a time engine from the transport.
     *
     * @param {object} engineOrTransported - engine or transported to be removed from the transport
     */

  }, {
    key: 'remove',
    value: function remove(engineOrTransported) {
      var engine = engineOrTransported;
      var transported = removeDuplet(this.__engines, this.__transported, engineOrTransported);

      if (!transported) {
        engine = removeDuplet(this.__transported, this.__engines, engineOrTransported);
        transported = engineOrTransported;
      }

      if (engine && transported) {
        var nextPosition = this.__transportedQueue.remove(transported);

        transported.destroy();

        if (this.__speed !== 0) this.resetPosition(nextPosition);
      } else {
        throw new Error("object has not been added to this transport");
      }
    }

    /**
     * Reset position of the given engine.
     *
     * @param {TimeEngine} transported - Engine to reset
     * @param {Number} position - New position
     */

  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(transported) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      var speed = this.__speed;

      if (speed !== 0) {
        if (position === undefined) position = transported.syncPosition(this.currentTime, this.currentPosition, speed);

        var nextPosition = this.__transportedQueue.move(transported, position);
        this.resetPosition(nextPosition);
      }
    }

    /**
     * Remove all time engines from the transport.
     */

  }, {
    key: 'clear',
    value: function clear() {
      this.syncSpeed(this.currentTime, this.currentPosition, 0);

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this.__transported), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var transported = _step2.value;

          transported.destroy();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__scheduler.currentTime;
    }

    /**
     * Get current master position. This getter will be replaced when the transport
     * is added to a master (i.e. transport or play-control).
     *
     * @type {Number}
     * @name currentPosition
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return this.__position + (this.__scheduler.currentTime - this.__time) * this.__speed;
    }
  }]);
  return Transport;
}(_timeEngine2.default);

exports.default = Transport;

},{"../core/audio-context":1,"../core/priority-queue":3,"../core/scheduling-queue":4,"../core/time-engine":5,"./factories":13,"babel-runtime/core-js/get-iterator":22,"babel-runtime/core-js/object/get-prototype-of":27,"babel-runtime/helpers/classCallCheck":33,"babel-runtime/helpers/createClass":34,"babel-runtime/helpers/get":35,"babel-runtime/helpers/inherits":36,"babel-runtime/helpers/possibleConstructorReturn":37}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _cbuffer = require('./cbuffer');

var _cbuffer2 = _interopRequireDefault(_cbuffer);

var _dsp = require('./dsp.js');

var _dsp2 = require('./dsp');

var _dsp3 = _interopRequireDefault(_dsp2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PhaseVocoder(winSize, sampleRate) {

	var _sampleRate = sampleRate;var _Hs = 0;var _Ha = 0;var _omega;

	var _previousInputPhase;var _previousOutputPhase;var _framingWindow;

	var _squaredFramingWindow;var _winSize = winSize;

	var _overlapBuffers;var _owOverlapBuffers;

	var _first = true;

	var _overlapFactor = 4;

	var _lastInputAlpha = 1;

	/*****************************************************/
	/******************* dsp.js FFT **********************/
	/*****************************************************/

	var fft = new _dsp.FFT(_winSize, sampleRate);
	/*****************************************************/
	/*****************************************************/
	/*****************************************************/

	var sqrt = Math.sqrt;var cos = Math.cos;
	var sin = Math.sin;var atan2 = Math.atan2;
	var round = Math.round;var max = Math.max;
	var ceil = Math.ceil;var pow = Math.pow;
	var PI = Math.PI;

	/*****************************************************/
	/***************PRE-ALLOCATE MEMORY*******************/
	/*****************************************************/

	//find_peaks
	var _hlfSize = round(_winSize / 2) + 1;

	// // process
	var _process = {
		fftObj: {
			real: new Float32Array(_hlfSize),
			imag: new Float32Array(_hlfSize),
			magnitude: new Float32Array(_hlfSize),
			phase: new Float32Array(_hlfSize)
		},
		pvOut: {
			real: create_constant_array(_winSize, 0, Float32Array),
			imag: create_constant_array(_winSize, 0, Float32Array),
			magnitude: create_constant_array(_winSize, 0, Float32Array),
			phase: create_constant_array(_winSize, 0, Float32Array)
		},
		processedFrame: new Float32Array(_winSize)
	};

	var _pv_step = {
		instPhaseAdv: new Float32Array(_hlfSize),
		phTh: new Float32Array(_hlfSize)
	};

	var _STFT = {
		_inputFrame: new Float32Array(_winSize),
		_zeros: new Float32Array(_winSize)
		/*****************************************************/
		/*****************************************************/
		/*****************************************************/

	};var phTh_idx = 0;
	var twoPI = 2 * PI;
	var expectedPhaseAdv, auxHeterodynedPhaseIncr, heterodynedPhaseIncr, instPhaseAdvPerSampleHop, instPhaseAdv_, prevInstPhaseAdv_;

	function overlap_and_slide(Hs, inF, squaredWinF, oBuf, owOBuf, windowSize, outF) {

		var owSample,
		    oSample = 0;

		for (var i = 0; i < Hs; i++) {
			owSample = owOBuf.shift() || 0;
			oSample = oBuf.shift() || 0;
			outF.push(oSample / (owSample < 10e-3 ? 1 : owSample));
			oBuf.push(0);
			owOBuf.push(0);
		}

		for (var i = 0; i < windowSize; i++) {
			oSample = oBuf.shift();
			oBuf.push(inF[i] + oSample);
			owSample = owOBuf.shift();
			owOBuf.push(squaredWinF[i] + owSample);
		}
	}

	function pv_step(fftObj, prevInPh, prevOutPh, omega, Ha, Hs, out) {

		var currInPh = fftObj.phase;
		var mag = fftObj.magnitude;
		var instPhaseAdv = _pv_step.instPhaseAdv;
		var phTh = _pv_step.phTh;

		var peak, prevPeak, reg, regStart, prevRegEnd, prevRegStart, d, i;
		phTh_idx = 0;

		for (i = 0; i < omega.length; i++) {
			expectedPhaseAdv = omega[i] * Ha;

			auxHeterodynedPhaseIncr = currInPh[i] - prevInPh[i] - expectedPhaseAdv;
			heterodynedPhaseIncr = auxHeterodynedPhaseIncr - twoPI * round(auxHeterodynedPhaseIncr / twoPI);

			instPhaseAdvPerSampleHop = omega[i] + heterodynedPhaseIncr / Ha;

			instPhaseAdv_ = instPhaseAdvPerSampleHop * Hs;

			if (mag[i] > max(mag[i - 2] | 0, mag[i - 1] | 0, mag[i + 1] | 0, mag[i + 2] | 0)) {
				// if (mag[i] > (mag[i-2]|0) && mag[i] > (mag[i-1]|0) && mag[i] > (mag[i+1]|0) && mag[i] > (mag[i+2]|0)) {
				peak = i;
				regStart = ceil((prevPeak + peak) / 2) | 0;
				prevRegEnd = regStart - 1;
				reg = max(0, prevRegEnd - prevRegStart + 1);
				prevRegStart = regStart;
				for (d = 0; d < reg; d++, phTh_idx++) {
					phTh[phTh_idx] = prevOutPh[prevPeak] + prevInstPhaseAdv_ - currInPh[prevPeak];
				}
				prevPeak = peak;
				prevInstPhaseAdv_ = instPhaseAdv_;
			}
		}

		for (var i = 0; i < phTh.length; i++) {
			var theta = phTh[i];

			var phThRe = cos(phTh[i]);
			var phThIm = sin(phTh[i]);

			out.real[i] = phThRe * fftObj.real[i] - phThIm * fftObj.imag[i];
			out.imag[i] = phThRe * fftObj.imag[i] + phThIm * fftObj.real[i];
			out.phase[i] = atan2(out.imag[i], out.real[i]);
		}

		return;
	}

	this.process = function (inputArray, outputArray) {

		var _ = this;

		var __Hs = _Hs;
		var __Ha = _Ha;

		// ----------------------------------
		// ----------ANALYSIS STEP-----------
		// ----------------------------------

		var processedFrame = _process.processedFrame;;
		var fftObj = _process.fftObj;
		// FOR SOME REASON, IF I DON'T CREATE A NEW "phase" ARHaY, I GET ARTIFACTS.
		// fftObj.phase = new Float32Array(_hlfSize); 
		var pvOut = _process.pvOut;
		_.STFT(inputArray, _framingWindow, _hlfSize, fftObj);
		pv_step(fftObj, _previousInputPhase, _previousOutputPhase, _omega, __Ha, __Hs, pvOut);
		_previousOutputPhase = pvOut.phase;
		// The "phase" issue mentioned above is related to this line. 
		// If I create a new Float array using the phase array, I get no issues.
		_previousInputPhase = new Float32Array(fftObj.phase);
		_.ISTFT(pvOut.real, pvOut.imag, _framingWindow, false, processedFrame);

		// ----------------------------------
		// ------OVERLAP AND SLIDE STEP------
		// ----------------------------------
		// var outputFrame = new Array(__Hs);

		overlap_and_slide(__Hs, processedFrame, _squaredFramingWindow, _overlapBuffers, _owOverlapBuffers, _winSize, outputArray);

		return __Hs;
	};

	this.STFT = function (inputFrame, windowFrame, wantedSize, out) {
		this.STFT_drom(inputFrame, windowFrame, wantedSize, out);
	};

	this.STFT_drom = function (inputFrame, windowFrame, wantedSize, out) {
		var winSize = windowFrame.length;
		var _inputFrame = _STFT._inputFrame;

		for (var i = 0; i < winSize; i++) {
			_inputFrame[i] = inputFrame[i] * windowFrame[i];
		}

		fft.forward(_inputFrame);
		out.real = fft.real;
		out.imag = fft.imag;

		var R = out.real;var I = out.imag;
		var P = out.phase;var M = out.magnitude;

		for (var p = 0; p < winSize && p < wantedSize; p++) {
			M[p] = sqrt(I[p] * I[p] + R[p] * R[p]) * 1000;
			P[p] = atan2(I[p], R[p]);
		}

		return;
	};

	this.ISTFT = function (real, imag, windowFrame, restoreEnergy, timeFrame) {
		this.ISTFT_drom(real, imag, windowFrame, restoreEnergy, timeFrame);
	};

	this.ISTFT_drom = function (real, imag, windowFrame, restoreEnergy, timeFrame) {

		fft.inverse(real, imag, timeFrame);

		return;
	};

	this.init = function () {

		_omega = create_omega_array(winSize);

		this.reset_phases_and_overlap_buffers();

		_framingWindow = create_sin_beta_window_array(winSize, 1);

		_squaredFramingWindow = _framingWindow.map(function (x, i) {
			return x * x;
		});

		this.set_alpha(1);
	};

	function create_omega_array(size) {
		return Array.apply(null, Array(size / 2 + 1)).map(function (x, i) {
			return twoPI * i / size;
		});
	}

	function create_sin_beta_window_array(size, beta) {
		return Array.apply(null, Array(size)).map(function (x, i) {
			return pow(sin(PI * i / size), beta);
		});
	}

	function create_constant_array(size, constant, ArrayType) {
		var arr = new (ArrayType ? ArrayType : Array)(size);
		for (var i = 0; i < size; i++) {
			arr[i] = constant;
		}return arr;
	}

	this.reset_phases_and_overlap_buffers = function () {

		_previousInputPhase = create_constant_array(winSize / 2, 0);
		_previousOutputPhase = create_constant_array(winSize / 2, 0);

		_overlapBuffers = new _cbuffer2.default(winSize);
		_owOverlapBuffers = new _cbuffer2.default(winSize);
		for (var i = 0; i < winSize; i++) {
			_overlapBuffers.push(0);
			_owOverlapBuffers.push(0);
		}

		_first = true;
	};

	this.reset_phases = function () {

		_previousInputPhase = create_constant_array(winSize / 2, 0);
		_previousOutputPhase = create_constant_array(winSize / 2, 0);

		_first = true;
	};

	this.get_previous_input_phase = function () {
		return _previousInputPhase;
	};

	this.get_previous_output_phase = function () {
		return _previousOutputPhase;
	};

	this.get_analysis_hop = function () {
		return _Ha;
	};

	this.get_synthesis_hop = function () {
		return _Hs;
	};

	this.get_alpha = function () {
		return _Hs / _Ha;
	};

	this.get_framing_window = function () {
		return _framingWindow;
	};

	this.get_squared_framing_window = function () {
		return _squaredFramingWindow;
	};

	this.set_alpha = function (newAlpha) {
		_lastInputAlpha = newAlpha;
		if (newAlpha <= 0.8) _overlapFactor = 2;else if (newAlpha <= 1) _overlapFactor = 4;else _overlapFactor = 5;

		/* "Fixed" synthesis hop size. */
		_Ha = round(_winSize / _overlapFactor);
		_Hs = round(newAlpha * _Ha);

		// _Hs = _Ha;

		// _Hs = round(_winSize/2);
		// _Ha = round(_Hs / newAlpha);
	};

	this.get_alpha_step = function () {
		return 1 / _Ha;
	};

	this.set_hops = function (Ha, Hs) {
		_Ha = Ha;
		_Hs = Hs;
	};

	this.get_specified_alpha = function () {
		return _lastInputAlpha;
	};

	this.set_overlap_factor = function (overlapFactor) {
		_overlapFactor = overlapFactor;
		this.set_alpha(_lastInputAlpha);
	};
} /*  From PhaseVocoder.js (c) 2015 by Echo66
      https://github.com/echo66/PhaseVocoderJS
  
      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
  	along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */

exports.default = PhaseVocoder;

},{"./cbuffer":20,"./dsp":21,"./dsp.js":21}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _cbuffer = require('./cbuffer');

var _cbuffer2 = _interopRequireDefault(_cbuffer);

var _PV_fast_ = require('./PV_fast_5');

var _PV_fast_2 = _interopRequireDefault(_PV_fast_);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function BufferedPV(frameSize) {

	var _frameSize = frameSize || 4096;
	var _pvL = new _PV_fast_2.default(_frameSize, _audioContext2.default.sampleRate);_pvL.init();
	var _pvR = new _PV_fast_2.default(_frameSize, _audioContext2.default.sampleRate);_pvR.init();
	var _buffer;
	var _position = 0;
	var _newAlpha = 1;

	var _midBufL = new _cbuffer2.default(Math.round(_frameSize * 2));
	var _midBufR = new _cbuffer2.default(Math.round(_frameSize * 2));

	this.process = function (outputAudioBuffer) {

		if (!_buffer) return;

		var sampleCounter = 0;

		var il = _buffer.getChannelData(0);
		var ir = _buffer.getChannelData(0);
		var ol = outputAudioBuffer.getChannelData(0);
		var or = outputAudioBuffer.getChannelData(1);

		while (_midBufR.size > 0 && sampleCounter < outputAudioBuffer.length) {
			var i = sampleCounter++;
			ol[i] = _midBufL.shift();
			or[i] = _midBufR.shift();
		}

		if (sampleCounter == outputAudioBuffer.length) return;

		do {

			var bufL = il.subarray(_position, _position + _frameSize);
			var bufR = ir.subarray(_position, _position + _frameSize);

			if (_newAlpha != undefined && _newAlpha != _pvL.get_alpha()) {
				_pvL.set_alpha(_newAlpha);
				_pvR.set_alpha(_newAlpha);
				_newAlpha = undefined;
			}

			/* LEFT */
			_pvL.process(bufL, _midBufL);
			_pvR.process(bufR, _midBufR);
			for (var i = sampleCounter; _midBufL.size > 0 && i < outputAudioBuffer.length; i++) {
				ol[i] = _midBufL.shift();
				or[i] = _midBufR.shift();
			}

			sampleCounter += _pvL.get_synthesis_hop();

			_position += _pvL.get_analysis_hop();
		} while (sampleCounter < outputAudioBuffer.length);
	};

	this.set_audio_buffer = function (newBuffer) {
		_buffer = newBuffer;
		_position = 0;
		_newAlpha = 1;
	};
	this.resetPhase = function () {
		_pvL.reset_phases();
		_pvR.reset_phases();
	};
	(0, _defineProperties2.default)(this, {
		'position': {
			get: function get() {
				return _position;
			},
			set: function set(newPosition) {
				_position = newPosition;
			}
		},
		'alpha': {
			get: function get() {
				return _pvL.get_alpha();
			},
			set: function set(newAlpha) {
				_newAlpha = newAlpha;
			}
		}
	});
} /*  From PhaseVocoder.js (c) 2015 by Echo66
      https://github.com/echo66/PhaseVocoderJS
  
  	This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
  	along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */

exports.default = BufferedPV;

},{"../core/audio-context":1,"./PV_fast_5":18,"./cbuffer":20,"babel-runtime/core-js/object/define-properties":24}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
/*
	The MIT License (MIT)
	Copyright (c) 2013 Trevor Norris <trev.norris@gmail.com>

	Permission is hereby granted, free of charge, to any person obtaining a copy of
	this software and associated documentation files (the "Software"), to deal in
	the Software without restriction, including without limitation the rights to
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
	the Software, and to permit persons to whom the Software is furnished to do so,
	subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
	FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
	COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
	IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

function CBuffer() {
	// handle cases where "new" keyword wasn't used
	if (!(this instanceof CBuffer)) {
		// multiple conditions need to be checked to properly emulate Array
		if (arguments.length > 1 || typeof arguments[0] !== 'number') {
			return CBuffer.apply(new CBuffer(arguments.length), arguments);
		} else {
			return new CBuffer(arguments[0]);
		}
	}
	// if no arguments, then nothing needs to be set
	if (arguments.length === 0) throw new Error('Missing Argument: You must pass a valid buffer length');
	// this is the same in either scenario
	this.size = this.start = 0;
	// set to callback fn if data is about to be overwritten
	this.overflow = null;
	// emulate Array based on passed arguments
	if (arguments.length > 1 || typeof arguments[0] !== 'number') {
		this.data = new Float32Array(arguments.length);
		this.end = (this.length = arguments.length) - 1;
		this.push.apply(this, arguments);
	} else {
		this.data = new Float32Array(arguments[0]);
		this.end = (this.length = arguments[0]) - 1;
	}
	// need to `return this` so `return CBuffer.apply` works
	return this;
}

function defaultComparitor(a, b) {
	return a == b ? 0 : a > b ? 1 : -1;
}

CBuffer.prototype = {
	// properly set constructor
	constructor: CBuffer,

	/* mutator methods */
	// pop last item
	pop: function pop() {
		var item;
		if (this.size === 0) return;
		item = this.data[this.end];
		// remove the reference to the object so it can be garbage collected
		delete this.data[this.end];
		this.end = (this.end - 1 + this.length) % this.length;
		this.size--;
		return item;
	},
	// push item to the end
	push: function push() {
		var i = 0;
		// check if overflow is set, and if data is about to be overwritten
		if (this.overflow && this.size + arguments.length > this.length) {
			// call overflow function and send data that's about to be overwritten
			for (; i < this.size + arguments.length - this.length; i++) {
				this.overflow(this.data[(this.end + i + 1) % this.length], this);
			}
		}
		// push items to the end, wrapping and erasing existing items
		// using arguments variable directly to reduce gc footprint
		for (i = 0; i < arguments.length; i++) {
			this.data[(this.end + i + 1) % this.length] = arguments[i];
		}
		// recalculate size
		if (this.size < this.length) {
			if (this.size + i > this.length) this.size = this.length;else this.size += i;
		}
		// recalculate end
		this.end = (this.end + i) % this.length;
		// recalculate start
		this.start = (this.length + this.end - this.size + 1) % this.length;
		// return number current number of items in CBuffer
		return this.size;
	},
	// reverse order of the buffer
	reverse: function reverse() {
		var i = 0,
		    tmp;
		for (; i < ~~(this.size / 2); i++) {
			tmp = this.data[(this.start + i) % this.length];
			this.data[(this.start + i) % this.length] = this.data[(this.start + (this.size - i - 1)) % this.length];
			this.data[(this.start + (this.size - i - 1)) % this.length] = tmp;
		}
		return this;
	},
	// rotate buffer to the left by cntr, or by 1
	rotateLeft: function rotateLeft(cntr) {
		if (typeof cntr === 'undefined') cntr = 1;
		if (typeof cntr !== 'number') throw new Error("Argument must be a number");
		while (--cntr >= 0) {
			this.push(this.shift());
		}
		return this;
	},
	// rotate buffer to the right by cntr, or by 1
	rotateRight: function rotateRight(cntr) {
		if (typeof cntr === 'undefined') cntr = 1;
		if (typeof cntr !== 'number') throw new Error("Argument must be a number");
		while (--cntr >= 0) {
			this.unshift(this.pop());
		}
		return this;
	},
	// remove and return first item
	shift: function shift() {
		var item;
		// check if there are any items in CBuff
		if (this.size === 0) return;
		// store first item for return
		item = this.data[this.start];
		// recalculate start of CBuffer
		this.start = (this.start + 1) % this.length;
		// decrement size
		this.size--;
		return item;
	},
	// sort items
	sort: function sort(fn) {
		// this.data.sort(fn || defaultComparitor);
		// this.start = 0;
		// this.end = this.size - 1;
		return this;
	},
	// add item to beginning of buffer
	unshift: function unshift() {
		var i = 0;
		// check if overflow is set, and if data is about to be overwritten
		if (this.overflow && this.size + arguments.length > this.length) {
			// call overflow function and send data that's about to be overwritten
			for (; i < this.size + arguments.length - this.length; i++) {
				this.overflow(this.data[this.end - i % this.length], this);
			}
		}
		for (i = 0; i < arguments.length; i++) {
			this.data[(this.length + this.start - i % this.length - 1) % this.length] = arguments[i];
		}
		if (this.length - this.size - i < 0) {
			this.end += this.length - this.size - i;
			if (this.end < 0) this.end = this.length + this.end % this.length;
		}
		if (this.size < this.length) {
			if (this.size + i > this.length) this.size = this.length;else this.size += i;
		}
		this.start -= arguments.length;
		if (this.start < 0) this.start = this.length + this.start % this.length;
		return this.size;
	},

	/* accessor methods */
	// return index of first matched element
	indexOf: function indexOf(arg, idx) {
		if (!idx) idx = 0;
		for (; idx < this.size; idx++) {
			if (this.data[(this.start + idx) % this.length] === arg) return idx;
		}
		return -1;
	},
	// return last index of the first match
	lastIndexOf: function lastIndexOf(arg, idx) {
		if (!idx) idx = this.size - 1;
		for (; idx >= 0; idx--) {
			if (this.data[(this.start + idx) % this.length] === arg) return idx;
		}
		return -1;
	},

	// return the index an item would be inserted to if this
	// is a sorted circular buffer
	sortedIndex: function sortedIndex(value, comparitor, context) {
		comparitor = comparitor || defaultComparitor;
		var low = this.start,
		    high = this.size - 1;

		// Tricky part is finding if its before or after the pivot
		// we can get this info by checking if the target is less than
		// the last item. After that it's just a typical binary search.
		if (low && comparitor.call(context, value, this.data[high]) > 0) {
			low = 0, high = this.end;
		}

		while (low < high) {
			var mid = low + high >>> 1;
			if (comparitor.call(context, value, this.data[mid]) > 0) low = mid + 1;else high = mid;
		}
		// http://stackoverflow.com/a/18618273/1517919
		return ((low - this.start) % this.size + this.size) % this.size;
	},

	/* iteration methods */
	// check every item in the array against a test
	every: function every(callback, context) {
		var i = 0;
		for (; i < this.size; i++) {
			if (!callback.call(context, this.data[(this.start + i) % this.length], i, this)) return false;
		}
		return true;
	},
	// loop through each item in buffer
	// TODO: figure out how to emulate Array use better
	forEach: function forEach(callback, context) {
		var i = 0;
		for (; i < this.size; i++) {
			callback.call(context, this.data[(this.start + i) % this.length], i, this);
		}
	},
	// check items agains test until one returns true
	// TODO: figure out how to emuldate Array use better
	some: function some(callback, context) {
		var i = 0;
		for (; i < this.size; i++) {
			if (callback.call(context, this.data[(this.start + i) % this.length], i, this)) return true;
		}
		return false;
	},
	// calculate the average value of a circular buffer
	avg: function avg() {
		return this.size == 0 ? 0 : this.sum() / this.size;
	},
	// loop through each item in buffer and calculate sum
	sum: function sum() {
		var index = this.size;
		var s = 0;
		while (index--) {
			s += this.data[index];
		}return s;
	},
	// loop through each item in buffer and calculate median
	median: function median() {
		if (this.size === 0) return 0;
		var values = this.slice().sort(defaultComparitor);
		var half = Math.floor(values.length / 2);
		if (values.length % 2) return values[half];else return (values[half - 1] + values[half]) / 2.0;
	},
	/* utility methods */
	// reset pointers to buffer with zero items
	// note: this will not remove values in cbuffer, so if for security values
	//       need to be overwritten, run `.fill(null).empty()`
	empty: function empty() {
		var i = 0;
		this.size = this.start = 0;
		this.end = this.length - 1;
		return this;
	},
	// fill all places with passed value or function
	fill: function fill(arg) {
		var i = 0;
		if (typeof arg === 'function') {
			while (this.data[i] = arg(), ++i < this.length) {}
		} else {
			while (this.data[i] = arg, ++i < this.length) {}
		}
		// reposition start/end
		this.start = 0;
		this.end = this.length - 1;
		this.size = this.length;
		return this;
	},
	// return first item in buffer
	first: function first() {
		return this.data[this.start];
	},
	// return last item in buffer
	last: function last() {
		return this.data[this.end];
	},
	// return specific index in buffer
	get: function get(arg) {
		return this.data[(this.start + arg) % this.length];
	},
	isFull: function isFull(arg) {
		return this.length === this.size;
	},
	// set value at specified index
	set: function set(idx, arg) {
		return this.data[(this.start + idx) % this.length] = arg;
	},
	// return clean array of values
	toArray: function toArray() {
		return this.slice();
	},
	// slice the buffer to an arraay
	slice: function slice(start, end) {
		var length = this.size;

		start = +start || 0;

		if (start < 0) {
			if (start >= end) return [];
			start = -start > length ? 0 : length + start;
		}

		if (end == null || end > length) end = length;else if (end < 0) end += length;else end = +end || 0;

		length = start < end ? end - start : 0;

		var result = Array(length);
		for (var index = 0; index < length; index++) {
			result[index] = this.data[(this.start + start + index) % this.length];
		}
		return result;
	}
};

//if (typeof module === 'object' && module.exports) module.exports = CBuffer;
//else global.CBuffer = CBuffer;

exports.default = CBuffer;

},{}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FFT = undefined;

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* 
 *  DSP.js - a comprehensive digital signal processing  library for javascript
 * 
 *  Created by Corban Brook <corbanbrook@gmail.com> on 2010-01-01.
 *  Copyright 2010 Corban Brook. All rights reserved.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 * 
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 * 
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

////////////////////////////////////////////////////////////////////////////////
//                                  CONSTANTS                                 //
////////////////////////////////////////////////////////////////////////////////

/**
 * DSP is an object which contains general purpose utility functions and constants
 */
var DSP = {
  // Channels
  LEFT: 0,
  RIGHT: 1,
  MIX: 2,

  // Waveforms
  SINE: 1,
  TRIANGLE: 2,
  SAW: 3,
  SQUARE: 4,

  // Filters
  LOWPASS: 0,
  HIGHPASS: 1,
  BANDPASS: 2,
  NOTCH: 3,

  // Window functions
  BARTLETT: 1,
  BARTLETTHANN: 2,
  BLACKMAN: 3,
  COSINE: 4,
  GAUSS: 5,
  HAMMING: 6,
  HANN: 7,
  LANCZOS: 8,
  RECTANGULAR: 9,
  TRIANGULAR: 10,

  // Loop modes
  OFF: 0,
  FW: 1,
  BW: 2,
  FWBW: 3,

  // Math
  TWO_PI: 2 * Math.PI
};

// Setup arrays for platforms which do not support byte arrays
function setupTypedArray(name, fallback) {
  var self = window;
  // check if TypedArray exists
  // typeof on Minefield and Chrome return function, typeof on Webkit returns object.
  if (typeof self[name] !== "function" && (0, _typeof3.default)(self[name]) !== "object") {
    // nope.. check if WebGLArray exists
    if (typeof self[fallback] === "function" && (0, _typeof3.default)(self[fallback]) !== "object") {
      self[name] = self[fallback];
    } else {
      // nope.. set as Native JS array
      self[name] = function (obj) {
        if (obj instanceof Array) {
          return obj;
        } else if (typeof obj === "number") {
          return new Array(obj);
        }
      };
    }
  }
}

setupTypedArray("Float32Array", "WebGLFloatArray");
setupTypedArray("Int32Array", "WebGLIntArray");
setupTypedArray("Uint16Array", "WebGLUnsignedShortArray");
setupTypedArray("Uint8Array", "WebGLUnsignedByteArray");

////////////////////////////////////////////////////////////////////////////////
//                            DSP UTILITY FUNCTIONS                           //
////////////////////////////////////////////////////////////////////////////////

/**
 * Inverts the phase of a signal
 *
 * @param {Array} buffer A sample buffer
 *
 * @returns The inverted sample buffer
 */
DSP.invert = function (buffer) {
  for (var i = 0, len = buffer.length; i < len; i++) {
    buffer[i] *= -1;
  }

  return buffer;
};

/**
 * Converts split-stereo (dual mono) sample buffers into a stereo interleaved sample buffer
 *
 * @param {Array} left  A sample buffer
 * @param {Array} right A sample buffer
 *
 * @returns The stereo interleaved buffer
 */
DSP.interleave = function (left, right) {
  if (left.length !== right.length) {
    throw "Can not interleave. Channel lengths differ.";
  }

  var stereoInterleaved = new Float32Array(left.length * 2);

  for (var i = 0, len = left.length; i < len; i++) {
    stereoInterleaved[2 * i] = left[i];
    stereoInterleaved[2 * i + 1] = right[i];
  }

  return stereoInterleaved;
};

/**
 * Converts a stereo-interleaved sample buffer into split-stereo (dual mono) sample buffers
 *
 * @param {Array} buffer A stereo-interleaved sample buffer
 *
 * @returns an Array containing left and right channels
 */
DSP.deinterleave = function () {
  var left,
      right,
      mix,
      deinterleaveChannel = [];

  deinterleaveChannel[DSP.MIX] = function (buffer) {
    for (var i = 0, len = buffer.length / 2; i < len; i++) {
      mix[i] = (buffer[2 * i] + buffer[2 * i + 1]) / 2;
    }
    return mix;
  };

  deinterleaveChannel[DSP.LEFT] = function (buffer) {
    for (var i = 0, len = buffer.length / 2; i < len; i++) {
      left[i] = buffer[2 * i];
    }
    return left;
  };

  deinterleaveChannel[DSP.RIGHT] = function (buffer) {
    for (var i = 0, len = buffer.length / 2; i < len; i++) {
      right[i] = buffer[2 * i + 1];
    }
    return right;
  };

  return function (channel, buffer) {
    left = left || new Float32Array(buffer.length / 2);
    right = right || new Float32Array(buffer.length / 2);
    mix = mix || new Float32Array(buffer.length / 2);

    if (buffer.length / 2 !== left.length) {
      left = new Float32Array(buffer.length / 2);
      right = new Float32Array(buffer.length / 2);
      mix = new Float32Array(buffer.length / 2);
    }

    return deinterleaveChannel[channel](buffer);
  };
}();

/**
 * Separates a channel from a stereo-interleaved sample buffer
 *
 * @param {Array}  buffer A stereo-interleaved sample buffer
 * @param {Number} channel A channel constant (LEFT, RIGHT, MIX)
 *
 * @returns an Array containing a signal mono sample buffer
 */
DSP.getChannel = DSP.deinterleave;

/**
 * Helper method (for Reverb) to mix two (interleaved) samplebuffers. It's possible
 * to negate the second buffer while mixing and to perform a volume correction
 * on the final signal.
 *
 * @param {Array} sampleBuffer1 Array containing Float values or a Float32Array
 * @param {Array} sampleBuffer2 Array containing Float values or a Float32Array
 * @param {Boolean} negate When true inverts/flips the audio signal
 * @param {Number} volumeCorrection When you add multiple sample buffers, use this to tame your signal ;)
 *
 * @returns A new Float32Array interleaved buffer.
 */
DSP.mixSampleBuffers = function (sampleBuffer1, sampleBuffer2, negate, volumeCorrection) {
  var outputSamples = new Float32Array(sampleBuffer1);

  for (var i = 0; i < sampleBuffer1.length; i++) {
    outputSamples[i] += (negate ? -sampleBuffer2[i] : sampleBuffer2[i]) / volumeCorrection;
  }

  return outputSamples;
};

// Biquad filter types
DSP.LPF = 0; // H(s) = 1 / (s^2 + s/Q + 1)
DSP.HPF = 1; // H(s) = s^2 / (s^2 + s/Q + 1)
DSP.BPF_CONSTANT_SKIRT = 2; // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
DSP.BPF_CONSTANT_PEAK = 3; // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
DSP.NOTCH = 4; // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
DSP.APF = 5; // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
DSP.PEAKING_EQ = 6; // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
DSP.LOW_SHELF = 7; // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
DSP.HIGH_SHELF = 8; // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)

// Biquad filter parameter types
DSP.Q = 1;
DSP.BW = 2; // SHARED with BACKWARDS LOOP MODE
DSP.S = 3;

// Find RMS of signal
DSP.RMS = function (buffer) {
  var total = 0;

  for (var i = 0, n = buffer.length; i < n; i++) {
    total += buffer[i] * buffer[i];
  }

  return Math.sqrt(total / n);
};

// Find Peak of signal
DSP.Peak = function (buffer) {
  var peak = 0;

  for (var i = 0, n = buffer.length; i < n; i++) {
    peak = Math.abs(buffer[i]) > peak ? Math.abs(buffer[i]) : peak;
  }

  return peak;
};

// Fourier Transform Module used by DFT, FFT, RFFT
function FourierTransform(bufferSize, sampleRate) {
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.bandwidth = 2 / bufferSize * sampleRate / 2;

  this.spectrum = new Float32Array(bufferSize / 2);
  this.real = new Float32Array(bufferSize);
  this.imag = new Float32Array(bufferSize);

  this.peakBand = 0;
  this.peak = 0;

  /**
   * Calculates the *middle* frequency of an FFT band.
   *
   * @param {Number} index The index of the FFT band.
   *
   * @returns The middle frequency in Hz.
   */
  this.getBandFrequency = function (index) {
    return this.bandwidth * index + this.bandwidth / 2;
  };

  this.calculateSpectrum = function () {
    var spectrum = this.spectrum,
        real = this.real,
        imag = this.imag,
        bSi = 2 / this.bufferSize,
        sqrt = Math.sqrt,
        rval,
        ival,
        mag;

    for (var i = 0, N = bufferSize / 2; i < N; i++) {
      rval = real[i];
      ival = imag[i];
      mag = bSi * sqrt(rval * rval + ival * ival);

      if (mag > this.peak) {
        this.peakBand = i;
        this.peak = mag;
      }

      spectrum[i] = mag;
    }
  };
}

/**
 * DFT is a class for calculating the Discrete Fourier Transform of a signal.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function DFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  var N = bufferSize / 2 * bufferSize;
  var TWO_PI = 2 * Math.PI;

  this.sinTable = new Float32Array(N);
  this.cosTable = new Float32Array(N);

  for (var i = 0; i < N; i++) {
    this.sinTable[i] = Math.sin(i * TWO_PI / bufferSize);
    this.cosTable[i] = Math.cos(i * TWO_PI / bufferSize);
  }
}

/**
 * Performs a forward transform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer
 *
 * @returns The frequency spectrum array
 */
DFT.prototype.forward = function (buffer) {
  var real = this.real,
      imag = this.imag,
      rval,
      ival;

  for (var k = 0; k < this.bufferSize / 2; k++) {
    rval = 0.0;
    ival = 0.0;

    for (var n = 0; n < buffer.length; n++) {
      rval += this.cosTable[k * n] * buffer[n];
      ival += this.sinTable[k * n] * buffer[n];
    }

    real[k] = rval;
    imag[k] = ival;
  }

  return this.calculateSpectrum();
};

/**
 * FFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function FFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  this.reverseTable = new Uint32Array(bufferSize);

  var limit = 1;
  var bit = bufferSize >> 1;

  var i;

  while (limit < bufferSize) {
    for (i = 0; i < limit; i++) {
      this.reverseTable[i + limit] = this.reverseTable[i] + bit;
    }

    limit = limit << 1;
    bit = bit >> 1;
  }

  this.sinTable = new Float32Array(bufferSize);
  this.cosTable = new Float32Array(bufferSize);

  for (i = 0; i < bufferSize; i++) {
    this.sinTable[i] = Math.sin(-Math.PI / i);
    this.cosTable[i] = Math.cos(-Math.PI / i);
  }
}

/**
 * Performs a forward transform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer. Buffer Length must be power of 2
 *
 * @returns The frequency spectrum array
 */
FFT.prototype.forward = function (buffer) {
  // Locally scope variables for speed up
  var bufferSize = this.bufferSize,
      cosTable = this.cosTable,
      sinTable = this.sinTable,
      reverseTable = this.reverseTable,
      real = this.real,
      imag = this.imag,
      spectrum = this.spectrum;

  var k = Math.floor(Math.log(bufferSize) / Math.LN2);

  if (Math.pow(2, k) !== bufferSize) {
    throw "Invalid buffer size, must be a power of 2.";
  }
  if (bufferSize !== buffer.length) {
    throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length;
  }

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    real[i] = buffer[reverseTable[i]];
    imag[i] = 0;
  }

  while (halfSize < bufferSize) {
    //phaseShiftStepReal = Math.cos(-Math.PI/halfSize);
    //phaseShiftStepImag = Math.sin(-Math.PI/halfSize);
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];

    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = currentPhaseShiftReal * real[off] - currentPhaseShiftImag * imag[off];
        ti = currentPhaseShiftReal * imag[off] + currentPhaseShiftImag * real[off];

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = tmpReal * phaseShiftStepReal - currentPhaseShiftImag * phaseShiftStepImag;
      currentPhaseShiftImag = tmpReal * phaseShiftStepImag + currentPhaseShiftImag * phaseShiftStepReal;
    }

    halfSize = halfSize << 1;
  }

  return this.calculateSpectrum();
};

FFT.prototype.inverse = function (real, imag, buffer) {
  // Locally scope variables for speed up
  var bufferSize = this.bufferSize,
      cosTable = this.cosTable,
      sinTable = this.sinTable,
      reverseTable = this.reverseTable,
      spectrum = this.spectrum;

  real = real || this.real;
  imag = imag || this.imag;

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    imag[i] *= -1;
  }

  var revReal = new Float32Array(bufferSize);
  var revImag = new Float32Array(bufferSize);

  for (i = 0; i < real.length; i++) {
    revReal[i] = real[reverseTable[i]];
    revImag[i] = imag[reverseTable[i]];
  }

  real = revReal;
  imag = revImag;

  while (halfSize < bufferSize) {
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];
    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = currentPhaseShiftReal * real[off] - currentPhaseShiftImag * imag[off];
        ti = currentPhaseShiftReal * imag[off] + currentPhaseShiftImag * real[off];

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = tmpReal * phaseShiftStepReal - currentPhaseShiftImag * phaseShiftStepImag;
      currentPhaseShiftImag = tmpReal * phaseShiftStepImag + currentPhaseShiftImag * phaseShiftStepReal;
    }

    halfSize = halfSize << 1;
  }

  // var buffer = new Float32Array(bufferSize); // this should be reused instead
  for (i = 0; i < bufferSize; i++) {
    buffer[i] = real[i] / bufferSize;
  }

  return buffer;
};

/**
 * RFFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * This method currently only contains a forward transform but is highly optimized.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */

// lookup tables don't really gain us any speed, but they do increase
// cache footprint, so don't use them in here

// also we don't use sepearate arrays for real/imaginary parts

// this one a little more than twice as fast as the one in FFT
// however I only did the forward transform

// the rest of this was translated from C, see http://www.jjj.de/fxt/
// this is the real split radix FFT

function RFFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  this.trans = new Float32Array(bufferSize);

  this.reverseTable = new Uint32Array(bufferSize);

  // don't use a lookup table to do the permute, use this instead
  this.reverseBinPermute = function (dest, source) {
    var bufferSize = this.bufferSize,
        halfSize = bufferSize >>> 1,
        nm1 = bufferSize - 1,
        i = 1,
        r = 0,
        h;

    dest[0] = source[0];

    do {
      r += halfSize;
      dest[i] = source[r];
      dest[r] = source[i];

      i++;

      h = halfSize << 1;
      while (h = h >> 1, !((r ^= h) & h)) {}

      if (r >= i) {
        dest[i] = source[r];
        dest[r] = source[i];

        dest[nm1 - i] = source[nm1 - r];
        dest[nm1 - r] = source[nm1 - i];
      }
      i++;
    } while (i < halfSize);
    dest[nm1] = source[nm1];
  };

  this.generateReverseTable = function () {
    var bufferSize = this.bufferSize,
        halfSize = bufferSize >>> 1,
        nm1 = bufferSize - 1,
        i = 1,
        r = 0,
        h;

    this.reverseTable[0] = 0;

    do {
      r += halfSize;

      this.reverseTable[i] = r;
      this.reverseTable[r] = i;

      i++;

      h = halfSize << 1;
      while (h = h >> 1, !((r ^= h) & h)) {}

      if (r >= i) {
        this.reverseTable[i] = r;
        this.reverseTable[r] = i;

        this.reverseTable[nm1 - i] = nm1 - r;
        this.reverseTable[nm1 - r] = nm1 - i;
      }
      i++;
    } while (i < halfSize);

    this.reverseTable[nm1] = nm1;
  };

  this.generateReverseTable();
}

// Ordering of output:
//
// trans[0]     = re[0] (==zero frequency, purely real)
// trans[1]     = re[1]
//             ...
// trans[n/2-1] = re[n/2-1]
// trans[n/2]   = re[n/2]    (==nyquist frequency, purely real)
//
// trans[n/2+1] = im[n/2-1]
// trans[n/2+2] = im[n/2-2]
//             ...
// trans[n-1]   = im[1] 

RFFT.prototype.forward = function (buffer) {
  var n = this.bufferSize,
      spectrum = this.spectrum,
      x = this.trans,
      TWO_PI = 2 * Math.PI,
      sqrt = Math.sqrt,
      i = n >>> 1,
      bSi = 2 / n,
      n2,
      n4,
      n8,
      nn,
      t1,
      t2,
      t3,
      t4,
      i1,
      i2,
      i3,
      i4,
      i5,
      i6,
      i7,
      i8,
      st1,
      cc1,
      ss1,
      cc3,
      ss3,
      e,
      a,
      rval,
      ival,
      mag;

  this.reverseBinPermute(x, buffer);

  /*
  var reverseTable = this.reverseTable;
   for (var k = 0, len = reverseTable.length; k < len; k++) {
    x[k] = buffer[reverseTable[k]];
  }
  */

  for (var ix = 0, id = 4; ix < n; id *= 4) {
    for (var i0 = ix; i0 < n; i0 += id) {
      //sumdiff(x[i0], x[i0+1]); // {a, b}  <--| {a+b, a-b}
      st1 = x[i0] - x[i0 + 1];
      x[i0] += x[i0 + 1];
      x[i0 + 1] = st1;
    }
    ix = 2 * (id - 1);
  }

  n2 = 2;
  nn = n >>> 1;

  while (nn = nn >>> 1) {
    ix = 0;
    n2 = n2 << 1;
    id = n2 << 1;
    n4 = n2 >>> 2;
    n8 = n2 >>> 3;
    do {
      if (n4 !== 1) {
        for (i0 = ix; i0 < n; i0 += id) {
          i1 = i0;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;

          //diffsum3_r(x[i3], x[i4], t1); // {a, b, s} <--| {a, b-a, a+b}
          t1 = x[i3] + x[i4];
          x[i4] -= x[i3];
          //sumdiff3(x[i1], t1, x[i3]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i3] = x[i1] - t1;
          x[i1] += t1;

          i1 += n8;
          i2 += n8;
          i3 += n8;
          i4 += n8;

          //sumdiff(x[i3], x[i4], t1, t2); // {s, d}  <--| {a+b, a-b}
          t1 = x[i3] + x[i4];
          t2 = x[i3] - x[i4];

          t1 = -t1 * Math.SQRT1_2;
          t2 *= Math.SQRT1_2;

          // sumdiff(t1, x[i2], x[i4], x[i3]); // {s, d}  <--| {a+b, a-b}
          st1 = x[i2];
          x[i4] = t1 + st1;
          x[i3] = t1 - st1;

          //sumdiff3(x[i1], t2, x[i2]); // {a, b, d} <--| {a+b, b, a-b}
          x[i2] = x[i1] - t2;
          x[i1] += t2;
        }
      } else {
        for (i0 = ix; i0 < n; i0 += id) {
          i1 = i0;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;

          //diffsum3_r(x[i3], x[i4], t1); // {a, b, s} <--| {a, b-a, a+b}
          t1 = x[i3] + x[i4];
          x[i4] -= x[i3];

          //sumdiff3(x[i1], t1, x[i3]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i3] = x[i1] - t1;
          x[i1] += t1;
        }
      }

      ix = (id << 1) - n2;
      id = id << 2;
    } while (ix < n);

    e = TWO_PI / n2;

    for (var j = 1; j < n8; j++) {
      a = j * e;
      ss1 = Math.sin(a);
      cc1 = Math.cos(a);

      //ss3 = sin(3*a); cc3 = cos(3*a);
      cc3 = 4 * cc1 * (cc1 * cc1 - 0.75);
      ss3 = 4 * ss1 * (0.75 - ss1 * ss1);

      ix = 0;id = n2 << 1;
      do {
        for (i0 = ix; i0 < n; i0 += id) {
          i1 = i0 + j;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;

          i5 = i0 + n4 - j;
          i6 = i5 + n4;
          i7 = i6 + n4;
          i8 = i7 + n4;

          //cmult(c, s, x, y, &u, &v)
          //cmult(cc1, ss1, x[i7], x[i3], t2, t1); // {u,v} <--| {x*c-y*s, x*s+y*c}
          t2 = x[i7] * cc1 - x[i3] * ss1;
          t1 = x[i7] * ss1 + x[i3] * cc1;

          //cmult(cc3, ss3, x[i8], x[i4], t4, t3);
          t4 = x[i8] * cc3 - x[i4] * ss3;
          t3 = x[i8] * ss3 + x[i4] * cc3;

          //sumdiff(t2, t4);   // {a, b} <--| {a+b, a-b}
          st1 = t2 - t4;
          t2 += t4;
          t4 = st1;

          //sumdiff(t2, x[i6], x[i8], x[i3]); // {s, d}  <--| {a+b, a-b}
          //st1 = x[i6]; x[i8] = t2 + st1; x[i3] = t2 - st1;
          x[i8] = t2 + x[i6];
          x[i3] = t2 - x[i6];

          //sumdiff_r(t1, t3); // {a, b} <--| {a+b, b-a}
          st1 = t3 - t1;
          t1 += t3;
          t3 = st1;

          //sumdiff(t3, x[i2], x[i4], x[i7]); // {s, d}  <--| {a+b, a-b}
          //st1 = x[i2]; x[i4] = t3 + st1; x[i7] = t3 - st1;
          x[i4] = t3 + x[i2];
          x[i7] = t3 - x[i2];

          //sumdiff3(x[i1], t1, x[i6]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i6] = x[i1] - t1;
          x[i1] += t1;

          //diffsum3_r(t4, x[i5], x[i2]); // {a, b, s} <--| {a, b-a, a+b}
          x[i2] = t4 + x[i5];
          x[i5] -= t4;
        }

        ix = (id << 1) - n2;
        id = id << 2;
      } while (ix < n);
    }
  }

  while (--i) {
    rval = x[i];
    ival = x[n - i - 1];
    mag = bSi * sqrt(rval * rval + ival * ival);

    if (mag > this.peak) {
      this.peakBand = i;
      this.peak = mag;
    }

    spectrum[i] = mag;
  }

  spectrum[0] = bSi * x[0];

  return spectrum;
};

function Sampler(file, bufferSize, sampleRate, playStart, playEnd, loopStart, loopEnd, loopMode) {
  this.file = file;
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.playStart = playStart || 0; // 0%
  this.playEnd = playEnd || 1; // 100%
  this.loopStart = loopStart || 0;
  this.loopEnd = loopEnd || 1;
  this.loopMode = loopMode || DSP.OFF;
  this.loaded = false;
  this.samples = [];
  this.signal = new Float32Array(bufferSize);
  this.frameCount = 0;
  this.envelope = null;
  this.amplitude = 1;
  this.rootFrequency = 110; // A2 110
  this.frequency = 550;
  this.step = this.frequency / this.rootFrequency;
  this.duration = 0;
  this.samplesProcessed = 0;
  this.playhead = 0;

  var audio = /* new Audio();*/document.createElement("AUDIO");
  var self = this;

  this.loadSamples = function (event) {
    var buffer = DSP.getChannel(DSP.MIX, event.frameBuffer);
    for (var i = 0; i < buffer.length; i++) {
      self.samples.push(buffer[i]);
    }
  };

  this.loadComplete = function () {
    // convert flexible js array into a fast typed array
    self.samples = new Float32Array(self.samples);
    self.loaded = true;
  };

  this.loadMetaData = function () {
    self.duration = audio.duration;
  };

  audio.addEventListener("MozAudioAvailable", this.loadSamples, false);
  audio.addEventListener("loadedmetadata", this.loadMetaData, false);
  audio.addEventListener("ended", this.loadComplete, false);
  audio.muted = true;
  audio.src = file;
  audio.play();
}

Sampler.prototype.applyEnvelope = function () {
  this.envelope.process(this.signal);
  return this.signal;
};

Sampler.prototype.generate = function () {
  var frameOffset = this.frameCount * this.bufferSize;

  var loopWidth = this.playEnd * this.samples.length - this.playStart * this.samples.length;
  var playStartSamples = this.playStart * this.samples.length; // ie 0.5 -> 50% of the length
  var playEndSamples = this.playEnd * this.samples.length; // ie 0.5 -> 50% of the length
  var offset;

  for (var i = 0; i < this.bufferSize; i++) {
    switch (this.loopMode) {
      case DSP.OFF:
        this.playhead = Math.round(this.samplesProcessed * this.step + playStartSamples);
        if (this.playhead < this.playEnd * this.samples.length) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        } else {
          this.signal[i] = 0;
        }
        break;

      case DSP.FW:
        this.playhead = Math.round(this.samplesProcessed * this.step % loopWidth + playStartSamples);
        if (this.playhead < this.playEnd * this.samples.length) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;

      case DSP.BW:
        this.playhead = playEndSamples - Math.round(this.samplesProcessed * this.step % loopWidth);
        if (this.playhead < this.playEnd * this.samples.length) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;

      case DSP.FWBW:
        if (Math.floor(this.samplesProcessed * this.step / loopWidth) % 2 === 0) {
          this.playhead = Math.round(this.samplesProcessed * this.step % loopWidth + playStartSamples);
        } else {
          this.playhead = playEndSamples - Math.round(this.samplesProcessed * this.step % loopWidth);
        }
        if (this.playhead < this.playEnd * this.samples.length) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;
    }
    this.samplesProcessed++;
  }

  this.frameCount++;

  return this.signal;
};

Sampler.prototype.setFreq = function (frequency) {
  var totalProcessed = this.samplesProcessed * this.step;
  this.frequency = frequency;
  this.step = this.frequency / this.rootFrequency;
  this.samplesProcessed = Math.round(totalProcessed / this.step);
};

Sampler.prototype.reset = function () {
  this.samplesProcessed = 0;
  this.playhead = 0;
};

/**
 * Oscillator class for generating and modifying signals
 *
 * @param {Number} type       A waveform constant (eg. DSP.SINE)
 * @param {Number} frequency  Initial frequency of the signal
 * @param {Number} amplitude  Initial amplitude of the signal
 * @param {Number} bufferSize Size of the sample buffer to generate
 * @param {Number} sampleRate The sample rate of the signal
 *
 * @contructor
 */
function Oscillator(type, frequency, amplitude, bufferSize, sampleRate) {
  this.frequency = frequency;
  this.amplitude = amplitude;
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  //this.pulseWidth = pulseWidth;
  this.frameCount = 0;

  this.waveTableLength = 2048;

  this.cyclesPerSample = frequency / sampleRate;

  this.signal = new Float32Array(bufferSize);
  this.envelope = null;

  switch (parseInt(type, 10)) {
    case DSP.TRIANGLE:
      this.func = Oscillator.Triangle;
      break;

    case DSP.SAW:
      this.func = Oscillator.Saw;
      break;

    case DSP.SQUARE:
      this.func = Oscillator.Square;
      break;

    default:
    case DSP.SINE:
      this.func = Oscillator.Sine;
      break;
  }

  this.generateWaveTable = function () {
    Oscillator.waveTable[this.func] = new Float32Array(2048);
    var waveTableTime = this.waveTableLength / this.sampleRate;
    var waveTableHz = 1 / waveTableTime;

    for (var i = 0; i < this.waveTableLength; i++) {
      Oscillator.waveTable[this.func][i] = this.func(i * waveTableHz / this.sampleRate);
    }
  };

  if (typeof Oscillator.waveTable === 'undefined') {
    Oscillator.waveTable = {};
  }

  if (typeof Oscillator.waveTable[this.func] === 'undefined') {
    this.generateWaveTable();
  }

  this.waveTable = Oscillator.waveTable[this.func];
}

/**
 * Set the amplitude of the signal
 *
 * @param {Number} amplitude The amplitude of the signal (between 0 and 1)
 */
Oscillator.prototype.setAmp = function (amplitude) {
  if (amplitude >= 0 && amplitude <= 1) {
    this.amplitude = amplitude;
  } else {
    throw "Amplitude out of range (0..1).";
  }
};

/**
 * Set the frequency of the signal
 *
 * @param {Number} frequency The frequency of the signal
 */
Oscillator.prototype.setFreq = function (frequency) {
  this.frequency = frequency;
  this.cyclesPerSample = frequency / this.sampleRate;
};

// Add an oscillator
Oscillator.prototype.add = function (oscillator) {
  for (var i = 0; i < this.bufferSize; i++) {
    //this.signal[i] += oscillator.valueAt(i);
    this.signal[i] += oscillator.signal[i];
  }

  return this.signal;
};

// Add a signal to the current generated osc signal
Oscillator.prototype.addSignal = function (signal) {
  for (var i = 0; i < signal.length; i++) {
    if (i >= this.bufferSize) {
      break;
    }
    this.signal[i] += signal[i];

    /*
    // Constrain amplitude
    if ( this.signal[i] > 1 ) {
      this.signal[i] = 1;
    } else if ( this.signal[i] < -1 ) {
      this.signal[i] = -1;
    }
    */
  }
  return this.signal;
};

// Add an envelope to the oscillator
Oscillator.prototype.addEnvelope = function (envelope) {
  this.envelope = envelope;
};

Oscillator.prototype.applyEnvelope = function () {
  this.envelope.process(this.signal);
};

Oscillator.prototype.valueAt = function (offset) {
  return this.waveTable[offset % this.waveTableLength];
};

Oscillator.prototype.generate = function () {
  var frameOffset = this.frameCount * this.bufferSize;
  var step = this.waveTableLength * this.frequency / this.sampleRate;
  var offset;

  for (var i = 0; i < this.bufferSize; i++) {
    //var step = (frameOffset + i) * this.cyclesPerSample % 1;
    //this.signal[i] = this.func(step) * this.amplitude;
    //this.signal[i] = this.valueAt(Math.round((frameOffset + i) * step)) * this.amplitude;
    offset = Math.round((frameOffset + i) * step);
    this.signal[i] = this.waveTable[offset % this.waveTableLength] * this.amplitude;
  }

  this.frameCount++;

  return this.signal;
};

Oscillator.Sine = function (step) {
  return Math.sin(DSP.TWO_PI * step);
};

Oscillator.Square = function (step) {
  return step < 0.5 ? 1 : -1;
};

Oscillator.Saw = function (step) {
  return 2 * (step - Math.round(step));
};

Oscillator.Triangle = function (step) {
  return 1 - 4 * Math.abs(Math.round(step) - step);
};

Oscillator.Pulse = function (step) {
  // stub
};

function ADSR(attackLength, decayLength, sustainLevel, sustainLength, releaseLength, sampleRate) {
  this.sampleRate = sampleRate;
  // Length in seconds
  this.attackLength = attackLength;
  this.decayLength = decayLength;
  this.sustainLevel = sustainLevel;
  this.sustainLength = sustainLength;
  this.releaseLength = releaseLength;
  this.sampleRate = sampleRate;

  // Length in samples
  this.attackSamples = attackLength * sampleRate;
  this.decaySamples = decayLength * sampleRate;
  this.sustainSamples = sustainLength * sampleRate;
  this.releaseSamples = releaseLength * sampleRate;

  // Updates the envelope sample positions
  this.update = function () {
    this.attack = this.attackSamples;
    this.decay = this.attack + this.decaySamples;
    this.sustain = this.decay + this.sustainSamples;
    this.release = this.sustain + this.releaseSamples;
  };

  this.update();

  this.samplesProcessed = 0;
}

ADSR.prototype.noteOn = function () {
  this.samplesProcessed = 0;
  this.sustainSamples = this.sustainLength * this.sampleRate;
  this.update();
};

// Send a note off when using a sustain of infinity to let the envelope enter the release phase
ADSR.prototype.noteOff = function () {
  this.sustainSamples = this.samplesProcessed - this.decaySamples;
  this.update();
};

ADSR.prototype.processSample = function (sample) {
  var amplitude = 0;

  if (this.samplesProcessed <= this.attack) {
    amplitude = 0 + (1 - 0) * ((this.samplesProcessed - 0) / (this.attack - 0));
  } else if (this.samplesProcessed > this.attack && this.samplesProcessed <= this.decay) {
    amplitude = 1 + (this.sustainLevel - 1) * ((this.samplesProcessed - this.attack) / (this.decay - this.attack));
  } else if (this.samplesProcessed > this.decay && this.samplesProcessed <= this.sustain) {
    amplitude = this.sustainLevel;
  } else if (this.samplesProcessed > this.sustain && this.samplesProcessed <= this.release) {
    amplitude = this.sustainLevel + (0 - this.sustainLevel) * ((this.samplesProcessed - this.sustain) / (this.release - this.sustain));
  }

  return sample * amplitude;
};

ADSR.prototype.value = function () {
  var amplitude = 0;

  if (this.samplesProcessed <= this.attack) {
    amplitude = 0 + (1 - 0) * ((this.samplesProcessed - 0) / (this.attack - 0));
  } else if (this.samplesProcessed > this.attack && this.samplesProcessed <= this.decay) {
    amplitude = 1 + (this.sustainLevel - 1) * ((this.samplesProcessed - this.attack) / (this.decay - this.attack));
  } else if (this.samplesProcessed > this.decay && this.samplesProcessed <= this.sustain) {
    amplitude = this.sustainLevel;
  } else if (this.samplesProcessed > this.sustain && this.samplesProcessed <= this.release) {
    amplitude = this.sustainLevel + (0 - this.sustainLevel) * ((this.samplesProcessed - this.sustain) / (this.release - this.sustain));
  }

  return amplitude;
};

ADSR.prototype.process = function (buffer) {
  for (var i = 0; i < buffer.length; i++) {
    buffer[i] *= this.value();

    this.samplesProcessed++;
  }

  return buffer;
};

ADSR.prototype.isActive = function () {
  if (this.samplesProcessed > this.release || this.samplesProcessed === -1) {
    return false;
  } else {
    return true;
  }
};

ADSR.prototype.disable = function () {
  this.samplesProcessed = -1;
};

function IIRFilter(type, cutoff, resonance, sampleRate) {
  this.sampleRate = sampleRate;

  switch (type) {
    case DSP.LOWPASS:
    case DSP.LP12:
      this.func = new IIRFilter.LP12(cutoff, resonance, sampleRate);
      break;
  }
}

IIRFilter.prototype.__defineGetter__('cutoff', function () {
  return this.func.cutoff;
});

IIRFilter.prototype.__defineGetter__('resonance', function () {
  return this.func.resonance;
});

IIRFilter.prototype.set = function (cutoff, resonance) {
  this.func.calcCoeff(cutoff, resonance);
};

IIRFilter.prototype.process = function (buffer) {
  this.func.process(buffer);
};

// Add an envelope to the filter
IIRFilter.prototype.addEnvelope = function (envelope) {
  if (envelope instanceof ADSR) {
    this.func.addEnvelope(envelope);
  } else {
    throw "Not an envelope.";
  }
};

IIRFilter.LP12 = function (cutoff, resonance, sampleRate) {
  this.sampleRate = sampleRate;
  this.vibraPos = 0;
  this.vibraSpeed = 0;
  this.envelope = false;

  this.calcCoeff = function (cutoff, resonance) {
    this.w = 2.0 * Math.PI * cutoff / this.sampleRate;
    this.q = 1.0 - this.w / (2.0 * (resonance + 0.5 / (1.0 + this.w)) + this.w - 2.0);
    this.r = this.q * this.q;
    this.c = this.r + 1.0 - 2.0 * Math.cos(this.w) * this.q;

    this.cutoff = cutoff;
    this.resonance = resonance;
  };

  this.calcCoeff(cutoff, resonance);

  this.process = function (buffer) {
    for (var i = 0; i < buffer.length; i++) {
      this.vibraSpeed += (buffer[i] - this.vibraPos) * this.c;
      this.vibraPos += this.vibraSpeed;
      this.vibraSpeed *= this.r;

      /*
      var temp = this.vibraPos;
            if ( temp > 1.0 ) {
        temp = 1.0;
      } else if ( temp < -1.0 ) {
        temp = -1.0;
      } else if ( temp != temp ) {
        temp = 1;
      }
            buffer[i] = temp;
      */

      if (this.envelope) {
        buffer[i] = buffer[i] * (1 - this.envelope.value()) + this.vibraPos * this.envelope.value();
        this.envelope.samplesProcessed++;
      } else {
        buffer[i] = this.vibraPos;
      }
    }
  };
};

IIRFilter.LP12.prototype.addEnvelope = function (envelope) {
  this.envelope = envelope;
};

function IIRFilter2(type, cutoff, resonance, sampleRate) {
  this.type = type;
  this.cutoff = cutoff;
  this.resonance = resonance;
  this.sampleRate = sampleRate;

  this.f = Float32Array(4);
  this.f[0] = 0.0; // lp
  this.f[1] = 0.0; // hp
  this.f[2] = 0.0; // bp
  this.f[3] = 0.0; // br 

  this.calcCoeff = function (cutoff, resonance) {
    this.freq = 2 * Math.sin(Math.PI * Math.min(0.25, cutoff / (this.sampleRate * 2)));
    this.damp = Math.min(2 * (1 - Math.pow(resonance, 0.25)), Math.min(2, 2 / this.freq - this.freq * 0.5));
  };

  this.calcCoeff(cutoff, resonance);
}

IIRFilter2.prototype.process = function (buffer) {
  var input, output;
  var f = this.f;

  for (var i = 0; i < buffer.length; i++) {
    input = buffer[i];

    // first pass
    f[3] = input - this.damp * f[2];
    f[0] = f[0] + this.freq * f[2];
    f[1] = f[3] - f[0];
    f[2] = this.freq * f[1] + f[2];
    output = 0.5 * f[this.type];

    // second pass
    f[3] = input - this.damp * f[2];
    f[0] = f[0] + this.freq * f[2];
    f[1] = f[3] - f[0];
    f[2] = this.freq * f[1] + f[2];
    output += 0.5 * f[this.type];

    if (this.envelope) {
      buffer[i] = buffer[i] * (1 - this.envelope.value()) + output * this.envelope.value();
      this.envelope.samplesProcessed++;
    } else {
      buffer[i] = output;
    }
  }
};

IIRFilter2.prototype.addEnvelope = function (envelope) {
  if (envelope instanceof ADSR) {
    this.envelope = envelope;
  } else {
    throw "This is not an envelope.";
  }
};

IIRFilter2.prototype.set = function (cutoff, resonance) {
  this.calcCoeff(cutoff, resonance);
};

function WindowFunction(type, alpha) {
  this.alpha = alpha;

  switch (type) {
    case DSP.BARTLETT:
      this.func = WindowFunction.Bartlett;
      break;

    case DSP.BARTLETTHANN:
      this.func = WindowFunction.BartlettHann;
      break;

    case DSP.BLACKMAN:
      this.func = WindowFunction.Blackman;
      this.alpha = this.alpha || 0.16;
      break;

    case DSP.COSINE:
      this.func = WindowFunction.Cosine;
      break;

    case DSP.GAUSS:
      this.func = WindowFunction.Gauss;
      this.alpha = this.alpha || 0.25;
      break;

    case DSP.HAMMING:
      this.func = WindowFunction.Hamming;
      break;

    case DSP.HANN:
      this.func = WindowFunction.Hann;
      break;

    case DSP.LANCZOS:
      this.func = WindowFunction.Lanczoz;
      break;

    case DSP.RECTANGULAR:
      this.func = WindowFunction.Rectangular;
      break;

    case DSP.TRIANGULAR:
      this.func = WindowFunction.Triangular;
      break;
  }
}

WindowFunction.prototype.process = function (buffer) {
  var length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] *= this.func(length, i, this.alpha);
  }
  return buffer;
};

WindowFunction.Bartlett = function (length, index) {
  return 2 / (length - 1) * ((length - 1) / 2 - Math.abs(index - (length - 1) / 2));
};

WindowFunction.BartlettHann = function (length, index) {
  return 0.62 - 0.48 * Math.abs(index / (length - 1) - 0.5) - 0.38 * Math.cos(DSP.TWO_PI * index / (length - 1));
};

WindowFunction.Blackman = function (length, index, alpha) {
  var a0 = (1 - alpha) / 2;
  var a1 = 0.5;
  var a2 = alpha / 2;

  return a0 - a1 * Math.cos(DSP.TWO_PI * index / (length - 1)) + a2 * Math.cos(4 * Math.PI * index / (length - 1));
};

WindowFunction.Cosine = function (length, index) {
  return Math.cos(Math.PI * index / (length - 1) - Math.PI / 2);
};

WindowFunction.Gauss = function (length, index, alpha) {
  return Math.pow(Math.E, -0.5 * Math.pow((index - (length - 1) / 2) / (alpha * (length - 1) / 2), 2));
};

WindowFunction.Hamming = function (length, index) {
  return 0.54 - 0.46 * Math.cos(DSP.TWO_PI * index / (length - 1));
};

WindowFunction.Hann = function (length, index) {
  return 0.5 * (1 - Math.cos(DSP.TWO_PI * index / (length - 1)));
};

WindowFunction.Lanczos = function (length, index) {
  var x = 2 * index / (length - 1) - 1;
  return Math.sin(Math.PI * x) / (Math.PI * x);
};

WindowFunction.Rectangular = function (length, index) {
  return 1;
};

WindowFunction.Triangular = function (length, index) {
  return 2 / length * (length / 2 - Math.abs(index - (length - 1) / 2));
};

function sinh(arg) {
  // Returns the hyperbolic sine of the number, defined as (exp(number) - exp(-number))/2 
  //
  // version: 1004.2314
  // discuss at: http://phpjs.org/functions/sinh    // +   original by: Onno Marsman
  // *     example 1: sinh(-0.9834330348825909);
  // *     returns 1: -1.1497971402636502
  return (Math.exp(arg) - Math.exp(-arg)) / 2;
}

/* 
 *  Biquad filter
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 */
// Implementation based on:
// http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
function Biquad(type, sampleRate) {
  this.Fs = sampleRate;
  this.type = type; // type of the filter
  this.parameterType = DSP.Q; // type of the parameter

  this.x_1_l = 0;
  this.x_2_l = 0;
  this.y_1_l = 0;
  this.y_2_l = 0;

  this.x_1_r = 0;
  this.x_2_r = 0;
  this.y_1_r = 0;
  this.y_2_r = 0;

  this.b0 = 1;
  this.a0 = 1;

  this.b1 = 0;
  this.a1 = 0;

  this.b2 = 0;
  this.a2 = 0;

  this.b0a0 = this.b0 / this.a0;
  this.b1a0 = this.b1 / this.a0;
  this.b2a0 = this.b2 / this.a0;
  this.a1a0 = this.a1 / this.a0;
  this.a2a0 = this.a2 / this.a0;

  this.f0 = 3000; // "wherever it's happenin', man."  Center Frequency or
  // Corner Frequency, or shelf midpoint frequency, depending
  // on which filter type.  The "significant frequency".

  this.dBgain = 12; // used only for peaking and shelving filters

  this.Q = 1; // the EE kind of definition, except for peakingEQ in which A*Q is
  // the classic EE Q.  That adjustment in definition was made so that
  // a boost of N dB followed by a cut of N dB for identical Q and
  // f0/Fs results in a precisely flat unity gain filter or "wire".

  this.BW = -3; // the bandwidth in octaves (between -3 dB frequencies for BPF
  // and notch or between midpoint (dBgain/2) gain frequencies for
  // peaking EQ

  this.S = 1; // a "shelf slope" parameter (for shelving EQ only).  When S = 1,
  // the shelf slope is as steep as it can be and remain monotonically
  // increasing or decreasing gain with frequency.  The shelf slope, in
  // dB/octave, remains proportional to S for all other values for a
  // fixed f0/Fs and dBgain.

  this.coefficients = function () {
    var b = [this.b0, this.b1, this.b2];
    var a = [this.a0, this.a1, this.a2];
    return { b: b, a: a };
  };

  this.setFilterType = function (type) {
    this.type = type;
    this.recalculateCoefficients();
  };

  this.setSampleRate = function (rate) {
    this.Fs = rate;
    this.recalculateCoefficients();
  };

  this.setQ = function (q) {
    this.parameterType = DSP.Q;
    this.Q = Math.max(Math.min(q, 115.0), 0.001);
    this.recalculateCoefficients();
  };

  this.setBW = function (bw) {
    this.parameterType = DSP.BW;
    this.BW = bw;
    this.recalculateCoefficients();
  };

  this.setS = function (s) {
    this.parameterType = DSP.S;
    this.S = Math.max(Math.min(s, 5.0), 0.0001);
    this.recalculateCoefficients();
  };

  this.setF0 = function (freq) {
    this.f0 = freq;
    this.recalculateCoefficients();
  };

  this.setDbGain = function (g) {
    this.dBgain = g;
    this.recalculateCoefficients();
  };

  this.recalculateCoefficients = function () {
    var A;
    if (type === DSP.PEAKING_EQ || type === DSP.LOW_SHELF || type === DSP.HIGH_SHELF) {
      A = Math.pow(10, this.dBgain / 40); // for peaking and shelving EQ filters only
    } else {
      A = Math.sqrt(Math.pow(10, this.dBgain / 20));
    }

    var w0 = DSP.TWO_PI * this.f0 / this.Fs;

    var cosw0 = Math.cos(w0);
    var sinw0 = Math.sin(w0);

    var alpha = 0;

    switch (this.parameterType) {
      case DSP.Q:
        alpha = sinw0 / (2 * this.Q);
        break;

      case DSP.BW:
        alpha = sinw0 * sinh(Math.LN2 / 2 * this.BW * w0 / sinw0);
        break;

      case DSP.S:
        alpha = sinw0 / 2 * Math.sqrt((A + 1 / A) * (1 / this.S - 1) + 2);
        break;
    }

    /**
        FYI: The relationship between bandwidth and Q is
             1/Q = 2*sinh(ln(2)/2*BW*w0/sin(w0))     (digital filter w BLT)
        or   1/Q = 2*sinh(ln(2)/2*BW)             (analog filter prototype)
         The relationship between shelf slope and Q is
             1/Q = sqrt((A + 1/A)*(1/S - 1) + 2)
    */

    var coeff;

    switch (this.type) {
      case DSP.LPF:
        // H(s) = 1 / (s^2 + s/Q + 1)
        this.b0 = (1 - cosw0) / 2;
        this.b1 = 1 - cosw0;
        this.b2 = (1 - cosw0) / 2;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.HPF:
        // H(s) = s^2 / (s^2 + s/Q + 1)
        this.b0 = (1 + cosw0) / 2;
        this.b1 = -(1 + cosw0);
        this.b2 = (1 + cosw0) / 2;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.BPF_CONSTANT_SKIRT:
        // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
        this.b0 = sinw0 / 2;
        this.b1 = 0;
        this.b2 = -sinw0 / 2;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.BPF_CONSTANT_PEAK:
        // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
        this.b0 = alpha;
        this.b1 = 0;
        this.b2 = -alpha;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.NOTCH:
        // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
        this.b0 = 1;
        this.b1 = -2 * cosw0;
        this.b2 = 1;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.APF:
        // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
        this.b0 = 1 - alpha;
        this.b1 = -2 * cosw0;
        this.b2 = 1 + alpha;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.PEAKING_EQ:
        // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
        this.b0 = 1 + alpha * A;
        this.b1 = -2 * cosw0;
        this.b2 = 1 - alpha * A;
        this.a0 = 1 + alpha / A;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha / A;
        break;

      case DSP.LOW_SHELF:
        // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
        coeff = sinw0 * Math.sqrt((A ^ 2 + 1) * (1 / this.S - 1) + 2 * A);
        this.b0 = A * (A + 1 - (A - 1) * cosw0 + coeff);
        this.b1 = 2 * A * (A - 1 - (A + 1) * cosw0);
        this.b2 = A * (A + 1 - (A - 1) * cosw0 - coeff);
        this.a0 = A + 1 + (A - 1) * cosw0 + coeff;
        this.a1 = -2 * (A - 1 + (A + 1) * cosw0);
        this.a2 = A + 1 + (A - 1) * cosw0 - coeff;
        break;

      case DSP.HIGH_SHELF:
        // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)
        coeff = sinw0 * Math.sqrt((A ^ 2 + 1) * (1 / this.S - 1) + 2 * A);
        this.b0 = A * (A + 1 + (A - 1) * cosw0 + coeff);
        this.b1 = -2 * A * (A - 1 + (A + 1) * cosw0);
        this.b2 = A * (A + 1 + (A - 1) * cosw0 - coeff);
        this.a0 = A + 1 - (A - 1) * cosw0 + coeff;
        this.a1 = 2 * (A - 1 - (A + 1) * cosw0);
        this.a2 = A + 1 - (A - 1) * cosw0 - coeff;
        break;
    }

    this.b0a0 = this.b0 / this.a0;
    this.b1a0 = this.b1 / this.a0;
    this.b2a0 = this.b2 / this.a0;
    this.a1a0 = this.a1 / this.a0;
    this.a2a0 = this.a2 / this.a0;
  };

  this.process = function (buffer) {
    //y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
    //       - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]

    var len = buffer.length;
    var output = new Float32Array(len);

    for (var i = 0; i < buffer.length; i++) {
      output[i] = this.b0a0 * buffer[i] + this.b1a0 * this.x_1_l + this.b2a0 * this.x_2_l - this.a1a0 * this.y_1_l - this.a2a0 * this.y_2_l;
      this.y_2_l = this.y_1_l;
      this.y_1_l = output[i];
      this.x_2_l = this.x_1_l;
      this.x_1_l = buffer[i];
    }

    return output;
  };

  this.processStereo = function (buffer) {
    //y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
    //       - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]

    var len = buffer.length;
    var output = new Float32Array(len);

    for (var i = 0; i < len / 2; i++) {
      output[2 * i] = this.b0a0 * buffer[2 * i] + this.b1a0 * this.x_1_l + this.b2a0 * this.x_2_l - this.a1a0 * this.y_1_l - this.a2a0 * this.y_2_l;
      this.y_2_l = this.y_1_l;
      this.y_1_l = output[2 * i];
      this.x_2_l = this.x_1_l;
      this.x_1_l = buffer[2 * i];

      output[2 * i + 1] = this.b0a0 * buffer[2 * i + 1] + this.b1a0 * this.x_1_r + this.b2a0 * this.x_2_r - this.a1a0 * this.y_1_r - this.a2a0 * this.y_2_r;
      this.y_2_r = this.y_1_r;
      this.y_1_r = output[2 * i + 1];
      this.x_2_r = this.x_1_r;
      this.x_1_r = buffer[2 * i + 1];
    }

    return output;
  };
}

/* 
 *  Magnitude to decibels
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 *  @buffer array of magnitudes to convert to decibels
 *
 *  @returns the array in decibels
 *
 */
DSP.mag2db = function (buffer) {
  var minDb = -120;
  var minMag = Math.pow(10.0, minDb / 20.0);

  var log = Math.log;
  var max = Math.max;

  var result = Float32Array(buffer.length);
  for (var i = 0; i < buffer.length; i++) {
    result[i] = 20.0 * log(max(buffer[i], minMag));
  }

  return result;
};

/* 
 *  Frequency response
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 *  Calculates the frequency response at the given points.
 *
 *  @b b coefficients of the filter
 *  @a a coefficients of the filter
 *  @w w points (normally between -PI and PI) where to calculate the frequency response
 *
 *  @returns the frequency response in magnitude
 *
 */
DSP.freqz = function (b, a, w) {
  var i, j;

  if (!w) {
    w = Float32Array(200);
    for (i = 0; i < w.length; i++) {
      w[i] = DSP.TWO_PI / w.length * i - Math.PI;
    }
  }

  var result = Float32Array(w.length);

  var sqrt = Math.sqrt;
  var cos = Math.cos;
  var sin = Math.sin;

  for (i = 0; i < w.length; i++) {
    var numerator = { real: 0.0, imag: 0.0 };
    for (j = 0; j < b.length; j++) {
      numerator.real += b[j] * cos(-j * w[i]);
      numerator.imag += b[j] * sin(-j * w[i]);
    }

    var denominator = { real: 0.0, imag: 0.0 };
    for (j = 0; j < a.length; j++) {
      denominator.real += a[j] * cos(-j * w[i]);
      denominator.imag += a[j] * sin(-j * w[i]);
    }

    result[i] = sqrt(numerator.real * numerator.real + numerator.imag * numerator.imag) / sqrt(denominator.real * denominator.real + denominator.imag * denominator.imag);
  }

  return result;
};

/* 
 *  Graphical Equalizer
 *
 *  Implementation of a graphic equalizer with a configurable bands-per-octave
 *  and minimum and maximum frequencies
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 */
function GraphicalEq(sampleRate) {
  this.FS = sampleRate;
  this.minFreq = 40.0;
  this.maxFreq = 16000.0;

  this.bandsPerOctave = 1.0;

  this.filters = [];
  this.freqzs = [];

  this.calculateFreqzs = true;

  this.recalculateFilters = function () {
    var bandCount = Math.round(Math.log(this.maxFreq / this.minFreq) * this.bandsPerOctave / Math.LN2);

    this.filters = [];
    for (var i = 0; i < bandCount; i++) {
      var freq = this.minFreq * Math.pow(2, i / this.bandsPerOctave);
      var newFilter = new Biquad(DSP.PEAKING_EQ, this.FS);
      newFilter.setDbGain(0);
      newFilter.setBW(1 / this.bandsPerOctave);
      newFilter.setF0(freq);
      this.filters[i] = newFilter;
      this.recalculateFreqz(i);
    }
  };

  this.setMinimumFrequency = function (freq) {
    this.minFreq = freq;
    this.recalculateFilters();
  };

  this.setMaximumFrequency = function (freq) {
    this.maxFreq = freq;
    this.recalculateFilters();
  };

  this.setBandsPerOctave = function (bands) {
    this.bandsPerOctave = bands;
    this.recalculateFilters();
  };

  this.setBandGain = function (bandIndex, gain) {
    if (bandIndex < 0 || bandIndex > this.filters.length - 1) {
      throw "The band index of the graphical equalizer is out of bounds.";
    }

    if (!gain) {
      throw "A gain must be passed.";
    }

    this.filters[bandIndex].setDbGain(gain);
    this.recalculateFreqz(bandIndex);
  };

  this.recalculateFreqz = function (bandIndex) {
    if (!this.calculateFreqzs) {
      return;
    }

    if (bandIndex < 0 || bandIndex > this.filters.length - 1) {
      throw "The band index of the graphical equalizer is out of bounds. " + bandIndex + " is out of [" + 0 + ", " + this.filters.length - 1 + "]";
    }

    if (!this.w) {
      this.w = Float32Array(400);
      for (var i = 0; i < this.w.length; i++) {
        this.w[i] = Math.PI / this.w.length * i;
      }
    }

    var b = [this.filters[bandIndex].b0, this.filters[bandIndex].b1, this.filters[bandIndex].b2];
    var a = [this.filters[bandIndex].a0, this.filters[bandIndex].a1, this.filters[bandIndex].a2];

    this.freqzs[bandIndex] = DSP.mag2db(DSP.freqz(b, a, this.w));
  };

  this.process = function (buffer) {
    var output = buffer;

    for (var i = 0; i < this.filters.length; i++) {
      output = this.filters[i].process(output);
    }

    return output;
  };

  this.processStereo = function (buffer) {
    var output = buffer;

    for (var i = 0; i < this.filters.length; i++) {
      output = this.filters[i].processStereo(output);
    }

    return output;
  };
}

/**
 * MultiDelay effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: http://code.almeros.com/code-examples/delay-firefox-audio-api/
 *
 * This is a delay that feeds it's own delayed signal back into its circular
 * buffer. Also known as a CombFilter.
 *
 * Compatible with interleaved stereo (or more channel) buffers and
 * non-interleaved mono buffers.
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffer)
 * @param {Number} delayInSamples Initial delay in samples
 * @param {Number} masterVolume Initial master volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} delayVolume Initial feedback delay volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 *
 * @constructor
 */
function MultiDelay(maxDelayInSamplesSize, delayInSamples, masterVolume, delayVolume) {
  this.delayBufferSamples = new Float32Array(maxDelayInSamplesSize); // The maximum size of delay
  this.delayInputPointer = delayInSamples;
  this.delayOutputPointer = 0;

  this.delayInSamples = delayInSamples;
  this.masterVolume = masterVolume;
  this.delayVolume = delayVolume;
}

/**
 * Change the delay time in samples.
 *
 * @param {Number} delayInSamples Delay in samples
 */
MultiDelay.prototype.setDelayInSamples = function (delayInSamples) {
  this.delayInSamples = delayInSamples;

  this.delayInputPointer = this.delayOutputPointer + delayInSamples;

  if (this.delayInputPointer >= this.delayBufferSamples.length - 1) {
    this.delayInputPointer = this.delayInputPointer - this.delayBufferSamples.length;
  }
};

/**
 * Change the master volume.
 *
 * @param {Number} masterVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
MultiDelay.prototype.setMasterVolume = function (masterVolume) {
  this.masterVolume = masterVolume;
};

/**
 * Change the delay feedback volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
MultiDelay.prototype.setDelayVolume = function (delayVolume) {
  this.delayVolume = delayVolume;
};

/**
 * Process a given interleaved or mono non-interleaved float value Array and adds the delayed audio.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved or mono non-interleaved as was fed to this function.
 */
MultiDelay.prototype.process = function (samples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(samples.length);

  for (var i = 0; i < samples.length; i++) {
    // delayBufferSamples could contain initial NULL's, return silence in that case
    var delaySample = this.delayBufferSamples[this.delayOutputPointer] === null ? 0.0 : this.delayBufferSamples[this.delayOutputPointer];

    // Mix normal audio data with delayed audio
    var sample = delaySample * this.delayVolume + samples[i];

    // Add audio data with the delay in the delay buffer
    this.delayBufferSamples[this.delayInputPointer] = sample;

    // Return the audio with delay mix
    outputSamples[i] = sample * this.masterVolume;

    // Manage circulair delay buffer pointers
    this.delayInputPointer++;
    if (this.delayInputPointer >= this.delayBufferSamples.length - 1) {
      this.delayInputPointer = 0;
    }

    this.delayOutputPointer++;
    if (this.delayOutputPointer >= this.delayBufferSamples.length - 1) {
      this.delayOutputPointer = 0;
    }
  }

  return outputSamples;
};

/**
 * SingleDelay effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: See usage in Reverb class
 *
 * This is a delay that does NOT feeds it's own delayed signal back into its 
 * circular buffer, neither does it return the original signal. Also known as
 * an AllPassFilter(?).
 *
 * Compatible with interleaved stereo (or more channel) buffers and
 * non-interleaved mono buffers.
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffer)
 * @param {Number} delayInSamples Initial delay in samples
 * @param {Number} delayVolume Initial feedback delay volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 *
 * @constructor
 */

function SingleDelay(maxDelayInSamplesSize, delayInSamples, delayVolume) {
  this.delayBufferSamples = new Float32Array(maxDelayInSamplesSize); // The maximum size of delay
  this.delayInputPointer = delayInSamples;
  this.delayOutputPointer = 0;

  this.delayInSamples = delayInSamples;
  this.delayVolume = delayVolume;
}

/**
 * Change the delay time in samples.
 *
 * @param {Number} delayInSamples Delay in samples
 */
SingleDelay.prototype.setDelayInSamples = function (delayInSamples) {
  this.delayInSamples = delayInSamples;
  this.delayInputPointer = this.delayOutputPointer + delayInSamples;

  if (this.delayInputPointer >= this.delayBufferSamples.length - 1) {
    this.delayInputPointer = this.delayInputPointer - this.delayBufferSamples.length;
  }
};

/**
 * Change the return signal volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
SingleDelay.prototype.setDelayVolume = function (delayVolume) {
  this.delayVolume = delayVolume;
};

/**
 * Process a given interleaved or mono non-interleaved float value Array and
 * returns the delayed audio.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved or mono non-interleaved as was fed to this function.
 */
SingleDelay.prototype.process = function (samples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(samples.length);

  for (var i = 0; i < samples.length; i++) {

    // Add audio data with the delay in the delay buffer
    this.delayBufferSamples[this.delayInputPointer] = samples[i];

    // delayBufferSamples could contain initial NULL's, return silence in that case
    var delaySample = this.delayBufferSamples[this.delayOutputPointer];

    // Return the audio with delay mix
    outputSamples[i] = delaySample * this.delayVolume;

    // Manage circulair delay buffer pointers
    this.delayInputPointer++;

    if (this.delayInputPointer >= this.delayBufferSamples.length - 1) {
      this.delayInputPointer = 0;
    }

    this.delayOutputPointer++;

    if (this.delayOutputPointer >= this.delayBufferSamples.length - 1) {
      this.delayOutputPointer = 0;
    }
  }

  return outputSamples;
};

/**
 * Reverb effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: http://code.almeros.com/code-examples/reverb-firefox-audio-api/
 *
 * This reverb consists of 6 SingleDelays, 6 MultiDelays and an IIRFilter2
 * for each of the two stereo channels.
 *
 * Compatible with interleaved stereo buffers only!
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffers)
 * @param {Number} delayInSamples Initial delay in samples for internal (Single/Multi)delays
 * @param {Number} masterVolume Initial master volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} mixVolume Initial reverb signal mix volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} delayVolume Initial feedback delay volume for internal (Single/Multi)delays. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} dampFrequency Initial low pass filter frequency. 0 to 44100 (depending on your maximum sampling frequency)
 *
 * @constructor
 */
function Reverb(maxDelayInSamplesSize, delayInSamples, masterVolume, mixVolume, delayVolume, dampFrequency) {
  this.delayInSamples = delayInSamples;
  this.masterVolume = masterVolume;
  this.mixVolume = mixVolume;
  this.delayVolume = delayVolume;
  this.dampFrequency = dampFrequency;

  this.NR_OF_MULTIDELAYS = 6;
  this.NR_OF_SINGLEDELAYS = 6;

  this.LOWPASSL = new IIRFilter2(DSP.LOWPASS, dampFrequency, 0, 44100);
  this.LOWPASSR = new IIRFilter2(DSP.LOWPASS, dampFrequency, 0, 44100);

  this.singleDelays = [];

  var i, delayMultiply;

  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    delayMultiply = 1.0 + i / 7.0; // 1.0, 1.1, 1.2...
    this.singleDelays[i] = new SingleDelay(maxDelayInSamplesSize, Math.round(this.delayInSamples * delayMultiply), this.delayVolume);
  }

  this.multiDelays = [];

  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    delayMultiply = 1.0 + i / 10.0; // 1.0, 1.1, 1.2... 
    this.multiDelays[i] = new MultiDelay(maxDelayInSamplesSize, Math.round(this.delayInSamples * delayMultiply), this.masterVolume, this.delayVolume);
  }
}

/**
 * Change the delay time in samples as a base for all delays.
 *
 * @param {Number} delayInSamples Delay in samples
 */
Reverb.prototype.setDelayInSamples = function (delayInSamples) {
  this.delayInSamples = delayInSamples;

  var i, delayMultiply;

  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    delayMultiply = 1.0 + i / 7.0; // 1.0, 1.1, 1.2...
    this.singleDelays[i].setDelayInSamples(Math.round(this.delayInSamples * delayMultiply));
  }

  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    delayMultiply = 1.0 + i / 10.0; // 1.0, 1.1, 1.2...
    this.multiDelays[i].setDelayInSamples(Math.round(this.delayInSamples * delayMultiply));
  }
};

/**
 * Change the master volume.
 *
 * @param {Number} masterVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setMasterVolume = function (masterVolume) {
  this.masterVolume = masterVolume;
};

/**
 * Change the reverb signal mix level.
 *
 * @param {Number} mixVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setMixVolume = function (mixVolume) {
  this.mixVolume = mixVolume;
};

/**
 * Change all delays feedback volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setDelayVolume = function (delayVolume) {
  this.delayVolume = delayVolume;

  var i;

  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    this.singleDelays[i].setDelayVolume(this.delayVolume);
  }

  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    this.multiDelays[i].setDelayVolume(this.delayVolume);
  }
};

/**
 * Change the Low Pass filter frequency.
 *
 * @param {Number} dampFrequency low pass filter frequency. 0 to 44100 (depending on your maximum sampling frequency)
 */
Reverb.prototype.setDampFrequency = function (dampFrequency) {
  this.dampFrequency = dampFrequency;

  this.LOWPASSL.set(dampFrequency, 0);
  this.LOWPASSR.set(dampFrequency, 0);
};

/**
 * Process a given interleaved float value Array and copies and adds the reverb signal.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved buffer.
 */
Reverb.prototype.process = function (interleavedSamples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(interleavedSamples.length);

  // Perform low pass on the input samples to mimick damp
  var leftRightMix = DSP.deinterleave(interleavedSamples);
  this.LOWPASSL.process(leftRightMix[DSP.LEFT]);
  this.LOWPASSR.process(leftRightMix[DSP.RIGHT]);
  var filteredSamples = DSP.interleave(leftRightMix[DSP.LEFT], leftRightMix[DSP.RIGHT]);

  var i;

  // Process MultiDelays in parallel
  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    // Invert the signal of every even multiDelay
    outputSamples = DSP.mixSampleBuffers(outputSamples, this.multiDelays[i].process(filteredSamples), 2 % i === 0, this.NR_OF_MULTIDELAYS);
  }

  // Process SingleDelays in series
  var singleDelaySamples = new Float32Array(outputSamples.length);
  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    // Invert the signal of every even singleDelay
    singleDelaySamples = DSP.mixSampleBuffers(singleDelaySamples, this.singleDelays[i].process(outputSamples), 2 % i === 0, 1);
  }

  // Apply the volume of the reverb signal
  for (i = 0; i < singleDelaySamples.length; i++) {
    singleDelaySamples[i] *= this.mixVolume;
  }

  // Mix the original signal with the reverb signal
  outputSamples = DSP.mixSampleBuffers(singleDelaySamples, interleavedSamples, 0, 1);

  // Apply the master volume to the complete signal
  for (i = 0; i < outputSamples.length; i++) {
    outputSamples[i] *= this.masterVolume;
  }

  return outputSamples;
};

exports.default = DSP;
exports.FFT = FFT;

},{"babel-runtime/helpers/typeof":38}],22:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":39}],23:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":40}],24:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-properties"), __esModule: true };
},{"core-js/library/fn/object/define-properties":41}],25:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":42}],26:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":43}],27:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/get-prototype-of":44}],28:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":45}],29:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":46}],30:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":47}],31:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":48}],32:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/weak-map"), __esModule: true };
},{"core-js/library/fn/weak-map":49}],33:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],34:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
},{"../core-js/object/define-property":25}],35:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getPrototypeOf = require("../core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _getOwnPropertyDescriptor = require("../core-js/object/get-own-property-descriptor");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);

  if (desc === undefined) {
    var parent = (0, _getPrototypeOf2.default)(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};
},{"../core-js/object/get-own-property-descriptor":26,"../core-js/object/get-prototype-of":27}],36:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _setPrototypeOf = require("../core-js/object/set-prototype-of");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = require("../core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
},{"../core-js/object/create":23,"../core-js/object/set-prototype-of":28,"../helpers/typeof":38}],37:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};
},{"../helpers/typeof":38}],38:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":30,"../core-js/symbol/iterator":31}],39:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');

},{"../modules/core.get-iterator":127,"../modules/es6.string.iterator":137,"../modules/web.dom.iterable":147}],40:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};

},{"../../modules/_core":65,"../../modules/es6.object.create":129}],41:[function(require,module,exports){
require('../../modules/es6.object.define-properties');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperties(T, D) {
  return $Object.defineProperties(T, D);
};

},{"../../modules/_core":65,"../../modules/es6.object.define-properties":130}],42:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

},{"../../modules/_core":65,"../../modules/es6.object.define-property":131}],43:[function(require,module,exports){
require('../../modules/es6.object.get-own-property-descriptor');
var $Object = require('../../modules/_core').Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};

},{"../../modules/_core":65,"../../modules/es6.object.get-own-property-descriptor":132}],44:[function(require,module,exports){
require('../../modules/es6.object.get-prototype-of');
module.exports = require('../../modules/_core').Object.getPrototypeOf;

},{"../../modules/_core":65,"../../modules/es6.object.get-prototype-of":133}],45:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/_core').Object.setPrototypeOf;

},{"../../modules/_core":65,"../../modules/es6.object.set-prototype-of":134}],46:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
require('../modules/es7.set.of');
require('../modules/es7.set.from');
module.exports = require('../modules/_core').Set;

},{"../modules/_core":65,"../modules/es6.object.to-string":135,"../modules/es6.set":136,"../modules/es6.string.iterator":137,"../modules/es7.set.from":140,"../modules/es7.set.of":141,"../modules/es7.set.to-json":142,"../modules/web.dom.iterable":147}],47:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":65,"../../modules/es6.object.to-string":135,"../../modules/es6.symbol":138,"../../modules/es7.symbol.async-iterator":143,"../../modules/es7.symbol.observable":144}],48:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":124,"../../modules/es6.string.iterator":137,"../../modules/web.dom.iterable":147}],49:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/web.dom.iterable');
require('../modules/es6.weak-map');
require('../modules/es7.weak-map.of');
require('../modules/es7.weak-map.from');
module.exports = require('../modules/_core').WeakMap;

},{"../modules/_core":65,"../modules/es6.object.to-string":135,"../modules/es6.weak-map":139,"../modules/es7.weak-map.from":145,"../modules/es7.weak-map.of":146,"../modules/web.dom.iterable":147}],50:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],51:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],52:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],53:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":83}],54:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":74}],55:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":115,"./_to-iobject":117,"./_to-length":118}],56:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":58,"./_ctx":66,"./_iobject":80,"./_to-length":118,"./_to-object":119}],57:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":82,"./_is-object":83,"./_wks":125}],58:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":57}],59:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":60,"./_wks":125}],60:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],61:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":52,"./_ctx":66,"./_descriptors":68,"./_for-of":74,"./_iter-define":86,"./_iter-step":87,"./_meta":90,"./_object-create":92,"./_object-dp":93,"./_redefine-all":105,"./_set-species":110,"./_validate-collection":122}],62:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":54,"./_classof":59}],63:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":52,"./_an-object":53,"./_array-methods":56,"./_for-of":74,"./_has":76,"./_is-object":83,"./_meta":90,"./_redefine-all":105,"./_validate-collection":122}],64:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var meta = require('./_meta');
var fails = require('./_fails');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var setToStringTag = require('./_set-to-string-tag');
var dP = require('./_object-dp').f;
var each = require('./_array-methods')(0);
var DESCRIPTORS = require('./_descriptors');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":52,"./_array-methods":56,"./_descriptors":68,"./_export":72,"./_fails":73,"./_for-of":74,"./_global":75,"./_hide":77,"./_is-object":83,"./_meta":90,"./_object-dp":93,"./_redefine-all":105,"./_set-to-string-tag":111}],65:[function(require,module,exports){
var core = module.exports = { version: '2.5.4' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],66:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":50}],67:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],68:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":73}],69:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":75,"./_is-object":83}],70:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],71:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":98,"./_object-keys":101,"./_object-pie":102}],72:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":65,"./_ctx":66,"./_global":75,"./_has":76,"./_hide":77}],73:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],74:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":53,"./_ctx":66,"./_is-array-iter":81,"./_iter-call":84,"./_to-length":118,"./core.get-iterator-method":126}],75:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],76:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],77:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":68,"./_object-dp":93,"./_property-desc":104}],78:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":75}],79:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":68,"./_dom-create":69,"./_fails":73}],80:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":60}],81:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":88,"./_wks":125}],82:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":60}],83:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],84:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":53}],85:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":77,"./_object-create":92,"./_property-desc":104,"./_set-to-string-tag":111,"./_wks":125}],86:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":72,"./_hide":77,"./_iter-create":85,"./_iterators":88,"./_library":89,"./_object-gpo":99,"./_redefine":106,"./_set-to-string-tag":111,"./_wks":125}],87:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],88:[function(require,module,exports){
module.exports = {};

},{}],89:[function(require,module,exports){
module.exports = true;

},{}],90:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":73,"./_has":76,"./_is-object":83,"./_object-dp":93,"./_uid":121}],91:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":73,"./_iobject":80,"./_object-gops":98,"./_object-keys":101,"./_object-pie":102,"./_to-object":119}],92:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":53,"./_dom-create":69,"./_enum-bug-keys":70,"./_html":78,"./_object-dps":94,"./_shared-key":112}],93:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":53,"./_descriptors":68,"./_ie8-dom-define":79,"./_to-primitive":120}],94:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":53,"./_descriptors":68,"./_object-dp":93,"./_object-keys":101}],95:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":68,"./_has":76,"./_ie8-dom-define":79,"./_object-pie":102,"./_property-desc":104,"./_to-iobject":117,"./_to-primitive":120}],96:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":97,"./_to-iobject":117}],97:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":70,"./_object-keys-internal":100}],98:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],99:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":76,"./_shared-key":112,"./_to-object":119}],100:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":55,"./_has":76,"./_shared-key":112,"./_to-iobject":117}],101:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":70,"./_object-keys-internal":100}],102:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],103:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":65,"./_export":72,"./_fails":73}],104:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],105:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};

},{"./_hide":77}],106:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":77}],107:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":50,"./_ctx":66,"./_export":72,"./_for-of":74}],108:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":72}],109:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":53,"./_ctx":66,"./_is-object":83,"./_object-gopd":95}],110:[function(require,module,exports){
'use strict';
var global = require('./_global');
var core = require('./_core');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_core":65,"./_descriptors":68,"./_global":75,"./_object-dp":93,"./_wks":125}],111:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":76,"./_object-dp":93,"./_wks":125}],112:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":113,"./_uid":121}],113:[function(require,module,exports){
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":75}],114:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":67,"./_to-integer":116}],115:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":116}],116:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],117:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":67,"./_iobject":80}],118:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":116}],119:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":67}],120:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":83}],121:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],122:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":83}],123:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":65,"./_global":75,"./_library":89,"./_object-dp":93,"./_wks-ext":124}],124:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":125}],125:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":75,"./_shared":113,"./_uid":121}],126:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":59,"./_core":65,"./_iterators":88,"./_wks":125}],127:[function(require,module,exports){
var anObject = require('./_an-object');
var get = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

},{"./_an-object":53,"./_core":65,"./core.get-iterator-method":126}],128:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":51,"./_iter-define":86,"./_iter-step":87,"./_iterators":88,"./_to-iobject":117}],129:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":72,"./_object-create":92}],130:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":68,"./_export":72,"./_object-dps":94}],131:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":68,"./_export":72,"./_object-dp":93}],132:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":95,"./_object-sap":103,"./_to-iobject":117}],133:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":99,"./_object-sap":103,"./_to-object":119}],134:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":72,"./_set-proto":109}],135:[function(require,module,exports){

},{}],136:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":64,"./_collection-strong":61,"./_validate-collection":122}],137:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":86,"./_string-at":114}],138:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":53,"./_descriptors":68,"./_enum-keys":71,"./_export":72,"./_fails":73,"./_global":75,"./_has":76,"./_hide":77,"./_is-array":82,"./_is-object":83,"./_library":89,"./_meta":90,"./_object-create":92,"./_object-dp":93,"./_object-gopd":95,"./_object-gopn":97,"./_object-gopn-ext":96,"./_object-gops":98,"./_object-keys":101,"./_object-pie":102,"./_property-desc":104,"./_redefine":106,"./_set-to-string-tag":111,"./_shared":113,"./_to-iobject":117,"./_to-primitive":120,"./_uid":121,"./_wks":125,"./_wks-define":123,"./_wks-ext":124}],139:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":56,"./_collection":64,"./_collection-weak":63,"./_fails":73,"./_is-object":83,"./_meta":90,"./_object-assign":91,"./_redefine":106,"./_validate-collection":122}],140:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":107}],141:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":108}],142:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":62,"./_export":72}],143:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":123}],144:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":123}],145:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":107}],146:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":108}],147:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":75,"./_hide":77,"./_iterators":88,"./_wks":125,"./es6.array.iterator":128}],148:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":149,"_process":151}],149:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":150}],150:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],151:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[12])(12)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2NvcmUvYXVkaW8tY29udGV4dC5qcyIsImRpc3QvY29yZS9hdWRpby10aW1lLWVuZ2luZS5qcyIsImRpc3QvY29yZS9wcmlvcml0eS1xdWV1ZS5qcyIsImRpc3QvY29yZS9zY2hlZHVsaW5nLXF1ZXVlLmpzIiwiZGlzdC9jb3JlL3RpbWUtZW5naW5lLmpzIiwiZGlzdC9lbmdpbmVzL2dyYW51bGFyLWVuZ2luZS5qcyIsImRpc3QvZW5naW5lcy9tZXRyb25vbWUuanMiLCJkaXN0L2VuZ2luZXMvcGhhc2V2b2NvZGVyLWVuZ2luZS5qcyIsImRpc3QvZW5naW5lcy9wbGF5ZXItZW5naW5lLmpzIiwiZGlzdC9lbmdpbmVzL3NlZ21lbnQtZW5naW5lLmpzIiwiZGlzdC9lbmdpbmVzL3NlcXVlbmNlci1lbmdpbmUuanMiLCJkaXN0L2luZGV4LmpzIiwiZGlzdC9tYXN0ZXJzL2ZhY3Rvcmllcy5qcyIsImRpc3QvbWFzdGVycy9wbGF5LWNvbnRyb2wuanMiLCJkaXN0L21hc3RlcnMvc2NoZWR1bGVyLmpzIiwiZGlzdC9tYXN0ZXJzL3NpbXBsZS1zY2hlZHVsZXIuanMiLCJkaXN0L21hc3RlcnMvdHJhbnNwb3J0LmpzIiwiZGlzdC91dGlscy9QVl9mYXN0XzUuanMiLCJkaXN0L3V0aWxzL2J1ZmZlcmVkLXB2LmpzIiwiZGlzdC91dGlscy9jYnVmZmVyLmpzIiwiZGlzdC91dGlscy9kc3AuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3dlYWstbWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vd2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXktaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1jYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS1hbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1mcm9tLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtY29sbGVjdGlvbi1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtc3BlY2llcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc3RyaW5nLWF0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdWlkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL192YWxpZGF0ZS1jb2xsZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnNldC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LndlYWstbWFwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0Lm9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zZXQudG8tanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcud2Vhay1tYXAuZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcud2Vhay1tYXAub2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvZGVidWcuanMiLCJub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUNBQSxJQUFNLGVBQWUsT0FBTyxZQUFQLElBQXVCLE9BQU8sa0JBQW5EOztBQUVBOzs7Ozs7Ozs7Ozs7Ozs7QUFlQSxJQUFJLGVBQWUsSUFBbkI7O0FBRUEsSUFBSSxZQUFKLEVBQWtCO0FBQ2hCLGlCQUFlLElBQUksWUFBSixFQUFmOztBQUVBLE1BQUksaUJBQWlCLElBQWpCLENBQXNCLFVBQVUsU0FBaEMsS0FBOEMsYUFBYSxV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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9cmV0dXJuIGV9KSgpIiwiY29uc3QgQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xyXG5cclxuLyoqXHJcbiAqIEV4cG9zZSBhIHVuaXF1ZSBhdWRpbyBjb250ZXh0IHNpbmdsZXRvbiBhcyB0aGUgZGVmYXVsdCBhdWRpb1xyXG4gKiBjb250ZXh0IHVzZWQgYnkgdGhlIGNvbXBvbmVudHMgb2YgdGhlIFdhdmVzIEF1ZGlvIGxpYnJhcnkgYW5kXHJcbiAqIGFwcGxpY2F0aW9ucyB1c2luZyB0aGUgbGlicmFyeS5cclxuICpcclxuICogQHR5cGUgQXVkaW9Db250ZXh0XHJcbiAqIEBuYW1lIGF1ZGlvQ29udGV4dFxyXG4gKiBAY29uc3RhbnRcclxuICogQGdsb2JhbFxyXG4gKiBAaW5zdGFuY2VcclxuICpcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0ICogYXMgYXVkaW8gZnJvbSAnd2F2ZXMtYXVkaW8nO1xyXG4gKiBjb25zdCBhdWRpb0NvbnRleHQgPSBhdWRpby5hdWRpb0NvbnRleHQ7XHJcbiAqL1xyXG5sZXQgYXVkaW9Db250ZXh0ID0gbnVsbDtcclxuXHJcbmlmIChBdWRpb0NvbnRleHQpIHtcclxuICBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XHJcblxyXG4gIGlmICgvKGlQaG9uZXxpUGFkKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgPCA0NDEwMCkge1xyXG4gICAgY29uc3QgYnVmZmVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCA0NDEwMCk7XHJcbiAgICBjb25zdCBkdW1teSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgIGR1bW15LmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgIGR1bW15LmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcclxuICAgIGR1bW15LnN0YXJ0KDApO1xyXG4gICAgZHVtbXkuZGlzY29ubmVjdCgpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXVkaW9Db250ZXh0O1xyXG4iLCJpbXBvcnQgVGltZUVuZ2luZSBmcm9tICcuL3RpbWUtZW5naW5lJztcclxuaW1wb3J0IGRlZmF1bHRBdWRpb0NvbnRleHQgZnJvbSAnLi9hdWRpby1jb250ZXh0JztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgYXVkaW8gcmVsYXRlZCB0aW1lIGVuZ2luZSBjb21wb25lbnRzLiBJdCBpc1xyXG4gKiB1c2VkIHRvIGhhbmRsZSBhdWRpbyByZWxhdGVkIGV2ZW50cyBzdWNoIGFzIHRoZSBwbGF5YmFjayBvZiBhIG1lZGlhIHN0cmVhbS5cclxuICogSXQgZXh0ZW5kcyB0aGUgVGltZUVuZ2luZSBjbGFzcyBieSB0aGUgc3RhbmRhcmQgd2ViIGF1ZGlvIG5vZGUgbWV0aG9kc1xyXG4gKiBjb25uZWN0IGFuZCBkaXNjb25uZWN0LlxyXG4gKlxyXG4gKiBbZXhhbXBsZV17QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL2F1ZGlvLXRpbWUtZW5naW5lLmh0bWx9XHJcbiAqXHJcbiAqIEBleHRlbmRzIFRpbWVFbmdpbmVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICpcclxuICogY2xhc3MgTXlFbmdpbmUgZXh0ZW5kcyBhdWRpby5BdWRpb1RpbWVFbmdpbmUge1xyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICAgc3VwZXIoKTtcclxuICogICAgIC8vIC4uLlxyXG4gKiAgIH1cclxuICogfVxyXG4gKi9cclxuY2xhc3MgQXVkaW9UaW1lRW5naW5lIGV4dGVuZHMgVGltZUVuZ2luZSB7XHJcbiAgY29uc3RydWN0b3IoYXVkaW9Db250ZXh0ID0gZGVmYXVsdEF1ZGlvQ29udGV4dCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1ZGlvIGNvbnRleHQgdXNlZCBieSB0aGUgVGltZUVuZ2luZSwgZGVmYXVsdCB0byB0aGUgZ2xvYmFsIGF1ZGlvQ29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBuYW1lIGF1ZGlvQ29udGV4dFxyXG4gICAgICogQHR5cGUgQXVkaW9Db250ZXh0XHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UaW1lRW5naW5lXHJcbiAgICAgKiBAc2VlIGF1ZGlvQ29udGV4dFxyXG4gICAgICovXHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE91dHB1dCBhdWRpbyBub2RlLiBCeSBkZWZhdWx0IHRoZSBjb25uZWN0IG1ldGhvZCBjb25uZWN0cyBhIGdpdmVuIG5vZGVcclxuICAgICAqIHRvIHRoaXMgb3V0cHV0IG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgb3V0cHV0Tm9kZVxyXG4gICAgICogQHR5cGUgQXVkaW9Ob2RlXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UaW1lRW5naW5lXHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKi9cclxuICAgIHRoaXMub3V0cHV0Tm9kZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25uZWN0IHRvIGFuIGF1ZGlvIG5vZGUgKGUuZy4gYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBdWRpb05vZGV9IHRhcmdldCAtIFRhcmdldCBhdWRpbyBub2RlXHJcbiAgICovXHJcbiAgY29ubmVjdCh0YXJnZXQpIHtcclxuICAgIHRoaXMub3V0cHV0Tm9kZS5jb25uZWN0KHRhcmdldCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc2Nvbm5lY3QgZnJvbSBhbiBhdWRpbyBub2RlIChlLmcuIGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbikuIElmIHVuZGVmaW5lZFxyXG4gICAqIGRpc2Nvbm5lY3QgZnJvbSBhbGwgdGFyZ2V0IG5vZGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBdWRpb05vZGV9IHRhcmdldCAtIFRhcmdldCBhdWRpbyBub2RlLlxyXG4gICAqL1xyXG4gIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xyXG4gICAgdGhpcy5vdXRwdXROb2RlLmRpc2Nvbm5lY3QoY29ubmVjdGlvbik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEF1ZGlvVGltZUVuZ2luZTtcclxuIiwiLy8gd29ya3MgYnkgcmVmZXJlbmNlXHJcbmZ1bmN0aW9uIHN3YXAoYXJyLCBpMSwgaTIpIHtcclxuICBjb25zdCB0bXAgPSBhcnJbaTFdO1xyXG4gIGFycltpMV0gPSBhcnJbaTJdO1xyXG4gIGFycltpMl0gPSB0bXA7XHJcbn1cclxuXHJcbi8vIGh0dHBzOi8vanNwZXJmLmNvbS9qcy1mb3ItbG9vcC12cy1hcnJheS1pbmRleG9mLzM0NlxyXG5mdW5jdGlvbiBpbmRleE9mKGFyciwgZWwpIHtcclxuICBjb25zdCBsID0gYXJyLmxlbmd0aDtcclxuICAvLyBpZ25vcmUgZmlyc3QgZWxlbWVudCBhcyBpdCBjYW4ndCBiZSBhIGVudHJ5XHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsOyBpKyspIHtcclxuICAgIGlmIChhcnJbaV0gPT09IGVsKSB7XHJcbiAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIC0xO1xyXG59XHJcblxyXG4vKipcclxuICogRGVmaW5lIGlmIGB0aW1lMWAgc2hvdWxkIGJlIGxvd2VyIGluIHRoZSB0b3BvZ3JhcGh5IHRoYW4gYHRpbWUyYC5cclxuICogSXMgZHluYW1pY2FsbHkgYWZmZWN0ZWQgdG8gdGhlIHByaW9yaXR5IHF1ZXVlIGFjY29yZGluZyB0byBoYW5kbGUgYG1pbmAgYW5kIGBtYXhgIGhlYXAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lMVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZTJcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmNvbnN0IF9pc0xvd2VyTWF4SGVhcCA9IGZ1bmN0aW9uKHRpbWUxLCB0aW1lMikge1xyXG4gIHJldHVybiB0aW1lMSA8IHRpbWUyO1xyXG59O1xyXG5cclxuY29uc3QgX2lzTG93ZXJNaW5IZWFwID0gZnVuY3Rpb24odGltZTEsIHRpbWUyKSB7XHJcbiAgcmV0dXJuIHRpbWUxID4gdGltZTI7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVmaW5lIGlmIGB0aW1lMWAgc2hvdWxkIGJlIGhpZ2hlciBpbiB0aGUgdG9wb2dyYXBoeSB0aGFuIGB0aW1lMmAuXHJcbiAqIElzIGR5bmFtaWNhbGx5IGFmZmVjdGVkIHRvIHRoZSBwcmlvcml0eSBxdWV1ZSBhY2NvcmRpbmcgdG8gaGFuZGxlIGBtaW5gIGFuZCBgbWF4YCBoZWFwLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZTFcclxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUyXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5jb25zdCBfaXNIaWdoZXJNYXhIZWFwID0gZnVuY3Rpb24odGltZTEsIHRpbWUyKSB7XHJcbiAgcmV0dXJuIHRpbWUxID4gdGltZTI7XHJcbn07XHJcblxyXG5jb25zdCBfaXNIaWdoZXJNaW5IZWFwID0gZnVuY3Rpb24odGltZTEsIHRpbWUyKSB7XHJcbiAgcmV0dXJuIHRpbWUxIDwgdGltZTI7XHJcbn07XHJcblxyXG5jb25zdCBQT1NJVElWRV9JTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHJcbi8qKlxyXG4gKiBQcmlvcml0eSBxdWV1ZSBpbXBsZW1lbnRpbmcgYSBiaW5hcnkgaGVhcC5cclxuICogQWN0cyBhcyBhIG1pbiBoZWFwIGJ5IGRlZmF1bHQsIGNhbiBiZSBkeW5hbWljYWxseSBjaGFuZ2VkIHRvIGEgbWF4IGhlYXBcclxuICogYnkgc2V0dGluZyBgcmV2ZXJzZWAgdG8gdHJ1ZS5cclxuICpcclxuICogX25vdGVfOiB0aGUgcXVldWUgY3JlYXRlcyBhbmQgbWFpbnRhaW5zIGEgbmV3IHByb3BlcnR5IChpLmUuIGBxdWV1ZVRpbWVgKVxyXG4gKiB0byBlYWNoIG9iamVjdCBhZGRlZC5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtoZWFwTGVuZ3RoPTEwMF0gLSBEZWZhdWx0IHNpemUgb2YgdGhlIGFycmF5IHVzZWQgdG8gY3JlYXRlIHRoZSBoZWFwLlxyXG4gKi9cclxuY2xhc3MgUHJpb3JpdHlRdWV1ZSB7XHJcbiAgY29uc3RydWN0b3IoaGVhcExlbmd0aCA9IDEwMCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb2ludGVyIHRvIHRoZSBmaXJzdCBlbXB0eSBpbmRleCBvZiB0aGUgaGVhcC5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUHJpb3JpdHlRdWV1ZVxyXG4gICAgICogQG5hbWUgX2N1cnJlbnRMZW5ndGhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2N1cnJlbnRMZW5ndGggPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2YgdGhlIHNvcnRlZCBpbmRleGVzIG9mIHRoZSBlbnRyaWVzLCB0aGUgYWN0dWFsIGhlYXAuIElnbm9yZSB0aGUgaW5kZXggMC5cclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqIEBtZW1iZXJvZiBQcmlvcml0eVF1ZXVlXHJcbiAgICAgKiBAbmFtZSBfaGVhcFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5faGVhcCA9IG5ldyBBcnJheShoZWFwTGVuZ3RoICsgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUeXBlIG9mIHRoZSBxdWV1ZTogYG1pbmAgaGVhcCBpZiBgZmFsc2VgLCBgbWF4YCBoZWFwIGlmIGB0cnVlYFxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAbWVtYmVyb2YgUHJpb3JpdHlRdWV1ZVxyXG4gICAgICogQG5hbWUgX3JldmVyc2VcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3JldmVyc2UgPSBudWxsO1xyXG5cclxuICAgIC8vIGluaXRpYWxpemUgY29tcGFyZSBmdW5jdGlvbnNcclxuICAgIHRoaXMucmV2ZXJzZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGltZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYmluYXJ5IGhlYXAuXHJcbiAgICogQHJldHVybnMge051bWJlcn1cclxuICAgKi9cclxuICBnZXQgdGltZSgpIHtcclxuICAgIGlmICh0aGlzLl9jdXJyZW50TGVuZ3RoID4gMSlcclxuICAgICAgcmV0dXJuIHRoaXMuX2hlYXBbMV0ucXVldWVUaW1lO1xyXG5cclxuICAgIHJldHVybiBJbmZpbml0eTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpcnN0IGVsZW1lbnQgaW4gdGhlIGJpbmFyeSBoZWFwLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGhlYWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faGVhcFsxXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIHF1ZXVlIChtYXggaGVhcCBpZiB0cnVlLCBtaW4gaGVhcCBpZiBmYWxzZSksXHJcbiAgICogcmVidWlsZCB0aGUgaGVhcCB3aXRoIHRoZSBleGlzdGluZyBlbnRyaWVzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgc2V0IHJldmVyc2UodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcmV2ZXJzZSkge1xyXG4gICAgICB0aGlzLl9yZXZlcnNlID0gdmFsdWU7XHJcblxyXG4gICAgICBpZiAodGhpcy5fcmV2ZXJzZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuX2lzTG93ZXIgPSBfaXNMb3dlck1heEhlYXA7XHJcbiAgICAgICAgdGhpcy5faXNIaWdoZXIgPSBfaXNIaWdoZXJNYXhIZWFwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX2lzTG93ZXIgPSBfaXNMb3dlck1pbkhlYXA7XHJcbiAgICAgICAgdGhpcy5faXNIaWdoZXIgPSBfaXNIaWdoZXJNaW5IZWFwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmJ1aWxkSGVhcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IHJldmVyc2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpeCB0aGUgaGVhcCBieSBtb3ZpbmcgYW4gZW50cnkgdG8gYSBuZXcgdXBwZXIgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBlbnRyeSB0byBtb3ZlLlxyXG4gICAqL1xyXG4gIF9idWJibGVVcChzdGFydEluZGV4KSB7XHJcbiAgICBsZXQgZW50cnkgPSB0aGlzLl9oZWFwW3N0YXJ0SW5kZXhdO1xyXG5cclxuICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7XHJcbiAgICBsZXQgcGFyZW50SW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gMik7XHJcbiAgICBsZXQgcGFyZW50ID0gdGhpcy5faGVhcFtwYXJlbnRJbmRleF07XHJcblxyXG4gICAgd2hpbGUgKHBhcmVudCAmJiB0aGlzLl9pc0hpZ2hlcihlbnRyeS5xdWV1ZVRpbWUsIHBhcmVudC5xdWV1ZVRpbWUpKSB7XHJcbiAgICAgIHN3YXAodGhpcy5faGVhcCwgaW5kZXgsIHBhcmVudEluZGV4KTtcclxuXHJcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XHJcbiAgICAgIHBhcmVudEluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIDIpO1xyXG4gICAgICBwYXJlbnQgPSB0aGlzLl9oZWFwW3BhcmVudEluZGV4XTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpeCB0aGUgaGVhcCBieSBtb3ZpbmcgYW4gZW50cnkgdG8gYSBuZXcgbG93ZXIgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBlbnRyeSB0byBtb3ZlLlxyXG4gICAqL1xyXG4gIF9idWJibGVEb3duKHN0YXJ0SW5kZXgpIHtcclxuICAgIGxldCBlbnRyeSA9IHRoaXMuX2hlYXBbc3RhcnRJbmRleF07XHJcblxyXG4gICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleDtcclxuICAgIGxldCBjMWluZGV4ID0gaW5kZXggKiAyO1xyXG4gICAgbGV0IGMyaW5kZXggPSBjMWluZGV4ICsgMTtcclxuICAgIGxldCBjaGlsZDEgPSB0aGlzLl9oZWFwW2MxaW5kZXhdO1xyXG4gICAgbGV0IGNoaWxkMiA9IHRoaXMuX2hlYXBbYzJpbmRleF07XHJcblxyXG4gICAgd2hpbGUgKChjaGlsZDEgJiYgdGhpcy5faXNMb3dlcihlbnRyeS5xdWV1ZVRpbWUsIGNoaWxkMS5xdWV1ZVRpbWUpKcKgfHxcclxuICAgICAgICAgICAoY2hpbGQyICYmIHRoaXMuX2lzTG93ZXIoZW50cnkucXVldWVUaW1lLCBjaGlsZDIucXVldWVUaW1lKSkpXHJcbiAgICB7XHJcbiAgICAgIC8vIHN3YXAgd2l0aCB0aGUgbWluaW11bSBjaGlsZFxyXG4gICAgICBsZXQgdGFyZ2V0SW5kZXg7XHJcblxyXG4gICAgICBpZiAoY2hpbGQyKVxyXG4gICAgICAgIHRhcmdldEluZGV4ID0gdGhpcy5faXNIaWdoZXIoY2hpbGQxLnF1ZXVlVGltZSwgY2hpbGQyLnF1ZXVlVGltZSkgPyBjMWluZGV4IDogYzJpbmRleDtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRhcmdldEluZGV4ID0gYzFpbmRleDtcclxuXHJcbiAgICAgIHN3YXAodGhpcy5faGVhcCwgaW5kZXgsIHRhcmdldEluZGV4KTtcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSB0byBmaW5kIG5leHQgY2hpbGRyZW5cclxuICAgICAgaW5kZXggPSB0YXJnZXRJbmRleDtcclxuICAgICAgYzFpbmRleCA9IGluZGV4ICogMjtcclxuICAgICAgYzJpbmRleCA9IGMxaW5kZXggKyAxO1xyXG4gICAgICBjaGlsZDEgPSB0aGlzLl9oZWFwW2MxaW5kZXhdO1xyXG4gICAgICBjaGlsZDIgPSB0aGlzLl9oZWFwW2MyaW5kZXhdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGQgdGhlIGhlYXAgKGZyb20gYm90dG9tIHVwKS5cclxuICAgKi9cclxuICBidWlsZEhlYXAoKSB7XHJcbiAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBpbnRlcm5hbCBub2RlXHJcbiAgICAvLyBAdG9kbyAtIG1ha2Ugc3VyZSB0aGF0J3MgdGhlIHJpZ2h0IHdheSB0byBkby5cclxuICAgIGxldCBtYXhJbmRleCA9IE1hdGguZmxvb3IoKHRoaXMuX2N1cnJlbnRMZW5ndGggLSAxKSAvIDIpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBtYXhJbmRleDsgaSA+IDA7IGktLSlcclxuICAgICAgdGhpcy5fYnViYmxlRG93bihpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIG5ldyBvYmplY3QgaW4gdGhlIGJpbmFyeSBoZWFwIGFuZCBzb3J0IGl0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudHJ5IC0gRW50cnkgdG8gaW5zZXJ0LlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gVGltZSBhdCB3aGljaCB0aGUgZW50cnkgc2hvdWxkIGJlIG9yZGVyZXIuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gLSBUaW1lIG9mIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgaGVhcC5cclxuICAgKi9cclxuICBpbnNlcnQoZW50cnksIHRpbWUpIHtcclxuICAgIGlmIChNYXRoLmFicyh0aW1lKSAhPT0gUE9TSVRJVkVfSU5GSU5JVFkpIHtcclxuICAgICAgZW50cnkucXVldWVUaW1lID0gdGltZTtcclxuICAgICAgLy8gYWRkIHRoZSBuZXcgZW50cnkgYXQgdGhlIGVuZCBvZiB0aGUgaGVhcFxyXG4gICAgICB0aGlzLl9oZWFwW3RoaXMuX2N1cnJlbnRMZW5ndGhdID0gZW50cnk7XHJcbiAgICAgIC8vIGJ1YmJsZSBpdCB1cFxyXG4gICAgICB0aGlzLl9idWJibGVVcCh0aGlzLl9jdXJyZW50TGVuZ3RoKTtcclxuICAgICAgdGhpcy5fY3VycmVudExlbmd0aCArPSAxO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMudGltZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRyeS5xdWV1ZVRpbWUgPSB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoZW50cnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW92ZSBhIGdpdmVuIGVudHJ5IHRvIGEgbmV3IHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudHJ5IC0gRW50cnkgdG8gbW92ZS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIFRpbWUgYXQgd2hpY2ggdGhlIGVudHJ5IHNob3VsZCBiZSBvcmRlcmVyLlxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBUaW1lIG9mIGZpcnN0IGVudHJ5IGluIHRoZSBoZWFwLlxyXG4gICAqL1xyXG4gIG1vdmUoZW50cnksIHRpbWUpIHtcclxuICAgIGlmIChNYXRoLmFicyh0aW1lKSAhPT0gUE9TSVRJVkVfSU5GSU5JVFkpIHtcclxuICAgICAgY29uc3QgaW5kZXggPSBpbmRleE9mKHRoaXMuX2hlYXAsIGVudHJ5KTtcclxuXHJcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBlbnRyeS5xdWV1ZVRpbWUgPSB0aW1lO1xyXG4gICAgICAgIC8vIGRlZmluZSBpZiB0aGUgZW50cnkgc2hvdWxkIGJlIGJ1YmJsZWQgdXAgb3IgZG93blxyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2hlYXBbTWF0aC5mbG9vcihpbmRleCAvIDIpXTtcclxuXHJcbiAgICAgICAgaWYgKHBhcmVudCAmJiB0aGlzLl9pc0hpZ2hlcih0aW1lLCBwYXJlbnQucXVldWVUaW1lKSlcclxuICAgICAgICAgIHRoaXMuX2J1YmJsZVVwKGluZGV4KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0aGlzLl9idWJibGVEb3duKGluZGV4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMudGltZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRyeS5xdWV1ZVRpbWUgPSB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoZW50cnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFuIGVudHJ5IGZyb20gdGhlIGhlYXAgYW5kIGZpeCB0aGUgaGVhcC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSAtIEVudHJ5IHRvIHJlbW92ZS5cclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gVGltZSBvZiBmaXJzdCBlbnRyeSBpbiB0aGUgaGVhcC5cclxuICAgKi9cclxuICByZW1vdmUoZW50cnkpIHtcclxuICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBlbnRyeVxyXG4gICAgY29uc3QgaW5kZXggPSBpbmRleE9mKHRoaXMuX2hlYXAsIGVudHJ5KTtcclxuXHJcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHRoaXMuX2N1cnJlbnRMZW5ndGggLSAxO1xyXG5cclxuICAgICAgLy8gaWYgdGhlIGVudHJ5IGlzIHRoZSBsYXN0IG9uZVxyXG4gICAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xyXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIGhlYXBcclxuICAgICAgICB0aGlzLl9oZWFwW2xhc3RJbmRleF0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gdXBkYXRlIGN1cnJlbnQgbGVuZ3RoXHJcbiAgICAgICAgdGhpcy5fY3VycmVudExlbmd0aCA9IGxhc3RJbmRleDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBzd2FwIHdpdGggdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgaGVhcFxyXG4gICAgICAgIHN3YXAodGhpcy5faGVhcCwgaW5kZXgsIGxhc3RJbmRleCk7XHJcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gaGVhcFxyXG4gICAgICAgIHRoaXMuX2hlYXBbbGFzdEluZGV4XSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ID09PSAxKSB7XHJcbiAgICAgICAgICB0aGlzLl9idWJibGVEb3duKDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBidWJibGUgdGhlIChleCBsYXN0KSBlbGVtZW50IHVwIG9yIGRvd24gYWNjb3JkaW5nIHRvIGl0cyBuZXcgY29udGV4dFxyXG4gICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLl9oZWFwW2luZGV4XTtcclxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2hlYXBbTWF0aC5mbG9vcihpbmRleCAvIDIpXTtcclxuXHJcbiAgICAgICAgICBpZiAocGFyZW50ICYmIHRoaXMuX2lzSGlnaGVyKGVudHJ5LnF1ZXVlVGltZSwgcGFyZW50LnF1ZXVlVGltZSkpXHJcbiAgICAgICAgICAgIHRoaXMuX2J1YmJsZVVwKGluZGV4KTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5fYnViYmxlRG93bihpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB1cGRhdGUgY3VycmVudCBsZW5ndGhcclxuICAgICAgdGhpcy5fY3VycmVudExlbmd0aCA9IGxhc3RJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy50aW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXIgdGhlIHF1ZXVlLlxyXG4gICAqL1xyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5fY3VycmVudExlbmd0aCA9IDE7XHJcbiAgICB0aGlzLl9oZWFwID0gbmV3IEFycmF5KHRoaXMuX2hlYXAubGVuZ3RoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgaWYgdGhlIHF1ZXVlIGNvbnRhaW5zIHRoZSBnaXZlbiBgZW50cnlgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudHJ5IC0gRW50cnkgdG8gYmUgY2hlY2tlZFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaGFzKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5faGVhcC5pbmRleE9mKGVudHJ5KSAhPT0gLTE7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcmlvcml0eVF1ZXVlO1xyXG4iLCIvKipcclxuICogU2NoZWR1bGluZ1F1ZXVlIGJhc2UgY2xhc3NcclxuICogaHR0cDovL3dhdmVzanMuZ2l0aHViLmlvL2F1ZGlvLyNhdWRpby1zY2hlZHVsaW5nLXF1ZXVlXHJcbiAqXHJcbiAqIE5vcmJlcnQuU2NobmVsbEBpcmNhbS5mclxyXG4gKiBDb3B5cmlnaHQgMjAxNCwgMjAxNSBJUkNBTSDigJPCoENlbnRyZSBQb21waWRvdVxyXG4gKi9cclxuXHJcbmltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gJy4vcHJpb3JpdHktcXVldWUnO1xyXG5pbXBvcnQgVGltZUVuZ2luZSBmcm9tICcuL3RpbWUtZW5naW5lJztcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgU2NoZWR1bGluZ1F1ZXVlXHJcbiAqIEBleHRlbmRzIFRpbWVFbmdpbmVcclxuICovXHJcbmNsYXNzIFNjaGVkdWxpbmdRdWV1ZSBleHRlbmRzIFRpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9fcXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xyXG4gICAgdGhpcy5fX2VuZ2luZXMgPSBuZXcgU2V0KCk7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lICdzY2hlZHVsZWQnIGludGVyZmFjZVxyXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcclxuICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX19xdWV1ZS5oZWFkO1xyXG4gICAgY29uc3QgbmV4dEVuZ2luZVRpbWUgPSBlbmdpbmUuYWR2YW5jZVRpbWUodGltZSk7XHJcblxyXG4gICAgaWYgKCFuZXh0RW5naW5lVGltZSkge1xyXG4gICAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcclxuICAgICAgdGhpcy5fX2VuZ2luZXMuZGVsZXRlKGVuZ2luZSk7XHJcbiAgICAgIHRoaXMuX19xdWV1ZS5yZW1vdmUoZW5naW5lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX19xdWV1ZS5tb3ZlKGVuZ2luZSwgbmV4dEVuZ2luZVRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9fcXVldWUudGltZTtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWFzdGVyIG1ldGhvZCB0byBiZSBpbXBsZW1lbnRlZCBieSBkZXJpdmVkIGNsYXNzXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICAvLyBjYWxsIGEgZnVuY3Rpb24gYXQgYSBnaXZlbiB0aW1lXHJcbiAgZGVmZXIoZnVuLCB0aW1lID0gdGhpcy5jdXJyZW50VGltZSkge1xyXG4gICAgaWYgKCEoZnVuIGluc3RhbmNlb2YgRnVuY3Rpb24pKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgY2Fubm90IGJlIGRlZmVyZWQgYnkgc2NoZWR1bGVyXCIpO1xyXG5cclxuICAgIHRoaXMuYWRkKHtcclxuICAgICAgYWR2YW5jZVRpbWU6IGZ1bmN0aW9uKHRpbWUpIHsgZnVuKHRpbWUpOyB9LCAvLyBtYWtlIHN1ciB0aGF0IHRoZSBhZHZhbmNlVGltZSBtZXRob2QgZG9lcyBub3QgcmV0dXJtIGFueXRoaW5nXHJcbiAgICB9LCB0aW1lKTtcclxuICB9XHJcblxyXG4gIC8vIGFkZCBhIHRpbWUgZW5naW5lIHRvIHRoZSBzY2hlZHVsZXJcclxuICBhZGQoZW5naW5lLCB0aW1lID0gdGhpcy5jdXJyZW50VGltZSkge1xyXG4gICAgaWYgKCFUaW1lRW5naW5lLmltcGxlbWVudHNTY2hlZHVsZWQoZW5naW5lKSlcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGNhbm5vdCBiZSBhZGRlZCB0byBzY2hlZHVsZXJcIik7XHJcblxyXG4gICAgaWYgKGVuZ2luZS5tYXN0ZXIpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIGEgbWFzdGVyXCIpO1xyXG5cclxuICAgIGVuZ2luZS5tYXN0ZXIgPSB0aGlzO1xyXG5cclxuICAgIC8vIGFkZCB0byBlbmdpbmVzIGFuZCBxdWV1ZVxyXG4gICAgdGhpcy5fX2VuZ2luZXMuYWRkKGVuZ2luZSk7XHJcbiAgICBjb25zdCBuZXh0VGltZSA9IHRoaXMuX19xdWV1ZS5pbnNlcnQoZW5naW5lLCB0aW1lKTtcclxuXHJcbiAgICAvLyByZXNjaGVkdWxlIHF1ZXVlXHJcbiAgICB0aGlzLnJlc2V0VGltZShuZXh0VGltZSk7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgYSB0aW1lIGVuZ2luZSBmcm9tIHRoZSBxdWV1ZVxyXG4gIHJlbW92ZShlbmdpbmUpIHtcclxuICAgIGlmIChlbmdpbmUubWFzdGVyICE9PSB0aGlzKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoaXMgc2NoZWR1bGVyXCIpO1xyXG5cclxuICAgIGVuZ2luZS5tYXN0ZXIgPSBudWxsO1xyXG5cclxuICAgIC8vIHJlbW92ZSBmcm9tIGFycmF5IGFuZCBxdWV1ZVxyXG4gICAgdGhpcy5fX2VuZ2luZXMuZGVsZXRlKGVuZ2luZSk7XHJcbiAgICBjb25zdCBuZXh0VGltZSA9IHRoaXMuX19xdWV1ZS5yZW1vdmUoZW5naW5lKTtcclxuXHJcbiAgICAvLyByZXNjaGVkdWxlIHF1ZXVlXHJcbiAgICB0aGlzLnJlc2V0VGltZShuZXh0VGltZSk7XHJcbiAgfVxyXG5cclxuICAvLyByZXNldCBuZXh0IGVuZ2luZSB0aW1lXHJcbiAgcmVzZXRFbmdpbmVUaW1lKGVuZ2luZSwgdGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcclxuICAgIGlmIChlbmdpbmUubWFzdGVyICE9PSB0aGlzKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoaXMgc2NoZWR1bGVyXCIpO1xyXG5cclxuICAgIGxldCBuZXh0VGltZTtcclxuXHJcbiAgICBpZiAodGhpcy5fX3F1ZXVlLmhhcyhlbmdpbmUpKVxyXG4gICAgICBuZXh0VGltZSA9IHRoaXMuX19xdWV1ZS5tb3ZlKGVuZ2luZSwgdGltZSk7XHJcbiAgICBlbHNlXHJcbiAgICAgIG5leHRUaW1lID0gdGhpcy5fX3F1ZXVlLmluc2VydChlbmdpbmUsIHRpbWUpO1xyXG5cclxuICAgIHRoaXMucmVzZXRUaW1lKG5leHRUaW1lKTtcclxuICB9XHJcblxyXG4gIC8vIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiBlbmdpbmUgaXMgc2NoZWR1bGVkXHJcbiAgaGFzKGVuZ2luZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19lbmdpbmVzLmhhcyhlbmdpbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gY2xlYXIgcXVldWVcclxuICBjbGVhcigpIHtcclxuICAgIGZvcihsZXQgZW5naW5lIG9mIHRoaXMuX19lbmdpbmVzKVxyXG4gICAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9fcXVldWUuY2xlYXIoKTtcclxuICAgIHRoaXMuX19lbmdpbmVzLmNsZWFyKCk7XHJcbiAgICB0aGlzLnJlc2V0VGltZShJbmZpbml0eSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTY2hlZHVsaW5nUXVldWVcclxuIiwiLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIHRpbWUgZW5naW5lc1xyXG4gKlxyXG4gKiBBIHRpbWUgZW5naW5lIGdlbmVyYXRlcyBtb3JlIG9yIGxlc3MgcmVndWxhciBldmVudHMgYW5kL29yIHBsYXlzIGJhY2sgYVxyXG4gKiBtZWRpYSBzdHJlYW0uIEl0IGltcGxlbWVudHMgb25lIG9yIG11bHRpcGxlIGludGVyZmFjZXMgdG8gYmUgZHJpdmVuIGJ5IGFcclxuICogbWFzdGVyIChpLmUuIGEgU2NoZWR1bGVyLCBhIFRyYW5zcG9ydCBvciBhIFBsYXlDb250cm9sKSBpbiBzeW5jaHJvbml6YXRpb25cclxuICogd2l0aCBvdGhlciBlbmdpbmVzLiBUaGUgcHJvdmlkZWQgaW50ZXJmYWNlcyBhcmUgc2NoZWR1bGVkLCB0cmFuc3BvcnRlZCxcclxuICogYW5kIHBsYXktY29udHJvbGxlZC5cclxuICpcclxuICpcclxuICogIyMjIyBUaGUgYHNjaGVkdWxlZGAgaW50ZXJmYWNlXHJcbiAqXHJcbiAqIFRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlIGFsbG93cyBmb3Igc3luY2hyb25pemluZyBhbiBlbmdpbmUgdG8gYSBtb25vdG9ub3VzIHRpbWVcclxuICogYXMgaXQgaXMgcHJvdmlkZWQgYnkgdGhlIFNjaGVkdWxlciBtYXN0ZXIuXHJcbiAqXHJcbiAqICMjIyMjIyBgYWR2YW5jZVRpbWUodGltZSA6TnVtYmVyKSAtPiB7TnVtYmVyfWBcclxuICpcclxuICogVGhlIGBhZHZhbmNlVGltZWAgbWV0aG9kIGhhcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhbiBgVGltZUVuZ2luZWAgYXMgcGFydCBvZiB0aGVcclxuICogc2NoZWR1bGVkIGludGVyZmFjZS4gVGhlIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG1hc3RlciAoZS5nLiB0aGUgc2NoZWR1bGVyKS5cclxuICogSXQgZ2VuZXJhdGVzIGFuIGV2ZW50IGFuZCB0byByZXR1cm5zIHRoZSB0aW1lIG9mIHRoZSBuZXh0IGV2ZW50IChpLmUuIHRoZSBuZXh0XHJcbiAqIGNhbGwgb2YgYWR2YW5jZVRpbWUpLiBUaGUgcmV0dXJuZWQgdGltZSBoYXMgdG8gYmUgZ3JlYXRlciB0aGFuIHRoZSB0aW1lXHJcbiAqIHJlY2VpdmVkIGFzIGFyZ3VtZW50IG9mIHRoZSBtZXRob2QuIEluIGNhc2UgdGhhdCBhIFRpbWVFbmdpbmUgaGFzIHRvIGdlbmVyYXRlXHJcbiAqIG11bHRpcGxlIGV2ZW50cyBhdCB0aGUgc2FtZSB0aW1lLCB0aGUgZW5naW5lIGhhcyB0byBpbXBsZW1lbnQgaXRzIG93biBsb29wXHJcbiAqIHdoaWxlKGV2ZW50LnRpbWUgPD0gdGltZSkgYW5kIHJldHVybiB0aGUgdGltZSBvZiB0aGUgbmV4dCBldmVudCAoaWYgYW55KS5cclxuICpcclxuICogIyMjIyMjIGByZXNldFRpbWUodGltZT11bmRlZmluZWQgOk51bWJlcilgXHJcbiAqXHJcbiAqIFRoZSBgcmVzZXRUaW1lYCBtZXRob2QgaXMgcHJvdmlkZWQgYnkgdGhlIGBUaW1lRW5naW5lYCBiYXNlIGNsYXNzLiBBbiBlbmdpbmUgbWF5XHJcbiAqIGNhbGwgdGhpcyBtZXRob2QgdG8gcmVzZXQgaXRzIG5leHQgZXZlbnQgdGltZSAoZS5nLiB3aGVuIGEgcGFyYW1ldGVyIGlzXHJcbiAqIGNoYW5nZWQgdGhhdCBpbmZsdWVuY2VzIHRoZSBlbmdpbmUncyB0ZW1wb3JhbCBiZWhhdmlvcikuIFdoZW4gbm8gYXJndW1lbnRcclxuICogaXMgZ2l2ZW4sIHRoZSB0aW1lIGlzIHJlc2V0IHRvIHRoZSBjdXJyZW50IG1hc3RlciB0aW1lLiBXaGVuIGNhbGxpbmcgdGhlXHJcbiAqIG1ldGhvZCB3aXRoIEluZmluaXR5IHRoZSBlbmdpbmUgaXMgc3VzcGVuZGVkIHdpdGhvdXQgYmVpbmcgcmVtb3ZlZCBmcm9tIHRoZVxyXG4gKiBtYXN0ZXIuXHJcbiAqXHJcbiAqXHJcbiAqICMjIyMgVGhlIGB0cmFuc3BvcnRlZGAgaW50ZXJmYWNlXHJcbiAqXHJcbiAqIFRoZSB0cmFuc3BvcnRlZCBpbnRlcmZhY2UgYWxsb3dzIGZvciBzeW5jaHJvbml6aW5nIGFuIGVuZ2luZSB0byBhIHBvc2l0aW9uXHJcbiAqIChpLmUuIG1lZGlhIHBsYXliYWNrIHRpbWUpIHRoYXQgY2FuIHJ1biBmb3J3YXJkIGFuZCBiYWNrd2FyZCBhbmQganVtcCBhcyBpdFxyXG4gKiBpcyBwcm92aWRlZCBieSB0aGUgVHJhbnNwb3J0IG1hc3Rlci5cclxuICpcclxuICogIyMjIyMjIGBzeW5jUG9zaXRpb24odGltZSA6TnVtYmVyLCBwb3NpdGlvbiA6TnVtYmVyLCBzcGVlZCA6TnVtYmVyKSAtPiB7TnVtYmVyfWBcclxuICpcclxuICogVGhlIGBzeW5jUG9zaXRvbmAgbWV0aG9kIGhhcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhIGBUaW1lRW5naW5lYCBhcyBwYXJ0IG9mIHRoZVxyXG4gKiB0cmFuc3BvcnRlZCBpbnRlcmZhY2UuIFRoZSBtZXRob2Qgc3luY1Bvc2l0b24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBtYXN0ZXJcclxuICogb2YgYSB0cmFuc3BvcnRlZCBlbmdpbmUgaGFzIHRvIChyZS0pc3luY2hyb25pemUgdGhlIGVuZ2luZSdzIHBvc2l0aW9uLiBUaGlzXHJcbiAqIGlzIGZvciBleGFtcGxlIHJlcXVpcmVkIHdoZW4gdGhlIG1hc3RlciAocmUtKXN0YXJ0cyBwbGF5YmFjaywganVtcHMgdG8gYW5cclxuICogYXJiaXRyYXJ5IHBvc2l0aW9uLCBhbmQgd2hlbiByZXZlcnNpbmcgcGxheWJhY2sgZGlyZWN0aW9uLiBUaGUgbWV0aG9kIHJldHVybnNcclxuICogdGhlIG5leHQgcG9zaXRpb24gb2YgdGhlIGVuZ2luZSBpbiB0aGUgZ2l2ZW4gcGxheWJhY2sgZGlyZWN0aW9uXHJcbiAqIChpLmUuIGBzcGVlZCA8IDBgIG9yIGBzcGVlZCA+IDBgKS5cclxuICpcclxuICogIyMjIyMjIGBhZHZhbmNlUG9zaXRpb24odGltZSA6TnVtYmVyLCBwb3NpdGlvbiA6TnVtYmVyLCBzcGVlZCA6TnVtYmVyKSAtPiB7TnVtYmVyfWBcclxuICpcclxuICogVGhlIGBhZHZhbmNlUG9zaXRpb25gIG1ldGhvZCBoYXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYSBgVGltZUVuZ2luZWAgYXMgcGFydFxyXG4gKiBvZiB0aGUgdHJhbnNwb3J0ZWQgaW50ZXJmYWNlLiBUaGUgbWFzdGVyIGNhbGxzIHRoZSBhZHZhbmNlUG9zaXRvbiBtZXRob2Qgd2hlblxyXG4gKiB0aGUgZW5naW5lJ3MgZXZlbnQgcG9zaXRpb24gaXMgcmVhY2hlZC4gVGhlIG1ldGhvZCBnZW5lcmF0ZXMgYW4gZXZlbnQgYW5kXHJcbiAqIHJldHVybnMgdGhlIG5leHQgcG9zaXRpb24gaW4gdGhlIGdpdmVuIHBsYXliYWNrIGRpcmVjdGlvbiAoaS5lLiBzcGVlZCA8IDAgb3JcclxuICogc3BlZWQgPiAwKS4gVGhlIHJldHVybmVkIHBvc2l0aW9uIGhhcyB0byBiZSBncmVhdGVyIChpLmUuIHdoZW4gc3BlZWQgPiAwKVxyXG4gKiBvciBsZXNzIChpLmUuIHdoZW4gc3BlZWQgPCAwKSB0aGFuIHRoZSBwb3NpdGlvbiByZWNlaXZlZCBhcyBhcmd1bWVudCBvZiB0aGVcclxuICogbWV0aG9kLlxyXG4gKlxyXG4gKiAjIyMjIyMgYHJlc2V0UG9zaXRpb24ocG9zaXRpb249dW5kZWZpbmVkIDpOdW1iZXIpYFxyXG4gKlxyXG4gKiBUaGUgcmVzZXRQb3NpdGlvbiBtZXRob2QgaXMgcHJvdmlkZWQgYnkgdGhlIFRpbWVFbmdpbmUgYmFzZSBjbGFzcy4gQW4gZW5naW5lXHJcbiAqIG1heSBjYWxsIHRoaXMgbWV0aG9kIHRvIHJlc2V0IGl0cyBuZXh0IGV2ZW50IHBvc2l0aW9uLiBXaGVuIG5vIGFyZ3VtZW50XHJcbiAqIGlzIGdpdmVuLCB0aGUgdGltZSBpcyByZXNldCB0byB0aGUgY3VycmVudCBtYXN0ZXIgdGltZS4gV2hlbiBjYWxsaW5nIHRoZVxyXG4gKiBtZXRob2Qgd2l0aCBJbmZpbml0eSB0aGUgZW5naW5lIGlzIHN1c3BlbmRlZCB3aXRob3V0IGJlaW5nIHJlbW92ZWQgZnJvbVxyXG4gKiB0aGUgbWFzdGVyLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyMjIFRoZSBzcGVlZC1jb250cm9sbGVkIGludGVyZmFjZVxyXG4gKlxyXG4gKiBUaGUgXCJzcGVlZC1jb250cm9sbGVkXCIgaW50ZXJmYWNlIGFsbG93cyBmb3Igc3luY3Jvbml6aW5nIGFuIGVuZ2luZSB0aGF0IGlzXHJcbiAqIG5laXRoZXIgZHJpdmVuIHRocm91Z2ggdGhlIHNjaGVkdWxlZCBub3IgdGhlIHRyYW5zcG9ydGVkIGludGVyZmFjZS4gVGhlXHJcbiAqIGludGVyZmFjZSBhbGxvd3MgaW4gcGFydGljdWxhciB0byBzeW5jaHJvbml6ZSBlbmdpbmVzIHRoYXQgYXNzdXJlIHRoZWlyIG93blxyXG4gKiBzY2hlZHVsaW5nIChpLmUuIGF1ZGlvIHBsYXllciBvciBhbiBvc2NpbGxhdG9yKSB0byB0aGUgZXZlbnQtYmFzZWQgc2NoZWR1bGVkXHJcbiAqIGFuZCB0cmFuc3BvcnRlZCBlbmdpbmVzLlxyXG4gKlxyXG4gKiAjIyMjIyMgYHN5bmNTcGVlZCh0aW1lIDpOdW1iZXIsIHBvc2l0aW9uIDpOdW1iZXIsIHNwZWVkIDpOdW1iZXIsIHNlZWs9ZmFsc2UgOkJvb2xlYW4pYFxyXG4gKlxyXG4gKiBUaGUgc3luY1NwZWVkIG1ldGhvZCBoYXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYSBUaW1lRW5naW5lIGFzIHBhcnQgb2YgdGhlXHJcbiAqIHNwZWVkLWNvbnRyb2xsZWQgaW50ZXJmYWNlLiBUaGUgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgbWFzdGVyIHdoZW5ldmVyIHRoZVxyXG4gKiBwbGF5YmFjayBzcGVlZCBjaGFuZ2VzIG9yIHRoZSBwb3NpdGlvbiBqdW1wcyBhcmJpdGFyaWx5IChpLmUuIG9uIGEgc2VlaykuXHJcbiAqXHJcbiAqXHJcbiAqIDxociAvPlxyXG4gKlxyXG4gKiBFeGFtcGxlIHRoYXQgc2hvd3MgYSBgVGltZUVuZ2luZWAgcnVubmluZyBpbiBhIGBTY2hlZHVsZXJgIHRoYXQgY291bnRzIHVwXHJcbiAqIGF0IGEgZ2l2ZW4gZnJlcXVlbmN5OlxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3RpbWUtZW5naW5lLmh0bWx9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICpcclxuICogY2xhc3MgTXlFbmdpbmUgZXh0ZW5kcyBhdWRpby5UaW1lRW5naW5lIHtcclxuICogICBjb25zdHJ1Y3RvcigpIHtcclxuICogICAgIHN1cGVyKCk7XHJcbiAqICAgICAvLyAuLi5cclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICovXHJcbmNsYXNzIFRpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZW5naW5lJ3MgbWFzdGVyLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtNaXhlZH1cclxuICAgICAqIEBuYW1lIG1hc3RlclxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVFbmdpbmVcclxuICAgICAqL1xyXG4gICAgdGhpcy5tYXN0ZXIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRpbWUgZW5naW5lJ3MgY3VycmVudCAobWFzdGVyKSB0aW1lLlxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbWVtYmVyb2YgVGltZUVuZ2luZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50VGltZSgpIHtcclxuICAgIGlmICh0aGlzLm1hc3RlcilcclxuICAgICAgcmV0dXJuIHRoaXMubWFzdGVyLmN1cnJlbnRUaW1lO1xyXG5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgdGltZSBlbmdpbmUncyBjdXJyZW50IChtYXN0ZXIpIHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbWVtYmVyb2YgVGltZUVuZ2luZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICB2YXIgbWFzdGVyID0gdGhpcy5tYXN0ZXI7XHJcblxyXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uO1xyXG5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY2hlZHVsZWQgaW50ZXJmYWNlXHJcbiAgICogICAtIGFkdmFuY2VUaW1lKHRpbWUpLCBjYWxsZWQgdG8gZ2VuZXJhdGUgbmV4dCBldmVudCBhdCBnaXZlbiB0aW1lLCByZXR1cm5zIG5leHQgdGltZVxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXHJcbiAgICovXHJcbiAgc3RhdGljIGltcGxlbWVudHNTY2hlZHVsZWQoZW5naW5lKSB7XHJcbiAgICByZXR1cm4gKGVuZ2luZS5hZHZhbmNlVGltZSAmJiBlbmdpbmUuYWR2YW5jZVRpbWUgaW5zdGFuY2VvZiBGdW5jdGlvbik7XHJcbiAgfVxyXG5cclxuICByZXNldFRpbWUodGltZSA9IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHRoaXMubWFzdGVyKVxyXG4gICAgICB0aGlzLm1hc3Rlci5yZXNldEVuZ2luZVRpbWUodGhpcywgdGltZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc3BvcnRlZCBpbnRlcmZhY2VcclxuICAgKiAgIC0gc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCksIGNhbGxlZCB0byByZXBvc2l0aW9uIFRpbWVFbmdpbmUsIHJldHVybnMgbmV4dCBwb3NpdGlvblxyXG4gICAqICAgLSBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSwgY2FsbGVkIHRvIGdlbmVyYXRlIG5leHQgZXZlbnQgYXQgZ2l2ZW4gdGltZSBhbmQgcG9zaXRpb24sIHJldHVybnMgbmV4dCBwb3NpdGlvblxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXHJcbiAgICovXHJcbiAgc3RhdGljIGltcGxlbWVudHNUcmFuc3BvcnRlZChlbmdpbmUpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIGVuZ2luZS5zeW5jUG9zaXRpb24gJiYgZW5naW5lLnN5bmNQb3NpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmXHJcbiAgICAgIGVuZ2luZS5hZHZhbmNlUG9zaXRpb24gJiYgZW5naW5lLmFkdmFuY2VQb3NpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbiA9IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHRoaXMubWFzdGVyKVxyXG4gICAgICB0aGlzLm1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNwZWVkLWNvbnRyb2xsZWQgaW50ZXJmYWNlXHJcbiAgICogICAtIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsICksIGNhbGxlZCB0b1xyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXHJcbiAgICovXHJcbiAgc3RhdGljIGltcGxlbWVudHNTcGVlZENvbnRyb2xsZWQoZW5naW5lKSB7XHJcbiAgICByZXR1cm4gKGVuZ2luZS5zeW5jU3BlZWQgJiYgZW5naW5lLnN5bmNTcGVlZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRpbWVFbmdpbmU7XHJcbiIsImltcG9ydCBBdWRpb1RpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS9hdWRpby10aW1lLWVuZ2luZSc7XHJcblxyXG5mdW5jdGlvbiBvcHRPckRlZihvcHQsIGRlZikge1xyXG4gIGlmIChvcHQgIT09IHVuZGVmaW5lZClcclxuICAgIHJldHVybiBvcHQ7XHJcblxyXG4gIHJldHVybiBkZWY7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR3JhbnVsYXIgc3ludGhlc2lzIFRpbWVFbmdpbmUgaW1wbGVtZW50aW5nIHRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlLlxyXG4gKiBUaGUgZ3JhaW4gcG9zaXRpb24gKGdyYWluIG9uc2V0IG9yIGNlbnRlciB0aW1lIGluIHRoZSBhdWRpbyBidWZmZXIpIGlzXHJcbiAqIG9wdGlvbmFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgZW5naW5lJ3MgY3VycmVudFBvc2l0aW9uIGF0dHJpYnV0ZS5cclxuICpcclxuICogRXhhbXBsZSB0aGF0IHNob3dzIGEgYEdyYW51bGFyRW5naW5lYCAod2l0aCBhIGZldyBwYXJhbWV0ZXIgY29udHJvbHMpIGRyaXZlblxyXG4gKiBieSBhIGBTY2hlZHVsZXJgIGFuZCBhIGBQbGF5Q29udHJvbGA6XHJcbiAqIHtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvZ3JhbnVsYXItZW5naW5lLmh0bWx9XHJcbiAqXHJcbiAqIEBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XHJcbiAqIGNvbnN0IHNjaGVkdWxlciA9IGF1ZGlvLmdldFNjaGVkdWxlcigpO1xyXG4gKiBjb25zdCBncmFudWxhckVuZ2luZSA9IG5ldyBhdWRpby5HcmFudWxhckVuZ2luZSgpO1xyXG4gKlxyXG4gKiBzY2hlZHVsZXIuYWRkKGdyYW51bGFyRW5naW5lKTtcclxuICpcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnM9e30gLSBQYXJhbWV0ZXJzXHJcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IFtvcHRpb25zLmJ1ZmZlcj1udWxsXSAtIEF1ZGlvIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kQWJzPTAuMDFdIC0gQWJzb2x1dGUgZ3JhaW4gcGVyaW9kIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kUmVsPTBdIC0gR3JhaW4gcGVyaW9kIHJlbGF0aXZlIHRvIGFic29sdXRlXHJcbiAqICBkdXJhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kVmFyPTBdIC0gQW1vdXQgb2YgcmFuZG9tIGdyYWluIHBlcmlvZFxyXG4gKiAgdmFyaWF0aW9uIHJlbGF0aXZlIHRvIGdyYWluIHBlcmlvZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kTWluPTAuMDAxXSAtIE1pbmltdW0gZ3JhaW4gcGVyaW9kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3NpdGlvbj0wXSAtIEdyYWluIHBvc2l0aW9uIChvbnNldCB0aW1lIGluIGF1ZGlvXHJcbiAqICBidWZmZXIpIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zaXRpb25WYXI9MC4wMDNdIC0gQW1vdXQgb2YgcmFuZG9tIGdyYWluIHBvc2l0aW9uXHJcbiAqICB2YXJpYXRpb24gaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbkFicz0wLjFdIC0gQWJzb2x1dGUgZ3JhaW4gZHVyYXRpb24gaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvblJlbD0wXSAtIEdyYWluIGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdyYWluXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvblZhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBkdXJhdGlvblxyXG4gKiAgcGVyaW9kIChvdmVybGFwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXR0YWNrQWJzPTBdIC0gQWJzb2x1dGUgYXR0YWNrIHRpbWUgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hdHRhY2tSZWw9MC41XSAtIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIGdyYWluIGR1cmF0aW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hdHRhY2tTaGFwZT0nbGluJ10gLSBTaGFwZSBvZiBhdHRhY2tcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VBYnM9MF0gLSBBYnNvbHV0ZSByZWxlYXNlIHRpbWUgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZWxlYXNlUmVsPTAuNV0gLSBSZWxlYXNlIHRpbWUgcmVsYXRpdmUgdG8gZ3JhaW4gZHVyYXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VTaGFwZT0nbGluJ10gLSBTaGFwZSBvZiByZWxlYXNlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5leHBSYW1wT2Zmc2V0PTAuMDAwMV0gLSBPZmZzZXQgKHN0YXJ0L2VuZCB2YWx1ZSlcclxuICogIGZvciBleHBvbmVudGlhbCBhdHRhY2svcmVsZWFzZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzYW1wbGluZz0wXSAtIEdyYWluIHJlc2FtcGxpbmcgaW4gY2VudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzYW1wbGluZ1Zhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSByZXNhbXBsaW5nIHZhcmlhdGlvbiBpbiBjZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5nYWluPTFdIC0gTGluZWFyIGdhaW4gZmFjdG9yXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2VudGVyZWQ9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBncmFpbiBwb3NpdGlvbiByZWZlcnNcclxuICogIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGdyYWluIChvciB0aGUgYmVnaW5uaW5nKVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmN5Y2xpYz1mYWxzZV0gLSBXaGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgYW5kIGdyYWluXHJcbiAqICBwb3NpdGlvbiBhcmUgY29uc2lkZXJlZCBhcyBjeWNsaWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb249MF0gLSBQb3J0aW9uIGF0IHRoZSBlbmQgb2YgdGhlXHJcbiAqICBhdWRpbyBidWZmZXIgdGhhdCBoYXMgYmVlbiBjb3BpZWQgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIGFzc3VyZSBjeWNsaWMgYmVoYXZpb3JcclxuICovXHJcbmNsYXNzIEdyYW51bGFyRW5naW5lIGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG9wdGlvbnMuYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1ZGlvIGJ1ZmZlclxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtBdWRpb0J1ZmZlcn1cclxuICAgICAqIEBuYW1lIGJ1ZmZlclxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5idWZmZXIgPSBvcHRPckRlZihvcHRpb25zLmJ1ZmZlciwgbnVsbCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBncmFpbiBwZXJpb2QgaW4gc2VjXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHBlcmlvZEFic1xyXG4gICAgICogQGRlZmF1bHQgMC4wMVxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RBYnMgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZEFicywgMC4wMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmFpbiBwZXJpb2QgcmVsYXRpdmUgdG8gYWJzb2x1dGUgZHVyYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcGVyaW9kUmVsXHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZFJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kUmVsLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBwZXJpb2QgdmFyaWF0aW9uIHJlbGF0aXZlIHRvIGdyYWluIHBlcmlvZFxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBwZXJpb2RWYXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGVyaW9kVmFyID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RWYXIsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWluaW11bSBncmFpbiBwZXJpb2RcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcGVyaW9kTWluXHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwMVxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RNaW4gPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZE1pbiwgMC4wMDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR3JhaW4gcG9zaXRpb24gKG9uc2V0IHRpbWUgaW4gYXVkaW8gYnVmZmVyKSBpbiBzZWNcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcG9zaXRpb25cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zaXRpb24gPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBwb3NpdGlvbiB2YXJpYXRpb24gaW4gc2VjXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHBvc2l0aW9uVmFyXHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwM1xyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3NpdGlvblZhciA9IG9wdE9yRGVmKG9wdGlvbnMucG9zaXRpb25WYXIsIDAuMDAzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIGdyYWluIGR1cmF0aW9uIGluIHNlY1xyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBkdXJhdGlvbkFic1xyXG4gICAgICogQGRlZmF1bHQgMC4xXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmR1cmF0aW9uQWJzID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvbkFicywgMC4xKTsgLy8gYWJzb2x1dGUgZ3JhaW4gZHVyYXRpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyYWluIGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdyYWluIHBlcmlvZCAob3ZlcmxhcClcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgZHVyYXRpb25SZWxcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHVyYXRpb25SZWwgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uUmVsLCAwKTtcclxuICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBkdXJhdGlvbiB2YXJpYXRpb24gaW4gc2VjXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBuYW1lIGR1cmF0aW9uVmFyXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZHVyYXRpb25WYXIgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIGF0dGFjayB0aW1lIGluIHNlY1xyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBhdHRhY2tBYnNcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXR0YWNrQWJzID0gb3B0T3JEZWYob3B0aW9ucy5hdHRhY2tBYnMsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNrIHRpbWUgcmVsYXRpdmUgdG8gZ3JhaW4gZHVyYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgYXR0YWNrUmVsXHJcbiAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXR0YWNrUmVsID0gb3B0T3JEZWYob3B0aW9ucy5hdHRhY2tSZWwsIDAuNSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaGFwZSBvZiBhdHRhY2sgKCdsaW4nIGZvciBsaW5lYXIgcmFtcCwgJ2V4cCcgZm9yIGV4cG9uZW50aWFsIHJhbXApXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBuYW1lIGF0dGFja1NoYXBlXHJcbiAgICAgKiBAZGVmYXVsdCAnbGluJ1xyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdHRhY2tTaGFwZSA9IG9wdE9yRGVmKG9wdGlvbnMuYXR0YWNrU2hhcGUsICdsaW4nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIHJlbGVhc2UgdGltZSBpbiBzZWNcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcmVsZWFzZUFic1xyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWxlYXNlQWJzID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlQWJzLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBncmFpbiBkdXJhdGlvblxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSByZWxlYXNlUmVsXHJcbiAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZVJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucmVsZWFzZVJlbCwgMC41KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNoYXBlIG9mIHJlbGVhc2UgKCdsaW4nIGZvciBsaW5lYXIgcmFtcCwgJ2V4cCcgZm9yIGV4cG9uZW50aWFsIHJhbXApXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBuYW1lIHJlbGVhc2VTaGFwZVxyXG4gICAgICogQGRlZmF1bHQgJ2xpbidcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZVNoYXBlID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlU2hhcGUsICdsaW4nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9mZnNldCAoc3RhcnQvZW5kIHZhbHVlKSBmb3IgZXhwb25lbnRpYWwgYXR0YWNrL3JlbGVhc2VcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgZXhwUmFtcE9mZnNldFxyXG4gICAgICogQGRlZmF1bHQgMC4wMDAxXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmV4cFJhbXBPZmZzZXQgPSBvcHRPckRlZihvcHRpb25zLmV4cFJhbXBPZmZzZXQsIDAuMDAwMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmFpbiByZXNhbXBsaW5nIGluIGNlbnRcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcmVzYW1wbGluZ1xyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNhbXBsaW5nID0gb3B0T3JEZWYob3B0aW9ucy5yZXNhbXBsaW5nLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSByZXNhbXBsaW5nIHZhcmlhdGlvbiBpbiBjZW50XHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHJlc2FtcGxpbmdWYXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzYW1wbGluZ1ZhciA9IG9wdE9yRGVmKG9wdGlvbnMucmVzYW1wbGluZ1ZhciwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lYXIgZ2FpbiBmYWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgZ2FpblxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5nYWluID0gb3B0T3JEZWYob3B0aW9ucy5nYWluLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGdyYWluIHBvc2l0aW9uIHJlZmVycyB0byB0aGUgY2VudGVyIG9mIHRoZSBncmFpbiAob3IgdGhlIGJlZ2lubmluZylcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBuYW1lIGNlbnRlcmVkXHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNlbnRlcmVkID0gb3B0T3JEZWYob3B0aW9ucy5jZW50ZXJlZCwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgYW5kIGdyYWluIHBvc2l0aW9uIGFyZSBjb25zaWRlcmVkIGFzIGN5Y2xpY1xyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQG5hbWUgY3ljbGljXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5jeWNsaWMgPSBvcHRPckRlZihvcHRpb25zLmN5Y2xpYywgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9ydGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBidWZmZXIgdGhhdCBoYXMgYmVlbiBjb3BpZWQgZnJvbSB0aGVcclxuICAgICAqIGJlZ2lubmluZyB0byBhc3N1cmUgY3ljbGljIGJlaGF2aW9yXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHdyYXBBcm91bmRFeHRlbnNpb25cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbiA9IG9wdE9yRGVmKG9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiwgMCk7XHJcblxyXG4gICAgdGhpcy5vdXRwdXROb2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGJ1ZmZlciBkdXJhdGlvbiAoZXhjbHVkaW5nIHdyYXBBcm91bmRFeHRlbnNpb24pXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGJ1ZmZlckR1cmF0aW9uXHJcbiAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGJ1ZmZlckR1cmF0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XHJcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xyXG5cclxuICAgICAgaWYgKHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbilcclxuICAgICAgICBidWZmZXJEdXJhdGlvbiAtPSB0aGlzLndyYXBBcm91bmRFeHRlbnNpb247XHJcblxyXG4gICAgICByZXR1cm4gYnVmZmVyRHVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDdXJyZW50IHBvc2l0aW9uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGN1cnJlbnRQb3NpdGlvblxyXG4gICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICB2YXIgbWFzdGVyID0gdGhpcy5tYXN0ZXI7XHJcblxyXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgYWR2YW5jZVRpbWUodGltZSkge1xyXG4gICAgdGltZSA9IE1hdGgubWF4KHRpbWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKTtcclxuICAgIHJldHVybiB0aW1lICsgdGhpcy50cmlnZ2VyKHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlciBhIGdyYWluLiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgYXQgYW55IHRpbWUgKHdoZXRoZXIgdGhlXHJcbiAgICogZW5naW5lIGlzIHNjaGVkdWxlZCBvciBub3QpIHRvIGdlbmVyYXRlIGEgc2luZ2xlIGdyYWluIGFjY29yZGluZyB0byB0aGVcclxuICAgKiBjdXJyZW50IGdyYWluIHBhcmFtZXRlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIGdyYWluIHN5bnRoZXNpcyBhdWRpbyB0aW1lXHJcbiAgICogQHJldHVybiB7TnVtYmVyfSAtIHBlcmlvZCB0byBuZXh0IGdyYWluXHJcbiAgICovXHJcbiAgdHJpZ2dlcih0aW1lKSB7XHJcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XHJcbiAgICB2YXIgZ3JhaW5UaW1lID0gdGltZSB8fCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XHJcbiAgICB2YXIgZ3JhaW5QZXJpb2QgPSB0aGlzLnBlcmlvZEFicztcclxuICAgIHZhciBncmFpblBvc2l0aW9uID0gdGhpcy5jdXJyZW50UG9zaXRpb247XHJcbiAgICB2YXIgZ3JhaW5EdXJhdGlvbiA9IHRoaXMuZHVyYXRpb25BYnM7XHJcblxyXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XHJcbiAgICAgIHZhciByZXNhbXBsaW5nUmF0ZSA9IDEuMDtcclxuXHJcbiAgICAgIC8vIGNhbGN1bGF0ZSByZXNhbXBsaW5nXHJcbiAgICAgIGlmICh0aGlzLnJlc2FtcGxpbmcgIT09IDAgfHwgdGhpcy5yZXNhbXBsaW5nVmFyID4gMCkge1xyXG4gICAgICAgIHZhciByYW5kb21SZXNhbXBsaW5nID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMi4wICogdGhpcy5yZXNhbXBsaW5nVmFyO1xyXG4gICAgICAgIHJlc2FtcGxpbmdSYXRlID0gTWF0aC5wb3coMi4wLCAodGhpcy5yZXNhbXBsaW5nICsgcmFuZG9tUmVzYW1wbGluZykgLyAxMjAwLjApO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyByYW5kb21pemUgZ3JhaW4gZHVyYXRpb25cclxuICAgICAgaWYgKHRoaXMuZHVyYXRpb25WYXIgPiAwKSBncmFpbkR1cmF0aW9uICs9ICgyLjAgKiBNYXRoLnJhbmRvbSgpIC0gMSkgKiB0aGlzLmR1cmF0aW9uVmFyO1xyXG5cclxuICAgICAgZ3JhaW5QZXJpb2QgKz0gdGhpcy5wZXJpb2RSZWwgKiBncmFpbkR1cmF0aW9uO1xyXG4gICAgICBncmFpbkR1cmF0aW9uICs9IHRoaXMuZHVyYXRpb25SZWwgKiBncmFpblBlcmlvZDtcclxuXHJcbiAgICAgIC8vIGdyYWluIHBlcmlvZCByYW5kb24gdmFyaWF0aW9uXHJcbiAgICAgIGlmICh0aGlzLnBlcmlvZFZhciA+IDAuMClcclxuICAgICAgICBncmFpblBlcmlvZCArPSAyLjAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLnBlcmlvZFZhciAqIGdyYWluUGVyaW9kO1xyXG5cclxuICAgICAgLy8gY2VudGVyIGdyYWluXHJcbiAgICAgIGlmICh0aGlzLmNlbnRlcmVkKVxyXG4gICAgICAgIGdyYWluUG9zaXRpb24gLT0gMC41ICogZ3JhaW5EdXJhdGlvbjtcclxuXHJcbiAgICAgIC8vIHJhbmRvbWl6ZSBncmFpbiBwb3NpdGlvblxyXG4gICAgICBpZiAodGhpcy5wb3NpdGlvblZhciA+IDApXHJcbiAgICAgICAgZ3JhaW5Qb3NpdGlvbiArPSAoMi4wICogTWF0aC5yYW5kb20oKSAtIDEpICogdGhpcy5wb3NpdGlvblZhcjtcclxuXHJcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAvLyB3cmFwIG9yIGNsaXAgZ3JhaW4gcG9zaXRpb24gYW5kIGR1cmF0aW9uIGludG8gYnVmZmVyIGR1cmF0aW9uXHJcbiAgICAgIGlmIChncmFpblBvc2l0aW9uIDwgMCB8fCBncmFpblBvc2l0aW9uID49IGJ1ZmZlckR1cmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3ljbGljKSB7XHJcbiAgICAgICAgICB2YXIgY3ljbGVzID0gZ3JhaW5Qb3NpdGlvbiAvIGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICAgICAgZ3JhaW5Qb3NpdGlvbiA9IChjeWNsZXMgLSBNYXRoLmZsb29yKGN5Y2xlcykpICogYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAgICAgaWYgKGdyYWluUG9zaXRpb24gKyBncmFpbkR1cmF0aW9uID4gdGhpcy5idWZmZXIuZHVyYXRpb24pXHJcbiAgICAgICAgICAgIGdyYWluRHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIGdyYWluUG9zaXRpb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChncmFpblBvc2l0aW9uIDwgMCkge1xyXG4gICAgICAgICAgICBncmFpblRpbWUgLT0gZ3JhaW5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgZ3JhaW5EdXJhdGlvbiArPSBncmFpblBvc2l0aW9uO1xyXG4gICAgICAgICAgICBncmFpblBvc2l0aW9uID0gMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoZ3JhaW5Qb3NpdGlvbiArIGdyYWluRHVyYXRpb24gPiBidWZmZXJEdXJhdGlvbilcclxuICAgICAgICAgICAgZ3JhaW5EdXJhdGlvbiA9IGJ1ZmZlckR1cmF0aW9uIC0gZ3JhaW5Qb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG1ha2UgZ3JhaW5cclxuICAgICAgaWYgKHRoaXMuZ2FpbiA+IDAgJiYgZ3JhaW5EdXJhdGlvbiA+PSAwLjAwMSkge1xyXG4gICAgICAgIC8vIG1ha2UgZ3JhaW4gZW52ZWxvcGVcclxuICAgICAgICB2YXIgZW52ZWxvcGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHZhciBhdHRhY2sgPSB0aGlzLmF0dGFja0FicyArIHRoaXMuYXR0YWNrUmVsICogZ3JhaW5EdXJhdGlvbjtcclxuICAgICAgICB2YXIgcmVsZWFzZSA9IHRoaXMucmVsZWFzZUFicyArIHRoaXMucmVsZWFzZVJlbCAqIGdyYWluRHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmIChhdHRhY2sgKyByZWxlYXNlID4gZ3JhaW5EdXJhdGlvbikge1xyXG4gICAgICAgICAgdmFyIGZhY3RvciA9IGdyYWluRHVyYXRpb24gLyAoYXR0YWNrICsgcmVsZWFzZSk7XHJcbiAgICAgICAgICBhdHRhY2sgKj0gZmFjdG9yO1xyXG4gICAgICAgICAgcmVsZWFzZSAqPSBmYWN0b3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYXR0YWNrRW5kVGltZSA9IGdyYWluVGltZSArIGF0dGFjaztcclxuICAgICAgICB2YXIgZ3JhaW5FbmRUaW1lID0gZ3JhaW5UaW1lICsgZ3JhaW5EdXJhdGlvbiAvIHJlc2FtcGxpbmdSYXRlO1xyXG4gICAgICAgIHZhciByZWxlYXNlU3RhcnRUaW1lID0gZ3JhaW5FbmRUaW1lIC0gcmVsZWFzZTtcclxuXHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi52YWx1ZSA9IDA7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmF0dGFja1NoYXBlID09PSAnbGluJykge1xyXG4gICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLjAsIGdyYWluVGltZSk7XHJcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5leHBSYW1wT2Zmc2V0LCBncmFpblRpbWUpO1xyXG4gICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVsZWFzZVN0YXJ0VGltZSA+IGF0dGFja0VuZFRpbWUpXHJcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgcmVsZWFzZVN0YXJ0VGltZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnJlbGVhc2VTaGFwZSA9PT0gJ2xpbicpIHtcclxuICAgICAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMC4wLCBncmFpbkVuZFRpbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5leHBSYW1wT2Zmc2V0LCBncmFpbkVuZFRpbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZW52ZWxvcGUuY29ubmVjdCh0aGlzLm91dHB1dE5vZGUpO1xyXG5cclxuICAgICAgICAvLyBtYWtlIHNvdXJjZVxyXG4gICAgICAgIHZhciBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcblxyXG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICBzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmVzYW1wbGluZ1JhdGU7XHJcbiAgICAgICAgc291cmNlLmNvbm5lY3QoZW52ZWxvcGUpO1xyXG5cclxuICAgICAgICBzb3VyY2Uuc3RhcnQoZ3JhaW5UaW1lLCBncmFpblBvc2l0aW9uKTtcclxuICAgICAgICBzb3VyY2Uuc3RvcChncmFpbkVuZFRpbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucGVyaW9kTWluLCBncmFpblBlcmlvZCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHcmFudWxhckVuZ2luZTtcclxuIiwiaW1wb3J0IEF1ZGlvVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcclxuXHJcbmZ1bmN0aW9uIG9wdE9yRGVmKG9wdCwgZGVmKSB7XHJcbiAgaWYob3B0ICE9PSB1bmRlZmluZWQpXHJcbiAgICByZXR1cm4gb3B0O1xyXG5cclxuICByZXR1cm4gZGVmO1xyXG59XHJcblxyXG4vKipcclxuICogTWV0cm9ub21lIGF1ZGlvIGVuZ2luZS4gSXQgZXh0ZW5kcyBUaW1lIEVuZ2luZSBhcyBhIHRyYW5zcG9ydGVkIGludGVyZmFjZS5cclxuICogW2V4YW1wbGVde0BsaW5rIGh0dHBzOi8vcmF3Z2l0LmNvbS93YXZlc2pzL3dhdmVzLWF1ZGlvL21hc3Rlci9leGFtcGxlcy9tZXRyb25vbWUuaHRtbH1cclxuICpcclxuICogQGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XHJcbiAqIGNvbnN0IG1ldHJvbm9tZSA9IG5ldyBhdWRpby5NZXRyb25vbWUoe3BlcmlvZDogMC4zMzN9KTtcclxuICpcclxuICogc2NoZWR1bGVyLmFkZChtZXRyb25vbWUpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gRGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2Q9MV0gLSBNZXRyb25vbWUgcGVyaW9kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jbGlja0ZyZXE9NjAwXSAtIE1ldHJvbm9tZSBjbGljayBmcmVxdWVuY3lcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNsaWNrQXR0YWNrPTAuMDAyXSAtIE1ldHJvbm9tZSBjbGljayBhdHRhY2sgdGltZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2xpY2tSZWxlYXNlPTAuMDk4XSAtIE1ldHJvbm9tZSBjbGljayByZWxlYXNlIHRpbWVcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdhaW49MV0gLSBHYWluXHJcbiAqL1xyXG5jbGFzcyBNZXRyb25vbWUgZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIob3B0aW9ucy5hdWRpb0NvbnRleHQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0cm9ub21lIHBlcmlvZFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX19wZXJpb2QgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZCwgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRyb25vbWUgY2xpY2sgZnJlcXVlbmN5XHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBNZXRyb25vbWVcclxuICAgICAqIEBuYW1lIGNsaWNrRnJlcVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xpY2tGcmVxID0gb3B0T3JEZWYob3B0aW9ucy5jbGlja0ZyZXEsIDYwMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRyb25vbWUgY2xpY2sgYXR0YWNrIHRpbWVcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxyXG4gICAgICogQG5hbWUgY2xpY2tBdHRhY2tcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaWNrQXR0YWNrID0gb3B0T3JEZWYob3B0aW9ucy5jbGlja0F0dGFjaywgMC4wMDIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0cm9ub21lIGNsaWNrIHJlbGVhc2UgdGltZVxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgTWV0cm9ub21lXHJcbiAgICAgKiBAbmFtZSBjbGlja1JlbGVhc2VcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaWNrUmVsZWFzZSA9IG9wdE9yRGVmKG9wdGlvbnMuY2xpY2tSZWxlYXNlLCAwLjA5OCk7XHJcblxyXG4gICAgdGhpcy5fX2xhc3RUaW1lID0gMDtcclxuICAgIHRoaXMuX19waGFzZSA9IDA7XHJcblxyXG4gICAgdGhpcy5fX2dhaW5Ob2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgdGhpcy5fX2dhaW5Ob2RlLmdhaW4udmFsdWUgPSBvcHRPckRlZihvcHRpb25zLmdhaW4sIDEpO1xyXG5cclxuICAgIHRoaXMub3V0cHV0Tm9kZSA9IHRoaXMuX19nYWluTm9kZTtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kIChzY2hlZHVsZWQgaW50ZXJmYWNlKVxyXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcclxuICAgIHRoaXMudHJpZ2dlcih0aW1lKTtcclxuICAgIHRoaXMuX19sYXN0VGltZSA9IHRpbWU7XHJcbiAgICByZXR1cm4gdGltZSArIHRoaXMuX19wZXJpb2Q7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAodHJhbnNwb3J0ZWQgaW50ZXJmYWNlKVxyXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGlmICh0aGlzLl9fcGVyaW9kID4gMCkge1xyXG4gICAgICB2YXIgbmV4dFBvc2l0aW9uID0gKE1hdGguZmxvb3IocG9zaXRpb24gLyB0aGlzLl9fcGVyaW9kKSArIHRoaXMuX19waGFzZSkgKiB0aGlzLl9fcGVyaW9kO1xyXG5cclxuICAgICAgaWYgKHNwZWVkID4gMCAmJiBuZXh0UG9zaXRpb24gPCBwb3NpdGlvbilcclxuICAgICAgICBuZXh0UG9zaXRpb24gKz0gdGhpcy5fX3BlcmlvZDtcclxuICAgICAgZWxzZSBpZiAoc3BlZWQgPCAwICYmIG5leHRQb3NpdGlvbiA+IHBvc2l0aW9uKVxyXG4gICAgICAgIG5leHRQb3NpdGlvbiAtPSB0aGlzLl9fcGVyaW9kO1xyXG5cclxuICAgICAgcmV0dXJuIG5leHRQb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gSW5maW5pdHkgKiBzcGVlZDtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXHJcbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdGhpcy50cmlnZ2VyKHRpbWUpO1xyXG5cclxuICAgIGlmIChzcGVlZCA8IDApXHJcbiAgICAgIHJldHVybiBwb3NpdGlvbiAtIHRoaXMuX19wZXJpb2Q7XHJcblxyXG4gICAgcmV0dXJuIHBvc2l0aW9uICsgdGhpcy5fX3BlcmlvZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXIgbWV0cm9ub21lIGNsaWNrXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgbWV0cm9ub21lIGNsaWNrIHN5bnRoZXNpcyBhdWRpbyB0aW1lXHJcbiAgICovXHJcbiAgdHJpZ2dlcih0aW1lKSB7XHJcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcclxuICAgIGNvbnN0IGNsaWNrQXR0YWNrID0gdGhpcy5jbGlja0F0dGFjaztcclxuICAgIGNvbnN0IGNsaWNrUmVsZWFzZSA9IHRoaXMuY2xpY2tSZWxlYXNlO1xyXG5cclxuICAgIGNvbnN0IGVudiA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICBlbnYuZ2Fpbi52YWx1ZSA9IDAuMDtcclxuICAgIGVudi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xyXG4gICAgZW52LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMS4wLCB0aW1lICsgY2xpY2tBdHRhY2spO1xyXG4gICAgZW52LmdhaW4uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSgwLjAwMDAwMDEsIHRpbWUgKyBjbGlja0F0dGFjayArIGNsaWNrUmVsZWFzZSk7XHJcbiAgICBlbnYuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcclxuICAgIGVudi5jb25uZWN0KHRoaXMub3V0cHV0Tm9kZSk7XHJcblxyXG4gICAgY29uc3Qgb3NjID0gYXVkaW9Db250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuICAgIG9zYy5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmNsaWNrRnJlcTtcclxuICAgIG9zYy5zdGFydCh0aW1lKTtcclxuICAgIG9zYy5zdG9wKHRpbWUgKyBjbGlja0F0dGFjayArIGNsaWNrUmVsZWFzZSk7XHJcbiAgICBvc2MuY29ubmVjdChlbnYpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogbGluZWFyIGdhaW4gZmFjdG9yXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGdhaW5cclxuICAgKiBAbWVtYmVyb2YgTWV0cm9ub21lXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcbiAgc2V0IGdhaW4odmFsdWUpIHtcclxuICAgIHRoaXMuX19nYWluTm9kZS5nYWluLnZhbHVlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBnZXQgZ2FpbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZ2Fpbk5vZGUuZ2Fpbi52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIG1ldHJvbm9tZSBwZXJpb2RcclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG5hbWUgcGVyaW9kXHJcbiAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBwZXJpb2QocGVyaW9kKSB7XHJcbiAgICB0aGlzLl9fcGVyaW9kID0gcGVyaW9kO1xyXG5cclxuICAgIGNvbnN0IG1hc3RlciA9IHRoaXMubWFzdGVyO1xyXG5cclxuICAgIGlmIChtYXN0ZXIpIHtcclxuICAgICAgaWYgKG1hc3Rlci5yZXNldEVuZ2luZVRpbWUpXHJcbiAgICAgICAgbWFzdGVyLnJlc2V0RW5naW5lVGltZSh0aGlzLCB0aGlzLl9fbGFzdFRpbWUgKyBwZXJpb2QpO1xyXG4gICAgICBlbHNlIGlmIChtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbilcclxuICAgICAgICBtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbih0aGlzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBwZXJpb2QoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3BlcmlvZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBwaGFzZSBwYXJhbWV0ZXIgKGF2YWlsYWJsZSBvbmx5IHdoZW4gJ3RyYW5zcG9ydGVkJyksIHNob3VsZCBiZVxyXG4gICAqIGJldHdlZW4gWzAsIDFbXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIHBoYXNlXHJcbiAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBwaGFzZShwaGFzZSkge1xyXG4gICAgdGhpcy5fX3BoYXNlID0gcGhhc2UgLSBNYXRoLmZsb29yKHBoYXNlKTtcclxuXHJcbiAgICBjb25zdCBtYXN0ZXIgPSB0aGlzLm1hc3RlcjtcclxuXHJcbiAgICBpZiAobWFzdGVyICYmIG1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIG1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBoYXNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19waGFzZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1ldHJvbm9tZTtcclxuIiwiaW1wb3J0IEF1ZGlvVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcclxuaW1wb3J0IFBoYXNlVm9jb2RlciBmcm9tICcuLi91dGlscy9QVl9mYXN0XzUnO1xyXG5pbXBvcnQgQnVmZmVyZWRQViBmcm9tICcuLi91dGlscy9idWZmZXJlZC1wdic7XHJcblxyXG5mdW5jdGlvbiBvcHRPckRlZihvcHQsIGRlZikge1xyXG4gIGlmIChvcHQgIT09IHVuZGVmaW5lZClcclxuICAgIHJldHVybiBvcHQ7XHJcblxyXG4gIHJldHVybiBkZWY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRPclByZXZpb3VzSW5kZXgoc29ydGVkQXJyYXksIHZhbHVlLCBpbmRleCA9IC0xKSB7XHJcbiAgdmFyIHNpemUgPSBzb3J0ZWRBcnJheS5sZW5ndGg7XHJcblxyXG4gIGlmIChzaXplID4gMCkge1xyXG4gICAgdmFyIGZpcnN0VmFsID0gc29ydGVkQXJyYXlbMF07XHJcbiAgICB2YXIgbGFzdFZhbCA9IHNvcnRlZEFycmF5W3NpemUgLSAxXTtcclxuXHJcbiAgICBpZiAodmFsdWUgPCBmaXJzdFZhbClcclxuICAgICAgaW5kZXggPSAtMTtcclxuICAgIGVsc2UgaWYgKHZhbHVlID49IGxhc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gc2l6ZSAtIDE7XHJcbiAgICBlbHNlIHtcclxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKVxyXG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoc2l6ZSAtIDEpICogKHZhbHVlIC0gZmlyc3RWYWwpIC8gKGxhc3RWYWwgLSBmaXJzdFZhbCkpO1xyXG5cclxuICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4XSA+IHZhbHVlKVxyXG4gICAgICAgIGluZGV4LS07XHJcblxyXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXggKyAxXSA8PSB2YWx1ZSlcclxuICAgICAgICBpbmRleCsrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGluZGV4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDdXJyZW50T3JOZXh0SW5kZXgoc29ydGVkQXJyYXksIHZhbHVlLCBpbmRleCA9IC0xKSB7XHJcbiAgdmFyIHNpemUgPSBzb3J0ZWRBcnJheS5sZW5ndGg7XHJcblxyXG4gIGlmIChzaXplID4gMCkge1xyXG4gICAgdmFyIGZpcnN0VmFsID0gc29ydGVkQXJyYXlbMF07XHJcbiAgICB2YXIgbGFzdFZhbCA9IHNvcnRlZEFycmF5W3NpemUgLSAxXTtcclxuXHJcbiAgICBpZiAodmFsdWUgPD0gZmlyc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gMDtcclxuICAgIGVsc2UgaWYgKHZhbHVlID49IGxhc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gc2l6ZTtcclxuICAgIGVsc2Uge1xyXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNpemUpXHJcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChzaXplIC0gMSkgKiAodmFsdWUgLSBmaXJzdFZhbCkgLyAobGFzdFZhbCAtIGZpcnN0VmFsKSk7XHJcblxyXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXhdIDwgdmFsdWUpXHJcbiAgICAgICAgaW5kZXgrKztcclxuXHJcbiAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleCAtIDFdID49IHZhbHVlKVxyXG4gICAgICAgIGluZGV4LS07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaW5kZXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VkIHdpdGggYSBidWZmZXIgdG8gc2VydmUgYXVkaW8gZmlsZXMgdmlhIGdyYW51bGFyIHN5bnRoZXNpcy5cclxuICpcclxuICogVGhlIGVuZ2luZSBpbXBsZW1lbnRzIHRoZSBcInNjaGVkdWxlZFwiIGFuZCBcInRyYW5zcG9ydGVkXCIgaW50ZXJmYWNlcy5cclxuICogV2hlbiBcInNjaGVkdWxlZFwiLCB0aGUgZW5naW5lICBnZW5lcmF0ZXMgc2VnbWVudHMgbW9yZSBvciBsZXNzwqBwZXJpb2RpY2FsbHlcclxuICogKGNvbnRyb2xsZWQgYnkgdGhlIHBlcmlvZEFicywgcGVyaW9kUmVsLCBhbmQgcGVyaW9WYXIgYXR0cmlidXRlcykuXHJcbiAqIFdoZW4gXCJ0cmFuc3BvcnRlZFwiLCB0aGUgZW5naW5lIGdlbmVyYXRlcyBzZWdtZW50cyBhdCB0aGUgcG9zaXRpb24gb2YgdGhlaXIgb25zZXQgdGltZS5cclxuICpcclxuICogRXhhbXBsZSB0aGF0IHNob3dzIGEgYFBoYXNldm9jb2RlckVuZ2luZWAgd2l0aCBhIGZldyBwYXJhbWV0ZXIgY29udHJvbHMgcnVubmluZyBpbiBhIGBTY2hlZHVsZXJgLlxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3BoYXNldm9jb2Rlci1lbmdpbmUuaHRtbH1cclxuICpcclxuICogQGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XHJcbiAqIGNvbnN0IFBoYXNldm9jb2RlckVuZ2luZSA9IG5ldyBhdWRpby5QaGFzZXZvY29kZXJFbmdpbmUoKTtcclxuICpcclxuICogc2NoZWR1bGVyLmFkZChQaGFzZXZvY29kZXJFbmdpbmUpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gRGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IFtvcHRpb25zLmJ1ZmZlcj1udWxsXSAtIEF1ZGlvIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kQWJzPTBdIC0gQWJzb2x1dGUgc2VnbWVudCBwZXJpb2QgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RSZWw9MV0gLSBTZWdtZW50IHBlcmlvZCByZWxhdGl2ZSB0byBpbnRlci1zZWdtZW50IGRpc3RhbmNlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RWYXI9MF0gLSBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwZXJpb2QgdmFyaWF0aW9uIHJlbGF0aXZlXHJcbiAqICB0byBzZWdtZW50IHBlcmlvZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kTWluPTAuMDAxXSAtIE1pbmltdW0gc2VnbWVudCBwZXJpb2RcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvc2l0aW9uQXJyYXk9WzAuMF1dIC0gQXJyYXkgb2Ygc2VnbWVudCBwb3NpdGlvbnMgKG9uc2V0IHRpbWVzXHJcbiAqICBpbiBhdWRpbyBidWZmZXIpIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zaXRpb25WYXI9MF0gLSBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwb3NpdGlvbiB2YXJpYXRpb24gaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbkFycmF5PVswLjBdXSAtIEFycmF5IG9mIHNlZ21lbnQgZHVyYXRpb25zIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25BYnM9MF0gLSBBYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25SZWw9MV0gLSBTZWdtZW50IGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdpdmVuIHNlZ21lbnRcclxuICogIGR1cmF0aW9uIG9yIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMub2Zmc2V0QXJyYXk9WzAuMF1dIC0gQXJyYXkgb2Ygc2VnbWVudCBvZmZzZXRzIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0QWJzPS0wLjAwNV0gLSBBYnNvbHV0ZSBzZWdtZW50IG9mZnNldCBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFJlbD0wXSAtIFNlZ21lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlbGF5PTAuMDA1XSAtIFRpbWUgYnkgd2hpY2ggYWxsIHNlZ21lbnRzIGFyZSBkZWxheWVkIChlc3BlY2lhbGx5XHJcbiAqICB0byByZWFsaXplIHNlZ21lbnQgb2Zmc2V0cylcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF0dGFja0Ficz0wLjAwNV0gLSBBYnNvbHV0ZSBhdHRhY2sgdGltZSBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF0dGFja1JlbD0wXSAtIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VBYnM9MC4wMDVdIC0gQWJzb2x1dGUgcmVsZWFzZSB0aW1lIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVsZWFzZVJlbD0wXSAtIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNhbXBsaW5nPTBdIC0gU2VnbWVudCByZXNhbXBsaW5nIGluIGNlbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc2FtcGxpbmdWYXI9MF0gLSBBbW91dCBvZiByYW5kb20gcmVzYW1wbGluZyB2YXJpYXRpb24gaW4gY2VudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ2Fpbj0xXSAtIExpbmVhciBnYWluIGZhY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYWJvcnRUaW1lPTAuMDA1XSAtIGZhZGUtb3V0IHRpbWUgd2hlbiBhYm9ydGVkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zZWdtZW50SW5kZXg9MF0gLSBJbmRleCBvZiB0aGUgc2VnbWVudCB0byBzeW50aGVzaXplIChpLmUuIG9mXHJcbiAqICB0aGlzLnBvc2l0aW9uQXJyYXkvZHVyYXRpb25BcnJheS9vZmZzZXRBcnJheSlcclxuICogQHBhcmFtIHtCb29sfSBbb3B0aW9ucy5jeWNsaWM9ZmFsc2VdIC0gV2hldGhlciB0aGUgYXVkaW8gYnVmZmVyIGFuZCBzZWdtZW50IGluZGljZXMgYXJlXHJcbiAqICBjb25zaWRlcmVkIGFzIGN5Y2xpY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbj0wXSAtIFBvcnRpb24gYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gYnVmZmVyXHJcbiAqICB0aGF0IGhhcyBiZWVuIGNvcGllZCBmcm9tIHRoZSBiZWdpbm5pbmcgdG8gYXNzdXJlIGN5Y2xpYyBiZWhhdmlvclxyXG4gKi9cclxuY2xhc3MgUGhhc2V2b2NvZGVyRW5naW5lIGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG9wdGlvbnMuYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1ZGlvIGJ1ZmZlclxyXG4gICAgICogQG5hbWUgYnVmZmVyXHJcbiAgICAgKiBAdHlwZSB7QXVkaW9CdWZmZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5idWZmZXIgPSBvcHRPckRlZihvcHRpb25zLmJ1ZmZlciwgbnVsbCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBzZWdtZW50IHBlcmlvZCBpbiBzZWNcclxuICAgICAqIEBuYW1lIHBlcmlvZEFic1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZEFicyA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kQWJzLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZ21lbnQgcGVyaW9kIHJlbGF0aXZlIHRvIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICAgICAqIEBuYW1lIHBlcmlvZFJlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZFJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kUmVsLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBlcmlvZCB2YXJpYXRpb24gcmVsYXRpdmUgdG8gc2VnbWVudCBwZXJpb2RcclxuICAgICAqIEBuYW1lIHBlcmlvZFZhclxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZFZhciA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1pbmltdW0gc2VnbWVudCBwZXJpb2RcclxuICAgICAqIEBuYW1lIHBlcmlvZE1pblxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDAxXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RNaW4gPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZE1pbiwgMC4wMDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2Ygc2VnbWVudCBwb3NpdGlvbnMgKG9uc2V0IHRpbWVzIGluIGF1ZGlvIGJ1ZmZlcikgaW4gc2VjXHJcbiAgICAgKiBAbmFtZSBwb3NpdGlvbkFycmF5XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgWzAuMF1cclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc2l0aW9uQXJyYXkgPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uQXJyYXksIFswLjBdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBvc2l0aW9uIHZhcmlhdGlvbiBpbiBzZWNcclxuICAgICAqIEBuYW1lIHBvc2l0aW9uVmFyXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zaXRpb25WYXIgPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHNlZ21lbnQgZHVyYXRpb25zIGluIHNlY1xyXG4gICAgICogQG5hbWUgZHVyYXRpb25BcnJheVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IFswLjBdXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kdXJhdGlvbkFycmF5ID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvbkFycmF5LCBbMC4wXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uIGluIHNlY1xyXG4gICAgICogQG5hbWUgZHVyYXRpb25BYnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kdXJhdGlvbkFicyA9IG9wdE9yRGVmKG9wdGlvbnMuZHVyYXRpb25BYnMsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VnbWVudCBkdXJhdGlvbiByZWxhdGl2ZSB0byBnaXZlbiBzZWdtZW50IGR1cmF0aW9uIG9yIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICAgICAqIEBuYW1lIGR1cmF0aW9uUmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHVyYXRpb25SZWwgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uUmVsLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHNlZ21lbnQgb2Zmc2V0cyBpbiBzZWNcclxuICAgICAqXHJcbiAgICAgKiBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICogb2Zmc2V0IDwgMDogdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb24gaXMgdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb25cclxuICAgICAqIGFuZCB0aGUgZHVyYXRpb24gaGFzIHRvIGJlIGNvcnJlY3RlZCBieSB0aGUgb2Zmc2V0XHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgb2Zmc2V0QXJyYXlcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqIEBkZWZhdWx0IFswLjBdXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5vZmZzZXRBcnJheSA9IG9wdE9yRGVmKG9wdGlvbnMub2Zmc2V0QXJyYXksIFswLjBdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIHNlZ21lbnQgb2Zmc2V0IGluIHNlY1xyXG4gICAgICogQG5hbWUgb2Zmc2V0QWJzXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgLTAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5vZmZzZXRBYnMgPSBvcHRPckRlZihvcHRpb25zLm9mZnNldEFicywgLTAuMDA1KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZ21lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAqIEBuYW1lIG9mZnNldFJlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9mZnNldFJlbCA9IG9wdE9yRGVmKG9wdGlvbnMub2Zmc2V0UmVsLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRpbWUgYnkgd2hpY2ggYWxsIHNlZ21lbnRzIGFyZSBkZWxheWVkIChlc3BlY2lhbGx5IHRvIHJlYWxpemUgc2VnbWVudCBvZmZzZXRzKVxyXG4gICAgICogQG5hbWUgZGVsYXlcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGVsYXkgPSBvcHRPckRlZihvcHRpb25zLmRlbGF5LCAwLjAwNSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBhdHRhY2sgdGltZSBpbiBzZWNcclxuICAgICAqIEBuYW1lIGF0dGFja0Fic1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdHRhY2tBYnMgPSBvcHRPckRlZihvcHRpb25zLmF0dGFja0FicywgMC4wMDUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNrIHRpbWUgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICogQG5hbWUgYXR0YWNrUmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXR0YWNrUmVsID0gb3B0T3JEZWYob3B0aW9ucy5hdHRhY2tSZWwsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzb2x1dGUgcmVsZWFzZSB0aW1lIGluIHNlY1xyXG4gICAgICogQG5hbWUgcmVsZWFzZUFic1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWxlYXNlQWJzID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlQWJzLCAwLjAwNSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWxlYXNlIHRpbWUgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICogQG5hbWUgcmVsZWFzZVJlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlbGVhc2VSZWwgPSBvcHRPckRlZihvcHRpb25zLnJlbGVhc2VSZWwsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VnbWVudCByZXNhbXBsaW5nIGluIGNlbnRcclxuICAgICAqIEBuYW1lIHJlc2FtcGxpbmdcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNhbXBsaW5nID0gb3B0T3JEZWYob3B0aW9ucy5yZXNhbXBsaW5nLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSByZXNhbXBsaW5nIHZhcmlhdGlvbiBpbiBjZW50XHJcbiAgICAgKiBAbmFtZSByZXNhbXBsaW5nVmFyXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzYW1wbGluZ1ZhciA9IG9wdE9yRGVmKG9wdGlvbnMucmVzYW1wbGluZ1ZhciwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lYXIgZ2FpbiBmYWN0b3JcclxuICAgICAqIEBuYW1lIGdhaW5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5nYWluID0gb3B0T3JEZWYob3B0aW9ucy5nYWluLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEluZGV4IG9mIHRoZSBzZWdtZW50IHRvIHN5bnRoZXNpemUgKGkuZS4gb2YgdGhpcy5wb3NpdGlvbkFycmF5L2R1cmF0aW9uQXJyYXkvb2Zmc2V0QXJyYXkpXHJcbiAgICAgKiBAbmFtZSBzZWdtZW50SW5kZXhcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5zZWdtZW50SW5kZXggPSBvcHRPckRlZihvcHRpb25zLnNlZ21lbnRJbmRleCwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgYW5kIHNlZ21lbnQgaW5kaWNlcyBhcmUgY29uc2lkZXJlZCBhcyBjeWNsaWNcclxuICAgICAqIEBuYW1lIGN5Y2xpY1xyXG4gICAgICogQHR5cGUge0Jvb2x9XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3ljbGljID0gb3B0T3JEZWYob3B0aW9ucy5jeWNsaWMsIGZhbHNlKTtcclxuICAgIHRoaXMuX19jeWNsaWNPZmZzZXQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgbGFzdCBzZWdtZW50IGlzIGFib3J0ZWQgd2hlbiB0cmlnZ2VyaW5nIHRoZSBuZXh0XHJcbiAgICAgKiBAbmFtZSBtb25vcGhvbmljXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm1vbm9waG9uaWMgPSBvcHRPckRlZihvcHRpb25zLm1vbm9waG9uaWMsIGZhbHNlKTtcclxuICAgIHRoaXMuX19jdXJyZW50U3JjID0gbnVsbDtcclxuICAgIHRoaXMuX19jdXJyZW50RW52ID0gbnVsbDtcclxuICAgIHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lID0gMDtcclxuICAgIHRoaXMuX19jdXJyZW50R2FpbiA9IDA7XHJcbiAgICB0aGlzLl9fY3VycmVudEVuZFRpbWUgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmFkZS1vdXQgdGltZSAod2hlbiBhYm9ydGVkKVxyXG4gICAgICogQG5hbWUgYWJvcnRUaW1lXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMC4wMDVcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmFib3J0VGltZSA9IG9wdE9yRGVmKG9wdGlvbnMuYWJvcnRUaW1lLCAwLjAwNSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3J0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGF1ZGlvIGJ1ZmZlciB0aGF0IGhhcyBiZWVuIGNvcGllZCBmcm9tIHRoZSBiZWdpbm5pbmcgdG8gYXNzdXJlIGN5Y2xpYyBiZWhhdmlvclxyXG4gICAgICogQG5hbWUgd3JhcEFyb3VuZEV4dGVuc2lvblxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLndyYXBBcm91bmRFeHRlbnNpb24gPSBvcHRPckRlZihvcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb24sIDApO1xyXG5cclxuICAgIHRoaXMub3V0cHV0Tm9kZSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuXHJcbiAgICAvLyBCdWZmZXJlZCBQaGFzZVZvY29kZXIgXHJcbiAgICB0aGlzLkJVRkZFUl9TSVpFID0gNDA5NjtcclxuICAgIHRoaXMuRlJBTUVfU0laRSA9IDIwNDg7XHJcbiAgICB0aGlzLl9wdiA9IG5ldyBCdWZmZXJlZFBWKHRoaXMuRlJBTUVfU0laRSk7XHJcbiAgICB0aGlzLl9wdi5zZXRfYXVkaW9fYnVmZmVyKHRoaXMuYnVmZmVyKTtcclxuICAgIHRoaXMuX3B2LmFscGhhID0gMjsgLy8gU3RyZXRjaCBmYWN0b3JcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBidWZmZXIgZHVyYXRpb24gKGV4Y2x1ZGluZyB3cmFwQXJvdW5kRXh0ZW5zaW9uKVxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAZGVmYXVsdCAwXHJcbiAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIGdldCBidWZmZXJEdXJhdGlvbigpIHtcclxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xyXG4gICAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbjtcclxuXHJcbiAgICAgIGlmICh0aGlzLndyYXBBcm91bmRFeHRlbnNpb24pXHJcbiAgICAgICAgYnVmZmVyRHVyYXRpb24gLT0gdGhpcy53cmFwQXJvdW5kRXh0ZW5zaW9uO1xyXG5cclxuICAgICAgcmV0dXJuIGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHRyYW5zcG9ydGVkIGludGVyZmFjZSlcclxuICBhZHZhbmNlVGltZSh0aW1lKSB7XHJcbiAgICB0aW1lID0gTWF0aC5tYXgodGltZSwgdGhpcy5hdWRpb0NvbnRleHQuY3VycmVudFRpbWUpO1xyXG4gICAgcmV0dXJuIHRpbWUgKyB0aGlzLnRyaWdnZXIodGltZSk7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAodHJhbnNwb3J0ZWQgaW50ZXJmYWNlKVxyXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIHZhciBpbmRleCA9IHRoaXMuc2VnbWVudEluZGV4O1xyXG4gICAgdmFyIGN5Y2xpY09mZnNldCA9IDA7XHJcbiAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgIGlmICh0aGlzLmN5Y2xpYykge1xyXG4gICAgICB2YXIgY3ljbGVzID0gcG9zaXRpb24gLyBidWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgIGN5Y2xpY09mZnNldCA9IE1hdGguZmxvb3IoY3ljbGVzKSAqIGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICBwb3NpdGlvbiAtPSBjeWNsaWNPZmZzZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNwZWVkID4gMCkge1xyXG4gICAgICBpbmRleCA9IGdldEN1cnJlbnRPck5leHRJbmRleCh0aGlzLnBvc2l0aW9uQXJyYXksIHBvc2l0aW9uKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA+PSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgIGN5Y2xpY09mZnNldCArPSBidWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcclxuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChzcGVlZCA8IDApIHtcclxuICAgICAgaW5kZXggPSBnZXRDdXJyZW50T3JQcmV2aW91c0luZGV4KHRoaXMucG9zaXRpb25BcnJheSwgcG9zaXRpb24pO1xyXG5cclxuICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgIGluZGV4ID0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgY3ljbGljT2Zmc2V0IC09IGJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuY3ljbGljKVxyXG4gICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIEluZmluaXR5O1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2VnbWVudEluZGV4ID0gaW5kZXg7XHJcbiAgICB0aGlzLl9fY3ljbGljT2Zmc2V0ID0gY3ljbGljT2Zmc2V0O1xyXG5cclxuICAgIHJldHVybiBjeWNsaWNPZmZzZXQgKyB0aGlzLnBvc2l0aW9uQXJyYXlbaW5kZXhdO1xyXG4gIH1cclxuXHJcbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHRyYW5zcG9ydGVkIGludGVyZmFjZSlcclxuICBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLnNlZ21lbnRJbmRleDtcclxuICAgIHZhciBjeWNsaWNPZmZzZXQgPSB0aGlzLl9fY3ljbGljT2Zmc2V0O1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcih0aW1lKTtcclxuXHJcbiAgICBpZiAoc3BlZWQgPiAwKSB7XHJcbiAgICAgIGluZGV4Kys7XHJcblxyXG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICBjeWNsaWNPZmZzZXQgKz0gdGhpcy5idWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcclxuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaW5kZXgtLTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICBpbmRleCA9IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxO1xyXG4gICAgICAgIGN5Y2xpY09mZnNldCAtPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuY3ljbGljKVxyXG4gICAgICAgICAgcmV0dXJuIC1JbmZpbml0eTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2VnbWVudEluZGV4ID0gaW5kZXg7XHJcbiAgICB0aGlzLl9fY3ljbGljT2Zmc2V0ID0gY3ljbGljT2Zmc2V0O1xyXG5cclxuICAgIHJldHVybiBjeWNsaWNPZmZzZXQgKyB0aGlzLnBvc2l0aW9uQXJyYXlbaW5kZXhdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlciBhIHNlZ21lbnQuXHJcbiAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIGF0IGFueSB0aW1lICh3aGV0aGVyIHRoZSBlbmdpbmUgaXMgc2NoZWR1bGVkL3RyYW5zcG9ydGVkIG9yIG5vdClcclxuICAgKiB0byBnZW5lcmF0ZSBhIHNpbmdsZSBzZWdtZW50IGFjY29yZGluZyB0byB0aGUgY3VycmVudCBzZWdtZW50IHBhcmFtZXRlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSBzZWdtZW50IHN5bnRoZXNpcyBhdWRpbyB0aW1lXHJcbiAgICogQHJldHVybiB7TnVtYmVyfSBwZXJpb2QgdG8gbmV4dCBzZWdtZW50XHJcbiAgICovXHJcbiAgdHJpZ2dlcih0aW1lKSB7XHJcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XHJcbiAgICB2YXIgc2VnbWVudFRpbWUgPSAodGltZSB8fCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWUpICsgdGhpcy5kZWxheTtcclxuICAgIHZhciBzZWdtZW50UGVyaW9kID0gdGhpcy5wZXJpb2RBYnM7XHJcbiAgICB2YXIgc2VnbWVudEluZGV4ID0gdGhpcy5zZWdtZW50SW5kZXg7XHJcblxyXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XHJcbiAgICAgIHZhciBzZWdtZW50UG9zaXRpb24gPSAwLjA7XHJcbiAgICAgIHZhciBzZWdtZW50RHVyYXRpb24gPSAwLjA7XHJcbiAgICAgIHZhciBzZWdtZW50T2Zmc2V0ID0gMC4wO1xyXG4gICAgICB2YXIgcmVzYW1wbGluZ1JhdGUgPSAxLjA7XHJcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICBpZiAodGhpcy5jeWNsaWMpXHJcbiAgICAgICAgc2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4ICUgdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aDtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHNlZ21lbnRJbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHNlZ21lbnRJbmRleCwgdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCAtIDEpKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uQXJyYXkpXHJcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkFycmF5W3NlZ21lbnRJbmRleF0gfHwgMDtcclxuXHJcbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uQXJyYXkpXHJcbiAgICAgICAgc2VnbWVudER1cmF0aW9uID0gdGhpcy5kdXJhdGlvbkFycmF5W3NlZ21lbnRJbmRleF0gfHwgMDtcclxuXHJcbiAgICAgIGlmICh0aGlzLm9mZnNldEFycmF5KVxyXG4gICAgICAgIHNlZ21lbnRPZmZzZXQgPSB0aGlzLm9mZnNldEFycmF5W3NlZ21lbnRJbmRleF0gfHwgMDtcclxuXHJcbiAgICAgIC8vIGNhbGN1bGF0ZSByZXNhbXBsaW5nXHJcbiAgICAgIGlmICh0aGlzLnJlc2FtcGxpbmcgIT09IDAgfHwgdGhpcy5yZXNhbXBsaW5nVmFyID4gMCkge1xyXG4gICAgICAgIHZhciByYW5kb21SZXNhbXBsaW5nID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMi4wICogdGhpcy5yZXNhbXBsaW5nVmFyO1xyXG4gICAgICAgIHJlc2FtcGxpbmdSYXRlID0gTWF0aC5wb3coMi4wLCAodGhpcy5yZXNhbXBsaW5nICsgcmFuZG9tUmVzYW1wbGluZykgLyAxMjAwLjApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBjYWxjdWxhdGUgaW50ZXItc2VnbWVudCBkaXN0YW5jZVxyXG4gICAgICBpZiAoc2VnbWVudER1cmF0aW9uID09PSAwIHx8IHRoaXMucGVyaW9kUmVsID4gMCkge1xyXG4gICAgICAgIHZhciBuZXh0U2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4ICsgMTtcclxuICAgICAgICB2YXIgbmV4dFBvc2l0aW9uLCBuZXh0T2Zmc2V0O1xyXG5cclxuICAgICAgICBpZiAobmV4dFNlZ21lbnRJbmRleCA9PT0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgaWYgKHRoaXMuY3ljbGljKSB7XHJcbiAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVswXSArIGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gdGhpcy5vZmZzZXRBcnJheVswXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICAgICAgICBuZXh0T2Zmc2V0ID0gMDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkFycmF5W25leHRTZWdtZW50SW5kZXhdO1xyXG4gICAgICAgICAgbmV4dE9mZnNldCA9IHRoaXMub2Zmc2V0QXJyYXlbbmV4dFNlZ21lbnRJbmRleF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgaW50ZXJTZWdtZW50RGlzdGFuY2UgPSBuZXh0UG9zaXRpb24gLSBzZWdtZW50UG9zaXRpb247XHJcblxyXG4gICAgICAgIC8vIGNvcnJlY3QgaW50ZXItc2VnbWVudCBkaXN0YW5jZSBieSBvZmZzZXRzXHJcbiAgICAgICAgLy8gICBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICAgIGlmIChzZWdtZW50T2Zmc2V0ID4gMClcclxuICAgICAgICAgIGludGVyU2VnbWVudERpc3RhbmNlIC09IHNlZ21lbnRPZmZzZXQ7XHJcblxyXG4gICAgICAgIGlmIChuZXh0T2Zmc2V0ID4gMClcclxuICAgICAgICAgIGludGVyU2VnbWVudERpc3RhbmNlICs9IG5leHRPZmZzZXQ7XHJcblxyXG4gICAgICAgIGlmIChpbnRlclNlZ21lbnREaXN0YW5jZSA8IDApXHJcbiAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSA9IDA7XHJcblxyXG4gICAgICAgIC8vIHVzZSBpbnRlci1zZWdtZW50IGRpc3RhbmNlIGluc3RlYWQgb2Ygc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICAgIGlmIChzZWdtZW50RHVyYXRpb24gPT09IDApXHJcbiAgICAgICAgICBzZWdtZW50RHVyYXRpb24gPSBpbnRlclNlZ21lbnREaXN0YW5jZTtcclxuXHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIHBlcmlvZCByZWxhdGl2ZSB0byBpbnRlciBtYXJrZXIgZGlzdGFuY2VcclxuICAgICAgICBzZWdtZW50UGVyaW9kICs9IHRoaXMucGVyaW9kUmVsICogaW50ZXJTZWdtZW50RGlzdGFuY2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGFkZCByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICBzZWdtZW50RHVyYXRpb24gKj0gdGhpcy5kdXJhdGlvblJlbDtcclxuICAgICAgc2VnbWVudER1cmF0aW9uICs9IHRoaXMuZHVyYXRpb25BYnM7XHJcblxyXG4gICAgICAvLyBhZGQgcmVsYXRpdmUgYW5kIGFic29sdXRlIHNlZ21lbnQgb2Zmc2V0XHJcbiAgICAgIHNlZ21lbnRPZmZzZXQgKj0gdGhpcy5vZmZzZXRSZWw7XHJcbiAgICAgIHNlZ21lbnRPZmZzZXQgKz0gdGhpcy5vZmZzZXRBYnM7XHJcblxyXG4gICAgICAvLyBhcHBseSBzZWdtZW50IG9mZnNldFxyXG4gICAgICAvLyAgIG9mZnNldCA+IDA6IHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGlzIGFmdGVyIHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uXHJcbiAgICAgIC8vICAgb2Zmc2V0IDwgMDogdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb24gaXMgdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gYW5kIHRoZSBkdXJhdGlvbiBoYXMgdG8gYmUgY29ycmVjdGVkIGJ5IHRoZSBvZmZzZXRcclxuICAgICAgaWYgKHNlZ21lbnRPZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgc2VnbWVudER1cmF0aW9uIC09IHNlZ21lbnRPZmZzZXQ7XHJcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uICs9IHNlZ21lbnRPZmZzZXQ7XHJcbiAgICAgICAgc2VnbWVudFRpbWUgKz0gKHNlZ21lbnRPZmZzZXQgLyByZXNhbXBsaW5nUmF0ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc2VnbWVudFRpbWUgLT0gKHNlZ21lbnRPZmZzZXQgLyByZXNhbXBsaW5nUmF0ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHJhbmRvbWl6ZSBzZWdtZW50IHBvc2l0aW9uXHJcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uVmFyID4gMClcclxuICAgICAgICBzZWdtZW50UG9zaXRpb24gKz0gMi4wICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5wb3NpdGlvblZhcjtcclxuXHJcbiAgICAgIC8vIHNob3J0ZW4gZHVyYXRpb24gb2Ygc2VnbWVudHMgb3ZlciB0aGUgZWRnZXMgb2YgdGhlIGJ1ZmZlclxyXG4gICAgICBpZiAoc2VnbWVudFBvc2l0aW9uIDwgMCkge1xyXG4gICAgICAgIC8vc2VnbWVudFRpbWUgLT0gZ3JhaW5Qb3NpdGlvbjsgaG0sIG5vdCBzdXJlIGlmIHdlIHdhbnQgdG8gZG8gdGhpc1xyXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiArPSBzZWdtZW50UG9zaXRpb247XHJcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uID0gMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNlZ21lbnRQb3NpdGlvbiArIHNlZ21lbnREdXJhdGlvbiA+IHRoaXMuYnVmZmVyLmR1cmF0aW9uKVxyXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uIC0gc2VnbWVudFBvc2l0aW9uO1xyXG5cclxuICAgICAgc2VnbWVudER1cmF0aW9uIC89IHJlc2FtcGxpbmdSYXRlO1xyXG5cclxuICAgICAgaWYgKHRoaXMubW9ub3Bob25pYylcclxuICAgICAgICB0aGlzLmFib3J0KHNlZ21lbnRUaW1lKTtcclxuXHJcbiAgICAgIC8vIG1ha2Ugc2VnbWVudFxyXG4gICAgICBpZiAodGhpcy5nYWluID4gMCAmJiBzZWdtZW50RHVyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgLy8gbWFrZSBzZWdtZW50IGVudmVsb3BlXHJcbiAgICAgICAgdmFyIGVudmVsb3BlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICB2YXIgYXR0YWNrID0gdGhpcy5hdHRhY2tBYnMgKyB0aGlzLmF0dGFja1JlbCAqIHNlZ21lbnREdXJhdGlvbjtcclxuICAgICAgICB2YXIgcmVsZWFzZSA9IHRoaXMucmVsZWFzZUFicyArIHRoaXMucmVsZWFzZVJlbCAqIHNlZ21lbnREdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKGF0dGFjayArIHJlbGVhc2UgPiBzZWdtZW50RHVyYXRpb24pIHtcclxuICAgICAgICAgIHZhciBmYWN0b3IgPSBzZWdtZW50RHVyYXRpb24gLyAoYXR0YWNrICsgcmVsZWFzZSk7XHJcbiAgICAgICAgICBhdHRhY2sgKj0gZmFjdG9yO1xyXG4gICAgICAgICAgcmVsZWFzZSAqPSBmYWN0b3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYXR0YWNrRW5kVGltZSA9IHNlZ21lbnRUaW1lICsgYXR0YWNrO1xyXG4gICAgICAgIHZhciBzZWdtZW50RW5kVGltZSA9IHNlZ21lbnRUaW1lICsgc2VnbWVudER1cmF0aW9uO1xyXG4gICAgICAgIHZhciByZWxlYXNlU3RhcnRUaW1lID0gc2VnbWVudEVuZFRpbWUgLSByZWxlYXNlO1xyXG5cclxuICAgICAgICBlbnZlbG9wZS5nYWluLnZhbHVlID0gMDtcclxuICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKDAuMCwgc2VnbWVudFRpbWUpO1xyXG4gICAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5nYWluLCBhdHRhY2tFbmRUaW1lKTtcclxuXHJcbiAgICAgICAgaWYgKHJlbGVhc2VTdGFydFRpbWUgPiBhdHRhY2tFbmRUaW1lKVxyXG4gICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh0aGlzLmdhaW4sIHJlbGVhc2VTdGFydFRpbWUpO1xyXG5cclxuICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAuMCwgc2VnbWVudEVuZFRpbWUpO1xyXG4gICAgICAgIGVudmVsb3BlLmNvbm5lY3QodGhpcy5vdXRwdXROb2RlKTtcclxuXHJcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRFbnYgPSBlbnZlbG9wZTtcclxuXHJcbiAgICAgICAgLy8gbWFrZSBzb3VyY2VcclxuICAgICAgICB2YXIgc291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG5cclxuICAgICAgICAvLyBCdWZmZXIgdG8gc2F2ZSB0aGUgc3RyZXRjaCBhdWRpbyBpbnRvXHJcbiAgICAgICAgdmFyIHN0cmV0Y2hlZEJ1ZmZlciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXIoMiwgc2VnbWVudER1cmF0aW9uICogYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUsIGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKTtcclxuXHJcbiAgICAgICAgLy8gVGhpcyBwcmVzZXJ2ZXMgYXR0YWNrIHRyYW5zaWVudHMgb24gc2VnbWVudCBvZmZzZXRzXHJcbiAgICAgICAgdGhpcy5fcHYucmVzZXRQaGFzZSgpOyBcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSBwaGFzZXZvY29kZXIncyBwb3NpdGlvbiBpbiBzb3VyY2UgYnVmZmVyIChpZSB0aGlzLmJ1ZmZlcikuXHJcbiAgICAgICAgdGhpcy5fcHYucG9zaXRpb24gPSBzZWdtZW50UG9zaXRpb24gKiBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZTtcclxuXHJcbiAgICAgICAgdGhpcy5fcHYucHJvY2VzcyhzdHJldGNoZWRCdWZmZXIpO1xyXG5cclxuICAgICAgICBzb3VyY2UuYnVmZmVyID0gc3RyZXRjaGVkQnVmZmVyO1xyXG4gICAgICAgIHNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSByZXNhbXBsaW5nUmF0ZTtcclxuICAgICAgICBzb3VyY2UuY29ubmVjdChlbnZlbG9wZSk7XHJcblxyXG4gICAgICAgIHNvdXJjZS5zdGFydChzZWdtZW50VGltZSk7XHJcbiAgICAgICAgc291cmNlLnN0b3Aoc2VnbWVudFRpbWUgKyBzZWdtZW50RHVyYXRpb24pO1xyXG5cclxuICAgICAgICB0aGlzLl9fY3VycmVudFNyYyA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZSA9IHJlbGVhc2VTdGFydFRpbWU7XHJcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRHYWluID0gdGhpcy5nYWluO1xyXG4gICAgICAgIHRoaXMuX19jdXJyZW50RW5kVGltZSA9IHNlZ21lbnRFbmRUaW1lO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ3JhaW4gcGVyaW9kIHJhbmRvbiB2YXJpYXRpb25cclxuICAgIGlmICh0aGlzLnBlcmlvZFZhciA+IDAuMClcclxuICAgICAgc2VnbWVudFBlcmlvZCArPSAyLjAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLnBlcmlvZFZhciAqIGdyYWluUGVyaW9kO1xyXG5cclxuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnBlcmlvZE1pbiwgc2VnbWVudFBlcmlvZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBYm9ydCB0aGUgY3VycmVudCBzZWdtZW50IGF0IGdpdmVuIHRpbWUsIGZhZGUgb3V0IGR1cmF0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIGFib3J0IHRpbWVcclxuICAgKi9cclxuICBhYm9ydCh0aW1lKSB7XHJcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcclxuICAgIGNvbnN0IGVuZFRpbWUgPSB0aGlzLl9fY3VycmVudEVuZFRpbWU7XHJcbiAgICBjb25zdCBhYm9ydFRpbWUgPSB0aW1lIHx8IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcclxuXHJcbiAgICBpZiAoYWJvcnRUaW1lIDwgZW5kVGltZSkge1xyXG4gICAgICBjb25zdCBzZWdtZW50RW5kVGltZSA9IE1hdGgubWluKGFib3J0VGltZSArIHRoaXMuYWJvcnRUaW1lLCBlbmRUaW1lKTtcclxuICAgICAgY29uc3QgZW52ZWxvcGUgPSB0aGlzLl9fY3VycmVudEVudjtcclxuICAgICAgbGV0IGN1cnJlbnRHYWluVmFsdWUgPSB0aGlzLl9fY3VycmVudEdhaW47XHJcblxyXG4gICAgICBpZiAoYWJvcnRUaW1lID4gdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUpIHtcclxuICAgICAgICBjb25zdCByZWxlYXNlU3RhcnQgPSB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZTtcclxuICAgICAgICBjdXJyZW50R2FpblZhbHVlICo9IChhYm9ydFRpbWUgLSByZWxlYXNlU3RhcnQpIC8gKGVuZFRpbWUgLSByZWxlYXNlU3RhcnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbnZlbG9wZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhhYm9ydFRpbWUpO1xyXG4gICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKGN1cnJlbnRHYWluVmFsdWUsIGFib3J0VGltZSk7XHJcbiAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgc2VnbWVudEVuZFRpbWUpO1xyXG5cclxuICAgICAgdGhpcy5fX2N1cnJlbnRTcmMgPSBudWxsO1xyXG4gICAgICB0aGlzLl9fY3VycmVudEVudiA9IG51bGw7XHJcbiAgICAgIHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lID0gMDtcclxuICAgICAgdGhpcy5fX2N1cnJlbnRHYWluID0gMDtcclxuICAgICAgdGhpcy5fX2N1cnJlbnRFbmRUaW1lID0gMDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0cmV0Y2hGYWN0b3IobmV3QWxwaGEpIHtcclxuICAgICAgdGhpcy5fcHYuYWxwaGEgPSBuZXdBbHBoYTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBoYXNldm9jb2RlckVuZ2luZTtcclxuIiwiaW1wb3J0IEF1ZGlvVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcclxuXHJcbmZ1bmN0aW9uIG9wdE9yRGVmKG9wdCwgZGVmKSB7XHJcbiAgaWYob3B0ICE9PSB1bmRlZmluZWQpXHJcbiAgICByZXR1cm4gb3B0O1xyXG5cclxuICByZXR1cm4gZGVmO1xyXG59XHJcblxyXG4vKipcclxuICogVXNlZCB3aXRoIGEgYnVmZmVyIHRvIHNlcnZlIGF1ZGlvIGZpbGVzLlxyXG4gKlxyXG4gKiBbZXhhbXBsZV17QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3BsYXllci1lbmdpbmUuaHRtbH1cclxuICpcclxuICogQGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3QgcGxheWVyRW5naW5lID0gYXVkaW8uUGxheWVyRW5naW5lKCk7XHJcbiAqIGNvbnN0IHBsYXlDb250cm9sID0gbmV3IGF1ZGlvLlBsYXlDb250cm9sKHBsYXllckVuZ2luZSk7XHJcbiAqXHJcbiAqIHBsYXlDb250cm9sLnN0YXJ0KCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBEZWZhdWx0IG9wdGlvbnNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmJ1ZmZlcj0xXSAtIEF1ZGlvIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZmFkZVRpbWU9NjAwXSAtIEZhZGUgdGltZSBmb3IgY2hhaW5pbmcgc2VnbWVudHNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmN5Y2xpYz1mYWxzZV0gLSBMb29wIG1vZGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdhaW49MV0gLSBHYWluXHJcbiAqL1xyXG5jbGFzcyBQbGF5ZXJFbmdpbmUgZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIob3B0aW9ucy5hdWRpb0NvbnRleHQpO1xyXG5cclxuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDsgLy8gc2V0IHdoZW4gYWRkZWQgdG8gdHJhbnNwb3J0ZXJcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1ZGlvIGJ1ZmZlclxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtBdWRpb0J1ZmZlcn1cclxuICAgICAqIEBuYW1lIGJ1ZmZlclxyXG4gICAgICogQG1lbWJlcm9mIFBsYXllckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYnVmZmVyID0gb3B0T3JEZWYob3B0aW9ucy5idWZmZXIsIG51bGwpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRmFkZSB0aW1lIGZvciBjaGFpbmluZyBzZWdtZW50cyAoZS5nLiBpbiBzdGFydCwgc3RvcCwgYW5kIHNlZWspXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIGZhZGVUaW1lXHJcbiAgICAgKiBAbWVtYmVyb2YgUGxheWVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBkZWZhdWx0IDAuMDA1XHJcbiAgICAgKi9cclxuICAgIHRoaXMuZmFkZVRpbWUgPSBvcHRPckRlZihvcHRpb25zLmZhZGVUaW1lLCAwLjAwNSk7XHJcblxyXG4gICAgdGhpcy5fX3RpbWUgPSAwO1xyXG4gICAgdGhpcy5fX3Bvc2l0aW9uID0gMDtcclxuICAgIHRoaXMuX19zcGVlZCA9IDA7XHJcblxyXG4gICAgdGhpcy5fX2J1ZmZlclNvdXJjZSA9IG51bGw7XHJcbiAgICB0aGlzLl9fZW52Tm9kZSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fX2dhaW5Ob2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgdGhpcy5fX2dhaW5Ob2RlLmdhaW4udmFsdWUgPSBvcHRPckRlZihvcHRpb25zLmdhaW4sIDEpO1xyXG5cclxuICAgIHRoaXMuX19jeWNsaWMgPSBvcHRPckRlZihvcHRpb25zLmN5Y2xpYywgZmFsc2UpO1xyXG5cclxuICAgIHRoaXMub3V0cHV0Tm9kZSA9IHRoaXMuX19nYWluTm9kZTtcclxuICB9XHJcblxyXG4gIF9fc3RhcnQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XHJcblxyXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XHJcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX19jeWNsaWMgJiYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBidWZmZXJEdXJhdGlvbikpIHtcclxuICAgICAgICB2YXIgcGhhc2UgPSBwb3NpdGlvbiAvIGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICAgIHBvc2l0aW9uID0gKHBoYXNlIC0gTWF0aC5mbG9vcihwaGFzZSkpICogYnVmZmVyRHVyYXRpb247XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwb3NpdGlvbiA+PSAwICYmIHBvc2l0aW9uIDwgYnVmZmVyRHVyYXRpb24gJiYgc3BlZWQgPiAwKSB7XHJcbiAgICAgICAgdGhpcy5fX2Vudk5vZGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHRoaXMuX19lbnZOb2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgdGltZSk7XHJcbiAgICAgICAgdGhpcy5fX2Vudk5vZGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgxLCB0aW1lICsgdGhpcy5mYWRlVGltZSk7XHJcbiAgICAgICAgdGhpcy5fX2Vudk5vZGUuY29ubmVjdCh0aGlzLl9fZ2Fpbk5vZGUpO1xyXG5cclxuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG4gICAgICAgIHRoaXMuX19idWZmZXJTb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XHJcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSBzcGVlZDtcclxuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLmxvb3AgPSB0aGlzLl9fY3ljbGljO1xyXG4gICAgICAgIHRoaXMuX19idWZmZXJTb3VyY2UubG9vcFN0YXJ0ID0gMDtcclxuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLmxvb3BFbmQgPSBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLnN0YXJ0KHRpbWUsIHBvc2l0aW9uKTtcclxuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLmNvbm5lY3QodGhpcy5fX2Vudk5vZGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfX2hhbHQodGltZSkge1xyXG4gICAgaWYgKHRoaXMuX19idWZmZXJTb3VyY2UpIHtcclxuICAgICAgdGhpcy5fX2Vudk5vZGUuZ2Fpbi5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGltZSk7XHJcbiAgICAgIHRoaXMuX19lbnZOb2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5fX2Vudk5vZGUuZ2Fpbi52YWx1ZSwgdGltZSk7XHJcbiAgICAgIHRoaXMuX19lbnZOb2RlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgdGltZSArIHRoaXMuZmFkZVRpbWUpO1xyXG4gICAgICB0aGlzLl9fYnVmZmVyU291cmNlLnN0b3AodGltZSArIHRoaXMuZmFkZVRpbWUpO1xyXG5cclxuICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZSA9IG51bGw7XHJcbiAgICAgIHRoaXMuX19lbnZOb2RlID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kIChzcGVlZC1jb250cm9sbGVkIGludGVyZmFjZSlcclxuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrID0gZmFsc2UpIHtcclxuICAgIHZhciBsYXN0U3BlZWQgPSB0aGlzLl9fc3BlZWQ7XHJcblxyXG4gICAgaWYgKHNwZWVkICE9PSBsYXN0U3BlZWQgfHwgc2Vlaykge1xyXG4gICAgICBpZiAoc2VlayB8fCBsYXN0U3BlZWQgKiBzcGVlZCA8IDApIHtcclxuICAgICAgICB0aGlzLl9faGFsdCh0aW1lKTtcclxuICAgICAgICB0aGlzLl9fc3RhcnQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICAgICAgfSBlbHNlIGlmIChsYXN0U3BlZWQgPT09IDAgfHwgc2Vlaykge1xyXG4gICAgICAgIHRoaXMuX19zdGFydCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNwZWVkID09PSAwKSB7XHJcbiAgICAgICAgdGhpcy5fX2hhbHQodGltZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fX2J1ZmZlclNvdXJjZSkge1xyXG4gICAgICAgIHRoaXMuX19idWZmZXJTb3VyY2UucGxheWJhY2tSYXRlLnNldFZhbHVlQXRUaW1lKHNwZWVkLCB0aW1lKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fX3NwZWVkID0gc3BlZWQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgd2hldGhlciB0aGUgYXVkaW8gYnVmZmVyIGlzIGNvbnNpZGVyZWQgYXMgY3ljbGljXHJcbiAgICogQHR5cGUge0Jvb2x9XHJcbiAgICogQG5hbWUgY3ljbGljXHJcbiAgICogQG1lbWJlcm9mIFBsYXllckVuZ2luZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBjeWNsaWMoY3ljbGljKSB7XHJcbiAgICBpZiAoY3ljbGljICE9PSB0aGlzLl9fY3ljbGljKSB7XHJcbiAgICAgIHZhciB0aW1lID0gdGhpcy5jdXJyZW50VGltZTtcclxuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5jdXJyZW50b3NpdGlvbjtcclxuXHJcbiAgICAgIHRoaXMuX19oYWx0KHRpbWUpO1xyXG4gICAgICB0aGlzLl9fY3ljbGljID0gY3ljbGljO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX19zcGVlZCAhPT0gMClcclxuICAgICAgICB0aGlzLl9fc3RhcnQodGltZSwgcG9zaXRpb24sIHRoaXMuX19zcGVlZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgY3ljbGljKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19jeWNsaWM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaW5lYXIgZ2FpbiBmYWN0b3JcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGdhaW5cclxuICAgKiBAbWVtYmVyb2YgUGxheWVyRW5naW5lXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcbiAgc2V0IGdhaW4odmFsdWUpIHtcclxuICAgIHZhciB0aW1lID0gdGhpcy5jdXJyZW50VGltZTtcclxuICAgIHRoaXMuX19nYWluTm9kZS5jYW5jZWxTY2hlZHVsZWRWYWx1ZXModGltZSk7XHJcbiAgICB0aGlzLl9fZ2Fpbk5vZGUuc2V0VmFsdWVBdFRpbWUodGhpcy5fX2dhaW5Ob2RlLmdhaW4udmFsdWUsIHRpbWUpO1xyXG4gICAgdGhpcy5fX2dhaW5Ob2RlLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAsIHRpbWUgKyB0aGlzLmZhZGVUaW1lKTtcclxuICB9XHJcblxyXG4gIGdldCBnYWluKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19nYWluTm9kZS5nYWluLnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGJ1ZmZlciBkdXJhdGlvblxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG5hbWUgYnVmZmVyRHVyYXRpb25cclxuICAgKiBAbWVtYmVyb2YgUGxheWVyRW5naW5lXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGJ1ZmZlckR1cmF0aW9uKCkge1xyXG4gICAgaWYodGhpcy5idWZmZXIpXHJcbiAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5kdXJhdGlvbjtcclxuXHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFBsYXllckVuZ2luZTtcclxuIiwiaW1wb3J0IEF1ZGlvVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcclxuXHJcbmZ1bmN0aW9uIG9wdE9yRGVmKG9wdCwgZGVmKSB7XHJcbiAgaWYgKG9wdCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgcmV0dXJuIG9wdDtcclxuXHJcbiAgcmV0dXJuIGRlZjtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q3VycmVudE9yUHJldmlvdXNJbmRleChzb3J0ZWRBcnJheSwgdmFsdWUsIGluZGV4ID0gLTEpIHtcclxuICB2YXIgc2l6ZSA9IHNvcnRlZEFycmF5Lmxlbmd0aDtcclxuXHJcbiAgaWYgKHNpemUgPiAwKSB7XHJcbiAgICB2YXIgZmlyc3RWYWwgPSBzb3J0ZWRBcnJheVswXTtcclxuICAgIHZhciBsYXN0VmFsID0gc29ydGVkQXJyYXlbc2l6ZSAtIDFdO1xyXG5cclxuICAgIGlmICh2YWx1ZSA8IGZpcnN0VmFsKVxyXG4gICAgICBpbmRleCA9IC0xO1xyXG4gICAgZWxzZSBpZiAodmFsdWUgPj0gbGFzdFZhbClcclxuICAgICAgaW5kZXggPSBzaXplIC0gMTtcclxuICAgIGVsc2Uge1xyXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNpemUpXHJcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChzaXplIC0gMSkgKiAodmFsdWUgLSBmaXJzdFZhbCkgLyAobGFzdFZhbCAtIGZpcnN0VmFsKSk7XHJcblxyXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXhdID4gdmFsdWUpXHJcbiAgICAgICAgaW5kZXgtLTtcclxuXHJcbiAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleCArIDFdIDw9IHZhbHVlKVxyXG4gICAgICAgIGluZGV4Kys7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaW5kZXg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRPck5leHRJbmRleChzb3J0ZWRBcnJheSwgdmFsdWUsIGluZGV4ID0gLTEpIHtcclxuICB2YXIgc2l6ZSA9IHNvcnRlZEFycmF5Lmxlbmd0aDtcclxuXHJcbiAgaWYgKHNpemUgPiAwKSB7XHJcbiAgICB2YXIgZmlyc3RWYWwgPSBzb3J0ZWRBcnJheVswXTtcclxuICAgIHZhciBsYXN0VmFsID0gc29ydGVkQXJyYXlbc2l6ZSAtIDFdO1xyXG5cclxuICAgIGlmICh2YWx1ZSA8PSBmaXJzdFZhbClcclxuICAgICAgaW5kZXggPSAwO1xyXG4gICAgZWxzZSBpZiAodmFsdWUgPj0gbGFzdFZhbClcclxuICAgICAgaW5kZXggPSBzaXplO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2l6ZSlcclxuICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoKHNpemUgLSAxKSAqICh2YWx1ZSAtIGZpcnN0VmFsKSAvIChsYXN0VmFsIC0gZmlyc3RWYWwpKTtcclxuXHJcbiAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleF0gPCB2YWx1ZSlcclxuICAgICAgICBpbmRleCsrO1xyXG5cclxuICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4IC0gMV0gPj0gdmFsdWUpXHJcbiAgICAgICAgaW5kZXgtLTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBpbmRleDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVzZWQgd2l0aCBhIGJ1ZmZlciB0byBzZXJ2ZSBhdWRpbyBmaWxlcyB2aWEgZ3JhbnVsYXIgc3ludGhlc2lzLlxyXG4gKlxyXG4gKiBUaGUgZW5naW5lIGltcGxlbWVudHMgdGhlIFwic2NoZWR1bGVkXCIgYW5kIFwidHJhbnNwb3J0ZWRcIiBpbnRlcmZhY2VzLlxyXG4gKiBXaGVuIFwic2NoZWR1bGVkXCIsIHRoZSBlbmdpbmUgIGdlbmVyYXRlcyBzZWdtZW50cyBtb3JlIG9yIGxlc3PCoHBlcmlvZGljYWxseVxyXG4gKiAoY29udHJvbGxlZCBieSB0aGUgcGVyaW9kQWJzLCBwZXJpb2RSZWwsIGFuZCBwZXJpb1ZhciBhdHRyaWJ1dGVzKS5cclxuICogV2hlbiBcInRyYW5zcG9ydGVkXCIsIHRoZSBlbmdpbmUgZ2VuZXJhdGVzIHNlZ21lbnRzIGF0IHRoZSBwb3NpdGlvbiBvZiB0aGVpciBvbnNldCB0aW1lLlxyXG4gKlxyXG4gKiBFeGFtcGxlIHRoYXQgc2hvd3MgYSBgU2VnbWVudEVuZ2luZWAgd2l0aCBhIGZldyBwYXJhbWV0ZXIgY29udHJvbHMgcnVubmluZyBpbiBhIGBTY2hlZHVsZXJgLlxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3NlZ21lbnQtZW5naW5lLmh0bWx9XHJcbiAqXHJcbiAqIEBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XHJcbiAqIGNvbnN0IHNjaGVkdWxlciA9IGF1ZGlvLmdldFNjaGVkdWxlcigpO1xyXG4gKiBjb25zdCBzZWdtZW50RW5naW5lID0gbmV3IGF1ZGlvLlNlZ21lbnRFbmdpbmUoKTtcclxuICpcclxuICogc2NoZWR1bGVyLmFkZChzZWdtZW50RW5naW5lKTtcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIERlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBbb3B0aW9ucy5idWZmZXI9bnVsbF0gLSBBdWRpbyBidWZmZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZEFicz0wXSAtIEFic29sdXRlIHNlZ21lbnQgcGVyaW9kIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kUmVsPTFdIC0gU2VnbWVudCBwZXJpb2QgcmVsYXRpdmUgdG8gaW50ZXItc2VnbWVudCBkaXN0YW5jZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kVmFyPTBdIC0gQW1vdXQgb2YgcmFuZG9tIHNlZ21lbnQgcGVyaW9kIHZhcmlhdGlvbiByZWxhdGl2ZVxyXG4gKiAgdG8gc2VnbWVudCBwZXJpb2RcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBlcmlvZE1pbj0wLjAwMV0gLSBNaW5pbXVtIHNlZ21lbnQgcGVyaW9kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3NpdGlvbkFycmF5PVswLjBdXSAtIEFycmF5IG9mIHNlZ21lbnQgcG9zaXRpb25zIChvbnNldCB0aW1lc1xyXG4gKiAgaW4gYXVkaW8gYnVmZmVyKSBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvc2l0aW9uVmFyPTBdIC0gQW1vdXQgb2YgcmFuZG9tIHNlZ21lbnQgcG9zaXRpb24gdmFyaWF0aW9uIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25BcnJheT1bMC4wXV0gLSBBcnJheSBvZiBzZWdtZW50IGR1cmF0aW9ucyBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uQWJzPTBdIC0gQWJzb2x1dGUgc2VnbWVudCBkdXJhdGlvbiBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmR1cmF0aW9uUmVsPTFdIC0gU2VnbWVudCBkdXJhdGlvbiByZWxhdGl2ZSB0byBnaXZlbiBzZWdtZW50XHJcbiAqICBkdXJhdGlvbiBvciBpbnRlci1zZWdtZW50IGRpc3RhbmNlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLm9mZnNldEFycmF5PVswLjBdXSAtIEFycmF5IG9mIHNlZ21lbnQgb2Zmc2V0cyBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldEFicz0tMC4wMDVdIC0gQWJzb2x1dGUgc2VnbWVudCBvZmZzZXQgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5vZmZzZXRSZWw9MF0gLSBTZWdtZW50IG9mZnNldCByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kZWxheT0wLjAwNV0gLSBUaW1lIGJ5IHdoaWNoIGFsbCBzZWdtZW50cyBhcmUgZGVsYXllZCAoZXNwZWNpYWxseVxyXG4gKiAgdG8gcmVhbGl6ZSBzZWdtZW50IG9mZnNldHMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hdHRhY2tBYnM9MC4wMDVdIC0gQWJzb2x1dGUgYXR0YWNrIHRpbWUgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hdHRhY2tSZWw9MF0gLSBBdHRhY2sgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZWxlYXNlQWJzPTAuMDA1XSAtIEFic29sdXRlIHJlbGVhc2UgdGltZSBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VSZWw9MF0gLSBSZWxlYXNlIHRpbWUgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzYW1wbGluZz0wXSAtIFNlZ21lbnQgcmVzYW1wbGluZyBpbiBjZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNhbXBsaW5nVmFyPTBdIC0gQW1vdXQgb2YgcmFuZG9tIHJlc2FtcGxpbmcgdmFyaWF0aW9uIGluIGNlbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdhaW49MV0gLSBMaW5lYXIgZ2FpbiBmYWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmFib3J0VGltZT0wLjAwNV0gLSBmYWRlLW91dCB0aW1lIHdoZW4gYWJvcnRlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuc2VnbWVudEluZGV4PTBdIC0gSW5kZXggb2YgdGhlIHNlZ21lbnQgdG8gc3ludGhlc2l6ZSAoaS5lLiBvZlxyXG4gKiAgdGhpcy5wb3NpdGlvbkFycmF5L2R1cmF0aW9uQXJyYXkvb2Zmc2V0QXJyYXkpXHJcbiAqIEBwYXJhbSB7Qm9vbH0gW29wdGlvbnMuY3ljbGljPWZhbHNlXSAtIFdoZXRoZXIgdGhlIGF1ZGlvIGJ1ZmZlciBhbmQgc2VnbWVudCBpbmRpY2VzIGFyZVxyXG4gKiAgY29uc2lkZXJlZCBhcyBjeWNsaWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb249MF0gLSBQb3J0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGF1ZGlvIGJ1ZmZlclxyXG4gKiAgdGhhdCBoYXMgYmVlbiBjb3BpZWQgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIGFzc3VyZSBjeWNsaWMgYmVoYXZpb3JcclxuICovXHJcbmNsYXNzIFNlZ21lbnRFbmdpbmUgZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIob3B0aW9ucy5hdWRpb0NvbnRleHQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXVkaW8gYnVmZmVyXHJcbiAgICAgKiBAbmFtZSBidWZmZXJcclxuICAgICAqIEB0eXBlIHtBdWRpb0J1ZmZlcn1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5idWZmZXIgPSBvcHRPckRlZihvcHRpb25zLmJ1ZmZlciwgbnVsbCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBzZWdtZW50IHBlcmlvZCBpbiBzZWNcclxuICAgICAqIEBuYW1lIHBlcmlvZEFic1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RBYnMgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZEFicywgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWdtZW50IHBlcmlvZCByZWxhdGl2ZSB0byBpbnRlci1zZWdtZW50IGRpc3RhbmNlXHJcbiAgICAgKiBAbmFtZSBwZXJpb2RSZWxcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGVyaW9kUmVsID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RSZWwsIDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW1vdXQgb2YgcmFuZG9tIHNlZ21lbnQgcGVyaW9kIHZhcmlhdGlvbiByZWxhdGl2ZSB0byBzZWdtZW50IHBlcmlvZFxyXG4gICAgICogQG5hbWUgcGVyaW9kVmFyXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZFZhciA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1pbmltdW0gc2VnbWVudCBwZXJpb2RcclxuICAgICAqIEBuYW1lIHBlcmlvZE1pblxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDAxXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGVyaW9kTWluID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RNaW4sIDAuMDAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHNlZ21lbnQgcG9zaXRpb25zIChvbnNldCB0aW1lcyBpbiBhdWRpbyBidWZmZXIpIGluIHNlY1xyXG4gICAgICogQG5hbWUgcG9zaXRpb25BcnJheVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IFswLjBdXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zaXRpb25BcnJheSA9IG9wdE9yRGVmKG9wdGlvbnMucG9zaXRpb25BcnJheSwgWzAuMF0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW1vdXQgb2YgcmFuZG9tIHNlZ21lbnQgcG9zaXRpb24gdmFyaWF0aW9uIGluIHNlY1xyXG4gICAgICogQG5hbWUgcG9zaXRpb25WYXJcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zaXRpb25WYXIgPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHNlZ21lbnQgZHVyYXRpb25zIGluIHNlY1xyXG4gICAgICogQG5hbWUgZHVyYXRpb25BcnJheVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IFswLjBdXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHVyYXRpb25BcnJheSA9IG9wdE9yRGVmKG9wdGlvbnMuZHVyYXRpb25BcnJheSwgWzAuMF0pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzb2x1dGUgc2VnbWVudCBkdXJhdGlvbiBpbiBzZWNcclxuICAgICAqIEBuYW1lIGR1cmF0aW9uQWJzXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmR1cmF0aW9uQWJzID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvbkFicywgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWdtZW50IGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdpdmVuIHNlZ21lbnQgZHVyYXRpb24gb3IgaW50ZXItc2VnbWVudCBkaXN0YW5jZVxyXG4gICAgICogQG5hbWUgZHVyYXRpb25SZWxcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHVyYXRpb25SZWwgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uUmVsLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHNlZ21lbnQgb2Zmc2V0cyBpbiBzZWNcclxuICAgICAqXHJcbiAgICAgKiBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICogb2Zmc2V0IDwgMDogdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb24gaXMgdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb25cclxuICAgICAqIGFuZCB0aGUgZHVyYXRpb24gaGFzIHRvIGJlIGNvcnJlY3RlZCBieSB0aGUgb2Zmc2V0XHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgb2Zmc2V0QXJyYXlcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqIEBkZWZhdWx0IFswLjBdXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMub2Zmc2V0QXJyYXkgPSBvcHRPckRlZihvcHRpb25zLm9mZnNldEFycmF5LCBbMC4wXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBzZWdtZW50IG9mZnNldCBpbiBzZWNcclxuICAgICAqIEBuYW1lIG9mZnNldEFic1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IC0wLjAwNVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9mZnNldEFicyA9IG9wdE9yRGVmKG9wdGlvbnMub2Zmc2V0QWJzLCAtMC4wMDUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VnbWVudCBvZmZzZXQgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICogQG5hbWUgb2Zmc2V0UmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLm9mZnNldFJlbCA9IG9wdE9yRGVmKG9wdGlvbnMub2Zmc2V0UmVsLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRpbWUgYnkgd2hpY2ggYWxsIHNlZ21lbnRzIGFyZSBkZWxheWVkIChlc3BlY2lhbGx5IHRvIHJlYWxpemUgc2VnbWVudCBvZmZzZXRzKVxyXG4gICAgICogQG5hbWUgZGVsYXlcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmRlbGF5ID0gb3B0T3JEZWYob3B0aW9ucy5kZWxheSwgMC4wMDUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzb2x1dGUgYXR0YWNrIHRpbWUgaW4gc2VjXHJcbiAgICAgKiBAbmFtZSBhdHRhY2tBYnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmF0dGFja0FicyA9IG9wdE9yRGVmKG9wdGlvbnMuYXR0YWNrQWJzLCAwLjAwNSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdHRhY2sgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXHJcbiAgICAgKiBAbmFtZSBhdHRhY2tSZWxcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXR0YWNrUmVsID0gb3B0T3JEZWYob3B0aW9ucy5hdHRhY2tSZWwsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWJzb2x1dGUgcmVsZWFzZSB0aW1lIGluIHNlY1xyXG4gICAgICogQG5hbWUgcmVsZWFzZUFic1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZUFicyA9IG9wdE9yRGVmKG9wdGlvbnMucmVsZWFzZUFicywgMC4wMDUpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVsZWFzZSB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAqIEBuYW1lIHJlbGVhc2VSZWxcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZVJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucmVsZWFzZVJlbCwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWdtZW50IHJlc2FtcGxpbmcgaW4gY2VudFxyXG4gICAgICogQG5hbWUgcmVzYW1wbGluZ1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNhbXBsaW5nID0gb3B0T3JEZWYob3B0aW9ucy5yZXNhbXBsaW5nLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSByZXNhbXBsaW5nIHZhcmlhdGlvbiBpbiBjZW50XHJcbiAgICAgKiBAbmFtZSByZXNhbXBsaW5nVmFyXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc2FtcGxpbmdWYXIgPSBvcHRPckRlZihvcHRpb25zLnJlc2FtcGxpbmdWYXIsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTGluZWFyIGdhaW4gZmFjdG9yXHJcbiAgICAgKiBAbmFtZSBnYWluXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmdhaW4gPSBvcHRPckRlZihvcHRpb25zLmdhaW4sIDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kZXggb2YgdGhlIHNlZ21lbnQgdG8gc3ludGhlc2l6ZSAoaS5lLiBvZiB0aGlzLnBvc2l0aW9uQXJyYXkvZHVyYXRpb25BcnJheS9vZmZzZXRBcnJheSlcclxuICAgICAqIEBuYW1lIHNlZ21lbnRJbmRleFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5zZWdtZW50SW5kZXggPSBvcHRPckRlZihvcHRpb25zLnNlZ21lbnRJbmRleCwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgYW5kIHNlZ21lbnQgaW5kaWNlcyBhcmUgY29uc2lkZXJlZCBhcyBjeWNsaWNcclxuICAgICAqIEBuYW1lIGN5Y2xpY1xyXG4gICAgICogQHR5cGUge0Jvb2x9XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmN5Y2xpYyA9IG9wdE9yRGVmKG9wdGlvbnMuY3ljbGljLCBmYWxzZSk7XHJcbiAgICB0aGlzLl9fY3ljbGljT2Zmc2V0ID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGxhc3Qgc2VnbWVudCBpcyBhYm9ydGVkIHdoZW4gdHJpZ2dlcmluZyB0aGUgbmV4dFxyXG4gICAgICogQG5hbWUgbW9ub3Bob25pY1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubW9ub3Bob25pYyA9IG9wdE9yRGVmKG9wdGlvbnMubW9ub3Bob25pYywgZmFsc2UpO1xyXG4gICAgdGhpcy5fX2N1cnJlbnRTcmMgPSBudWxsO1xyXG4gICAgdGhpcy5fX2N1cnJlbnRFbnYgPSBudWxsO1xyXG4gICAgdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUgPSAwO1xyXG4gICAgdGhpcy5fX2N1cnJlbnRHYWluID0gMDtcclxuICAgIHRoaXMuX19jdXJyZW50RW5kVGltZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGYWRlLW91dCB0aW1lICh3aGVuIGFib3J0ZWQpXHJcbiAgICAgKiBAbmFtZSBhYm9ydFRpbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmFib3J0VGltZSA9IG9wdE9yRGVmKG9wdGlvbnMuYWJvcnRUaW1lLCAwLjAwNSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQb3J0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGF1ZGlvIGJ1ZmZlciB0aGF0IGhhcyBiZWVuIGNvcGllZCBmcm9tIHRoZSBiZWdpbm5pbmcgdG8gYXNzdXJlIGN5Y2xpYyBiZWhhdmlvclxyXG4gICAgICogQG5hbWUgd3JhcEFyb3VuZEV4dGVuc2lvblxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy53cmFwQXJvdW5kRXh0ZW5zaW9uID0gb3B0T3JEZWYob3B0aW9ucy53cmFwQXJvdW5kRXh0ZW5zaW9uLCAwKTtcclxuXHJcbiAgICB0aGlzLm91dHB1dE5vZGUgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYnVmZmVyIGR1cmF0aW9uIChleGNsdWRpbmcgd3JhcEFyb3VuZEV4dGVuc2lvbilcclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQGRlZmF1bHQgMFxyXG4gICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcbiAgZ2V0IGJ1ZmZlckR1cmF0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XHJcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xyXG5cclxuICAgICAgaWYgKHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbilcclxuICAgICAgICBidWZmZXJEdXJhdGlvbiAtPSB0aGlzLndyYXBBcm91bmRFeHRlbnNpb247XHJcblxyXG4gICAgICByZXR1cm4gYnVmZmVyRHVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAodHJhbnNwb3J0ZWQgaW50ZXJmYWNlKVxyXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcclxuICAgIHRpbWUgPSBNYXRoLm1heCh0aW1lLCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSk7XHJcbiAgICByZXR1cm4gdGltZSArIHRoaXMudHJpZ2dlcih0aW1lKTtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXHJcbiAgc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5zZWdtZW50SW5kZXg7XHJcbiAgICB2YXIgY3ljbGljT2Zmc2V0ID0gMDtcclxuICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgaWYgKHRoaXMuY3ljbGljKSB7XHJcbiAgICAgIHZhciBjeWNsZXMgPSBwb3NpdGlvbiAvIGJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgICAgY3ljbGljT2Zmc2V0ID0gTWF0aC5mbG9vcihjeWNsZXMpICogYnVmZmVyRHVyYXRpb247XHJcbiAgICAgIHBvc2l0aW9uIC09IGN5Y2xpY09mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3BlZWQgPiAwKSB7XHJcbiAgICAgIGluZGV4ID0gZ2V0Q3VycmVudE9yTmV4dEluZGV4KHRoaXMucG9zaXRpb25BcnJheSwgcG9zaXRpb24pO1xyXG5cclxuICAgICAgaWYgKGluZGV4ID49IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGgpIHtcclxuICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgY3ljbGljT2Zmc2V0ICs9IGJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuY3ljbGljKVxyXG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHNwZWVkIDwgMCkge1xyXG4gICAgICBpbmRleCA9IGdldEN1cnJlbnRPclByZXZpb3VzSW5kZXgodGhpcy5wb3NpdGlvbkFycmF5LCBwb3NpdGlvbik7XHJcblxyXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgaW5kZXggPSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoIC0gMTtcclxuICAgICAgICBjeWNsaWNPZmZzZXQgLT0gYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jeWNsaWMpXHJcbiAgICAgICAgICByZXR1cm4gLUluZmluaXR5O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZWdtZW50SW5kZXggPSBpbmRleDtcclxuICAgIHRoaXMuX19jeWNsaWNPZmZzZXQgPSBjeWNsaWNPZmZzZXQ7XHJcblxyXG4gICAgcmV0dXJuIGN5Y2xpY09mZnNldCArIHRoaXMucG9zaXRpb25BcnJheVtpbmRleF07XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAodHJhbnNwb3J0ZWQgaW50ZXJmYWNlKVxyXG4gIGFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIHZhciBpbmRleCA9IHRoaXMuc2VnbWVudEluZGV4O1xyXG4gICAgdmFyIGN5Y2xpY09mZnNldCA9IHRoaXMuX19jeWNsaWNPZmZzZXQ7XHJcblxyXG4gICAgdGhpcy50cmlnZ2VyKHRpbWUpO1xyXG5cclxuICAgIGlmIChzcGVlZCA+IDApIHtcclxuICAgICAgaW5kZXgrKztcclxuXHJcbiAgICAgIGlmIChpbmRleCA+PSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgIGN5Y2xpY09mZnNldCArPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgICAgICBpZiAoIXRoaXMuY3ljbGljKVxyXG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpbmRleC0tO1xyXG5cclxuICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgIGluZGV4ID0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgY3ljbGljT2Zmc2V0IC09IHRoaXMuYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jeWNsaWMpXHJcbiAgICAgICAgICByZXR1cm4gLUluZmluaXR5O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZWdtZW50SW5kZXggPSBpbmRleDtcclxuICAgIHRoaXMuX19jeWNsaWNPZmZzZXQgPSBjeWNsaWNPZmZzZXQ7XHJcblxyXG4gICAgcmV0dXJuIGN5Y2xpY09mZnNldCArIHRoaXMucG9zaXRpb25BcnJheVtpbmRleF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmlnZ2VyIGEgc2VnbWVudC5cclxuICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgYXQgYW55IHRpbWUgKHdoZXRoZXIgdGhlIGVuZ2luZSBpcyBzY2hlZHVsZWQvdHJhbnNwb3J0ZWQgb3Igbm90KVxyXG4gICAqIHRvIGdlbmVyYXRlIGEgc2luZ2xlIHNlZ21lbnQgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHNlZ21lbnQgcGFyYW1ldGVycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIHNlZ21lbnQgc3ludGhlc2lzIGF1ZGlvIHRpbWVcclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHBlcmlvZCB0byBuZXh0IHNlZ21lbnRcclxuICAgKi9cclxuICB0cmlnZ2VyKHRpbWUpIHtcclxuICAgIHZhciBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcclxuICAgIHZhciBzZWdtZW50VGltZSA9ICh0aW1lIHx8IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSkgKyB0aGlzLmRlbGF5O1xyXG4gICAgdmFyIHNlZ21lbnRQZXJpb2QgPSB0aGlzLnBlcmlvZEFicztcclxuICAgIHZhciBzZWdtZW50SW5kZXggPSB0aGlzLnNlZ21lbnRJbmRleDtcclxuXHJcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcclxuICAgICAgdmFyIHNlZ21lbnRQb3NpdGlvbiA9IDAuMDtcclxuICAgICAgdmFyIHNlZ21lbnREdXJhdGlvbiA9IDAuMDtcclxuICAgICAgdmFyIHNlZ21lbnRPZmZzZXQgPSAwLjA7XHJcbiAgICAgIHZhciByZXNhbXBsaW5nUmF0ZSA9IDEuMDtcclxuICAgICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgIGlmICh0aGlzLmN5Y2xpYylcclxuICAgICAgICBzZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXggJSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoO1xyXG4gICAgICBlbHNlXHJcbiAgICAgICAgc2VnbWVudEluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VnbWVudEluZGV4LCB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoIC0gMSkpO1xyXG5cclxuICAgICAgaWYgKHRoaXMucG9zaXRpb25BcnJheSlcclxuICAgICAgICBzZWdtZW50UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uQXJyYXlbc2VnbWVudEluZGV4XSB8fCAwO1xyXG5cclxuICAgICAgaWYgKHRoaXMuZHVyYXRpb25BcnJheSlcclxuICAgICAgICBzZWdtZW50RHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uQXJyYXlbc2VnbWVudEluZGV4XSB8fCAwO1xyXG5cclxuICAgICAgaWYgKHRoaXMub2Zmc2V0QXJyYXkpXHJcbiAgICAgICAgc2VnbWVudE9mZnNldCA9IHRoaXMub2Zmc2V0QXJyYXlbc2VnbWVudEluZGV4XSB8fCAwO1xyXG5cclxuICAgICAgLy8gY2FsY3VsYXRlIHJlc2FtcGxpbmdcclxuICAgICAgaWYgKHRoaXMucmVzYW1wbGluZyAhPT0gMCB8fCB0aGlzLnJlc2FtcGxpbmdWYXIgPiAwKSB7XHJcbiAgICAgICAgdmFyIHJhbmRvbVJlc2FtcGxpbmcgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyLjAgKiB0aGlzLnJlc2FtcGxpbmdWYXI7XHJcbiAgICAgICAgcmVzYW1wbGluZ1JhdGUgPSBNYXRoLnBvdygyLjAsICh0aGlzLnJlc2FtcGxpbmcgKyByYW5kb21SZXNhbXBsaW5nKSAvIDEyMDAuMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGNhbGN1bGF0ZSBpbnRlci1zZWdtZW50IGRpc3RhbmNlXHJcbiAgICAgIGlmIChzZWdtZW50RHVyYXRpb24gPT09IDAgfHwgdGhpcy5wZXJpb2RSZWwgPiAwKSB7XHJcbiAgICAgICAgdmFyIG5leHRTZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXggKyAxO1xyXG4gICAgICAgIHZhciBuZXh0UG9zaXRpb24sIG5leHRPZmZzZXQ7XHJcblxyXG4gICAgICAgIGlmIChuZXh0U2VnbWVudEluZGV4ID09PSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5jeWNsaWMpIHtcclxuICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkFycmF5WzBdICsgYnVmZmVyRHVyYXRpb247XHJcbiAgICAgICAgICAgIG5leHRPZmZzZXQgPSB0aGlzLm9mZnNldEFycmF5WzBdO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gYnVmZmVyRHVyYXRpb247XHJcbiAgICAgICAgICAgIG5leHRPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uQXJyYXlbbmV4dFNlZ21lbnRJbmRleF07XHJcbiAgICAgICAgICBuZXh0T2Zmc2V0ID0gdGhpcy5vZmZzZXRBcnJheVtuZXh0U2VnbWVudEluZGV4XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpbnRlclNlZ21lbnREaXN0YW5jZSA9IG5leHRQb3NpdGlvbiAtIHNlZ21lbnRQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgLy8gY29ycmVjdCBpbnRlci1zZWdtZW50IGRpc3RhbmNlIGJ5IG9mZnNldHNcclxuICAgICAgICAvLyAgIG9mZnNldCA+IDA6IHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGlzIGFmdGVyIHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uXHJcbiAgICAgICAgaWYgKHNlZ21lbnRPZmZzZXQgPiAwKVxyXG4gICAgICAgICAgaW50ZXJTZWdtZW50RGlzdGFuY2UgLT0gc2VnbWVudE9mZnNldDtcclxuXHJcbiAgICAgICAgaWYgKG5leHRPZmZzZXQgPiAwKVxyXG4gICAgICAgICAgaW50ZXJTZWdtZW50RGlzdGFuY2UgKz0gbmV4dE9mZnNldDtcclxuXHJcbiAgICAgICAgaWYgKGludGVyU2VnbWVudERpc3RhbmNlIDwgMClcclxuICAgICAgICAgIGludGVyU2VnbWVudERpc3RhbmNlID0gMDtcclxuXHJcbiAgICAgICAgLy8gdXNlIGludGVyLXNlZ21lbnQgZGlzdGFuY2UgaW5zdGVhZCBvZiBzZWdtZW50IGR1cmF0aW9uXHJcbiAgICAgICAgaWYgKHNlZ21lbnREdXJhdGlvbiA9PT0gMClcclxuICAgICAgICAgIHNlZ21lbnREdXJhdGlvbiA9IGludGVyU2VnbWVudERpc3RhbmNlO1xyXG5cclxuICAgICAgICAvLyBjYWxjdWxhdGUgcGVyaW9kIHJlbGF0aXZlIHRvIGludGVyIG1hcmtlciBkaXN0YW5jZVxyXG4gICAgICAgIHNlZ21lbnRQZXJpb2QgKz0gdGhpcy5wZXJpb2RSZWwgKiBpbnRlclNlZ21lbnREaXN0YW5jZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWRkIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uXHJcbiAgICAgIHNlZ21lbnREdXJhdGlvbiAqPSB0aGlzLmR1cmF0aW9uUmVsO1xyXG4gICAgICBzZWdtZW50RHVyYXRpb24gKz0gdGhpcy5kdXJhdGlvbkFicztcclxuXHJcbiAgICAgIC8vIGFkZCByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgc2VnbWVudCBvZmZzZXRcclxuICAgICAgc2VnbWVudE9mZnNldCAqPSB0aGlzLm9mZnNldFJlbDtcclxuICAgICAgc2VnbWVudE9mZnNldCArPSB0aGlzLm9mZnNldEFicztcclxuXHJcbiAgICAgIC8vIGFwcGx5IHNlZ21lbnQgb2Zmc2V0XHJcbiAgICAgIC8vICAgb2Zmc2V0ID4gMDogdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gaXMgYWZ0ZXIgdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb25cclxuICAgICAgLy8gICBvZmZzZXQgPCAwOiB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvbiBpcyB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBhbmQgdGhlIGR1cmF0aW9uIGhhcyB0byBiZSBjb3JyZWN0ZWQgYnkgdGhlIG9mZnNldFxyXG4gICAgICBpZiAoc2VnbWVudE9mZnNldCA8IDApIHtcclxuICAgICAgICBzZWdtZW50RHVyYXRpb24gLT0gc2VnbWVudE9mZnNldDtcclxuICAgICAgICBzZWdtZW50UG9zaXRpb24gKz0gc2VnbWVudE9mZnNldDtcclxuICAgICAgICBzZWdtZW50VGltZSArPSAoc2VnbWVudE9mZnNldCAvIHJlc2FtcGxpbmdSYXRlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzZWdtZW50VGltZSAtPSAoc2VnbWVudE9mZnNldCAvIHJlc2FtcGxpbmdSYXRlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gcmFuZG9taXplIHNlZ21lbnQgcG9zaXRpb25cclxuICAgICAgaWYgKHRoaXMucG9zaXRpb25WYXIgPiAwKVxyXG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiArPSAyLjAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLnBvc2l0aW9uVmFyO1xyXG5cclxuICAgICAgLy8gc2hvcnRlbiBkdXJhdGlvbiBvZiBzZWdtZW50cyBvdmVyIHRoZSBlZGdlcyBvZiB0aGUgYnVmZmVyXHJcbiAgICAgIGlmIChzZWdtZW50UG9zaXRpb24gPCAwKSB7XHJcbiAgICAgICAgLy9zZWdtZW50VGltZSAtPSBncmFpblBvc2l0aW9uOyBobSwgbm90IHN1cmUgaWYgd2Ugd2FudCB0byBkbyB0aGlzXHJcbiAgICAgICAgc2VnbWVudER1cmF0aW9uICs9IHNlZ21lbnRQb3NpdGlvbjtcclxuICAgICAgICBzZWdtZW50UG9zaXRpb24gPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2VnbWVudFBvc2l0aW9uICsgc2VnbWVudER1cmF0aW9uID4gdGhpcy5idWZmZXIuZHVyYXRpb24pXHJcbiAgICAgICAgc2VnbWVudER1cmF0aW9uID0gdGhpcy5idWZmZXIuZHVyYXRpb24gLSBzZWdtZW50UG9zaXRpb247XHJcblxyXG4gICAgICBzZWdtZW50RHVyYXRpb24gLz0gcmVzYW1wbGluZ1JhdGU7XHJcblxyXG4gICAgICBpZiAodGhpcy5tb25vcGhvbmljKVxyXG4gICAgICAgIHRoaXMuYWJvcnQoc2VnbWVudFRpbWUpO1xyXG5cclxuICAgICAgLy8gbWFrZSBzZWdtZW50XHJcbiAgICAgIGlmICh0aGlzLmdhaW4gPiAwICYmIHNlZ21lbnREdXJhdGlvbiA+IDApIHtcclxuICAgICAgICAvLyBtYWtlIHNlZ21lbnQgZW52ZWxvcGVcclxuICAgICAgICB2YXIgZW52ZWxvcGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHZhciBhdHRhY2sgPSB0aGlzLmF0dGFja0FicyArIHRoaXMuYXR0YWNrUmVsICogc2VnbWVudER1cmF0aW9uO1xyXG4gICAgICAgIHZhciByZWxlYXNlID0gdGhpcy5yZWxlYXNlQWJzICsgdGhpcy5yZWxlYXNlUmVsICogc2VnbWVudER1cmF0aW9uO1xyXG5cclxuICAgICAgICBpZiAoYXR0YWNrICsgcmVsZWFzZSA+IHNlZ21lbnREdXJhdGlvbikge1xyXG4gICAgICAgICAgdmFyIGZhY3RvciA9IHNlZ21lbnREdXJhdGlvbiAvIChhdHRhY2sgKyByZWxlYXNlKTtcclxuICAgICAgICAgIGF0dGFjayAqPSBmYWN0b3I7XHJcbiAgICAgICAgICByZWxlYXNlICo9IGZhY3RvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBhdHRhY2tFbmRUaW1lID0gc2VnbWVudFRpbWUgKyBhdHRhY2s7XHJcbiAgICAgICAgdmFyIHNlZ21lbnRFbmRUaW1lID0gc2VnbWVudFRpbWUgKyBzZWdtZW50RHVyYXRpb247XHJcbiAgICAgICAgdmFyIHJlbGVhc2VTdGFydFRpbWUgPSBzZWdtZW50RW5kVGltZSAtIHJlbGVhc2U7XHJcblxyXG4gICAgICAgIGVudmVsb3BlLmdhaW4udmFsdWUgPSAwO1xyXG4gICAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMC4wLCBzZWdtZW50VGltZSk7XHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSh0aGlzLmdhaW4sIGF0dGFja0VuZFRpbWUpO1xyXG5cclxuICAgICAgICBpZiAocmVsZWFzZVN0YXJ0VGltZSA+IGF0dGFja0VuZFRpbWUpXHJcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgcmVsZWFzZVN0YXJ0VGltZSk7XHJcblxyXG4gICAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMC4wLCBzZWdtZW50RW5kVGltZSk7XHJcbiAgICAgICAgZW52ZWxvcGUuY29ubmVjdCh0aGlzLm91dHB1dE5vZGUpO1xyXG5cclxuICAgICAgICB0aGlzLl9fY3VycmVudEVudiA9IGVudmVsb3BlO1xyXG5cclxuICAgICAgICAvLyBtYWtlIHNvdXJjZVxyXG4gICAgICAgIHZhciBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcblxyXG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICBzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmVzYW1wbGluZ1JhdGU7XHJcbiAgICAgICAgc291cmNlLmNvbm5lY3QoZW52ZWxvcGUpO1xyXG5cclxuICAgICAgICBzb3VyY2Uuc3RhcnQoc2VnbWVudFRpbWUsIHNlZ21lbnRQb3NpdGlvbik7XHJcbiAgICAgICAgc291cmNlLnN0b3Aoc2VnbWVudFRpbWUgKyBzZWdtZW50RHVyYXRpb24pO1xyXG5cclxuICAgICAgICB0aGlzLl9fY3VycmVudFNyYyA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZSA9IHJlbGVhc2VTdGFydFRpbWU7XHJcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRHYWluID0gdGhpcy5nYWluO1xyXG4gICAgICAgIHRoaXMuX19jdXJyZW50RW5kVGltZSA9IHNlZ21lbnRFbmRUaW1lO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gZ3JhaW4gcGVyaW9kIHJhbmRvbiB2YXJpYXRpb25cclxuICAgIGlmICh0aGlzLnBlcmlvZFZhciA+IDAuMClcclxuICAgICAgc2VnbWVudFBlcmlvZCArPSAyLjAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLnBlcmlvZFZhciAqIGdyYWluUGVyaW9kO1xyXG5cclxuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnBlcmlvZE1pbiwgc2VnbWVudFBlcmlvZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBYm9ydCB0aGUgY3VycmVudCBzZWdtZW50IGF0IGdpdmVuIHRpbWUsIGZhZGUgb3V0IGR1cmF0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIGFib3J0IHRpbWVcclxuICAgKi9cclxuICBhYm9ydCh0aW1lKSB7XHJcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcclxuICAgIGNvbnN0IGVuZFRpbWUgPSB0aGlzLl9fY3VycmVudEVuZFRpbWU7XHJcbiAgICBjb25zdCBhYm9ydFRpbWUgPSB0aW1lIHx8IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcclxuXHJcbiAgICBpZiAoYWJvcnRUaW1lIDwgZW5kVGltZSkge1xyXG4gICAgICBjb25zdCBzZWdtZW50RW5kVGltZSA9IE1hdGgubWluKGFib3J0VGltZSArIHRoaXMuYWJvcnRUaW1lLCBlbmRUaW1lKTtcclxuICAgICAgY29uc3QgZW52ZWxvcGUgPSB0aGlzLl9fY3VycmVudEVudjtcclxuICAgICAgbGV0IGN1cnJlbnRHYWluVmFsdWUgPSB0aGlzLl9fY3VycmVudEdhaW47XHJcblxyXG4gICAgICBpZiAoYWJvcnRUaW1lID4gdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUpIHtcclxuICAgICAgICBjb25zdCByZWxlYXNlU3RhcnQgPSB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZTtcclxuICAgICAgICBjdXJyZW50R2FpblZhbHVlICo9IChhYm9ydFRpbWUgLSByZWxlYXNlU3RhcnQpIC8gKGVuZFRpbWUgLSByZWxlYXNlU3RhcnQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbnZlbG9wZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhhYm9ydFRpbWUpO1xyXG4gICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKGN1cnJlbnRHYWluVmFsdWUsIGFib3J0VGltZSk7XHJcbiAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgc2VnbWVudEVuZFRpbWUpO1xyXG5cclxuICAgICAgdGhpcy5fX2N1cnJlbnRTcmMgPSBudWxsO1xyXG4gICAgICB0aGlzLl9fY3VycmVudEVudiA9IG51bGw7XHJcbiAgICAgIHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lID0gMDtcclxuICAgICAgdGhpcy5fX2N1cnJlbnRHYWluID0gMDtcclxuICAgICAgdGhpcy5fX2N1cnJlbnRFbmRUaW1lID0gMDtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNlZ21lbnRFbmdpbmU7XHJcbiIsImltcG9ydCBBdWRpb1RpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS9hdWRpby10aW1lLWVuZ2luZSc7XHJcbmltcG9ydCBTZWdtZW50RW5naW5lIGZyb20gJy4vc2VnbWVudC1lbmdpbmUnO1xyXG5cclxuZnVuY3Rpb24gb3B0T3JEZWYob3B0LCBkZWYpIHtcclxuICAgIGlmIChvcHQgIT09IHVuZGVmaW5lZClcclxuICAgICAgICByZXR1cm4gb3B0O1xyXG5cclxuICAgIHJldHVybiBkZWY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRPclByZXZpb3VzSW5kZXgoc29ydGVkQXJyYXksIHZhbHVlLCBpbmRleCA9IC0xKSB7XHJcbiAgICB2YXIgc2l6ZSA9IHNvcnRlZEFycmF5Lmxlbmd0aDtcclxuXHJcbiAgICBpZiAoc2l6ZSA+IDApIHtcclxuICAgICAgICB2YXIgZmlyc3RWYWwgPSBzb3J0ZWRBcnJheVswXTtcclxuICAgICAgICB2YXIgbGFzdFZhbCA9IHNvcnRlZEFycmF5W3NpemUgLSAxXTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlIDwgZmlyc3RWYWwpXHJcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XHJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPj0gbGFzdFZhbClcclxuICAgICAgICAgICAgaW5kZXggPSBzaXplIC0gMTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKVxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChzaXplIC0gMSkgKiAodmFsdWUgLSBmaXJzdFZhbCkgLyAobGFzdFZhbCAtIGZpcnN0VmFsKSk7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXhdID4gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICBpbmRleC0tO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4ICsgMV0gPD0gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5kZXg7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRPck5leHRJbmRleChzb3J0ZWRBcnJheSwgdmFsdWUsIGluZGV4ID0gLTEpIHtcclxuICAgIHZhciBzaXplID0gc29ydGVkQXJyYXkubGVuZ3RoO1xyXG5cclxuICAgIGlmIChzaXplID4gMCkge1xyXG4gICAgICAgIHZhciBmaXJzdFZhbCA9IHNvcnRlZEFycmF5WzBdO1xyXG4gICAgICAgIHZhciBsYXN0VmFsID0gc29ydGVkQXJyYXlbc2l6ZSAtIDFdO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUgPD0gZmlyc3RWYWwpXHJcbiAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA+PSBsYXN0VmFsKVxyXG4gICAgICAgICAgICBpbmRleCA9IHNpemU7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2l6ZSlcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoc2l6ZSAtIDEpICogKHZhbHVlIC0gZmlyc3RWYWwpIC8gKGxhc3RWYWwgLSBmaXJzdFZhbCkpO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4XSA8IHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgaW5kZXgrKztcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleCAtIDFdID49IHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgaW5kZXgtLTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG59XHJcblxyXG4vKipcclxuICogQGNsYXNzIFNlcXVlbmNlckVuZ2luZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VxdWVuY2VyRW5naW5lIGV4dGVuZHMgU2VnbWVudEVuZ2luZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICogQHBhcmFtIHtBdWRpb0J1ZmZlcn0gYnVmZmVyIGluaXRpYWwgYXVkaW8gYnVmZmVyIGZvciBncmFudWxhciBzeW50aGVzaXNcclxuICAgICAqXHJcbiAgICAgKiBUaGUgZW5naW5lIGltcGxlbWVudHMgdGhlIFwic2NoZWR1bGVkXCIgYW5kIFwidHJhbnNwb3J0ZWRcIiBpbnRlcmZhY2VzLlxyXG4gICAgICogV2hlbiBcInNjaGVkdWxlZFwiLCB0aGUgZW5naW5lICBnZW5lcmF0ZXMgc2VnbWVudHMgbW9yZSBvciBsZXNzwqBwZXJpb2RpY2FsbHlcclxuICAgICAqIChjb250cm9sbGVkIGJ5IHRoZSBwZXJpb2RBYnMsIHBlcmlvZFJlbCwgYW5kIHBlcmlvVmFyIGF0dHJpYnV0ZXMpLlxyXG4gICAgICogV2hlbiBcInRyYW5zcG9ydGVkXCIsIHRoZSBlbmdpbmUgZ2VuZXJhdGVzIHNlZ21lbnRzIGF0IHRoZSBwb3NpdGlvbiBvZiB0aGVpciBvbnNldCB0aW1lLlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZ1bmN0aW9uIGNhbGxiYWNrIHRoYXQgZ2V0cyBjYWxsZWQgZnJvbSB0cmlnZ2VyKCkuXHJcbiAgICAgICAgICogVGhpcyBsZXRzIHlvdSBzZXQgdXAgZXZlbnRzIHRvIGJlIHRyaWdnZXJlZCBieSB0aGUgc2VxdWVuY2VyLlxyXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gb3B0T3JEZWYob3B0aW9ucy5jYWxsYmFjaywgbnVsbCk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHJpZ2dlciBhIHNlZ21lbnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIHNlZ21lbnQgc3ludGhlc2lzIGF1ZGlvIHRpbWVcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gcGVyaW9kIHRvIG5leHQgc2VnbWVudFxyXG4gICAgICpcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCBhdCBhbnkgdGltZSAod2hldGhlciB0aGUgZW5naW5lIGlzIHNjaGVkdWxlZC90cmFuc3BvcnRlZCBvciBub3QpXHJcbiAgICAgKiB0byBnZW5lcmF0ZSBhIHNpbmdsZSBzZWdtZW50IGFjY29yZGluZyB0byB0aGUgY3VycmVudCBzZWdtZW50IHBhcmFtZXRlcnMuXHJcbiAgICAgKi9cclxuICAgIHRyaWdnZXIodGltZSkge1xyXG4gICAgICAgIHZhciBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcclxuICAgICAgICB2YXIgc2VnbWVudFRpbWUgPSAodGltZSB8fCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWUpICsgdGhpcy5kZWxheTtcclxuICAgICAgICB2YXIgc2VnbWVudFBlcmlvZCA9IHRoaXMucGVyaW9kQWJzO1xyXG4gICAgICAgIHZhciBzZWdtZW50SW5kZXggPSB0aGlzLnNlZ21lbnRJbmRleDtcclxuXHJcbiAgICAgICAgLy8gSWdub3JlIGJ1ZmZlciBmb3Igbm93LCB0aGlzIGlzIGEgc2VxdW5jZXIuLi4gbm8gYXVkaW8gcHJvZHVjZWQuXHJcbiAgICAgICAgaWYgKCAvKnRoaXMuYnVmZmVyKi8gdHJ1ZSkge1xyXG4gICAgICAgICAgICB2YXIgc2VnbWVudFBvc2l0aW9uID0gMC4wO1xyXG4gICAgICAgICAgICB2YXIgc2VnbWVudER1cmF0aW9uID0gMC4wO1xyXG4gICAgICAgICAgICB2YXIgc2VnbWVudE9mZnNldCA9IDAuMDtcclxuICAgICAgICAgICAgdmFyIHJlc2FtcGxpbmdSYXRlID0gMS4wO1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMuY3ljbGljKVxyXG4gICAgICAgICAgICAgICAgc2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4ICUgdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aDtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgc2VnbWVudEluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oc2VnbWVudEluZGV4LCB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoIC0gMSkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMucG9zaXRpb25BcnJheSlcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5kdXJhdGlvbkFycmF5KVxyXG4gICAgICAgICAgICAgICAgc2VnbWVudER1cmF0aW9uID0gdGhpcy5kdXJhdGlvbkFycmF5W3NlZ21lbnRJbmRleF0gfHwgMDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9mZnNldEFycmF5KVxyXG4gICAgICAgICAgICAgICAgc2VnbWVudE9mZnNldCA9IHRoaXMub2Zmc2V0QXJyYXlbc2VnbWVudEluZGV4XSB8fCAwO1xyXG5cclxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHJlc2FtcGxpbmdcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVzYW1wbGluZyAhPT0gMCB8fCB0aGlzLnJlc2FtcGxpbmdWYXIgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmFuZG9tUmVzYW1wbGluZyA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIuMCAqIHRoaXMucmVzYW1wbGluZ1ZhcjtcclxuICAgICAgICAgICAgICAgIHJlc2FtcGxpbmdSYXRlID0gTWF0aC5wb3coMi4wLCAodGhpcy5yZXNhbXBsaW5nICsgcmFuZG9tUmVzYW1wbGluZykgLyAxMjAwLjApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgaW50ZXItc2VnbWVudCBkaXN0YW5jZVxyXG4gICAgICAgICAgICBpZiAoc2VnbWVudER1cmF0aW9uID09PSAwIHx8IHRoaXMucGVyaW9kUmVsID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRTZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXggKyAxO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRQb3NpdGlvbiwgbmV4dE9mZnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFNlZ21lbnRJbmRleCA9PT0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN5Y2xpYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uQXJyYXlbMF0gKyBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE9mZnNldCA9IHRoaXMub2Zmc2V0QXJyYXlbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gYnVmZmVyRHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkFycmF5W25leHRTZWdtZW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRPZmZzZXQgPSB0aGlzLm9mZnNldEFycmF5W25leHRTZWdtZW50SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbnRlclNlZ21lbnREaXN0YW5jZSA9IG5leHRQb3NpdGlvbiAtIHNlZ21lbnRQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBjb3JyZWN0IGludGVyLXNlZ21lbnQgZGlzdGFuY2UgYnkgb2Zmc2V0c1xyXG4gICAgICAgICAgICAgICAgLy8gICBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICAgICAgICAgICAgaWYgKHNlZ21lbnRPZmZzZXQgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGludGVyU2VnbWVudERpc3RhbmNlIC09IHNlZ21lbnRPZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRPZmZzZXQgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGludGVyU2VnbWVudERpc3RhbmNlICs9IG5leHRPZmZzZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGludGVyU2VnbWVudERpc3RhbmNlIDwgMClcclxuICAgICAgICAgICAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gdXNlIGludGVyLXNlZ21lbnQgZGlzdGFuY2UgaW5zdGVhZCBvZiBzZWdtZW50IGR1cmF0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudER1cmF0aW9uID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHNlZ21lbnREdXJhdGlvbiA9IGludGVyU2VnbWVudERpc3RhbmNlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBwZXJpb2QgcmVsYXRpdmUgdG8gaW50ZXIgbWFya2VyIGRpc3RhbmNlXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50UGVyaW9kICs9IHRoaXMucGVyaW9kUmVsICogaW50ZXJTZWdtZW50RGlzdGFuY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgLy8gYWRkIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uXHJcbiAgICAgICAgICAgIHNlZ21lbnREdXJhdGlvbiAqPSB0aGlzLmR1cmF0aW9uUmVsO1xyXG4gICAgICAgICAgICBzZWdtZW50RHVyYXRpb24gKz0gdGhpcy5kdXJhdGlvbkFicztcclxuXHJcbiAgICAgICAgICAgIC8vIGFkZCByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgc2VnbWVudCBvZmZzZXRcclxuICAgICAgICAgICAgc2VnbWVudE9mZnNldCAqPSB0aGlzLm9mZnNldFJlbDtcclxuICAgICAgICAgICAgc2VnbWVudE9mZnNldCArPSB0aGlzLm9mZnNldEFicztcclxuXHJcbiAgICAgICAgICAgIC8vIGFwcGx5IHNlZ21lbnQgb2Zmc2V0XHJcbiAgICAgICAgICAgIC8vICAgb2Zmc2V0ID4gMDogdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gaXMgYWZ0ZXIgdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb25cclxuICAgICAgICAgICAgLy8gICBvZmZzZXQgPCAwOiB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvbiBpcyB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBhbmQgdGhlIGR1cmF0aW9uIGhhcyB0byBiZSBjb3JyZWN0ZWQgYnkgdGhlIG9mZnNldFxyXG4gICAgICAgICAgICBpZiAoc2VnbWVudE9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnREdXJhdGlvbiAtPSBzZWdtZW50T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudFBvc2l0aW9uICs9IHNlZ21lbnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50VGltZSArPSAoc2VnbWVudE9mZnNldCAvIHJlc2FtcGxpbmdSYXRlKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRUaW1lIC09IChzZWdtZW50T2Zmc2V0IC8gcmVzYW1wbGluZ1JhdGUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyByYW5kb21pemUgc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvblZhciA+IDApXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50UG9zaXRpb24gKz0gMi4wICogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogdGhpcy5wb3NpdGlvblZhcjtcclxuXHJcbiAgICAgICAgICAgIC8vIHNob3J0ZW4gZHVyYXRpb24gb2Ygc2VnbWVudHMgb3ZlciB0aGUgZWRnZXMgb2YgdGhlIGJ1ZmZlclxyXG4gICAgICAgICAgICBpZiAoc2VnbWVudFBvc2l0aW9uIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgLy9zZWdtZW50VGltZSAtPSBncmFpblBvc2l0aW9uOyBobSwgbm90IHN1cmUgaWYgd2Ugd2FudCB0byBkbyB0aGlzXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50RHVyYXRpb24gKz0gc2VnbWVudFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudFBvc2l0aW9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNlZ21lbnRQb3NpdGlvbiArIHNlZ21lbnREdXJhdGlvbiA+IHRoaXMuYnVmZmVyLmR1cmF0aW9uKVxyXG4gICAgICAgICAgICAgICAgc2VnbWVudER1cmF0aW9uID0gdGhpcy5idWZmZXIuZHVyYXRpb24gLSBzZWdtZW50UG9zaXRpb247XHJcblxyXG4gICAgICAgICAgICBzZWdtZW50RHVyYXRpb24gLz0gcmVzYW1wbGluZ1JhdGU7XHJcblxyXG4gICAgICAgICAgICAvLyBtYWtlIHNlZ21lbnRcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2FpbiA+IDAgJiYgc2VnbWVudER1cmF0aW9uID4gMCkge1xyXG4gICAgICAgICAgICAgIC8vIG1ha2Ugc2VnbWVudCBlbnZlbG9wZVxyXG4gICAgICAgICAgICAgIHZhciBlbnZlbG9wZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgICAgICAgdmFyIGF0dGFjayA9IHRoaXMuYXR0YWNrQWJzICsgdGhpcy5hdHRhY2tSZWwgKiBzZWdtZW50RHVyYXRpb247XHJcbiAgICAgICAgICAgICAgdmFyIHJlbGVhc2UgPSB0aGlzLnJlbGVhc2VBYnMgKyB0aGlzLnJlbGVhc2VSZWwgKiBzZWdtZW50RHVyYXRpb247XHJcblxyXG4gICAgICAgICAgICAgIGlmIChhdHRhY2sgKyByZWxlYXNlID4gc2VnbWVudER1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFjdG9yID0gc2VnbWVudER1cmF0aW9uIC8gKGF0dGFjayArIHJlbGVhc2UpO1xyXG4gICAgICAgICAgICAgICAgYXR0YWNrICo9IGZhY3RvcjtcclxuICAgICAgICAgICAgICAgIHJlbGVhc2UgKj0gZmFjdG9yO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgdmFyIGF0dGFja0VuZFRpbWUgPSBzZWdtZW50VGltZSArIGF0dGFjaztcclxuICAgICAgICAgICAgICB2YXIgc2VnbWVudEVuZFRpbWUgPSBzZWdtZW50VGltZSArIHNlZ21lbnREdXJhdGlvbjtcclxuICAgICAgICAgICAgICB2YXIgcmVsZWFzZVN0YXJ0VGltZSA9IHNlZ21lbnRFbmRUaW1lIC0gcmVsZWFzZTtcclxuXHJcbiAgICAgICAgICAgICAgZW52ZWxvcGUuZ2Fpbi52YWx1ZSA9IDA7XHJcbiAgICAgICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLjAsIHNlZ21lbnRUaW1lKTtcclxuICAgICAgICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyZWxlYXNlU3RhcnRUaW1lID4gYXR0YWNrRW5kVGltZSlcclxuICAgICAgICAgICAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5nYWluLCByZWxlYXNlU3RhcnRUaW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLjAsIHNlZ21lbnRFbmRUaW1lKTtcclxuICAgICAgICAgICAgICBlbnZlbG9wZS5jb25uZWN0KHRoaXMub3V0cHV0Tm9kZSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG1ha2Ugc291cmNlXHJcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuXHJcbiAgICAgICAgICAgICAgc291cmNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xyXG4gICAgICAgICAgICAgIHNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSByZXNhbXBsaW5nUmF0ZTtcclxuICAgICAgICAgICAgICBzb3VyY2UuY29ubmVjdChlbnZlbG9wZSk7XHJcblxyXG4gICAgICAgICAgICAgIHNvdXJjZS5zdGFydChzZWdtZW50VGltZSwgc2VnbWVudFBvc2l0aW9uKTtcclxuICAgICAgICAgICAgICBzb3VyY2Uuc3RvcChzZWdtZW50VGltZSArIHNlZ21lbnREdXJhdGlvbik7XHJcbiAgICAgICAgICAgIH0qL1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzLmNhbGxiYWNrKSA9PSAnW29iamVjdCBGdW5jdGlvbl0nKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNhbGxiYWNrKHNlZ21lbnRJbmRleCk7XHJcbiAgICAgICAgICAgIC8vaWYgKHJlc3VsdClcclxuICAgICAgICAgICAgLy8gICAgY29uc29sZS5sb2cocmVzdWx0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTZXF1ZW5jZXIuVHJpZ2dlcjogXCIgKyBzZWdtZW50SW5kZXggKyBcIiBQb3NpdGlvbjogXCIgKyBzZWdtZW50UG9zaXRpb24pO1xyXG5cclxuICAgICAgICAvLyBncmFpbiBwZXJpb2QgcmFuZG9uIHZhcmlhdGlvblxyXG4gICAgICAgIGlmICh0aGlzLnBlcmlvZFZhciA+IDAuMClcclxuICAgICAgICAgICAgc2VnbWVudFBlcmlvZCArPSAyLjAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLnBlcmlvZFZhciAqIGdyYWluUGVyaW9kO1xyXG5cclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5wZXJpb2RNaW4sIHNlZ21lbnRQZXJpb2QpO1xyXG4gICAgfVxyXG59IiwiLy8gY29yZVxyXG5leHBvcnQgeyBkZWZhdWx0IGFzIGF1ZGlvQ29udGV4dCB9IGZyb20gJy4vY29yZS9hdWRpby1jb250ZXh0JztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBUaW1lRW5naW5lIH0gZnJvbSAnLi9jb3JlL3RpbWUtZW5naW5lJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBBdWRpb1RpbWVFbmdpbmUgfSBmcm9tICcuL2NvcmUvYXVkaW8tdGltZS1lbmdpbmUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFByaW9yaXR5UXVldWUgfSBmcm9tICcuL2NvcmUvcHJpb3JpdHktcXVldWUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNjaGVkdWxpbmdRdWV1ZSB9IGZyb20gJy4vY29yZS9zY2hlZHVsaW5nLXF1ZXVlJztcclxuXHJcbi8vIGVuZ2luZXNcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBHcmFudWxhckVuZ2luZSB9IGZyb20gJy4vZW5naW5lcy9ncmFudWxhci1lbmdpbmUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1ldHJvbm9tZSB9IGZyb20gJy4vZW5naW5lcy9tZXRyb25vbWUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBsYXllckVuZ2luZSB9IGZyb20gJy4vZW5naW5lcy9wbGF5ZXItZW5naW5lJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZWdtZW50RW5naW5lIH0gZnJvbSAnLi9lbmdpbmVzL3NlZ21lbnQtZW5naW5lJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBTZXF1ZW5jZXJFbmdpbmUgfSBmcm9tICcuL2VuZ2luZXMvc2VxdWVuY2VyLWVuZ2luZSc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGhhc2V2b2NvZGVyRW5naW5lIH0gZnJvbSAnLi9lbmdpbmVzL3BoYXNldm9jb2Rlci1lbmdpbmUnO1xyXG5cclxuLy8gbWFzdGVyc1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBsYXlDb250cm9sIH0gZnJvbSAnLi9tYXN0ZXJzL3BsYXktY29udHJvbCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVHJhbnNwb3J0IH0gZnJvbSAnLi9tYXN0ZXJzL3RyYW5zcG9ydCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2NoZWR1bGVyIH0gZnJvbSAnLi9tYXN0ZXJzL3NjaGVkdWxlcic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2ltcGxlU2NoZWR1bGVyIH0gZnJvbSAnLi9tYXN0ZXJzL3NpbXBsZS1zY2hlZHVsZXInO1xyXG5cclxuLy8gZmFjdG9yaWVzXHJcbmV4cG9ydCB7IGdldFNjaGVkdWxlciB9IGZyb20gJy4vbWFzdGVycy9mYWN0b3JpZXMnO1xyXG5leHBvcnQgeyBnZXRTaW1wbGVTY2hlZHVsZXIgfSBmcm9tICcuL21hc3RlcnMvZmFjdG9yaWVzJztcclxuIiwiLy8gc2NoZWR1bGVycyBzaG91bGQgYmUgc2luZ2xldG9uc1xyXG5pbXBvcnQgZGVmYXVsdEF1ZGlvQ29udGV4dCBmcm9tICcuLi9jb3JlL2F1ZGlvLWNvbnRleHQnO1xyXG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJy4vc2NoZWR1bGVyJztcclxuaW1wb3J0IFNpbXBsZVNjaGVkdWxlciBmcm9tICcuL3NpbXBsZS1zY2hlZHVsZXInO1xyXG5cclxuY29uc3Qgc2NoZWR1bGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qgc2ltcGxlU2NoZWR1bGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgdW5pcXVlIGluc3RhbmNlIG9mIGBTY2hlZHVsZXJgXHJcbiAqXHJcbiAqIEBnbG9iYWxcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtTY2hlZHVsZXJ9XHJcbiAqIEBzZWUgU2NoZWR1bGVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0U2NoZWR1bGVyID0gZnVuY3Rpb24oYXVkaW9Db250ZXh0ID0gZGVmYXVsdEF1ZGlvQ29udGV4dCkge1xyXG4gIGxldCBzY2hlZHVsZXIgPSBzY2hlZHVsZXJNYXAuZ2V0KGF1ZGlvQ29udGV4dCk7XHJcblxyXG4gIGlmICghc2NoZWR1bGVyKSB7XHJcbiAgICBzY2hlZHVsZXIgPSBuZXcgU2NoZWR1bGVyKHsgYXVkaW9Db250ZXh0OiBhdWRpb0NvbnRleHQgfSk7XHJcbiAgICBzY2hlZHVsZXJNYXAuc2V0KGF1ZGlvQ29udGV4dCwgc2NoZWR1bGVyKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzY2hlZHVsZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHVuaXF1ZSBpbnN0YW5jZSBvZiBgU2ltcGxlU2NoZWR1bGVyYFxyXG4gKlxyXG4gKiBAZ2xvYmFsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7U2ltcGxlU2NoZWR1bGVyfVxyXG4gKiBAc2VlIFNpbXBsZVNjaGVkdWxlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFNpbXBsZVNjaGVkdWxlciA9IGZ1bmN0aW9uKGF1ZGlvQ29udGV4dCA9IGRlZmF1bHRBdWRpb0NvbnRleHQpIHtcclxuICBsZXQgc2ltcGxlU2NoZWR1bGVyID0gc2ltcGxlU2NoZWR1bGVyTWFwLmdldChhdWRpb0NvbnRleHQpO1xyXG5cclxuICBpZiAoIXNpbXBsZVNjaGVkdWxlcikge1xyXG4gICAgc2ltcGxlU2NoZWR1bGVyID0gbmV3IFNpbXBsZVNjaGVkdWxlcih7IGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0IH0pO1xyXG4gICAgc2ltcGxlU2NoZWR1bGVyTWFwLnNldChhdWRpb0NvbnRleHQsIHNpbXBsZVNjaGVkdWxlcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc2ltcGxlU2NoZWR1bGVyO1xyXG59O1xyXG4iLCJpbXBvcnQgZGVmYXVsdEF1ZGlvQ29udGV4dCBmcm9tICcuLi9jb3JlL2F1ZGlvLWNvbnRleHQnO1xyXG5pbXBvcnQgU2NoZWR1bGluZ1F1ZXVlIGZyb20gJy4uL2NvcmUvc2NoZWR1bGluZy1xdWV1ZSc7XHJcbmltcG9ydCBUaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvdGltZS1lbmdpbmUnO1xyXG5pbXBvcnQgeyBnZXRTY2hlZHVsZXIgfSBmcm9tICcuL2ZhY3Rvcmllcyc7XHJcblxyXG5jb25zdCBFUFNJTE9OID0gMWUtODtcclxuXHJcbmNsYXNzIExvb3BDb250cm9sIGV4dGVuZHMgVGltZUVuZ2luZSB7XHJcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5fX3BsYXlDb250cm9sID0gcGxheUNvbnRyb2w7XHJcbiAgICB0aGlzLnNwZWVkID0gMTtcclxuICAgIHRoaXMubG93ZXIgPSAtSW5maW5pdHk7XHJcbiAgICB0aGlzLnVwcGVyID0gSW5maW5pdHk7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAoc2NoZWR1bGVkIGludGVyZmFjZSlcclxuICBhZHZhbmNlVGltZSh0aW1lKSB7XHJcbiAgICBjb25zdCBwbGF5Q29udHJvbCA9IHRoaXMuX19wbGF5Q29udHJvbDtcclxuICAgIGNvbnN0IHNwZWVkID0gdGhpcy5zcGVlZDtcclxuICAgIGNvbnN0IGxvd2VyID0gdGhpcy5sb3dlcjtcclxuICAgIGNvbnN0IHVwcGVyID0gdGhpcy51cHBlcjtcclxuXHJcbiAgICBpZiAoc3BlZWQgPiAwKVxyXG4gICAgICB0aW1lICs9IEVQU0lMT047XHJcbiAgICBlbHNlXHJcbiAgICAgIHRpbWUgLT0gRVBTSUxPTjtcclxuXHJcbiAgICBpZiAoc3BlZWQgPiAwKSB7XHJcbiAgICAgIHBsYXlDb250cm9sLnN5bmNTcGVlZCh0aW1lLCBsb3dlciwgc3BlZWQsIHRydWUpO1xyXG4gICAgICByZXR1cm4gcGxheUNvbnRyb2wuX19nZXRUaW1lQXRQb3NpdGlvbih1cHBlcikgLSBFUFNJTE9OO1xyXG4gICAgfSBlbHNlIGlmIChzcGVlZCA8IDApIHtcclxuICAgICAgcGxheUNvbnRyb2wuc3luY1NwZWVkKHRpbWUsIHVwcGVyLCBzcGVlZCwgdHJ1ZSk7XHJcbiAgICAgIHJldHVybiBwbGF5Q29udHJvbC5fX2dldFRpbWVBdFBvc2l0aW9uKGxvd2VyKSArIEVQU0lMT047XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEluZmluaXR5O1xyXG4gIH1cclxuXHJcbiAgcmVzY2hlZHVsZShzcGVlZCkge1xyXG4gICAgY29uc3QgcGxheUNvbnRyb2wgPSB0aGlzLl9fcGxheUNvbnRyb2w7XHJcbiAgICBjb25zdCBsb3dlciA9IE1hdGgubWluKHBsYXlDb250cm9sLl9fbG9vcFN0YXJ0LCBwbGF5Q29udHJvbC5fX2xvb3BFbmQpO1xyXG4gICAgY29uc3QgdXBwZXIgPSBNYXRoLm1heChwbGF5Q29udHJvbC5fX2xvb3BTdGFydCwgcGxheUNvbnRyb2wuX19sb29wRW5kKTtcclxuXHJcbiAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XHJcbiAgICB0aGlzLmxvd2VyID0gbG93ZXI7XHJcbiAgICB0aGlzLnVwcGVyID0gdXBwZXI7XHJcblxyXG4gICAgaWYgKGxvd2VyID09PSB1cHBlcilcclxuICAgICAgc3BlZWQgPSAwO1xyXG5cclxuICAgIGlmIChzcGVlZCA+IDApXHJcbiAgICAgIHRoaXMucmVzZXRUaW1lKHBsYXlDb250cm9sLl9fZ2V0VGltZUF0UG9zaXRpb24odXBwZXIpIC0gRVBTSUxPTik7XHJcbiAgICBlbHNlIGlmIChzcGVlZCA8IDApXHJcbiAgICAgIHRoaXMucmVzZXRUaW1lKHBsYXlDb250cm9sLl9fZ2V0VGltZUF0UG9zaXRpb24obG93ZXIpICsgRVBTSUxPTik7XHJcbiAgICBlbHNlXHJcbiAgICAgIHRoaXMucmVzZXRUaW1lKEluZmluaXR5KTtcclxuICB9XHJcblxyXG4gIGFwcGx5TG9vcEJvdW5kYXJpZXMocG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICBjb25zdCBsb3dlciA9IHRoaXMubG93ZXI7XHJcbiAgICBjb25zdCB1cHBlciA9IHRoaXMudXBwZXI7XHJcblxyXG4gICAgaWYgKHNwZWVkID4gMCAmJiBwb3NpdGlvbiA+PSB1cHBlcilcclxuICAgICAgcmV0dXJuIGxvd2VyICsgKHBvc2l0aW9uIC0gbG93ZXIpICUgKHVwcGVyIC0gbG93ZXIpO1xyXG4gICAgZWxzZSBpZiAoc3BlZWQgPCAwICYmIHBvc2l0aW9uIDwgbG93ZXIpXHJcbiAgICAgIHJldHVybiB1cHBlciAtICh1cHBlciAtIHBvc2l0aW9uKSAlICh1cHBlciAtIGxvd2VyKTtcclxuXHJcbiAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgfVxyXG59XHJcblxyXG4vLyBwbGF5IGNvbnRyb2xsZWQgYmFzZSBjbGFzc1xyXG5jbGFzcyBQbGF5Q29udHJvbGxlZCB7XHJcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xyXG4gICAgdGhpcy5fX3BsYXlDb250cm9sID0gcGxheUNvbnRyb2w7XHJcblxyXG4gICAgZW5naW5lLm1hc3RlciA9IHRoaXM7XHJcbiAgICB0aGlzLl9fZW5naW5lID0gZW5naW5lO1xyXG4gIH1cclxuXHJcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlaywgbGFzdFNwZWVkKSB7XHJcbiAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsIHNlZWspO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19wbGF5Q29udHJvbC5jdXJyZW50VGltZTtcclxuICB9XHJcblxyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3BsYXlDb250cm9sLmN1cnJlbnRQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2wgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX19lbmdpbmUubWFzdGVyID0gbnVsbDtcclxuICAgIHRoaXMuX19lbmdpbmUgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gcGxheSBjb250cm9sIGZvciBlbmdpbmVzIGltcGxlbWVudGluZyB0aGUgKnNwZWVkLWNvbnRyb2xsZWQqIGludGVyZmFjZVxyXG5jbGFzcyBQbGF5Q29udHJvbGxlZFNwZWVkQ29udHJvbGxlZCBleHRlbmRzIFBsYXlDb250cm9sbGVkIHtcclxuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCwgZW5naW5lKSB7XHJcbiAgICBzdXBlcihwbGF5Q29udHJvbCwgZW5naW5lKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIHBsYXkgY29udHJvbCBmb3IgZW5naW5lcyBpbXBsbWVudGluZyB0aGUgKnRyYW5zcG9ydGVkKiBpbnRlcmZhY2VcclxuY2xhc3MgUGxheUNvbnRyb2xsZWRUcmFuc3BvcnRlZCBleHRlbmRzIFBsYXlDb250cm9sbGVkIHtcclxuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCwgZW5naW5lKSB7XHJcbiAgICBzdXBlcihwbGF5Q29udHJvbCwgZW5naW5lKTtcclxuXHJcbiAgICB0aGlzLl9fc2NoZWR1bGVySG9vayA9IG5ldyBQbGF5Q29udHJvbGxlZFNjaGVkdWxlckhvb2socGxheUNvbnRyb2wsIGVuZ2luZSk7XHJcbiAgfVxyXG5cclxuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrLCBsYXN0U3BlZWQpIHtcclxuICAgIGlmIChzcGVlZCAhPT0gbGFzdFNwZWVkIHx8IChzZWVrICYmIHNwZWVkICE9PSAwKSkge1xyXG4gICAgICB2YXIgbmV4dFBvc2l0aW9uO1xyXG5cclxuICAgICAgLy8gcmVzeW5jIHRyYW5zcG9ydGVkIGVuZ2luZXNcclxuICAgICAgaWYgKHNlZWsgfHwgc3BlZWQgKiBsYXN0U3BlZWQgPCAwKSB7XHJcbiAgICAgICAgLy8gc2VlayBvciByZXZlcnNlIGRpcmVjdGlvblxyXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX19lbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgIH0gZWxzZSBpZiAobGFzdFNwZWVkID09PSAwKSB7XHJcbiAgICAgICAgLy8gc3RhcnRcclxuICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fZW5naW5lLnN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNwZWVkID09PSAwKSB7XHJcbiAgICAgICAgLy8gc3RvcFxyXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IEluZmluaXR5O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQpXHJcbiAgICAgICAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgMCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQpIHtcclxuICAgICAgICAvLyBjaGFuZ2Ugc3BlZWQgd2l0aG91dCByZXZlcnNpbmcgZGlyZWN0aW9uXHJcbiAgICAgICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fX3NjaGVkdWxlckhvb2sucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmVzZXRFbmdpbmVQb3NpdGlvbihlbmdpbmUsIHBvc2l0aW9uID0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YXIgcGxheUNvbnRyb2wgPSB0aGlzLl9fcGxheUNvbnRyb2w7XHJcbiAgICAgIHZhciB0aW1lID0gcGxheUNvbnRyb2wuX19zeW5jKCk7XHJcblxyXG4gICAgICBwb3NpdGlvbiA9IHRoaXMuX19lbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHBsYXlDb250cm9sLl9fcG9zaXRpb24sIHBsYXlDb250cm9sLl9fc3BlZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX19zY2hlZHVsZXJIb29rLnJlc2V0UG9zaXRpb24ocG9zaXRpb24pO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX19zY2hlZHVsZXJIb29rLmRlc3Ryb3koKTtcclxuICAgIHRoaXMuX19zY2hlZHVsZXJIb29rID0gbnVsbDtcclxuXHJcbiAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBwbGF5IGNvbnRyb2wgZm9yIHRpbWUgZW5naW5lcyBpbXBsZW1lbnRpbmcgdGhlICpzY2hlZHVsZWQqIGludGVyZmFjZVxyXG5jbGFzcyBQbGF5Q29udHJvbGxlZFNjaGVkdWxlZCBleHRlbmRzIFBsYXlDb250cm9sbGVkIHtcclxuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCwgZW5naW5lKSB7XHJcbiAgICBzdXBlcihwbGF5Q29udHJvbCwgZW5naW5lKTtcclxuXHJcbiAgICAvLyBzY2hlZHVsaW5nIHF1ZXVlIGJlY29tZXMgbWFzdGVyIG9mIGVuZ2luZVxyXG4gICAgZW5naW5lLm1hc3RlciA9IG51bGw7XHJcbiAgICB0aGlzLl9fc2NoZWR1bGluZ1F1ZXVlID0gbmV3IFBsYXlDb250cm9sbGVkU2NoZWR1bGluZ1F1ZXVlKHBsYXlDb250cm9sLCBlbmdpbmUpO1xyXG4gIH1cclxuXHJcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlaywgbGFzdFNwZWVkKSB7XHJcbiAgICBpZiAobGFzdFNwZWVkID09PSAwICYmIHNwZWVkICE9PSAwKSAvLyBzdGFydCBvciBzZWVrXHJcbiAgICAgIHRoaXMuX19lbmdpbmUucmVzZXRUaW1lKCk7XHJcbiAgICBlbHNlIGlmIChsYXN0U3BlZWQgIT09IDAgJiYgc3BlZWQgPT09IDApIC8vIHN0b3BcclxuICAgICAgdGhpcy5fX2VuZ2luZS5yZXNldFRpbWUoSW5maW5pdHkpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX19zY2hlZHVsaW5nUXVldWUuZGVzdHJveSgpO1xyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gdHJhbnNsYXRlcyB0cmFuc3BvcnRlZCBlbmdpbmUgYWR2YW5jZVBvc2l0aW9uIGludG8gZ2xvYmFsIHNjaGVkdWxlciB0aW1lc1xyXG5jbGFzcyBQbGF5Q29udHJvbGxlZFNjaGVkdWxlckhvb2sgZXh0ZW5kcyBUaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCwgZW5naW5lKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IHBsYXlDb250cm9sO1xyXG4gICAgdGhpcy5fX2VuZ2luZSA9IGVuZ2luZTtcclxuXHJcbiAgICB0aGlzLl9fbmV4dFBvc2l0aW9uID0gSW5maW5pdHk7XHJcbiAgICBwbGF5Q29udHJvbC5fX3NjaGVkdWxlci5hZGQodGhpcywgSW5maW5pdHkpO1xyXG4gIH1cclxuXHJcbiAgYWR2YW5jZVRpbWUodGltZSkge1xyXG4gICAgdmFyIHBsYXlDb250cm9sID0gdGhpcy5fX3BsYXlDb250cm9sO1xyXG4gICAgdmFyIGVuZ2luZSA9IHRoaXMuX19lbmdpbmU7XHJcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9fbmV4dFBvc2l0aW9uO1xyXG4gICAgdmFyIG5leHRQb3NpdGlvbiA9IGVuZ2luZS5hZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHBsYXlDb250cm9sLl9fc3BlZWQpO1xyXG4gICAgdmFyIG5leHRUaW1lID0gcGxheUNvbnRyb2wuX19nZXRUaW1lQXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xyXG5cclxuICAgIHRoaXMuX19uZXh0UG9zaXRpb24gPSBuZXh0UG9zaXRpb247XHJcbiAgICByZXR1cm4gbmV4dFRpbWU7XHJcbiAgfVxyXG5cclxuICBnZXQgY3VycmVudFRpbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3BsYXlDb250cm9sLmN1cnJlbnRUaW1lO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcGxheUNvbnRyb2wuY3VycmVudFBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbiA9IHRoaXMuX19uZXh0UG9zaXRpb24pIHtcclxuICAgIHZhciB0aW1lID0gdGhpcy5fX3BsYXlDb250cm9sLl9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pO1xyXG4gICAgdGhpcy5fX25leHRQb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgdGhpcy5yZXNldFRpbWUodGltZSk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5fX3BsYXlDb250cm9sLl9fc2NoZWR1bGVyLnJlbW92ZSh0aGlzKTtcclxuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IG51bGw7XHJcbiAgICB0aGlzLl9fZW5naW5lID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vIGludGVybmFsIHNjaGVkdWxpbmcgcXVldWUgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IHBvc2l0aW9uIChhbmQgdGltZSkgb2YgdGhlIHBsYXkgY29udHJvbFxyXG5jbGFzcyBQbGF5Q29udHJvbGxlZFNjaGVkdWxpbmdRdWV1ZSBleHRlbmRzIFNjaGVkdWxpbmdRdWV1ZSB7XHJcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IHBsYXlDb250cm9sO1xyXG4gICAgdGhpcy5fX2VuZ2luZSA9IGVuZ2luZTtcclxuXHJcbiAgICB0aGlzLmFkZChlbmdpbmUsIEluZmluaXR5KTtcclxuICAgIHBsYXlDb250cm9sLl9fc2NoZWR1bGVyLmFkZCh0aGlzLCBJbmZpbml0eSk7XHJcbiAgfVxyXG5cclxuICBnZXQgY3VycmVudFRpbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3BsYXlDb250cm9sLmN1cnJlbnRUaW1lO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcGxheUNvbnRyb2wuY3VycmVudFBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX19wbGF5Q29udHJvbC5fX3NjaGVkdWxlci5yZW1vdmUodGhpcyk7XHJcbiAgICB0aGlzLnJlbW92ZSh0aGlzLl9fZW5naW5lKTtcclxuXHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2wgPSBudWxsO1xyXG4gICAgdGhpcy5fX2VuZ2luZSA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEV4dGVuZHMgVGltZSBFbmdpbmUgdG8gcHJvdmlkZSBwbGF5YmFjayBjb250cm9sIG9mIGEgVGltZSBFbmdpbmUgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIFtleGFtcGxlXXtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvcGxheS1jb250cm9sLmh0bWx9XHJcbiAqXHJcbiAqIEBleHRlbmRzIFRpbWVFbmdpbmVcclxuICogQHBhcmFtIHtUaW1lRW5naW5lfSBlbmdpbmUgLSBlbmdpbmUgdG8gY29udHJvbFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XHJcbiAqIGNvbnN0IHBsYXllckVuZ2luZSA9IGF1ZGlvLlBsYXllckVuZ2luZSgpO1xyXG4gKiBjb25zdCBwbGF5Q29udHJvbCA9IG5ldyBhdWRpby5QbGF5Q29udHJvbChwbGF5ZXJFbmdpbmUpO1xyXG4gKlxyXG4gKiBwbGF5Q29udHJvbC5zdGFydCgpO1xyXG4gKi9cclxuY2xhc3MgUGxheUNvbnRyb2wgZXh0ZW5kcyBUaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihlbmdpbmUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IG9wdGlvbnMuYXVkaW9Db250ZXh0IHx8IGRlZmF1bHRBdWRpb0NvbnRleHQ7XHJcbiAgICB0aGlzLl9fc2NoZWR1bGVyID0gZ2V0U2NoZWR1bGVyKHRoaXMuYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX19sb29wQ29udHJvbCA9IG51bGw7XHJcbiAgICB0aGlzLl9fbG9vcFN0YXJ0ID0gMDtcclxuICAgIHRoaXMuX19sb29wRW5kID0gMTtcclxuXHJcbiAgICAvLyBzeW5jaHJvbml6ZWQgdGllLCBwb3NpdGlvbiwgYW5kIHNwZWVkXHJcbiAgICB0aGlzLl9fdGltZSA9IDA7XHJcbiAgICB0aGlzLl9fcG9zaXRpb24gPSAwO1xyXG4gICAgdGhpcy5fX3NwZWVkID0gMDtcclxuXHJcbiAgICAvLyBub24temVybyBcInVzZXJcIiBzcGVlZFxyXG4gICAgdGhpcy5fX3BsYXlpbmdTcGVlZCA9IDE7XHJcblxyXG4gICAgaWYgKGVuZ2luZSlcclxuICAgICAgdGhpcy5fX3NldEVuZ2luZShlbmdpbmUpO1xyXG4gIH1cclxuXHJcbiAgX19zZXRFbmdpbmUoZW5naW5lKSB7XHJcbiAgICBpZiAoZW5naW5lLm1hc3RlcilcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gYSBtYXN0ZXJcIik7XHJcblxyXG4gICAgaWYgKFRpbWVFbmdpbmUuaW1wbGVtZW50c1NwZWVkQ29udHJvbGxlZChlbmdpbmUpKVxyXG4gICAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQgPSBuZXcgUGxheUNvbnRyb2xsZWRTcGVlZENvbnRyb2xsZWQodGhpcywgZW5naW5lKTtcclxuICAgIGVsc2UgaWYgKFRpbWVFbmdpbmUuaW1wbGVtZW50c1RyYW5zcG9ydGVkKGVuZ2luZSkpXHJcbiAgICAgIHRoaXMuX19wbGF5Q29udHJvbGxlZCA9IG5ldyBQbGF5Q29udHJvbGxlZFRyYW5zcG9ydGVkKHRoaXMsIGVuZ2luZSk7XHJcbiAgICBlbHNlIGlmIChUaW1lRW5naW5lLmltcGxlbWVudHNTY2hlZHVsZWQoZW5naW5lKSlcclxuICAgICAgdGhpcy5fX3BsYXlDb250cm9sbGVkID0gbmV3IFBsYXlDb250cm9sbGVkU2NoZWR1bGVkKHRoaXMsIGVuZ2luZSk7XHJcbiAgICBlbHNlXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBjYW5ub3QgYmUgYWRkZWQgdG8gcGxheSBjb250cm9sXCIpO1xyXG4gIH1cclxuXHJcbiAgX19yZXNldEVuZ2luZSgpIHtcclxuICAgIHRoaXMuX19wbGF5Q29udHJvbGxlZC5kZXN0cm95KCk7XHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlL2V4dHJhcG9sYXRlIHBsYXlpbmcgdGltZSBmb3IgZ2l2ZW4gcG9zaXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiBwb3NpdGlvblxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gZXh0cmFwb2xhdGVkIHRpbWVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgIHJldHVybiB0aGlzLl9fdGltZSArIChwb3NpdGlvbiAtIHRoaXMuX19wb3NpdGlvbikgLyB0aGlzLl9fc3BlZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUvZXh0cmFwb2xhdGUgcGxheWluZyBwb3NpdGlvbiBmb3IgZ2l2ZW4gdGltZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgdGltZVxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gZXh0cmFwb2xhdGVkIHBvc2l0aW9uXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfX2dldFBvc2l0aW9uQXRUaW1lKHRpbWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcG9zaXRpb24gKyAodGltZSAtIHRoaXMuX190aW1lKSAqIHRoaXMuX19zcGVlZDtcclxuICB9XHJcblxyXG4gIF9fc3luYygpIHtcclxuICAgIGNvbnN0IG5vdyA9IHRoaXMuY3VycmVudFRpbWU7XHJcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gKG5vdyAtIHRoaXMuX190aW1lKSAqIHRoaXMuX19zcGVlZDtcclxuICAgIHRoaXMuX190aW1lID0gbm93O1xyXG4gICAgcmV0dXJuIG5vdztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IG1hc3RlciB0aW1lLlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZXBsYWNlZCB3aGVuIHRoZSBwbGF5LWNvbnRyb2wgaXMgYWRkZWQgdG8gYSBtYXN0ZXIuXHJcbiAgICpcclxuICAgKiBAbmFtZSBjdXJyZW50VGltZVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19zY2hlZHVsZXIuY3VycmVudFRpbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY3VycmVudCBtYXN0ZXIgcG9zaXRpb24uXHJcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlcGxhY2VkIHdoZW4gdGhlIHBsYXktY29udHJvbCBpcyBhZGRlZCB0byBhIG1hc3Rlci5cclxuICAgKlxyXG4gICAqIEBuYW1lIGN1cnJlbnRQb3NpdGlvblxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcG9zaXRpb24gKyAodGhpcy5fX3NjaGVkdWxlci5jdXJyZW50VGltZSAtIHRoaXMuX190aW1lKSAqIHRoaXMuX19zcGVlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgaWYgdGhlIHBsYXkgY29udHJvbCBpcyBydW5uaW4gZy5cclxuICAgKlxyXG4gICAqIEBuYW1lIHJ1bm5pbmdcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAbWVtYmVyb2YgUGxheUNvbnRyb2xcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcnVubmluZygpIHtcclxuICAgIHJldHVybiAhKHRoaXMuX19zcGVlZCA9PT0gMCk7XHJcbiAgfVxyXG5cclxuICBzZXQoZW5naW5lID0gbnVsbCkge1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XHJcbiAgICBjb25zdCBzcGVlZCA9IHRoaXMuX19zcGVlZDtcclxuXHJcbiAgICBpZiAodGhpcy5fX3BsYXlDb250cm9sbGVkICE9PSBudWxsICYmIHRoaXMuX19wbGF5Q29udHJvbGxlZC5fX2VuZ2luZSAhPT0gZW5naW5lKSB7XHJcblxyXG4gICAgICB0aGlzLnN5bmNTcGVlZCh0aW1lLCB0aGlzLl9fcG9zaXRpb24sIDApO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX19wbGF5Q29udHJvbGxlZClcclxuICAgICAgICB0aGlzLl9fcmVzZXRFbmdpbmUoKTtcclxuXHJcblxyXG4gICAgICBpZiAodGhpcy5fX3BsYXlDb250cm9sbGVkID09PSBudWxsICYmIGVuZ2luZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuX19zZXRFbmdpbmUoZW5naW5lKTtcclxuXHJcbiAgICAgICAgaWYgKHNwZWVkICE9PSAwKVxyXG4gICAgICAgICAgdGhpcy5zeW5jU3BlZWQodGltZSwgdGhpcy5fX3Bvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHBsYXkgY29udHJvbCBsb29wIGJlaGF2aW9yLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQG5hbWUgbG9vcFxyXG4gICAqIEBtZW1iZXJvZiBQbGF5Q29udHJvbFxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBsb29wKGVuYWJsZSkge1xyXG4gICAgaWYgKGVuYWJsZSAmJiB0aGlzLl9fbG9vcFN0YXJ0ID4gLUluZmluaXR5ICYmIHRoaXMuX19sb29wRW5kIDwgSW5maW5pdHkpIHtcclxuICAgICAgaWYgKCF0aGlzLl9fbG9vcENvbnRyb2wpIHtcclxuICAgICAgICB0aGlzLl9fbG9vcENvbnRyb2wgPSBuZXcgTG9vcENvbnRyb2wodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fX3NjaGVkdWxlci5hZGQodGhpcy5fX2xvb3BDb250cm9sLCBJbmZpbml0eSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9fc3BlZWQgIT09IDApIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuY3VycmVudFBvc2l0aW9uO1xyXG4gICAgICAgIGNvbnN0IGxvd2VyID0gTWF0aC5taW4odGhpcy5fX2xvb3BTdGFydCwgdGhpcy5fX2xvb3BFbmQpO1xyXG4gICAgICAgIGNvbnN0IHVwcGVyID0gTWF0aC5tYXgodGhpcy5fX2xvb3BTdGFydCwgdGhpcy5fX2xvb3BFbmQpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fX3NwZWVkID4gMCAmJiBwb3NpdGlvbiA+IHVwcGVyKVxyXG4gICAgICAgICAgdGhpcy5zZWVrKHVwcGVyKTtcclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9fc3BlZWQgPCAwICYmIHBvc2l0aW9uIDwgbG93ZXIpXHJcbiAgICAgICAgICB0aGlzLnNlZWsobG93ZXIpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMuX19sb29wQ29udHJvbC5yZXNjaGVkdWxlKHRoaXMuX19zcGVlZCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5fX2xvb3BDb250cm9sKSB7XHJcbiAgICAgIHRoaXMuX19zY2hlZHVsZXIucmVtb3ZlKHRoaXMuX19sb29wQ29udHJvbCk7XHJcbiAgICAgIHRoaXMuX19sb29wQ29udHJvbCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgbG9vcCgpIHtcclxuICAgIHJldHVybiAoISF0aGlzLl9fbG9vcENvbnRyb2wpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBsb29wIHN0YXJ0IGFuZCBlbmQgdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsb29wU3RhcnQgLSBsb29wIHN0YXJ0IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsb29wRW5kIC0gbG9vcCBlbmQgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0TG9vcEJvdW5kYXJpZXMobG9vcFN0YXJ0LCBsb29wRW5kKSB7XHJcbiAgICB0aGlzLl9fbG9vcFN0YXJ0ID0gbG9vcFN0YXJ0O1xyXG4gICAgdGhpcy5fX2xvb3BFbmQgPSBsb29wRW5kO1xyXG5cclxuICAgIHRoaXMubG9vcCA9IHRoaXMubG9vcDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbG9vcCBzdGFydCB2YWx1ZVxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbmFtZSBsb29wU3RhcnRcclxuICAgKiBAbWVtYmVyb2YgUGxheUNvbnRyb2xcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKi9cclxuICBzZXQgbG9vcFN0YXJ0KGxvb3BTdGFydCkge1xyXG4gICAgdGhpcy5zZXRMb29wQm91bmRhcmllcyhsb29wU3RhcnQsIHRoaXMuX19sb29wRW5kKTtcclxuICB9XHJcblxyXG4gIGdldCBsb29wU3RhcnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2xvb3BTdGFydDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbG9vcCBlbmQgdmFsdWVcclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG5hbWUgbG9vcEVuZFxyXG4gICAqIEBtZW1iZXJvZiBQbGF5Q29udHJvbFxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBsb29wRW5kKGxvb3BFbmQpIHtcclxuICAgIHRoaXMuc2V0TG9vcEJvdW5kYXJpZXModGhpcy5fX2xvb3BTdGFydCwgbG9vcEVuZCk7XHJcbiAgfVxyXG5cclxuICBnZXQgbG9vcEVuZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fbG9vcEVuZDtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kIChzcGVlZC1jb250cm9sbGVkIGludGVyZmFjZSlcclxuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGxhc3RTcGVlZCA9IHRoaXMuX19zcGVlZDtcclxuXHJcbiAgICBpZiAoc3BlZWQgIT09IGxhc3RTcGVlZCB8fCBzZWVrKSB7XHJcbiAgICAgIGlmICgoc2VlayB8fCBsYXN0U3BlZWQgPT09IDApICYmIHRoaXMuX19sb29wQ29udHJvbClcclxuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX19sb29wQ29udHJvbC5hcHBseUxvb3BCb3VuZGFyaWVzKHBvc2l0aW9uLCBzcGVlZCk7XHJcblxyXG4gICAgICB0aGlzLl9fdGltZSA9IHRpbWU7XHJcbiAgICAgIHRoaXMuX19wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICB0aGlzLl9fc3BlZWQgPSBzcGVlZDtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9fcGxheUNvbnRyb2xsZWQpXHJcbiAgICAgICAgdGhpcy5fX3BsYXlDb250cm9sbGVkLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsIHNlZWssIGxhc3RTcGVlZCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5fX2xvb3BDb250cm9sKVxyXG4gICAgICAgIHRoaXMuX19sb29wQ29udHJvbC5yZXNjaGVkdWxlKHNwZWVkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0cyBwbGF5YmFja1xyXG4gICAqL1xyXG4gIHN0YXJ0KCkge1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XHJcbiAgICB0aGlzLnN5bmNTcGVlZCh0aW1lLCB0aGlzLl9fcG9zaXRpb24sIHRoaXMuX19wbGF5aW5nU3BlZWQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2VzIHBsYXliYWNrIGFuZCBzdGF5cyBhdCB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICAgKi9cclxuICBwYXVzZSgpIHtcclxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xyXG4gICAgdGhpcy5zeW5jU3BlZWQodGltZSwgdGhpcy5fX3Bvc2l0aW9uLCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3BzIHBsYXliYWNrIGFuZCBzZWVrcyB0byBpbml0aWFsICgwKSBwb3NpdGlvbi5cclxuICAgKi9cclxuICBzdG9wKCkge1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XHJcbiAgICB0aGlzLnN5bmNTcGVlZCh0aW1lLCAwLCAwLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIHNwZWVkIGlmIHByb3ZpZGVkLCBzZXRzIHRoZSBwbGF5YmFjayBzcGVlZC4gVGhlIHNwZWVkIHZhbHVlIHNob3VsZFxyXG4gICAqIGJlIG5vbi16ZXJvIGJldHdlZW4gLTE2IGFuZCAtMS8xNiBvciBiZXR3ZWVuIDEvMTYgYW5kIDE2LlxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbmFtZSBzcGVlZFxyXG4gICAqIEBtZW1iZXJvZiBQbGF5Q29udHJvbFxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBzcGVlZChzcGVlZCkge1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XHJcblxyXG4gICAgaWYgKHNwZWVkID49IDApIHtcclxuICAgICAgaWYgKHNwZWVkIDwgMC4wMSlcclxuICAgICAgICBzcGVlZCA9IDAuMDE7XHJcbiAgICAgIGVsc2UgaWYgKHNwZWVkID4gMTAwKVxyXG4gICAgICAgIHNwZWVkID0gMTAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHNwZWVkIDwgLTEwMClcclxuICAgICAgICBzcGVlZCA9IC0xMDA7XHJcbiAgICAgIGVsc2UgaWYgKHNwZWVkID4gLTAuMDEpXHJcbiAgICAgICAgc3BlZWQgPSAtMC4wMTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9fcGxheWluZ1NwZWVkID0gc3BlZWQ7XHJcblxyXG4gICAgaWYgKCF0aGlzLm1hc3RlciAmJiB0aGlzLl9fc3BlZWQgIT09IDApXHJcbiAgICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIHRoaXMuX19wb3NpdGlvbiwgc3BlZWQpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNwZWVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19wbGF5aW5nU3BlZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgKGp1bXAgdG8pIHBsYXlpbmcgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGFyZ2V0IHBvc2l0aW9uXHJcbiAgICovXHJcbiAgc2Vlayhwb3NpdGlvbikge1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XHJcbiAgICB0aGlzLl9fcG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCB0aGlzLl9fc3BlZWQsIHRydWUpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGxheUNvbnRyb2w7XHJcbiIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XHJcbmltcG9ydCBkZWZhdWx0QXVkaW9Db250ZXh0IGZyb20gJy4uL2NvcmUvYXVkaW8tY29udGV4dCc7XHJcbmltcG9ydCBTY2hlZHVsaW5nUXVldWUgZnJvbSAnLi4vY29yZS9zY2hlZHVsaW5nLXF1ZXVlJztcclxuXHJcbmNvbnN0IGxvZyA9IGRlYnVnKCd3YXZlc2pzOmF1ZGlvJyk7XHJcblxyXG4vKipcclxuICogVGhlIGBTY2hlZHVsZXJgIGNsYXNzIGltcGxlbWVudHMgYSBtYXN0ZXIgZm9yIGBUaW1lRW5naW5lYCBvciBgQXVkaW9UaW1lRW5naW5lYFxyXG4gKiBpbnN0YW5jZXMgdGhhdCBpbXBsZW1lbnQgdGhlICpzY2hlZHVsZWQqIGludGVyZmFjZSBzdWNoIGFzIHRoZSBgTWV0cm9ub21lYFxyXG4gKiBgR3JhbnVsYXJFbmdpbmVgLlxyXG4gKlxyXG4gKiBBIGBTY2hlZHVsZXJgIGNhbiBhbHNvIHNjaGVkdWxlIHNpbXBsZSBjYWxsYmFjayBmdW5jdGlvbnMuXHJcbiAqIFRoZSBjbGFzcyBpcyBiYXNlZCBvbiByZWN1cnNpdmUgY2FsbHMgdG8gYHNldFRpbWVPdXRgIGFuZCB1c2VzIHRoZVxyXG4gKiBgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lYCBhcyBsb2dpY2FsIHBhc3NlZCB0byB0aGUgYGFkdmFuY2VUaW1lYCBtZXRob2RzXHJcbiAqIG9mIHRoZSBzY2hlZHVsZWQgZW5naW5lcyBvciB0byB0aGUgc2NoZWR1bGVkIGNhbGxiYWNrIGZ1bmN0aW9ucy5cclxuICogSXQgZXh0ZW5kcyB0aGUgYFNjaGVkdWxpbmdRdWV1ZWAgY2xhc3MgdGhhdCBpdHNlbGYgaW5jbHVkZXMgYSBgUHJpb3JpdHlRdWV1ZWBcclxuICogdG8gYXNzdXJlIHRoZSBvcmRlciBvZiB0aGUgc2NoZWR1bGVkIGVuZ2luZXMgKHNlZSBgU2ltcGxlU2NoZWR1bGVyYCBmb3IgYVxyXG4gKiBzaW1wbGlmaWVkIHNjaGVkdWxlciBpbXBsZW1lbnRhdGlvbiB3aXRob3V0IGBQcmlvcml0eVF1ZXVlYCkuXHJcbiAqXHJcbiAqIFRvIGdldCBhIHVuaXF1ZSBpbnN0YW5jZSBvZiBgU2NoZWR1bGVyYCBhcyB0aGUgZ2xvYmFsIHNjaGVkdWxlciBvZiBhblxyXG4gKiBhcHBsaWNhdGlvbiwgdGhlIGBnZXRTY2hlZHVsZXJgIGZhY3RvcnkgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQuIFRoZVxyXG4gKiBmdW5jdGlvbiBhY2NlcHRzIGFuIGF1ZGlvIGNvbnRleHQgYXMgb3B0aW9uYWwgYXJndW1lbnQgYW5kIHVzZXMgdGhlIFdhdmVzXHJcbiAqIGRlZmF1bHQgYXVkaW8gY29udGV4dCAoc2VlIGBhdWRpb0NvbnRleHRgKSBhc1xyXG4gKiBkZWZhdWx0LiBUaGUgZmFjdG9yeSBjcmVhdGVzIGEgc2luZ2xlIHNjaGVkdWxlciBmb3IgZWFjaCBhdWRpbyBjb250ZXh0LlxyXG4gKlxyXG4gKiBFeGFtcGxlIHRoYXQgc2hvd3MgdGhyZWUgTWV0cm9ub21lIGVuZ2luZXMgcnVubmluZyBpbiBhIFNjaGVkdWxlcjpcclxuICoge0BsaW5rIGh0dHBzOi8vcmF3Z2l0LmNvbS93YXZlc2pzL3dhdmVzLWF1ZGlvL21hc3Rlci9leGFtcGxlcy9zY2hlZHVsZXIuaHRtbH1cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kPTAuMDI1XSAtIHBlcmlvZCBvZiB0aGUgc2NoZWR1bGVyLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubG9va2FoZWFkPTAuMV0gLSBsb29rYWhlYWQgb2YgdGhlIHNjaGVkdWxlci5cclxuICpcclxuICogQHNlZSBUaW1lRW5naW5lXHJcbiAqIEBzZWUgQXVkaW9UaW1lRW5naW5lXHJcbiAqIEBzZWUgZ2V0U2NoZWR1bGVyXHJcbiAqIEBzZWUgU2ltcGxlU2NoZWR1bGVyXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XHJcbiAqXHJcbiAqIHNjaGVkdWxlci5hZGQobXlFbmdpbmUpO1xyXG4gKi9cclxuY2xhc3MgU2NoZWR1bGVyIGV4dGVuZHMgU2NoZWR1bGluZ1F1ZXVlIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBvcHRpb25zLmF1ZGlvQ29udGV4dCB8fCDCoGRlZmF1bHRBdWRpb0NvbnRleHQ7XHJcblxyXG4gICAgdGhpcy5fX2N1cnJlbnRUaW1lID0gbnVsbDtcclxuICAgIHRoaXMuX19uZXh0VGltZSA9IEluZmluaXR5O1xyXG4gICAgdGhpcy5fX3RpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2NoZWR1bGVyIChzZXRUaW1lb3V0KSBwZXJpb2RcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBwZXJpb2RcclxuICAgICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZCA9IG9wdGlvbnMucGVyaW9kIHx8IMKgMC4wMjU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzY2hlZHVsZXIgbG9va2FoZWFkIHRpbWUgKD4gcGVyaW9kKVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIGxvb2thaGVhZFxyXG4gICAgICogQG1lbWJlcm9mIFNjaGVkdWxlclxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubG9va2FoZWFkID0gb3B0aW9ucy5sb29rYWhlYWQgfHwgwqAwLjE7XHJcbiAgfVxyXG5cclxuICAvLyBzZXRUaW1lb3V0IHNjaGVkdWxpbmcgbG9vcFxyXG4gIF9fdGljaygpIHtcclxuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xyXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBhdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XHJcbiAgICBsZXQgdGltZSA9IHRoaXMuX19uZXh0VGltZTtcclxuXHJcbiAgICB0aGlzLl9fdGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgd2hpbGUgKHRpbWUgPD0gY3VycmVudFRpbWUgKyB0aGlzLmxvb2thaGVhZCkge1xyXG4gICAgICB0aGlzLl9fY3VycmVudFRpbWUgPSB0aW1lO1xyXG4gICAgICB0aW1lID0gdGhpcy5hZHZhbmNlVGltZSh0aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9fY3VycmVudFRpbWUgPSBudWxsO1xyXG4gICAgdGhpcy5yZXNldFRpbWUodGltZSk7XHJcbiAgfVxyXG5cclxuICByZXNldFRpbWUodGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcclxuICAgIGlmICh0aGlzLm1hc3Rlcikge1xyXG4gICAgICB0aGlzLm1hc3Rlci5yZXNldCh0aGlzLCB0aW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0aGlzLl9fdGltZW91dCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9fdGltZW91dCk7XHJcbiAgICAgICAgdGhpcy5fX3RpbWVvdXQgPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGltZSAhPT0gSW5maW5pdHkpIHtcclxuICAgICAgICBpZiAodGhpcy5fX25leHRUaW1lID09PSBJbmZpbml0eSlcclxuICAgICAgICAgIGxvZygnU2NoZWR1bGVyIFN0YXJ0Jyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRpbWVPdXREZWxheSA9IE1hdGgubWF4KCh0aW1lIC0gdGhpcy5sb29rYWhlYWQgLSB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSksIHRoaXMucGVyaW9kKTtcclxuXHJcbiAgICAgICAgdGhpcy5fX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX190aWNrKCk7XHJcbiAgICAgICAgfSwgTWF0aC5jZWlsKHRpbWVPdXREZWxheSAqIDEwMDApKTtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9fbmV4dFRpbWUgIT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgbG9nKCdTY2hlZHVsZXIgU3RvcCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9fbmV4dFRpbWUgPSB0aW1lO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2NoZWR1bGVyIGN1cnJlbnQgbG9naWNhbCB0aW1lLlxyXG4gICAqXHJcbiAgICogQG5hbWUgY3VycmVudFRpbWVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKi9cclxuICBnZXQgY3VycmVudFRpbWUoKSB7XHJcbiAgICBpZiAodGhpcy5tYXN0ZXIpXHJcbiAgICAgIHJldHVybiB0aGlzLm1hc3Rlci5jdXJyZW50VGltZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fX2N1cnJlbnRUaW1lIHx8IHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy5sb29rYWhlYWQ7XHJcbiAgfVxyXG5cclxuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xyXG4gICAgY29uc3QgbWFzdGVyID0gdGhpcy5tYXN0ZXI7XHJcblxyXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uO1xyXG5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvLyBpbmhlcml0ZWQgZnJvbSBzY2hlZHVsaW5nIHF1ZXVlXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgVGltZUVuZ2luZSBvciBhIHNpbXBsZSBjYWxsYmFjayBmdW5jdGlvbiB0byB0aGUgc2NoZWR1bGVyIGF0IGFuXHJcbiAgICogb3B0aW9uYWxseSBnaXZlbiB0aW1lLiBXaGV0aGVyIHRoZSBhZGQgbWV0aG9kIGlzIGNhbGxlZCB3aXRoIGEgVGltZUVuZ2luZVxyXG4gICAqIG9yIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXQgcmV0dXJucyBhIFRpbWVFbmdpbmUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhcmd1bWVudFxyXG4gICAqIG9mIHRoZSBtZXRob2RzIHJlbW92ZSBhbmQgcmVzZXRFbmdpbmVUaW1lLiBBIFRpbWVFbmdpbmUgYWRkZWQgdG8gYSBzY2hlZHVsZXJcclxuICAgKiBoYXMgdG8gaW1wbGVtZW50IHRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gYWRkZWQgdG8gYVxyXG4gICAqIHNjaGVkdWxlciB3aWxsIGJlIGNhbGxlZCBhdCB0aGUgZ2l2ZW4gdGltZSBhbmQgd2l0aCB0aGUgZ2l2ZW4gdGltZSBhc1xyXG4gICAqIGFyZ3VtZW50LiBUaGUgY2FsbGJhY2sgY2FuIHJldHVybiBhIG5ldyBzY2hlZHVsaW5nIHRpbWUgKGkuZS4gdGhlIG5leHRcclxuICAgKiB0aW1lIHdoZW4gaXQgd2lsbCBiZSBjYWxsZWQpIG9yIGl0IGNhbiByZXR1cm4gSW5maW5pdHkgdG8gc3VzcGVuZCBzY2hlZHVsaW5nXHJcbiAgICogd2l0aG91dCByZW1vdmluZyB0aGUgZnVuY3Rpb24gZnJvbSB0aGUgc2NoZWR1bGVyLiBBIGZ1bmN0aW9uIHRoYXQgZG9lc1xyXG4gICAqIG5vdCByZXR1cm4gYSB2YWx1ZSAob3IgcmV0dXJucyBudWxsIG9yIDApIGlzIHJlbW92ZWQgZnJvbSB0aGUgc2NoZWR1bGVyXHJcbiAgICogYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGFyZ3VtZW50IG9mIHRoZSBtZXRob2RzIHJlbW92ZSBhbmQgcmVzZXRFbmdpbmVUaW1lXHJcbiAgICogYW55bW9yZS5cclxuICAgKlxyXG4gICAqIEBuYW1lIGFkZFxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV8RnVuY3Rpb259IGVuZ2luZSAtIEVuZ2luZSB0byBhZGQgdG8gdGhlIHNjaGVkdWxlclxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZT10aGlzLmN1cnJlbnRUaW1lXSAtIFNjaGVkdWxlIHRpbWVcclxuICAgKi9cclxuICAvKipcclxuICAgKiBSZW1vdmUgYSBUaW1lRW5naW5lIGZyb20gdGhlIHNjaGVkdWxlciB0aGF0IGhhcyBiZWVuIGFkZGVkIHRvIHRoZVxyXG4gICAqIHNjaGVkdWxlciB1c2luZyB0aGUgYWRkIG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEBuYW1lIGFkZFxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV9IGVuZ2luZSAtIEVuZ2luZSB0byByZW1vdmUgZnJvbSB0aGUgc2NoZWR1bGVyXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lPXRoaXMuY3VycmVudFRpbWVdIC0gU2NoZWR1bGUgdGltZVxyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIFJlc2NoZWR1bGUgYSBzY2hlZHVsZWQgdGltZSBlbmdpbmUgYXQgYSBnaXZlbiB0aW1lLlxyXG4gICAqXHJcbiAgICogQG5hbWUgcmVzZXRFbmdpbmVUaW1lXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICogQG1lbWJlcm9mIFNjaGVkdWxlclxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gRW5naW5lIHRvIHJlc2NoZWR1bGVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIFNjaGVkdWxlIHRpbWVcclxuICAgKi9cclxuICAvKipcclxuICAgKiBSZW1vdmUgYWxsIHNjaGVkdWxlZCBjYWxsYmFja3MgYW5kIGVuZ2luZXMgZnJvbSB0aGUgc2NoZWR1bGVyLlxyXG4gICAqXHJcbiAgICogQG5hbWUgY2xlYXJcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTY2hlZHVsZXI7XHJcbiIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XHJcbmltcG9ydCBkZWZhdWx0QXVkaW9Db250ZXh0IGZyb20gJy4uL2NvcmUvYXVkaW8tY29udGV4dCc7XHJcbmltcG9ydCBUaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvdGltZS1lbmdpbmUnO1xyXG5cclxuY29uc3QgbG9nID0gZGVidWcoJ3dhdmVzanM6YXVkaW8nKTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKlxyXG4gKlxyXG4gKiBUaGUgU2ltcGxlU2NoZWR1bGVyIGNsYXNzIGltcGxlbWVudHMgYSBzaW1wbGlmaWVkIG1hc3RlciBmb3IgdGltZSBlbmdpbmVzXHJcbiAqIChzZWUgVGltZUVuZ2luZSBvciBBdWRpb1RpbWVFbmdpbmUpIHRoYXQgaW1wbGVtZW50IHRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlXHJcbiAqIHN1Y2ggYXMgdGhlIE1ldHJvbm9tZSBhbmQgdGhlIEdyYW51bGFyRW5naW5lLiBUaGUgQVBJIGFuZCBmdW50aW9uYWxpdGllcyBvZlxyXG4gKiB0aGUgU2ltcGxlU2NoZWR1bGVyIGNsYXNzIGFyZSBpZGVudGljYWwgdG8gdGhlIFNjaGVkdWxlciBjbGFzcy4gQnV0LCBvdGhlclxyXG4gKiB0aGFuIHRoZSBTY2hlZHVsZXIsIHRoZSBTaW1wbGVTY2hlZHVsZXIgY2xhc3MgZG9lcyBub3QgZ3VhcmFudGVlIHRoZSBvcmRlclxyXG4gKiBvZiBldmVudHMgKGkuZS4gY2FsbHMgdG8gdGhlIGFkdmFuY2VUaW1lIG1ldGhvZCBvZiBzY2hlZHVsZWQgdGltZSBlbmdpbmVzXHJcbiAqIGFuZCB0byBzY2hlZHVsZWQgY2FsbGJhY2sgZnVuY3Rpb25zKSB3aXRoaW4gYSBzY2hlZHVsaW5nIHBlcmlvZCAoc2VlIHBlcmlvZFxyXG4gKiBhdHRyaWJ1dGUpLlxyXG4gKlxyXG4gKiBUbyBnZXQgYSB1bmlxdWUgaW5zdGFuY2Ugb2YgU2ltcGxlU2NoZWR1bGVyIGFzIHRoZSBnbG9iYWwgc2NoZWR1bGVyIG9mIGFuXHJcbiAqIGFwcGxpY2F0aW9uLCB0aGUgZ2V0U2ltcGxlU2NoZWR1bGVyIGZhY3RvcnkgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQuIFRoZVxyXG4gKiBmdW5jdGlvbiBhY2NlcHRzIGFuIGF1ZGlvIGNvbnRleHQgYXMgb3B0aW9uYWwgYXJndW1lbnQgYW5kIHVzZXMgdGhlIFdhdmVzXHJcbiAqIGRlZmF1bHQgYXVkaW8gY29udGV4dCAoc2VlIEF1ZGlvIENvbnRleHQpIGFzIGRlZmF1bHQuIFRoZSBmYWN0b3J5IGNyZWF0ZXNcclxuICogYSBzaW5nbGUgKHNpbXBsZSkgc2NoZWR1bGVyIGZvciBlYWNoIGF1ZGlvIGNvbnRleHQuXHJcbiAqXHJcbiAqIEV4YW1wbGUgdGhhdCBzaG93cyB0aHJlZSBNZXRyb25vbWUgZW5naW5lcyBydW5uaW5nIGluIGEgU2ltcGxlU2NoZWR1bGVyOlxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3NpbXBsZS1zY2hlZHVsZXIuaHRtbH1cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kPTAuMDI1XSAtIHBlcmlvZCBvZiB0aGUgc2NoZWR1bGVyLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubG9va2FoZWFkPTAuMV0gLSBsb29rYWhlYWQgb2YgdGhlIHNjaGVkdWxlci5cclxuICpcclxuICogQHNlZSBUaW1lRW5naW5lXHJcbiAqIEBzZWUgQXVkaW9UaW1lRW5naW5lXHJcbiAqIEBzZWUgZ2V0U2ltcGxlU2NoZWR1bGVyXHJcbiAqIEBzZWUgU2NoZWR1bGVyXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2ltcGxlU2NoZWR1bGVyKCk7XHJcbiAqXHJcbiAqIHNjaGVkdWxlci5hZGQobXlFbmdpbmUpO1xyXG4gKi9cclxuY2xhc3MgU2ltcGxlU2NoZWR1bGVyIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gb3B0aW9ucy5hdWRpb0NvbnRleHQgfHwgwqBkZWZhdWx0QXVkaW9Db250ZXh0O1xyXG5cclxuICAgIHRoaXMuX19lbmdpbmVzID0gbmV3IFNldCgpO1xyXG5cclxuICAgIHRoaXMuX19zY2hlZEVuZ2luZXMgPSBbXTtcclxuICAgIHRoaXMuX19zY2hlZFRpbWVzID0gW107XHJcblxyXG4gICAgdGhpcy5fX2N1cnJlbnRUaW1lID0gbnVsbDtcclxuICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNjaGVkdWxlciAoc2V0VGltZW91dCkgcGVyaW9kXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcGVyaW9kXHJcbiAgICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2QgPSBvcHRpb25zLnBlcmlvZCB8fCAwLjAyNTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNjaGVkdWxlciBsb29rYWhlYWQgdGltZSAoPiBwZXJpb2QpXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgbG9va2FoZWFkXHJcbiAgICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5sb29rYWhlYWQgPSBvcHRpb25zLmxvb2thaGVhZCB8fCAwLjE7XHJcbiAgfVxyXG5cclxuICBfX3NjaGVkdWxlRW5naW5lKGVuZ2luZSwgdGltZSkge1xyXG4gICAgdGhpcy5fX3NjaGVkRW5naW5lcy5wdXNoKGVuZ2luZSk7XHJcbiAgICB0aGlzLl9fc2NoZWRUaW1lcy5wdXNoKHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgX19yZXNjaGVkdWxlRW5naW5lKGVuZ2luZSwgdGltZSkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fX3NjaGVkRW5naW5lcy5pbmRleE9mKGVuZ2luZSk7XHJcblxyXG4gICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgaWYgKHRpbWUgIT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgdGhpcy5fX3NjaGVkVGltZXNbaW5kZXhdID0gdGltZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9fc2NoZWRFbmdpbmVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgdGhpcy5fX3NjaGVkVGltZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aW1lIDwgSW5maW5pdHkpIHtcclxuICAgICAgdGhpcy5fX3NjaGVkRW5naW5lcy5wdXNoKGVuZ2luZSk7XHJcbiAgICAgIHRoaXMuX19zY2hlZFRpbWVzLnB1c2godGltZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfX3Vuc2NoZWR1bGVFbmdpbmUoZW5naW5lKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9fc2NoZWRFbmdpbmVzLmluZGV4T2YoZW5naW5lKTtcclxuXHJcbiAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICB0aGlzLl9fc2NoZWRFbmdpbmVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIHRoaXMuX19zY2hlZFRpbWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfX3Jlc2V0VGljaygpIHtcclxuICAgIGlmICh0aGlzLl9fc2NoZWRFbmdpbmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgaWYgKCF0aGlzLl9fdGltZW91dCkge1xyXG4gICAgICAgIGxvZygnU2ltcGxlU2NoZWR1bGVyIFN0YXJ0Jyk7XHJcbiAgICAgICAgdGhpcy5fX3RpY2soKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9fdGltZW91dCkge1xyXG4gICAgICBsb2coJ1NpbXBsZVNjaGVkdWxlciBTdG9wJyk7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9fdGltZW91dCk7XHJcbiAgICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9fdGljaygpIHtcclxuICAgIHZhciBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcclxuICAgIHZhciBjdXJyZW50VGltZSA9IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcclxuICAgIHZhciBpID0gMDtcclxuXHJcbiAgICB3aGlsZSAoaSA8IHRoaXMuX19zY2hlZEVuZ2luZXMubGVuZ3RoKSB7XHJcbiAgICAgIHZhciBlbmdpbmUgPSB0aGlzLl9fc2NoZWRFbmdpbmVzW2ldO1xyXG4gICAgICB2YXIgdGltZSA9IHRoaXMuX19zY2hlZFRpbWVzW2ldO1xyXG5cclxuICAgICAgd2hpbGUgKHRpbWUgJiYgdGltZSA8PSBjdXJyZW50VGltZSArIHRoaXMubG9va2FoZWFkKSB7XHJcbiAgICAgICAgdGltZSA9IE1hdGgubWF4KHRpbWUsIGN1cnJlbnRUaW1lKTtcclxuICAgICAgICB0aGlzLl9fY3VycmVudFRpbWUgPSB0aW1lO1xyXG4gICAgICAgIHRpbWUgPSBlbmdpbmUuYWR2YW5jZVRpbWUodGltZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aW1lICYmIHRpbWUgPCBJbmZpbml0eSkge1xyXG4gICAgICAgIHRoaXMuX19zY2hlZFRpbWVzW2krK10gPSB0aW1lO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX191bnNjaGVkdWxlRW5naW5lKGVuZ2luZSk7XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBlbmdpbmUgZnJvbSBzY2hlZHVsZXJcclxuICAgICAgICBpZiAoIXRpbWUpIHtcclxuICAgICAgICAgIGVuZ2luZS5tYXN0ZXIgPSBudWxsO1xyXG4gICAgICAgICAgdGhpcy5fX2VuZ2luZXMuZGVsZXRlKGVuZ2luZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fX2N1cnJlbnRUaW1lID0gbnVsbDtcclxuICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICBpZiAodGhpcy5fX3NjaGVkRW5naW5lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuX190aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fX3RpY2soKTtcclxuICAgICAgfSwgdGhpcy5wZXJpb2QgKiAxMDAwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjaGVkdWxlciBjdXJyZW50IGxvZ2ljYWwgdGltZS5cclxuICAgKlxyXG4gICAqIEBuYW1lIGN1cnJlbnRUaW1lXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19jdXJyZW50VGltZSB8fCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMubG9va2FoZWFkO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvLyBjYWxsIGEgZnVuY3Rpb24gYXQgYSBnaXZlbiB0aW1lXHJcbiAgLyoqXHJcbiAgICogRGVmZXIgdGhlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uIGF0IGEgZ2l2ZW4gdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1biAtIEZ1bmN0aW9uIHRvIGRlZmVyXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lPXRoaXMuY3VycmVudFRpbWVdIC0gU2NoZWR1bGUgdGltZVxyXG4gICAqL1xyXG4gIGRlZmVyKGZ1biwgdGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcclxuICAgIGlmICghKGZ1biBpbnN0YW5jZW9mIEZ1bmN0aW9uKSlcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGNhbm5vdCBiZSBkZWZlcmVkIGJ5IHNjaGVkdWxlclwiKTtcclxuXHJcbiAgICB0aGlzLmFkZCh7XHJcbiAgICAgIGFkdmFuY2VUaW1lOiBmdW5jdGlvbih0aW1lKSB7IGZ1bih0aW1lKTsgfSwgLy8gbWFrZSBzdXIgdGhhdCB0aGUgYWR2YW5jZVRpbWUgbWV0aG9kIGRvZXMgbm90IHJldHVybSBhbnl0aGluZ1xyXG4gICAgfSwgdGltZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBUaW1lRW5naW5lIGZ1bmN0aW9uIHRvIHRoZSBzY2hlZHVsZXIgYXQgYW4gb3B0aW9uYWxseSBnaXZlbiB0aW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUaW1lRW5naW5lfSBlbmdpbmUgLSBFbmdpbmUgdG8gYWRkIHRvIHRoZSBzY2hlZHVsZXJcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWU9dGhpcy5jdXJyZW50VGltZV0gLSBTY2hlZHVsZSB0aW1lXHJcbiAgICovXHJcbiAgYWRkKGVuZ2luZSwgdGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcclxuICAgIGlmICghVGltZUVuZ2luZS5pbXBsZW1lbnRzU2NoZWR1bGVkKGVuZ2luZSkpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBjYW5ub3QgYmUgYWRkZWQgdG8gc2NoZWR1bGVyXCIpO1xyXG5cclxuICAgIGlmIChlbmdpbmUubWFzdGVyKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byBhIG1hc3RlclwiKTtcclxuXHJcbiAgICAvLyBzZXQgbWFzdGVyIGFuZCBhZGQgdG8gYXJyYXlcclxuICAgIGVuZ2luZS5tYXN0ZXIgPSB0aGlzO1xyXG4gICAgdGhpcy5fX2VuZ2luZXMuYWRkKGVuZ2luZSk7XHJcblxyXG4gICAgLy8gc2NoZWR1bGUgZW5naW5lXHJcbiAgICB0aGlzLl9fc2NoZWR1bGVFbmdpbmUoZW5naW5lLCB0aW1lKTtcclxuICAgIHRoaXMuX19yZXNldFRpY2soKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIFRpbWVFbmdpbmUgZnJvbSB0aGUgc2NoZWR1bGVyIHRoYXQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlXHJcbiAgICogc2NoZWR1bGVyIHVzaW5nIHRoZSBhZGQgbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUaW1lRW5naW5lfSBlbmdpbmUgLSBFbmdpbmUgdG8gcmVtb3ZlIGZyb20gdGhlIHNjaGVkdWxlclxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZT10aGlzLmN1cnJlbnRUaW1lXSAtIFNjaGVkdWxlIHRpbWVcclxuICAgKi9cclxuICByZW1vdmUoZW5naW5lKSB7XHJcbiAgICBpZiAoIWVuZ2luZS5tYXN0ZXIgfHwgZW5naW5lLm1hc3RlciAhPT0gdGhpcylcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW5naW5lIGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGlzIHNjaGVkdWxlclwiKTtcclxuXHJcbiAgICAvLyByZXNldCBtYXN0ZXIgYW5kIHJlbW92ZSBmcm9tIGFycmF5XHJcbiAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcclxuICAgIHRoaXMuX19lbmdpbmVzLmRlbGV0ZShlbmdpbmUpO1xyXG5cclxuICAgIC8vIHVuc2NoZWR1bGUgZW5naW5lXHJcbiAgICB0aGlzLl9fdW5zY2hlZHVsZUVuZ2luZShlbmdpbmUpO1xyXG4gICAgdGhpcy5fX3Jlc2V0VGljaygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzY2hlZHVsZSBhIHNjaGVkdWxlZCB0aW1lIGVuZ2luZSBhdCBhIGdpdmVuIHRpbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV9IGVuZ2luZSAtIEVuZ2luZSB0byByZXNjaGVkdWxlXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBTY2hlZHVsZSB0aW1lXHJcbiAgICovXHJcbiAgcmVzZXRFbmdpbmVUaW1lKGVuZ2luZSwgdGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcclxuICAgIHRoaXMuX19yZXNjaGVkdWxlRW5naW5lKGVuZ2luZSwgdGltZSk7XHJcbiAgICB0aGlzLl9fcmVzZXRUaWNrKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayB3aGV0aGVyIGEgZ2l2ZW4gZW5naW5lIGlzIHNjaGVkdWxlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gRW5naW5lIHRvIGNoZWNrXHJcbiAgICovXHJcbiAgaGFzKGVuZ2luZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19lbmdpbmVzLmhhcyhlbmdpbmUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFsbCBlbmdpbmVzIGZyb20gdGhlIHNjaGVkdWxlci5cclxuICAgKi9cclxuICBjbGVhcigpIHtcclxuICAgIGlmICh0aGlzLl9fdGltZW91dCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fX3RpbWVvdXQpO1xyXG4gICAgICB0aGlzLl9fdGltZW91dCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fX3NjaGVkRW5naW5lcy5sZW5ndGggPSAwO1xyXG4gICAgdGhpcy5fX3NjaGVkVGltZXMubGVuZ3RoID0gMDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNpbXBsZVNjaGVkdWxlcjtcclxuIiwiaW1wb3J0IGRlZmF1bHRBdWRpb0NvbnRleHQgZnJvbSAnLi4vY29yZS9hdWRpby1jb250ZXh0JztcclxuaW1wb3J0IFByaW9yaXR5UXVldWUgZnJvbSAnLi4vY29yZS9wcmlvcml0eS1xdWV1ZSc7XHJcbmltcG9ydCBTY2hlZHVsaW5nUXVldWUgZnJvbSAnLi4vY29yZS9zY2hlZHVsaW5nLXF1ZXVlJztcclxuaW1wb3J0IFRpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS90aW1lLWVuZ2luZSc7XHJcbmltcG9ydCB7IGdldFNjaGVkdWxlciB9IGZyb20gJy4vZmFjdG9yaWVzJztcclxuXHJcblxyXG5mdW5jdGlvbiBhZGREdXBsZXQoZmlyc3RBcnJheSwgc2Vjb25kQXJyYXksIGZpcnN0RWxlbWVudCwgc2Vjb25kRWxlbWVudCkge1xyXG4gIGZpcnN0QXJyYXkucHVzaChmaXJzdEVsZW1lbnQpO1xyXG4gIHNlY29uZEFycmF5LnB1c2goc2Vjb25kRWxlbWVudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZUR1cGxldChmaXJzdEFycmF5LCBzZWNvbmRBcnJheSwgZmlyc3RFbGVtZW50KSB7XHJcbiAgY29uc3QgaW5kZXggPSBmaXJzdEFycmF5LmluZGV4T2YoZmlyc3RFbGVtZW50KTtcclxuXHJcbiAgaWYgKGluZGV4ID49IDApIHtcclxuICAgIGNvbnN0IHNlY29uZEVsZW1lbnQgPSBzZWNvbmRBcnJheVtpbmRleF07XHJcblxyXG4gICAgZmlyc3RBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgc2Vjb25kQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICByZXR1cm4gc2Vjb25kRWxlbWVudDtcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vLyBUaGUgVHJhbnNwb3J0ZWQgY2FsbCBpcyB0aGUgYmFzZSBjbGFzcyBvZiB0aGUgYWRhcHRlcnMgYmV0d2VlblxyXG4vLyBkaWZmZXJlbnQgdHlwZXMgb2YgZW5naW5lcyAoaS5lLiB0cmFuc3BvcnRlZCwgc2NoZWR1bGVkLCBwbGF5LWNvbnRyb2xsZWQpXHJcbi8vIFRoZSBhZGFwdGVycyBhcmUgYXQgdGhlIHNhbWUgdGltZSBtYXN0ZXJzIGZvciB0aGUgZW5naW5lcyBhZGRlZCB0byB0aGUgdHJhbnNwb3J0XHJcbi8vIGFuZCB0cmFuc3BvcnRlZCBUaW1lRW5naW5lcyBpbnNlcnRlZCBpbnRvIHRoZSB0cmFuc3BvcnQncyBwb3NpdGlvbi1iYXNlZCBwcml0b3JpdHkgcXVldWUuXHJcbmNsYXNzIFRyYW5zcG9ydGVkIGV4dGVuZHMgVGltZUVuZ2luZSB7XHJcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0LCBkdXJhdGlvbiwgb2Zmc2V0LCBzdHJldGNoID0gMSkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMubWFzdGVyID0gdHJhbnNwb3J0O1xyXG5cclxuICAgIHRoaXMuX19lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICBlbmdpbmUubWFzdGVyID0gdGhpcztcclxuXHJcbiAgICB0aGlzLl9fc3RhcnRQb3NpdGlvbiA9IHN0YXJ0O1xyXG4gICAgdGhpcy5fX2VuZFBvc2l0aW9uID0gIWlzRmluaXRlKGR1cmF0aW9uKSA/IEluZmluaXR5IDogc3RhcnQgKyBkdXJhdGlvbjtcclxuICAgIHRoaXMuX19vZmZzZXRQb3NpdGlvbiA9IHN0YXJ0ICsgb2Zmc2V0O1xyXG4gICAgdGhpcy5fX3N0cmV0Y2hQb3NpdGlvbiA9IHN0cmV0Y2g7XHJcbiAgICB0aGlzLl9faXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBzZXRCb3VuZGFyaWVzKHN0YXJ0LCBkdXJhdGlvbiwgb2Zmc2V0ID0gMCwgc3RyZXRjaCA9IDEpIHtcclxuICAgIHRoaXMuX19zdGFydFBvc2l0aW9uID0gc3RhcnQ7XHJcbiAgICB0aGlzLl9fZW5kUG9zaXRpb24gPSBzdGFydCArIGR1cmF0aW9uO1xyXG4gICAgdGhpcy5fX29mZnNldFBvc2l0aW9uID0gc3RhcnQgKyBvZmZzZXQ7XHJcbiAgICB0aGlzLl9fc3RyZXRjaFBvc2l0aW9uID0gc3RyZXRjaDtcclxuICAgIHRoaXMucmVzZXRQb3NpdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7fVxyXG4gIHN0b3AodGltZSwgcG9zaXRpb24pIHt9XHJcblxyXG4gIGdldCBjdXJyZW50VGltZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1hc3Rlci5jdXJyZW50VGltZTtcclxuICB9XHJcblxyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tYXN0ZXIuY3VycmVudFBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgaWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHBvc2l0aW9uICs9IHRoaXMuX19vZmZzZXRQb3NpdGlvbjtcclxuXHJcbiAgICB0aGlzLm1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGlmIChzcGVlZCA+IDApIHtcclxuICAgICAgaWYgKHBvc2l0aW9uIDwgdGhpcy5fX3N0YXJ0UG9zaXRpb24pIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX19pc1J1bm5pbmcpXHJcbiAgICAgICAgICB0aGlzLnN0b3AodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24pO1xyXG5cclxuICAgICAgICB0aGlzLl9faXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGFydFBvc2l0aW9uO1xyXG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgdGhpcy5fX2VuZFBvc2l0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCh0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbiwgc3BlZWQpO1xyXG5cclxuICAgICAgICB0aGlzLl9faXNSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2VuZFBvc2l0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocG9zaXRpb24gPiB0aGlzLl9fZW5kUG9zaXRpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5fX2lzUnVubmluZykgLy8gaWYgZW5naW5lIGlzIHJ1bm5pbmdcclxuICAgICAgICAgIHRoaXMuc3RvcCh0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbik7XHJcblxyXG4gICAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2VuZFBvc2l0aW9uO1xyXG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID4gdGhpcy5fX3N0YXJ0UG9zaXRpb24pIHtcclxuICAgICAgICB0aGlzLnN0YXJ0KHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XHJcblxyXG4gICAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhcnRQb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9faXNSdW5uaW5nKSAvLyBpZiBlbmdpbmUgaXMgcnVubmluZ1xyXG4gICAgICB0aGlzLnN0b3AodGltZSwgcG9zaXRpb24pO1xyXG5cclxuICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgIHJldHVybiBJbmZpbml0eSAqIHNwZWVkO1xyXG4gIH1cclxuXHJcbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgaWYgKCF0aGlzLl9faXNSdW5uaW5nKSB7XHJcbiAgICAgIHRoaXMuc3RhcnQodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcclxuICAgICAgdGhpcy5fX2lzUnVubmluZyA9IHRydWU7XHJcblxyXG4gICAgICBpZiAoc3BlZWQgPiAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9fZW5kUG9zaXRpb247XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXJ0UG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3RvcCBlbmdpbmVcclxuICAgIHRoaXMuc3RvcCh0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbik7XHJcblxyXG4gICAgdGhpcy5fX2lzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIEluZmluaXR5ICogc3BlZWQ7XHJcbiAgfVxyXG5cclxuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICBpZiAoc3BlZWQgPT09IDApIC8vIHN0b3BcclxuICAgICAgdGhpcy5zdG9wKHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLm1hc3RlciA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fX2VuZ2luZS5tYXN0ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fX2VuZ2luZSA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBUcmFuc3BvcnRlZFRyYW5zcG9ydGVkXHJcbi8vIGhhcyB0byBzd2l0Y2ggb24gYW5kIG9mZiB0aGUgc2NoZWR1bGVkIGVuZ2luZXMgd2hlbiB0aGUgdHJhbnNwb3J0IGhpdHMgdGhlIGVuZ2luZSdzIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25cclxuY2xhc3MgVHJhbnNwb3J0ZWRUcmFuc3BvcnRlZCBleHRlbmRzIFRyYW5zcG9ydGVkIHtcclxuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKSB7XHJcbiAgICBzdXBlcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGlmIChzcGVlZCA+IDAgJiYgcG9zaXRpb24gPCB0aGlzLl9fZW5kUG9zaXRpb24pXHJcbiAgICAgIHBvc2l0aW9uID0gTWF0aC5tYXgocG9zaXRpb24sIHRoaXMuX19zdGFydFBvc2l0aW9uKTtcclxuICAgIGVsc2UgaWYgKHNwZWVkIDwgMCAmJiBwb3NpdGlvbiA+PSB0aGlzLl9fc3RhcnRQb3NpdGlvbilcclxuICAgICAgcG9zaXRpb24gPSBNYXRoLm1pbihwb3NpdGlvbiwgdGhpcy5fX2VuZFBvc2l0aW9uKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fX29mZnNldFBvc2l0aW9uICsgdGhpcy5fX2VuZ2luZS5zeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcclxuICB9XHJcblxyXG4gIGFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIHBvc2l0aW9uID0gdGhpcy5fX29mZnNldFBvc2l0aW9uICsgdGhpcy5fX2VuZ2luZS5hZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcclxuXHJcbiAgICBpZiAoc3BlZWQgPiAwICYmIHBvc2l0aW9uIDwgdGhpcy5fX2VuZFBvc2l0aW9uIHx8IHNwZWVkIDwgMCAmJiBwb3NpdGlvbiA+PSB0aGlzLl9fc3RhcnRQb3NpdGlvbilcclxuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG5cclxuICAgIHJldHVybiBJbmZpbml0eSAqIHNwZWVkO1xyXG4gIH1cclxuXHJcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgaWYgKHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKVxyXG4gICAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRFbmdpbmVQb3NpdGlvbihlbmdpbmUsIHBvc2l0aW9uID0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAocG9zaXRpb24gIT09IHVuZGVmaW5lZClcclxuICAgICAgcG9zaXRpb24gKz0gdGhpcy5fX29mZnNldFBvc2l0aW9uO1xyXG5cclxuICAgIHRoaXMucmVzZXRQb3NpdGlvbihwb3NpdGlvbik7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBUcmFuc3BvcnRlZFNwZWVkQ29udHJvbGxlZFxyXG4vLyBoYXMgdG8gc3RhcnQgYW5kIHN0b3AgdGhlIHNwZWVkLWNvbnRyb2xsZWQgZW5naW5lcyB3aGVuIHRoZSB0cmFuc3BvcnQgaGl0cyB0aGUgZW5naW5lJ3Mgc3RhcnQgYW5kIGVuZCBwb3NpdGlvblxyXG5jbGFzcyBUcmFuc3BvcnRlZFNwZWVkQ29udHJvbGxlZCBleHRlbmRzIFRyYW5zcG9ydGVkIHtcclxuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKSB7XHJcbiAgICBzdXBlcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIHN0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIHN0b3AodGltZSwgcG9zaXRpb24pIHtcclxuICAgIHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCAwKTtcclxuICB9XHJcblxyXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGlmICh0aGlzLl9faXNSdW5uaW5nKVxyXG4gICAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKHRoaXMubWFzdGVyLmN1cnJlbnRUaW1lLCB0aGlzLm1hc3Rlci5jdXJyZW50UG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIDApO1xyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gVHJhbnNwb3J0ZWRTY2hlZHVsZWRcclxuLy8gaGFzIHRvIHN3aXRjaCBvbiBhbmQgb2ZmIHRoZSBzY2hlZHVsZWQgZW5naW5lcyB3aGVuIHRoZSB0cmFuc3BvcnQgaGl0cyB0aGUgZW5naW5lJ3Mgc3RhcnQgYW5kIGVuZCBwb3NpdGlvblxyXG5jbGFzcyBUcmFuc3BvcnRlZFNjaGVkdWxlZCBleHRlbmRzIFRyYW5zcG9ydGVkIHtcclxuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKSB7XHJcbiAgICBzdXBlcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcclxuXHJcbiAgICAvLyBzY2hlZHVsaW5nIHF1ZXVlIGJlY29tZXMgbWFzdGVyIG9mIGVuZ2luZVxyXG4gICAgZW5naW5lLm1hc3RlciA9IG51bGw7XHJcbiAgICB0cmFuc3BvcnQuX19zY2hlZHVsaW5nUXVldWUuYWRkKGVuZ2luZSwgSW5maW5pdHkpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICB0aGlzLm1hc3Rlci5fX3NjaGVkdWxpbmdRdWV1ZS5yZXNldEVuZ2luZVRpbWUodGhpcy5fX2VuZ2luZSwgdGltZSk7XHJcbiAgfVxyXG5cclxuICBzdG9wKHRpbWUsIHBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLm1hc3Rlci5fX3NjaGVkdWxpbmdRdWV1ZS5yZXNldEVuZ2luZVRpbWUodGhpcy5fX2VuZ2luZSwgSW5maW5pdHkpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMubWFzdGVyLl9fc2NoZWR1bGluZ1F1ZXVlLnJlbW92ZSh0aGlzLl9fZW5naW5lKTtcclxuICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIHRyYW5zbGF0ZXMgYWR2YW5jZVBvc2l0aW9uIG9mICp0cmFuc3BvcnRlZCogZW5naW5lcyBpbnRvIGdsb2JhbCBzY2hlZHVsZXIgdGltZXNcclxuY2xhc3MgVHJhbnNwb3J0U2NoZWR1bGVySG9vayBleHRlbmRzIFRpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xyXG5cclxuICAgIHRoaXMuX19uZXh0UG9zaXRpb24gPSBJbmZpbml0eTtcclxuICAgIHRoaXMuX19uZXh0VGltZSA9IEluZmluaXR5O1xyXG4gICAgdHJhbnNwb3J0Ll9fc2NoZWR1bGVyLmFkZCh0aGlzLCBJbmZpbml0eSk7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAoc2NoZWR1bGVkIGludGVyZmFjZSlcclxuICBhZHZhbmNlVGltZSh0aW1lKSB7XHJcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLl9fdHJhbnNwb3J0O1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9fbmV4dFBvc2l0aW9uO1xyXG4gICAgY29uc3Qgc3BlZWQgPSB0cmFuc3BvcnQuX19zcGVlZDtcclxuICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IHRyYW5zcG9ydC5hZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICAgIGNvbnN0IG5leHRUaW1lID0gdHJhbnNwb3J0Ll9fZ2V0VGltZUF0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcclxuXHJcbiAgICB0aGlzLl9fbmV4dFBvc2l0aW9uID0gbmV4dFBvc2l0aW9uO1xyXG4gICAgdGhpcy5fX25leHRUaW1lID0gbmV4dFRpbWU7XHJcblxyXG4gICAgcmV0dXJuIG5leHRUaW1lO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbiA9IHRoaXMuX19uZXh0UG9zaXRpb24pIHtcclxuICAgIGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMuX190cmFuc3BvcnQ7XHJcbiAgICBjb25zdCB0aW1lID0gdHJhbnNwb3J0Ll9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pO1xyXG5cclxuICAgIHRoaXMuX19uZXh0UG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIHRoaXMuX19uZXh0VGltZSA9IHRpbWU7XHJcblxyXG4gICAgdGhpcy5yZXNldFRpbWUodGltZSk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5fX3RyYW5zcG9ydC5fX3NjaGVkdWxlci5yZW1vdmUodGhpcyk7XHJcbiAgICB0aGlzLl9fdHJhbnNwb3J0ID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vIGludGVybmFsIHNjaGVkdWxpbmcgcXVldWUgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IHBvc2l0aW9uIChhbmQgdGltZSkgb2YgdGhlIHBsYXkgY29udHJvbFxyXG5jbGFzcyBUcmFuc3BvcnRTY2hlZHVsaW5nUXVldWUgZXh0ZW5kcyBTY2hlZHVsaW5nUXVldWUge1xyXG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xyXG4gICAgdHJhbnNwb3J0Ll9fc2NoZWR1bGVyLmFkZCh0aGlzLCBJbmZpbml0eSk7XHJcbiAgfVxyXG5cclxuICBnZXQgY3VycmVudFRpbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3RyYW5zcG9ydC5jdXJyZW50VGltZTtcclxuICB9XHJcblxyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3RyYW5zcG9ydC5jdXJyZW50UG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5fX3RyYW5zcG9ydC5fX3NjaGVkdWxlci5yZW1vdmUodGhpcyk7XHJcbiAgICB0aGlzLl9fdHJhbnNwb3J0ID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBzeW5jaHJvbml6ZWQgc2NoZWR1bGluZyBvZiBUaW1lIEVuZ2luZSBpbnN0YW5jZXMuXHJcbiAqXHJcbiAqIFtleGFtcGxlXXtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvdHJhbnNwb3J0Lmh0bWx9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3QgdHJhbnNwb3J0ID0gYXVkaW8uVHJhbnNwb3J0KCk7XHJcbiAqIGNvbnN0IHBsYXlDb250cm9sID0gbmV3IGF1ZGlvLlBsYXlDb250cm9sKHRyYW5zcG9ydCk7XHJcbiAqIGNvbnN0IG15RW5naW5lID0gbmV3IE15RW5naW5lKCk7XHJcbiAqIGNvbnN0IHlvdXJFbmdpbmUgPSBuZXcgeW91ckVuZ2luZSgpO1xyXG4gKlxyXG4gKiB0cmFuc3BvcnQuYWRkKG15RW5naW5lKTtcclxuICogdHJhbnNwb3J0LmFkZCh5b3VyRW5naW5lKTtcclxuICpcclxuICogcGxheUNvbnRyb2wuc3RhcnQoKTtcclxuICovXHJcbmNsYXNzIFRyYW5zcG9ydCBleHRlbmRzIFRpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IG9wdGlvbnMuYXVkaW9Db250ZXh0IHx8IGRlZmF1bHRBdWRpb0NvbnRleHQ7XHJcblxyXG4gICAgdGhpcy5fX2VuZ2luZXMgPSBbXTtcclxuICAgIHRoaXMuX190cmFuc3BvcnRlZCA9IFtdO1xyXG5cclxuICAgIHRoaXMuX19zY2hlZHVsZXIgPSBnZXRTY2hlZHVsZXIodGhpcy5hdWRpb0NvbnRleHQpO1xyXG4gICAgdGhpcy5fX3NjaGVkdWxlckhvb2sgPSBuZXcgVHJhbnNwb3J0U2NoZWR1bGVySG9vayh0aGlzKTtcclxuICAgIHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoKTtcclxuICAgIHRoaXMuX19zY2hlZHVsaW5nUXVldWUgPSBuZXcgVHJhbnNwb3J0U2NoZWR1bGluZ1F1ZXVlKHRoaXMpO1xyXG5cclxuICAgIC8vIHN5bmNyb25pemVkIHRpbWUsIHBvc2l0aW9uLCBhbmQgc3BlZWRcclxuICAgIHRoaXMuX190aW1lID0gMDtcclxuICAgIHRoaXMuX19wb3NpdGlvbiA9IDA7XHJcbiAgICB0aGlzLl9fc3BlZWQgPSAwO1xyXG4gIH1cclxuXHJcbiAgX19nZXRUaW1lQXRQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIHRoaXMuX190aW1lICsgKHBvc2l0aW9uIC0gdGhpcy5fX3Bvc2l0aW9uKSAvIHRoaXMuX19zcGVlZDtcclxuICB9XHJcblxyXG4gIF9fZ2V0UG9zaXRpb25BdFRpbWUodGltZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiArICh0aW1lIC0gdGhpcy5fX3RpbWUpICogdGhpcy5fX3NwZWVkO1xyXG4gIH1cclxuXHJcbiAgX19zeW5jVHJhbnNwb3J0ZWRQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGNvbnN0IG51bVRyYW5zcG9ydGVkRW5naW5lcyA9IHRoaXMuX190cmFuc3BvcnRlZC5sZW5ndGg7XHJcbiAgICBsZXQgbmV4dFBvc2l0aW9uID0gSW5maW5pdHkgKiBzcGVlZDtcclxuXHJcbiAgICBpZiAobnVtVHJhbnNwb3J0ZWRFbmdpbmVzID4gMCkge1xyXG4gICAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5jbGVhcigpO1xyXG4gICAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5yZXZlcnNlID0gKHNwZWVkIDwgMCk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRyYW5zcG9ydGVkRW5naW5lczsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZW5naW5lID0gdGhpcy5fX3RyYW5zcG9ydGVkW2ldO1xyXG4gICAgICAgIGNvbnN0IG5leHRFbmdpbmVQb3NpdGlvbiA9IGVuZ2luZS5zeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICAgICAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5pbnNlcnQoZW5naW5lLCBuZXh0RW5naW5lUG9zaXRpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS50aW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXh0UG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBfX3N5bmNUcmFuc3BvcnRlZFNwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgZm9yIChsZXQgdHJhbnNwb3J0ZWQgb2YgdGhpcy5fX3RyYW5zcG9ydGVkKVxyXG4gICAgICB0cmFuc3BvcnRlZC5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IG1hc3RlciB0aW1lLiBUaGlzIGdldHRlciB3aWxsIGJlIHJlcGxhY2VkIHdoZW4gdGhlIHRyYW5zcG9ydFxyXG4gICAqIGlzIGFkZGVkIHRvIGEgbWFzdGVyIChpLmUuIHRyYW5zcG9ydCBvciBwbGF5LWNvbnRyb2wpLlxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbmFtZSBjdXJyZW50VGltZVxyXG4gICAqIEBtZW1iZXJvZiBUcmFuc3BvcnRcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY3VycmVudFRpbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3NjaGVkdWxlci5jdXJyZW50VGltZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IG1hc3RlciBwb3NpdGlvbi4gVGhpcyBnZXR0ZXIgd2lsbCBiZSByZXBsYWNlZCB3aGVuIHRoZSB0cmFuc3BvcnRcclxuICAgKiBpcyBhZGRlZCB0byBhIG1hc3RlciAoaS5lLiB0cmFuc3BvcnQgb3IgcGxheS1jb250cm9sKS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG5hbWUgY3VycmVudFBvc2l0aW9uXHJcbiAgICogQG1lbWJlcm9mIFRyYW5zcG9ydFxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICBjb25zdCBtYXN0ZXIgPSB0aGlzLm1hc3RlcjtcclxuXHJcbiAgICBpZiAobWFzdGVyICYmIG1hc3Rlci5jdXJyZW50UG9zaXRpb24gIT09IHVuZGVmaW5lZClcclxuICAgICAgcmV0dXJuIG1hc3Rlci5jdXJyZW50UG9zaXRpb247XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiArICh0aGlzLl9fc2NoZWR1bGVyLmN1cnJlbnRUaW1lIC0gdGhpcy5fX3RpbWUpICogdGhpcy5fX3NwZWVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgbmV4dCB0cmFuc3BvcnQgcG9zaXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuZXh0IC0gdHJhbnNwb3J0IHBvc2l0aW9uXHJcbiAgICovXHJcbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgY29uc3QgbWFzdGVyID0gdGhpcy5tYXN0ZXI7XHJcblxyXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICBtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XHJcbiAgICBlbHNlXHJcbiAgICAgIHRoaXMuX19zY2hlZHVsZXJIb29rLnJlc2V0UG9zaXRpb24ocG9zaXRpb24pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIHRyYW5zcG9ydGVkIHRpbWUgZW5naW5lIGludGVyZmFjZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWVkXHJcbiAgICovXHJcbiAgc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdGhpcy5fX3RpbWUgPSB0aW1lO1xyXG4gICAgdGhpcy5fX3Bvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB0aGlzLl9fc3BlZWQgPSBzcGVlZDtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgdHJhbnNwb3J0ZWQgdGltZSBlbmdpbmUgaW50ZXJmYWNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25cclxuICAgKiBAcGFyYW0ge051bWJlcn0gc3BlZWRcclxuICAgKi9cclxuICBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5oZWFkO1xyXG4gICAgY29uc3QgbmV4dEVuZ2luZVBvc2l0aW9uID0gZW5naW5lLmFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgcmV0dXJuIHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLm1vdmUoZW5naW5lLCBuZXh0RW5naW5lUG9zaXRpb24pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIHRyYW5zcG9ydGVkIHRpbWUgZW5naW5lIGludGVyZmFjZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWVkXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbc2Vlaz1mYWxzZV1cclxuICAgKi9cclxuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGxhc3RTcGVlZCA9IHRoaXMuX19zcGVlZDtcclxuXHJcbiAgICB0aGlzLl9fdGltZSA9IHRpbWU7XHJcbiAgICB0aGlzLl9fcG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIHRoaXMuX19zcGVlZCA9IHNwZWVkO1xyXG5cclxuICAgIGlmIChzcGVlZCAhPT0gbGFzdFNwZWVkIHx8IChzZWVrICYmIHNwZWVkICE9PSAwKSkge1xyXG4gICAgICBsZXQgbmV4dFBvc2l0aW9uO1xyXG5cclxuICAgICAgLy8gcmVzeW5jIHRyYW5zcG9ydGVkIGVuZ2luZXNcclxuICAgICAgaWYgKHNlZWsgfHwgc3BlZWQgKiBsYXN0U3BlZWQgPCAwKSB7XHJcbiAgICAgICAgLy8gc2VlayBvciByZXZlcnNlIGRpcmVjdGlvblxyXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX19zeW5jVHJhbnNwb3J0ZWRQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKGxhc3RTcGVlZCA9PT0gMCkge1xyXG4gICAgICAgIC8vIHN0YXJ0XHJcbiAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3BlZWQgPT09IDApIHtcclxuICAgICAgICAvLyBzdG9wXHJcbiAgICAgICAgbmV4dFBvc2l0aW9uID0gSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFNwZWVkKHRpbWUsIHBvc2l0aW9uLCAwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBjaGFuZ2Ugc3BlZWQgd2l0aG91dCByZXZlcnNpbmcgZGlyZWN0aW9uXHJcbiAgICAgICAgdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFNwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgdGltZSBlbmdpbmUgdG8gdGhlIHRyYW5zcG9ydC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbmdpbmUgLSBlbmdpbmUgdG8gYmUgYWRkZWQgdG8gdGhlIHRyYW5zcG9ydFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIHN0YXJ0IHBvc2l0aW9uXHJcbiAgICovXHJcbiAgYWRkKGVuZ2luZSwgc3RhcnRQb3NpdGlvbiA9IDAsIGVuZFBvc2l0aW9uID0gSW5maW5pdHksIG9mZnNldFBvc2l0aW9uID0gMCkge1xyXG4gICAgbGV0IHRyYW5zcG9ydGVkID0gbnVsbDtcclxuXHJcbiAgICBpZiAob2Zmc2V0UG9zaXRpb24gPT09IC1JbmZpbml0eSlcclxuICAgICAgb2Zmc2V0UG9zaXRpb24gPSAwO1xyXG5cclxuICAgIGlmIChlbmdpbmUubWFzdGVyKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byBhIG1hc3RlclwiKTtcclxuXHJcbiAgICBpZiAoVGltZUVuZ2luZS5pbXBsZW1lbnRzVHJhbnNwb3J0ZWQoZW5naW5lKSlcclxuICAgICAgdHJhbnNwb3J0ZWQgPSBuZXcgVHJhbnNwb3J0ZWRUcmFuc3BvcnRlZCh0aGlzLCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbik7XHJcbiAgICBlbHNlIGlmIChUaW1lRW5naW5lLmltcGxlbWVudHNTcGVlZENvbnRyb2xsZWQoZW5naW5lKSlcclxuICAgICAgdHJhbnNwb3J0ZWQgPSBuZXcgVHJhbnNwb3J0ZWRTcGVlZENvbnRyb2xsZWQodGhpcywgZW5naW5lLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgb2Zmc2V0UG9zaXRpb24pO1xyXG4gICAgZWxzZSBpZiAoVGltZUVuZ2luZS5pbXBsZW1lbnRzU2NoZWR1bGVkKGVuZ2luZSkpXHJcbiAgICAgIHRyYW5zcG9ydGVkID0gbmV3IFRyYW5zcG9ydGVkU2NoZWR1bGVkKHRoaXMsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcclxuICAgIGVsc2VcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGNhbm5vdCBiZSBhZGRlZCB0byBhIHRyYW5zcG9ydFwiKTtcclxuXHJcbiAgICBpZiAodHJhbnNwb3J0ZWQpIHtcclxuICAgICAgY29uc3Qgc3BlZWQgPSB0aGlzLl9fc3BlZWQ7XHJcblxyXG4gICAgICBhZGREdXBsZXQodGhpcy5fX2VuZ2luZXMsIHRoaXMuX190cmFuc3BvcnRlZCwgZW5naW5lLCB0cmFuc3BvcnRlZCk7XHJcblxyXG4gICAgICBpZiAoc3BlZWQgIT09IDApIHtcclxuICAgICAgICAvLyBzeW5jIGFuZCBzdGFydFxyXG4gICAgICAgIGNvbnN0IG5leHRFbmdpbmVQb3NpdGlvbiA9IHRyYW5zcG9ydGVkLnN5bmNQb3NpdGlvbih0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmN1cnJlbnRQb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLmluc2VydCh0cmFuc3BvcnRlZCwgbmV4dEVuZ2luZVBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNldFBvc2l0aW9uKG5leHRQb3NpdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJhbnNwb3J0ZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgYSB0aW1lIGVuZ2luZSBmcm9tIHRoZSB0cmFuc3BvcnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZW5naW5lT3JUcmFuc3BvcnRlZCAtIGVuZ2luZSBvciB0cmFuc3BvcnRlZCB0byBiZSByZW1vdmVkIGZyb20gdGhlIHRyYW5zcG9ydFxyXG4gICAqL1xyXG4gIHJlbW92ZShlbmdpbmVPclRyYW5zcG9ydGVkKSB7XHJcbiAgICBsZXQgZW5naW5lID0gZW5naW5lT3JUcmFuc3BvcnRlZDtcclxuICAgIGxldCB0cmFuc3BvcnRlZCA9IHJlbW92ZUR1cGxldCh0aGlzLl9fZW5naW5lcywgdGhpcy5fX3RyYW5zcG9ydGVkLCBlbmdpbmVPclRyYW5zcG9ydGVkKTtcclxuXHJcbiAgICBpZiAoIXRyYW5zcG9ydGVkKSB7XHJcbiAgICAgIGVuZ2luZSA9IHJlbW92ZUR1cGxldCh0aGlzLl9fdHJhbnNwb3J0ZWQsIHRoaXMuX19lbmdpbmVzLCBlbmdpbmVPclRyYW5zcG9ydGVkKTtcclxuICAgICAgdHJhbnNwb3J0ZWQgPSBlbmdpbmVPclRyYW5zcG9ydGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlbmdpbmUgJiYgdHJhbnNwb3J0ZWQpIHtcclxuICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0gdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUucmVtb3ZlKHRyYW5zcG9ydGVkKTtcclxuXHJcbiAgICAgIHRyYW5zcG9ydGVkLmRlc3Ryb3koKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9fc3BlZWQgIT09IDApXHJcbiAgICAgICAgdGhpcy5yZXNldFBvc2l0aW9uKG5leHRQb3NpdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoaXMgdHJhbnNwb3J0XCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGVuZ2luZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gdHJhbnNwb3J0ZWQgLSBFbmdpbmUgdG8gcmVzZXRcclxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBOZXcgcG9zaXRpb25cclxuICAgKi9cclxuICByZXNldEVuZ2luZVBvc2l0aW9uKHRyYW5zcG9ydGVkLCBwb3NpdGlvbiA9IHVuZGVmaW5lZCkge1xyXG4gICAgY29uc3Qgc3BlZWQgPSB0aGlzLl9fc3BlZWQ7XHJcblxyXG4gICAgaWYgKHNwZWVkICE9PSAwKSB7XHJcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHBvc2l0aW9uID0gdHJhbnNwb3J0ZWQuc3luY1Bvc2l0aW9uKHRoaXMuY3VycmVudFRpbWUsIHRoaXMuY3VycmVudFBvc2l0aW9uLCBzcGVlZCk7XHJcblxyXG4gICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5tb3ZlKHRyYW5zcG9ydGVkLCBwb3NpdGlvbik7XHJcbiAgICAgIHRoaXMucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFsbCB0aW1lIGVuZ2luZXMgZnJvbSB0aGUgdHJhbnNwb3J0LlxyXG4gICAqL1xyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5zeW5jU3BlZWQodGhpcy5jdXJyZW50VGltZSwgdGhpcy5jdXJyZW50UG9zaXRpb24sIDApO1xyXG5cclxuICAgIGZvciAobGV0IHRyYW5zcG9ydGVkIG9mIHRoaXMuX190cmFuc3BvcnRlZClcclxuICAgICAgdHJhbnNwb3J0ZWQuZGVzdHJveSgpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVHJhbnNwb3J0O1xyXG4iLCIvKiAgRnJvbSBQaGFzZVZvY29kZXIuanMgKGMpIDIwMTUgYnkgRWNobzY2XG4gICAgaHR0cHM6Ly9naXRodWIuY29tL2VjaG82Ni9QaGFzZVZvY29kZXJKU1xuXG4gICAgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuXHRhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuaW1wb3J0IENCdWZmZXIgZnJvbSAnLi9jYnVmZmVyJztcbmltcG9ydCB7RkZUfSBmcm9tICcuL2RzcC5qcyc7XG5pbXBvcnQgRFNQIGZyb20gJy4vZHNwJztcblxuZnVuY3Rpb24gUGhhc2VWb2NvZGVyKHdpblNpemUsIHNhbXBsZVJhdGUpIHtcblxuXHR2YXIgX3NhbXBsZVJhdGUgPSBzYW1wbGVSYXRlOyB2YXIgX0hzID0gMDsgdmFyIF9IYSA9IDA7IHZhciBfb21lZ2E7XG5cblx0dmFyIF9wcmV2aW91c0lucHV0UGhhc2U7IHZhciBfcHJldmlvdXNPdXRwdXRQaGFzZTsgdmFyIF9mcmFtaW5nV2luZG93O1xuXHRcblx0dmFyIF9zcXVhcmVkRnJhbWluZ1dpbmRvdzsgdmFyIF93aW5TaXplID0gd2luU2l6ZTtcblxuXHR2YXIgX292ZXJsYXBCdWZmZXJzOyB2YXIgX293T3ZlcmxhcEJ1ZmZlcnM7XG5cblx0dmFyIF9maXJzdCA9IHRydWU7XG5cblx0dmFyIF9vdmVybGFwRmFjdG9yID0gNDtcblxuXHR2YXIgX2xhc3RJbnB1dEFscGhhID0gMTtcblxuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqIGRzcC5qcyBGRlQgKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdHZhciBmZnQgPSBuZXcgRkZUKF93aW5TaXplLCBzYW1wbGVSYXRlKTtcblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG5cdHZhciBzcXJ0ID0gTWF0aC5zcXJ0OyB2YXIgY29zID0gTWF0aC5jb3M7XG5cdHZhciBzaW4gPSBNYXRoLnNpbjsgdmFyIGF0YW4yID0gTWF0aC5hdGFuMjtcblx0dmFyIHJvdW5kID0gTWF0aC5yb3VuZDsgdmFyIG1heCA9IE1hdGgubWF4O1xuXHR2YXIgY2VpbCA9IE1hdGguY2VpbDsgdmFyIHBvdyA9IE1hdGgucG93O1xuXHR2YXIgUEkgPSBNYXRoLlBJO1xuXG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqUFJFLUFMTE9DQVRFIE1FTU9SWSoqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHQvL2ZpbmRfcGVha3Ncblx0dmFyIF9obGZTaXplID0gcm91bmQoX3dpblNpemUvMikrMTtcblxuXHQvLyAvLyBwcm9jZXNzXG5cdHZhciBfcHJvY2VzcyA9IHtcblx0XHRmZnRPYmogOiB7XG5cdFx0XHRyZWFsOiBuZXcgRmxvYXQzMkFycmF5KF9obGZTaXplKSwgXG5cdFx0XHRpbWFnOiBuZXcgRmxvYXQzMkFycmF5KF9obGZTaXplKSwgXG5cdFx0XHRtYWduaXR1ZGU6IG5ldyBGbG9hdDMyQXJyYXkoX2hsZlNpemUpLCBcblx0XHRcdHBoYXNlOiBuZXcgRmxvYXQzMkFycmF5KF9obGZTaXplKVxuXHRcdH0sIFxuXHRcdHB2T3V0IDoge1xuXHRcdFx0cmVhbDogY3JlYXRlX2NvbnN0YW50X2FycmF5KF93aW5TaXplLCAwLCBGbG9hdDMyQXJyYXkpLCBcblx0XHRcdGltYWc6IGNyZWF0ZV9jb25zdGFudF9hcnJheShfd2luU2l6ZSwgMCwgRmxvYXQzMkFycmF5KSwgXG5cdFx0XHRtYWduaXR1ZGU6IGNyZWF0ZV9jb25zdGFudF9hcnJheShfd2luU2l6ZSwgMCwgRmxvYXQzMkFycmF5KSwgXG5cdFx0XHRwaGFzZTogY3JlYXRlX2NvbnN0YW50X2FycmF5KF93aW5TaXplLCAwLCBGbG9hdDMyQXJyYXkpXG5cdFx0fSxcblx0XHRwcm9jZXNzZWRGcmFtZSA6IG5ldyBGbG9hdDMyQXJyYXkoX3dpblNpemUpXG5cdH07XG5cblx0dmFyIF9wdl9zdGVwID0ge1xuXHRcdGluc3RQaGFzZUFkdiA6IG5ldyBGbG9hdDMyQXJyYXkoX2hsZlNpemUpLCBcblx0XHRwaFRoIDogbmV3IEZsb2F0MzJBcnJheShfaGxmU2l6ZSlcblx0fTtcblxuXHR2YXIgX1NURlQgPSB7XG5cdFx0X2lucHV0RnJhbWUgOiBuZXcgRmxvYXQzMkFycmF5KF93aW5TaXplKSxcblx0XHRfemVyb3M6IG5ldyBGbG9hdDMyQXJyYXkoX3dpblNpemUpXG5cdH1cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHR2YXIgcGhUaF9pZHggPSAwO1xuXHR2YXIgdHdvUEkgPSAyICogUEk7XG5cdHZhciBleHBlY3RlZFBoYXNlQWR2LCBhdXhIZXRlcm9keW5lZFBoYXNlSW5jciwgaGV0ZXJvZHluZWRQaGFzZUluY3IsIFxuXHRcdGluc3RQaGFzZUFkdlBlclNhbXBsZUhvcCwgaW5zdFBoYXNlQWR2XywgcHJldkluc3RQaGFzZUFkdl87XG5cdFxuXHRmdW5jdGlvbiBvdmVybGFwX2FuZF9zbGlkZShIcywgaW5GLCBzcXVhcmVkV2luRiwgb0J1Ziwgb3dPQnVmLCB3aW5kb3dTaXplLCBvdXRGKSB7XG5cblx0XHR2YXIgb3dTYW1wbGUsIG9TYW1wbGUgPSAwO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IEhzOyBpKyspIHtcblx0ICAgICAgb3dTYW1wbGUgPSBvd09CdWYuc2hpZnQoKSB8fCAwO1xuXHQgICAgICBvU2FtcGxlICA9IG9CdWYuc2hpZnQoKSB8fCAwO1xuXHQgICAgICBvdXRGLnB1c2gob1NhbXBsZSAvICgob3dTYW1wbGU8MTBlLTMpPyAxIDogb3dTYW1wbGUpKTtcblx0ICAgICAgb0J1Zi5wdXNoKDApO1xuXHQgICAgICBvd09CdWYucHVzaCgwKTtcblx0ICAgIH1cblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aW5kb3dTaXplOyBpKyspIHtcblx0ICAgICAgb1NhbXBsZSA9IG9CdWYuc2hpZnQoKTtcblx0ICAgICAgb0J1Zi5wdXNoKGluRltpXSArIG9TYW1wbGUpO1xuXHQgICAgICBvd1NhbXBsZSA9IG93T0J1Zi5zaGlmdCgpO1xuXHQgICAgICBvd09CdWYucHVzaChzcXVhcmVkV2luRltpXSArIG93U2FtcGxlKTtcblx0ICAgIH1cblx0fVxuXG5cblx0ZnVuY3Rpb24gcHZfc3RlcChmZnRPYmosIHByZXZJblBoLCBwcmV2T3V0UGgsIG9tZWdhLCBIYSwgSHMsIG91dCkge1xuXG5cdFx0dmFyIGN1cnJJblBoID0gZmZ0T2JqLnBoYXNlO1xuXHRcdHZhciBtYWcgPSBmZnRPYmoubWFnbml0dWRlO1xuXHRcdHZhciBpbnN0UGhhc2VBZHYgPSBfcHZfc3RlcC5pbnN0UGhhc2VBZHY7XG5cdFx0dmFyIHBoVGggPSBfcHZfc3RlcC5waFRoO1xuXG5cdFx0dmFyIHBlYWssIHByZXZQZWFrLCByZWcsIHJlZ1N0YXJ0LCBwcmV2UmVnRW5kLCBwcmV2UmVnU3RhcnQsIGQsIGk7XG5cdFx0cGhUaF9pZHggPSAwO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IG9tZWdhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRleHBlY3RlZFBoYXNlQWR2ID0gb21lZ2FbaV0gKiBIYTtcblxuXHRcdFx0YXV4SGV0ZXJvZHluZWRQaGFzZUluY3IgPSAoY3VyckluUGhbaV0gLSBwcmV2SW5QaFtpXSkgLSBleHBlY3RlZFBoYXNlQWR2O1xuXHRcdFx0aGV0ZXJvZHluZWRQaGFzZUluY3IgPSBhdXhIZXRlcm9keW5lZFBoYXNlSW5jciAtIHR3b1BJICogcm91bmQoYXV4SGV0ZXJvZHluZWRQaGFzZUluY3IvdHdvUEkpO1xuXG5cdFx0XHRpbnN0UGhhc2VBZHZQZXJTYW1wbGVIb3AgPSBvbWVnYVtpXSArIGhldGVyb2R5bmVkUGhhc2VJbmNyIC8gSGE7XG5cblx0XHRcdGluc3RQaGFzZUFkdl8gPSBpbnN0UGhhc2VBZHZQZXJTYW1wbGVIb3AgKiBIcztcblxuXHRcdFx0aWYgKG1hZ1tpXSA+IG1heCgobWFnW2ktMl18MCksIChtYWdbaS0xXXwwKSwgKG1hZ1tpKzFdfDApLCAobWFnW2krMl18MCkpKSB7XG5cdFx0XHQvLyBpZiAobWFnW2ldID4gKG1hZ1tpLTJdfDApICYmIG1hZ1tpXSA+IChtYWdbaS0xXXwwKSAmJiBtYWdbaV0gPiAobWFnW2krMV18MCkgJiYgbWFnW2ldID4gKG1hZ1tpKzJdfDApKSB7XG5cdFx0XHRcdHBlYWsgPSBpO1xuXHRcdFx0XHRyZWdTdGFydCA9IGNlaWwoKHByZXZQZWFrICsgcGVhaykvMikgfCAwOyBcblx0XHRcdFx0cHJldlJlZ0VuZCA9IHJlZ1N0YXJ0LTE7XG5cdFx0XHRcdHJlZyA9IG1heCgwLCBwcmV2UmVnRW5kIC0gcHJldlJlZ1N0YXJ0ICsgMSk7XG5cdFx0XHRcdHByZXZSZWdTdGFydCA9IHJlZ1N0YXJ0O1xuXHRcdFx0XHRmb3IgKGQgPSAwOyBkIDwgcmVnOyBkKyssIHBoVGhfaWR4KyspIHtcblx0XHRcdFx0XHRwaFRoW3BoVGhfaWR4XSA9IHByZXZPdXRQaFtwcmV2UGVha10gKyBwcmV2SW5zdFBoYXNlQWR2XyAtIGN1cnJJblBoW3ByZXZQZWFrXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcmV2UGVhayA9IHBlYWs7XG5cdFx0XHRcdHByZXZJbnN0UGhhc2VBZHZfID0gaW5zdFBoYXNlQWR2Xztcblx0XHRcdH1cblx0XHR9XG5cdFx0XG5cdFx0Zm9yICh2YXIgaT0wOyBpPHBoVGgubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB0aGV0YSA9IHBoVGhbaV07XG5cblx0XHRcdHZhciBwaFRoUmUgPSBjb3MocGhUaFtpXSk7XG5cdFx0XHR2YXIgcGhUaEltID0gc2luKHBoVGhbaV0pO1xuXHRcdFx0XG5cdFx0XHRvdXQucmVhbFtpXSA9IHBoVGhSZSAqIGZmdE9iai5yZWFsW2ldIC0gcGhUaEltICogZmZ0T2JqLmltYWdbaV07XG5cdFx0XHRvdXQuaW1hZ1tpXSA9IHBoVGhSZSAqIGZmdE9iai5pbWFnW2ldICsgcGhUaEltICogZmZ0T2JqLnJlYWxbaV07XG5cdFx0XHRvdXQucGhhc2VbaV0gPSBhdGFuMihvdXQuaW1hZ1tpXSwgb3V0LnJlYWxbaV0pO1xuXHRcdH1cblx0XHRcblx0XHRyZXR1cm47XG5cdH1cblxuXG5cdHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKGlucHV0QXJyYXksIG91dHB1dEFycmF5KSB7XG5cblx0XHR2YXIgXyA9IHRoaXM7XG5cblx0XHR2YXIgX19IcyA9IF9Icztcblx0XHR2YXIgX19IYSA9IF9IYTtcblxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvLyAtLS0tLS0tLS0tQU5BTFlTSVMgU1RFUC0tLS0tLS0tLS0tXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdFxuXHRcdHZhciBwcm9jZXNzZWRGcmFtZSA9IF9wcm9jZXNzLnByb2Nlc3NlZEZyYW1lOztcblx0XHR2YXIgZmZ0T2JqID0gX3Byb2Nlc3MuZmZ0T2JqO1xuXHRcdC8vIEZPUiBTT01FIFJFQVNPTiwgSUYgSSBET04nVCBDUkVBVEUgQSBORVcgXCJwaGFzZVwiIEFSSGFZLCBJIEdFVCBBUlRJRkFDVFMuXG5cdFx0Ly8gZmZ0T2JqLnBoYXNlID0gbmV3IEZsb2F0MzJBcnJheShfaGxmU2l6ZSk7IFxuXHRcdHZhciBwdk91dCA9IF9wcm9jZXNzLnB2T3V0O1xuXHRcdF8uU1RGVChpbnB1dEFycmF5LCBfZnJhbWluZ1dpbmRvdywgX2hsZlNpemUsIGZmdE9iaik7XG5cdFx0cHZfc3RlcChmZnRPYmosIF9wcmV2aW91c0lucHV0UGhhc2UsIF9wcmV2aW91c091dHB1dFBoYXNlLCBfb21lZ2EsIF9fSGEsIF9fSHMsIHB2T3V0KTtcblx0XHRfcHJldmlvdXNPdXRwdXRQaGFzZSA9IHB2T3V0LnBoYXNlO1xuXHRcdC8vIFRoZSBcInBoYXNlXCIgaXNzdWUgbWVudGlvbmVkIGFib3ZlIGlzIHJlbGF0ZWQgdG8gdGhpcyBsaW5lLiBcblx0XHQvLyBJZiBJIGNyZWF0ZSBhIG5ldyBGbG9hdCBhcnJheSB1c2luZyB0aGUgcGhhc2UgYXJyYXksIEkgZ2V0IG5vIGlzc3Vlcy5cblx0XHRfcHJldmlvdXNJbnB1dFBoYXNlID0gbmV3IEZsb2F0MzJBcnJheShmZnRPYmoucGhhc2UpOyBcblx0XHRfLklTVEZUKHB2T3V0LnJlYWwsIHB2T3V0LmltYWcsIF9mcmFtaW5nV2luZG93LCBmYWxzZSwgcHJvY2Vzc2VkRnJhbWUpO1xuXG5cblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0Ly8gLS0tLS0tT1ZFUkxBUCBBTkQgU0xJREUgU1RFUC0tLS0tLVxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHQvLyB2YXIgb3V0cHV0RnJhbWUgPSBuZXcgQXJyYXkoX19Icyk7XG5cblx0XHRvdmVybGFwX2FuZF9zbGlkZShfX0hzLCBwcm9jZXNzZWRGcmFtZSwgX3NxdWFyZWRGcmFtaW5nV2luZG93LCBfb3ZlcmxhcEJ1ZmZlcnMsIF9vd092ZXJsYXBCdWZmZXJzLCBfd2luU2l6ZSwgb3V0cHV0QXJyYXkpO1xuXG5cdFx0cmV0dXJuIF9fSHM7XG5cblx0fVxuXG5cdFxuXHR0aGlzLlNURlQgPSBmdW5jdGlvbihpbnB1dEZyYW1lLCB3aW5kb3dGcmFtZSwgd2FudGVkU2l6ZSwgb3V0KSB7XG5cdFx0dGhpcy5TVEZUX2Ryb20oaW5wdXRGcmFtZSwgd2luZG93RnJhbWUsIHdhbnRlZFNpemUsIG91dCk7XG5cdH1cblxuXHR0aGlzLlNURlRfZHJvbSA9IGZ1bmN0aW9uKGlucHV0RnJhbWUsIHdpbmRvd0ZyYW1lLCB3YW50ZWRTaXplLCBvdXQpIHtcblx0XHR2YXIgd2luU2l6ZSA9IHdpbmRvd0ZyYW1lLmxlbmd0aDtcblx0XHR2YXIgX2lucHV0RnJhbWUgPSBfU1RGVC5faW5wdXRGcmFtZTtcblxuXHRcdGZvciAodmFyIGk9MDsgaTx3aW5TaXplOyBpKyspIHtcblx0XHRcdF9pbnB1dEZyYW1lW2ldID0gaW5wdXRGcmFtZVtpXSAqIHdpbmRvd0ZyYW1lW2ldO1xuXHRcdH1cblx0XHRcblx0XHRmZnQuZm9yd2FyZChfaW5wdXRGcmFtZSk7XG5cdFx0b3V0LnJlYWwgPSBmZnQucmVhbDtcblx0XHRvdXQuaW1hZyA9IGZmdC5pbWFnO1xuXHRcdFxuXHRcdHZhciBSID0gb3V0LnJlYWw7IHZhciBJID0gb3V0LmltYWc7XG5cdFx0dmFyIFAgPSBvdXQucGhhc2U7IHZhciBNID0gb3V0Lm1hZ25pdHVkZTtcblxuXHRcdGZvciAodmFyIHA9MDsgcDx3aW5TaXplICYmIHA8d2FudGVkU2l6ZTsgcCsrKSB7XHRcblx0XHRcdE1bcF0gPSBzcXJ0KElbcF0qSVtwXSArIFJbcF0qUltwXSkgKiAxMDAwO1xuXHRcdFx0UFtwXSA9IGF0YW4yKElbcF0sIFJbcF0pO1xuXHRcdH1cblxuXHRcdHJldHVybjtcblx0fVxuXG5cblxuXHR0aGlzLklTVEZUID0gZnVuY3Rpb24ocmVhbCwgaW1hZywgd2luZG93RnJhbWUsIHJlc3RvcmVFbmVyZ3ksIHRpbWVGcmFtZSkge1xuXHRcdHRoaXMuSVNURlRfZHJvbShyZWFsLCBpbWFnLCB3aW5kb3dGcmFtZSwgcmVzdG9yZUVuZXJneSwgdGltZUZyYW1lKTtcblx0fVxuXG5cdHRoaXMuSVNURlRfZHJvbSA9IGZ1bmN0aW9uKHJlYWwsIGltYWcsIHdpbmRvd0ZyYW1lLCByZXN0b3JlRW5lcmd5LCB0aW1lRnJhbWUpIHtcblxuXHRcdGZmdC5pbnZlcnNlKHJlYWwsIGltYWcsIHRpbWVGcmFtZSk7XG5cblx0XHRyZXR1cm47XG5cblx0fVxuXG5cblxuXHR0aGlzLmluaXQgPSBmdW5jdGlvbigpIHtcblxuXHRcdF9vbWVnYSA9IGNyZWF0ZV9vbWVnYV9hcnJheSh3aW5TaXplKTtcblxuXHRcdHRoaXMucmVzZXRfcGhhc2VzX2FuZF9vdmVybGFwX2J1ZmZlcnMoKTtcblxuXHRcdF9mcmFtaW5nV2luZG93ID0gY3JlYXRlX3Npbl9iZXRhX3dpbmRvd19hcnJheSh3aW5TaXplLCAxKTtcblxuXHRcdF9zcXVhcmVkRnJhbWluZ1dpbmRvdyA9IF9mcmFtaW5nV2luZG93Lm1hcChmdW5jdGlvbih4LGkpeyByZXR1cm4geCp4OyB9KTtcblxuXHRcdHRoaXMuc2V0X2FscGhhKDEpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlX29tZWdhX2FycmF5KHNpemUpIHtcblx0XHRyZXR1cm4gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoc2l6ZS8yICsgMSkpLm1hcChmdW5jdGlvbiAoeCwgaSkgeyBcblx0XHRcdHJldHVybiB0d29QSSAqIGkgLyBzaXplO1xuXHRcdH0pO1xuXHR9XG5cdFxuXHRmdW5jdGlvbiBjcmVhdGVfc2luX2JldGFfd2luZG93X2FycmF5KHNpemUsIGJldGEpIHtcblx0XHRyZXR1cm4gQXJyYXkuYXBwbHkobnVsbCwgQXJyYXkoc2l6ZSkpLm1hcChmdW5jdGlvbih4LGkpe1xuXHRcdFx0cmV0dXJuIHBvdyhzaW4oUEkgKiBpIC8gc2l6ZSksIGJldGEpO1xuXHRcdH0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlX2NvbnN0YW50X2FycmF5KHNpemUsIGNvbnN0YW50LCBBcnJheVR5cGUpIHtcblx0XHR2YXIgYXJyID0gbmV3ICgoQXJyYXlUeXBlKT9BcnJheVR5cGU6QXJyYXkpKHNpemUpO1xuXHRcdGZvciAodmFyIGk9MDsgaTxzaXplOyBpKyspIFxuXHRcdFx0YXJyW2ldID0gY29uc3RhbnQ7XG5cdFx0cmV0dXJuIGFycjtcblx0fVxuXG5cdHRoaXMucmVzZXRfcGhhc2VzX2FuZF9vdmVybGFwX2J1ZmZlcnMgPSBmdW5jdGlvbigpIHtcblxuXHRcdF9wcmV2aW91c0lucHV0UGhhc2UgPSBjcmVhdGVfY29uc3RhbnRfYXJyYXkod2luU2l6ZS8yLCAwKTtcblx0XHRfcHJldmlvdXNPdXRwdXRQaGFzZSA9IGNyZWF0ZV9jb25zdGFudF9hcnJheSh3aW5TaXplLzIsIDApO1xuXG5cdFx0X292ZXJsYXBCdWZmZXJzID0gbmV3IENCdWZmZXIod2luU2l6ZSk7XG5cdFx0X293T3ZlcmxhcEJ1ZmZlcnMgPSBuZXcgQ0J1ZmZlcih3aW5TaXplKTtcblx0XHRmb3IgKHZhciBpPTA7IGkgPCB3aW5TaXplOyBpKyspIHtcblx0XHRcdF9vdmVybGFwQnVmZmVycy5wdXNoKDApO1xuXHRcdFx0X293T3ZlcmxhcEJ1ZmZlcnMucHVzaCgwKTtcblx0XHR9XG5cblx0XHRfZmlyc3QgPSB0cnVlO1xuXHR9XG5cblx0dGhpcy5yZXNldF9waGFzZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdF9wcmV2aW91c0lucHV0UGhhc2UgPSBjcmVhdGVfY29uc3RhbnRfYXJyYXkod2luU2l6ZS8yLCAwKTtcblx0XHRfcHJldmlvdXNPdXRwdXRQaGFzZSA9IGNyZWF0ZV9jb25zdGFudF9hcnJheSh3aW5TaXplLzIsIDApO1xuXG5cdFx0X2ZpcnN0ID0gdHJ1ZTtcblx0fVxuXG5cblx0dGhpcy5nZXRfcHJldmlvdXNfaW5wdXRfcGhhc2UgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX3ByZXZpb3VzSW5wdXRQaGFzZTtcblx0fVxuXG5cdHRoaXMuZ2V0X3ByZXZpb3VzX291dHB1dF9waGFzZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfcHJldmlvdXNPdXRwdXRQaGFzZTtcblx0fVxuXG5cdHRoaXMuZ2V0X2FuYWx5c2lzX2hvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfSGE7XG5cdH1cblxuXHR0aGlzLmdldF9zeW50aGVzaXNfaG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF9Icztcblx0fVxuXG5cdHRoaXMuZ2V0X2FscGhhID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF9IcyAvIF9IYTtcblx0fVxuXG5cdHRoaXMuZ2V0X2ZyYW1pbmdfd2luZG93ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF9mcmFtaW5nV2luZG93O1xuXHR9XG5cblx0dGhpcy5nZXRfc3F1YXJlZF9mcmFtaW5nX3dpbmRvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfc3F1YXJlZEZyYW1pbmdXaW5kb3c7XG5cdH1cblxuXHR0aGlzLnNldF9hbHBoYSA9IGZ1bmN0aW9uKG5ld0FscGhhKSB7XG5cdFx0X2xhc3RJbnB1dEFscGhhID0gbmV3QWxwaGE7XG5cdFx0aWYgKG5ld0FscGhhIDw9IDAuOClcblx0XHRcdF9vdmVybGFwRmFjdG9yID0gMjtcblx0XHRlbHNlIGlmIChuZXdBbHBoYSA8PSAxKVxuXHRcdFx0X292ZXJsYXBGYWN0b3IgPSA0O1xuXHRcdGVsc2Vcblx0XHRcdF9vdmVybGFwRmFjdG9yID0gNTtcblxuXHRcdC8qIFwiRml4ZWRcIiBzeW50aGVzaXMgaG9wIHNpemUuICovXG5cdFx0X0hhID0gcm91bmQoX3dpblNpemUvX292ZXJsYXBGYWN0b3IpO1xuXHRcdF9IcyA9IHJvdW5kKG5ld0FscGhhICogX0hhKTtcblx0XHRcblx0XHQvLyBfSHMgPSBfSGE7XG5cblx0XHQvLyBfSHMgPSByb3VuZChfd2luU2l6ZS8yKTtcblx0XHQvLyBfSGEgPSByb3VuZChfSHMgLyBuZXdBbHBoYSk7XG5cdH1cblxuXHR0aGlzLmdldF9hbHBoYV9zdGVwID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIDEvX0hhO1xuXHR9XG5cblx0dGhpcy5zZXRfaG9wcyA9IGZ1bmN0aW9uKEhhLCBIcykge1xuXHRcdF9IYSA9IEhhO1xuXHRcdF9IcyA9IEhzO1xuXHR9XG5cblx0dGhpcy5nZXRfc3BlY2lmaWVkX2FscGhhID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF9sYXN0SW5wdXRBbHBoYTtcblx0fVxuXG5cdHRoaXMuc2V0X292ZXJsYXBfZmFjdG9yID0gZnVuY3Rpb24ob3ZlcmxhcEZhY3Rvcikge1xuXHRcdF9vdmVybGFwRmFjdG9yID0gb3ZlcmxhcEZhY3Rvcjtcblx0XHR0aGlzLnNldF9hbHBoYShfbGFzdElucHV0QWxwaGEpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBoYXNlVm9jb2RlcjsiLCIvKiAgRnJvbSBQaGFzZVZvY29kZXIuanMgKGMpIDIwMTUgYnkgRWNobzY2XG4gICAgaHR0cHM6Ly9naXRodWIuY29tL2VjaG82Ni9QaGFzZVZvY29kZXJKU1xuXG5cdFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcblx0YWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgQ0J1ZmZlciBmcm9tICcuL2NidWZmZXInO1xuaW1wb3J0IFBoYXNlVm9jb2RlciBmcm9tICcuL1BWX2Zhc3RfNSc7XG5pbXBvcnQgYXVkaW9Db250ZXh0IGZyb20gJy4uL2NvcmUvYXVkaW8tY29udGV4dCc7XG5cbmZ1bmN0aW9uIEJ1ZmZlcmVkUFYoZnJhbWVTaXplKSB7XG5cblx0dmFyIF9mcmFtZVNpemUgPSBmcmFtZVNpemUgfHwgNDA5Njtcblx0dmFyIF9wdkwgPSBuZXcgUGhhc2VWb2NvZGVyKF9mcmFtZVNpemUsIGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKTsgX3B2TC5pbml0KCk7XG5cdHZhciBfcHZSID0gbmV3IFBoYXNlVm9jb2RlcihfZnJhbWVTaXplLCBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSk7IF9wdlIuaW5pdCgpO1xuXHR2YXIgX2J1ZmZlcjtcblx0dmFyIF9wb3NpdGlvbiA9IDA7XG5cdHZhciBfbmV3QWxwaGEgPSAxO1xuXG5cdHZhciBfbWlkQnVmTCA9IG5ldyBDQnVmZmVyKE1hdGgucm91bmQoX2ZyYW1lU2l6ZSAqIDIpKTtcblx0dmFyIF9taWRCdWZSID0gbmV3IENCdWZmZXIoTWF0aC5yb3VuZChfZnJhbWVTaXplICogMikpO1xuXG5cdFxuXG5cdHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKG91dHB1dEF1ZGlvQnVmZmVyKSB7XG5cblx0XHRpZiAoIV9idWZmZXIpIFxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dmFyIHNhbXBsZUNvdW50ZXIgPSAwO1xuXG4gICAgICAgIHZhciBpbCA9IF9idWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgIHZhciBpciA9IF9idWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG4gICAgICAgIHZhciBvbCA9IG91dHB1dEF1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICB2YXIgb3IgPSBvdXRwdXRBdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YSgxKTtcblxuXG4gICAgICAgIHdoaWxlIChfbWlkQnVmUi5zaXplID4gMCAmJiBzYW1wbGVDb3VudGVyIDwgb3V0cHV0QXVkaW9CdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGkgPSBzYW1wbGVDb3VudGVyKys7XG4gICAgICAgICAgb2xbaV0gPSBfbWlkQnVmTC5zaGlmdCgpO1xuICAgICAgICAgIG9yW2ldID0gX21pZEJ1ZlIuc2hpZnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzYW1wbGVDb3VudGVyID09IG91dHB1dEF1ZGlvQnVmZmVyLmxlbmd0aClcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgZG8ge1xuXG4gICAgICAgICAgdmFyIGJ1ZkwgPSBpbC5zdWJhcnJheShfcG9zaXRpb24sIF9wb3NpdGlvbiArIF9mcmFtZVNpemUpO1xuICAgICAgICAgIHZhciBidWZSID0gaXIuc3ViYXJyYXkoX3Bvc2l0aW9uLCBfcG9zaXRpb24gKyBfZnJhbWVTaXplKTtcblxuICAgICAgICAgIGlmIChfbmV3QWxwaGEgIT0gdW5kZWZpbmVkICYmIF9uZXdBbHBoYSAhPSBfcHZMLmdldF9hbHBoYSgpKSB7XG4gICAgICAgICAgICBfcHZMLnNldF9hbHBoYShfbmV3QWxwaGEpO1xuICAgICAgICAgICAgX3B2Ui5zZXRfYWxwaGEoX25ld0FscGhhKTtcbiAgICAgICAgICAgIF9uZXdBbHBoYSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIC8qIExFRlQgKi9cbiAgICAgICAgICBfcHZMLnByb2Nlc3MoYnVmTCwgX21pZEJ1ZkwpO1xuICAgICAgICAgIF9wdlIucHJvY2VzcyhidWZSLCBfbWlkQnVmUik7XG4gICAgICAgICAgZm9yICh2YXIgaT1zYW1wbGVDb3VudGVyOyBfbWlkQnVmTC5zaXplID4gMCAmJiBpIDwgb3V0cHV0QXVkaW9CdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG9sW2ldID0gX21pZEJ1Zkwuc2hpZnQoKTtcbiAgICAgICAgICAgIG9yW2ldID0gX21pZEJ1ZlIuc2hpZnQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzYW1wbGVDb3VudGVyICs9IF9wdkwuZ2V0X3N5bnRoZXNpc19ob3AoKTtcblxuICAgICAgICAgIF9wb3NpdGlvblxuICAgICAgICAgICArPSBfcHZMLmdldF9hbmFseXNpc19ob3AoKTtcblxuICAgICAgICB9IHdoaWxlIChzYW1wbGVDb3VudGVyIDwgb3V0cHV0QXVkaW9CdWZmZXIubGVuZ3RoKTtcblx0fVxuXG5cdHRoaXMuc2V0X2F1ZGlvX2J1ZmZlciA9IGZ1bmN0aW9uKG5ld0J1ZmZlcikge1xuXHRcdF9idWZmZXIgPSBuZXdCdWZmZXI7XG5cdFx0X3Bvc2l0aW9uID0gMDtcblx0XHRfbmV3QWxwaGEgPSAxO1xuXHR9XG5cdHRoaXMucmVzZXRQaGFzZSA9IGZ1bmN0aW9uKCkge1xuXHRcdF9wdkwucmVzZXRfcGhhc2VzKCk7XG5cdFx0X3B2Ui5yZXNldF9waGFzZXMoKTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG5cdFx0J3Bvc2l0aW9uJyA6IHtcblx0XHRcdGdldCA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gX3Bvc2l0aW9uO1xuXHRcdFx0fSwgXG5cdFx0XHRzZXQgOiBmdW5jdGlvbihuZXdQb3NpdGlvbikge1xuXHRcdFx0XHRfcG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcblx0XHRcdH1cblx0XHR9LCBcblx0XHQnYWxwaGEnIDoge1xuXHRcdFx0Z2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBfcHZMLmdldF9hbHBoYSgpO1xuXHRcdFx0fSwgXG5cdFx0XHRzZXQgOiBmdW5jdGlvbihuZXdBbHBoYSkge1xuXHRcdFx0XHRfbmV3QWxwaGEgPSBuZXdBbHBoYTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBCdWZmZXJlZFBWOyIsIi8qXG5cdFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXHRDb3B5cmlnaHQgKGMpIDIwMTMgVHJldm9yIE5vcnJpcyA8dHJldi5ub3JyaXNAZ21haWwuY29tPlxuXG5cdFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2Zcblx0dGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxuXHR0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvXG5cdHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mXG5cdHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcblx0c3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblx0VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5cdGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0VEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuXHRJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTU1xuXHRGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1Jcblx0Q09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSXG5cdElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG5cdENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG5mdW5jdGlvbiBDQnVmZmVyKCkge1xuXHQvLyBoYW5kbGUgY2FzZXMgd2hlcmUgXCJuZXdcIiBrZXl3b3JkIHdhc24ndCB1c2VkXG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDQnVmZmVyKSkge1xuXHRcdC8vIG11bHRpcGxlIGNvbmRpdGlvbnMgbmVlZCB0byBiZSBjaGVja2VkIHRvIHByb3Blcmx5IGVtdWxhdGUgQXJyYXlcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEgfHwgdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ251bWJlcicpIHtcblx0XHRcdHJldHVybiBDQnVmZmVyLmFwcGx5KG5ldyBDQnVmZmVyKGFyZ3VtZW50cy5sZW5ndGgpLCBhcmd1bWVudHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gbmV3IENCdWZmZXIoYXJndW1lbnRzWzBdKTtcblx0XHR9XG5cdH1cblx0Ly8gaWYgbm8gYXJndW1lbnRzLCB0aGVuIG5vdGhpbmcgbmVlZHMgdG8gYmUgc2V0XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuXHR0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgQXJndW1lbnQ6IFlvdSBtdXN0IHBhc3MgYSB2YWxpZCBidWZmZXIgbGVuZ3RoJyk7XG5cdC8vIHRoaXMgaXMgdGhlIHNhbWUgaW4gZWl0aGVyIHNjZW5hcmlvXG5cdHRoaXMuc2l6ZSA9IHRoaXMuc3RhcnQgPSAwO1xuXHQvLyBzZXQgdG8gY2FsbGJhY2sgZm4gaWYgZGF0YSBpcyBhYm91dCB0byBiZSBvdmVyd3JpdHRlblxuXHR0aGlzLm92ZXJmbG93ID0gbnVsbDtcblx0Ly8gZW11bGF0ZSBBcnJheSBiYXNlZCBvbiBwYXNzZWQgYXJndW1lbnRzXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSB8fCB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnbnVtYmVyJykge1xuXHRcdHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cdFx0dGhpcy5lbmQgPSAodGhpcy5sZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoKSAtIDE7XG5cdFx0dGhpcy5wdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShhcmd1bWVudHNbMF0pO1xuXHRcdHRoaXMuZW5kID0gKHRoaXMubGVuZ3RoID0gYXJndW1lbnRzWzBdKSAtIDE7XG5cdH1cblx0Ly8gbmVlZCB0byBgcmV0dXJuIHRoaXNgIHNvIGByZXR1cm4gQ0J1ZmZlci5hcHBseWAgd29ya3Ncblx0cmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJpdG9yKGEsIGIpIHtcblx0cmV0dXJuIGEgPT0gYiA/IDAgOiBhID4gYiA/IDEgOiAtMTtcbn1cblxuQ0J1ZmZlci5wcm90b3R5cGUgPSB7XG5cdC8vIHByb3Blcmx5IHNldCBjb25zdHJ1Y3RvclxuXHRjb25zdHJ1Y3RvciA6IENCdWZmZXIsXG5cblx0LyogbXV0YXRvciBtZXRob2RzICovXG5cdC8vIHBvcCBsYXN0IGl0ZW1cblx0cG9wIDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpdGVtO1xuXHRcdGlmICh0aGlzLnNpemUgPT09IDApIHJldHVybjtcblx0XHRpdGVtID0gdGhpcy5kYXRhW3RoaXMuZW5kXTtcblx0XHQvLyByZW1vdmUgdGhlIHJlZmVyZW5jZSB0byB0aGUgb2JqZWN0IHNvIGl0IGNhbiBiZSBnYXJiYWdlIGNvbGxlY3RlZFxuXHRcdGRlbGV0ZSB0aGlzLmRhdGFbdGhpcy5lbmRdO1xuXHRcdHRoaXMuZW5kID0gKHRoaXMuZW5kIC0gMSArIHRoaXMubGVuZ3RoKSAlIHRoaXMubGVuZ3RoO1xuXHRcdHRoaXMuc2l6ZS0tO1xuXHRcdHJldHVybiBpdGVtO1xuXHR9LFxuXHQvLyBwdXNoIGl0ZW0gdG8gdGhlIGVuZFxuXHRwdXNoIDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpID0gMDtcblx0XHQvLyBjaGVjayBpZiBvdmVyZmxvdyBpcyBzZXQsIGFuZCBpZiBkYXRhIGlzIGFib3V0IHRvIGJlIG92ZXJ3cml0dGVuXG5cdFx0aWYgKHRoaXMub3ZlcmZsb3cgJiYgdGhpcy5zaXplICsgYXJndW1lbnRzLmxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG5cdFx0XHQvLyBjYWxsIG92ZXJmbG93IGZ1bmN0aW9uIGFuZCBzZW5kIGRhdGEgdGhhdCdzIGFib3V0IHRvIGJlIG92ZXJ3cml0dGVuXG5cdFx0XHRmb3IgKDsgaSA8IHRoaXMuc2l6ZSArIGFyZ3VtZW50cy5sZW5ndGggLSB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMub3ZlcmZsb3codGhpcy5kYXRhWyh0aGlzLmVuZCArIGkgKyAxKSAlIHRoaXMubGVuZ3RoXSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIHB1c2ggaXRlbXMgdG8gdGhlIGVuZCwgd3JhcHBpbmcgYW5kIGVyYXNpbmcgZXhpc3RpbmcgaXRlbXNcblx0XHQvLyB1c2luZyBhcmd1bWVudHMgdmFyaWFibGUgZGlyZWN0bHkgdG8gcmVkdWNlIGdjIGZvb3RwcmludFxuXHRcdGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuZGF0YVsodGhpcy5lbmQgKyBpICsgMSkgJSB0aGlzLmxlbmd0aF0gPSBhcmd1bWVudHNbaV07XG5cdFx0fVxuXHRcdC8vIHJlY2FsY3VsYXRlIHNpemVcblx0XHRpZiAodGhpcy5zaXplIDwgdGhpcy5sZW5ndGgpIHtcblx0XHRcdGlmICh0aGlzLnNpemUgKyBpID4gdGhpcy5sZW5ndGgpIHRoaXMuc2l6ZSA9IHRoaXMubGVuZ3RoO1xuXHRcdFx0ZWxzZSB0aGlzLnNpemUgKz0gaTtcblx0XHR9XG5cdFx0Ly8gcmVjYWxjdWxhdGUgZW5kXG5cdFx0dGhpcy5lbmQgPSAodGhpcy5lbmQgKyBpKSAlIHRoaXMubGVuZ3RoO1xuXHRcdC8vIHJlY2FsY3VsYXRlIHN0YXJ0XG5cdFx0dGhpcy5zdGFydCA9ICh0aGlzLmxlbmd0aCArIHRoaXMuZW5kIC0gdGhpcy5zaXplICsgMSkgJSB0aGlzLmxlbmd0aDtcblx0XHQvLyByZXR1cm4gbnVtYmVyIGN1cnJlbnQgbnVtYmVyIG9mIGl0ZW1zIGluIENCdWZmZXJcblx0XHRyZXR1cm4gdGhpcy5zaXplO1xuXHR9LFxuXHQvLyByZXZlcnNlIG9yZGVyIG9mIHRoZSBidWZmZXJcblx0cmV2ZXJzZSA6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHR0bXA7XG5cdFx0Zm9yICg7IGkgPCB+fih0aGlzLnNpemUgLyAyKTsgaSsrKSB7XG5cdFx0XHR0bXAgPSB0aGlzLmRhdGFbKHRoaXMuc3RhcnQgKyBpKSAlIHRoaXMubGVuZ3RoXTtcblx0XHRcdHRoaXMuZGF0YVsodGhpcy5zdGFydCArIGkpICUgdGhpcy5sZW5ndGhdID0gdGhpcy5kYXRhWyh0aGlzLnN0YXJ0ICsgKHRoaXMuc2l6ZSAtIGkgLSAxKSkgJSB0aGlzLmxlbmd0aF07XG5cdFx0XHR0aGlzLmRhdGFbKHRoaXMuc3RhcnQgKyAodGhpcy5zaXplIC0gaSAtIDEpKSAlIHRoaXMubGVuZ3RoXSA9IHRtcDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdC8vIHJvdGF0ZSBidWZmZXIgdG8gdGhlIGxlZnQgYnkgY250ciwgb3IgYnkgMVxuXHRyb3RhdGVMZWZ0IDogZnVuY3Rpb24gKGNudHIpIHtcblx0XHRpZiAodHlwZW9mIGNudHIgPT09ICd1bmRlZmluZWQnKSBjbnRyID0gMTtcblx0XHRpZiAodHlwZW9mIGNudHIgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuXHRcdHdoaWxlICgtLWNudHIgPj0gMCkge1xuXHRcdFx0dGhpcy5wdXNoKHRoaXMuc2hpZnQoKSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHQvLyByb3RhdGUgYnVmZmVyIHRvIHRoZSByaWdodCBieSBjbnRyLCBvciBieSAxXG5cdHJvdGF0ZVJpZ2h0IDogZnVuY3Rpb24gKGNudHIpIHtcblx0XHRpZiAodHlwZW9mIGNudHIgPT09ICd1bmRlZmluZWQnKSBjbnRyID0gMTtcblx0XHRpZiAodHlwZW9mIGNudHIgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuXHRcdHdoaWxlICgtLWNudHIgPj0gMCkge1xuXHRcdFx0dGhpcy51bnNoaWZ0KHRoaXMucG9wKCkpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0Ly8gcmVtb3ZlIGFuZCByZXR1cm4gZmlyc3QgaXRlbVxuXHRzaGlmdCA6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaXRlbTtcblx0XHQvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGl0ZW1zIGluIENCdWZmXG5cdFx0aWYgKHRoaXMuc2l6ZSA9PT0gMCkgcmV0dXJuO1xuXHRcdC8vIHN0b3JlIGZpcnN0IGl0ZW0gZm9yIHJldHVyblxuXHRcdGl0ZW0gPSB0aGlzLmRhdGFbdGhpcy5zdGFydF07XG5cdFx0Ly8gcmVjYWxjdWxhdGUgc3RhcnQgb2YgQ0J1ZmZlclxuXHRcdHRoaXMuc3RhcnQgPSAodGhpcy5zdGFydCArIDEpICUgdGhpcy5sZW5ndGg7XG5cdFx0Ly8gZGVjcmVtZW50IHNpemVcblx0XHR0aGlzLnNpemUtLTtcblx0XHRyZXR1cm4gaXRlbTtcblx0fSxcblx0Ly8gc29ydCBpdGVtc1xuXHRzb3J0IDogZnVuY3Rpb24gKGZuKSB7XG5cdFx0Ly8gdGhpcy5kYXRhLnNvcnQoZm4gfHwgZGVmYXVsdENvbXBhcml0b3IpO1xuXHRcdC8vIHRoaXMuc3RhcnQgPSAwO1xuXHRcdC8vIHRoaXMuZW5kID0gdGhpcy5zaXplIC0gMTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0Ly8gYWRkIGl0ZW0gdG8gYmVnaW5uaW5nIG9mIGJ1ZmZlclxuXHR1bnNoaWZ0IDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpID0gMDtcblx0XHQvLyBjaGVjayBpZiBvdmVyZmxvdyBpcyBzZXQsIGFuZCBpZiBkYXRhIGlzIGFib3V0IHRvIGJlIG92ZXJ3cml0dGVuXG5cdFx0aWYgKHRoaXMub3ZlcmZsb3cgJiYgdGhpcy5zaXplICsgYXJndW1lbnRzLmxlbmd0aCA+IHRoaXMubGVuZ3RoKSB7XG5cdFx0XHQvLyBjYWxsIG92ZXJmbG93IGZ1bmN0aW9uIGFuZCBzZW5kIGRhdGEgdGhhdCdzIGFib3V0IHRvIGJlIG92ZXJ3cml0dGVuXG5cdFx0XHRmb3IgKDsgaSA8IHRoaXMuc2l6ZSArIGFyZ3VtZW50cy5sZW5ndGggLSB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRoaXMub3ZlcmZsb3codGhpcy5kYXRhW3RoaXMuZW5kIC0gKGkgJSB0aGlzLmxlbmd0aCldLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5kYXRhWyh0aGlzLmxlbmd0aCArIHRoaXMuc3RhcnQgLSAoaSAlIHRoaXMubGVuZ3RoKSAtIDEpICUgdGhpcy5sZW5ndGhdID0gYXJndW1lbnRzW2ldO1xuXHRcdH1cblx0XHRpZiAodGhpcy5sZW5ndGggLSB0aGlzLnNpemUgLSBpIDwgMCkge1xuXHRcdFx0dGhpcy5lbmQgKz0gdGhpcy5sZW5ndGggLSB0aGlzLnNpemUgLSBpO1xuXHRcdFx0aWYgKHRoaXMuZW5kIDwgMCkgdGhpcy5lbmQgPSB0aGlzLmxlbmd0aCArICh0aGlzLmVuZCAlIHRoaXMubGVuZ3RoKTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuc2l6ZSA8IHRoaXMubGVuZ3RoKSB7XG5cdFx0XHRpZiAodGhpcy5zaXplICsgaSA+IHRoaXMubGVuZ3RoKSB0aGlzLnNpemUgPSB0aGlzLmxlbmd0aDtcblx0XHRcdGVsc2UgdGhpcy5zaXplICs9IGk7XG5cdFx0fVxuXHRcdHRoaXMuc3RhcnQgLT0gYXJndW1lbnRzLmxlbmd0aDtcblx0XHRpZiAodGhpcy5zdGFydCA8IDApIHRoaXMuc3RhcnQgPSB0aGlzLmxlbmd0aCArICh0aGlzLnN0YXJ0ICUgdGhpcy5sZW5ndGgpO1xuXHRcdHJldHVybiB0aGlzLnNpemU7XG5cdH0sXG5cblx0LyogYWNjZXNzb3IgbWV0aG9kcyAqL1xuXHQvLyByZXR1cm4gaW5kZXggb2YgZmlyc3QgbWF0Y2hlZCBlbGVtZW50XG5cdGluZGV4T2YgOiBmdW5jdGlvbiAoYXJnLCBpZHgpIHtcblx0XHRpZiAoIWlkeCkgaWR4ID0gMDtcblx0XHRmb3IgKDsgaWR4IDwgdGhpcy5zaXplOyBpZHgrKykge1xuXHRcdFx0aWYgKHRoaXMuZGF0YVsodGhpcy5zdGFydCArIGlkeCkgJSB0aGlzLmxlbmd0aF0gPT09IGFyZykgcmV0dXJuIGlkeDtcblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXHQvLyByZXR1cm4gbGFzdCBpbmRleCBvZiB0aGUgZmlyc3QgbWF0Y2hcblx0bGFzdEluZGV4T2YgOiBmdW5jdGlvbiAoYXJnLCBpZHgpIHtcblx0XHRpZiAoIWlkeCkgaWR4ID0gdGhpcy5zaXplIC0gMTtcblx0XHRmb3IgKDsgaWR4ID49IDA7IGlkeC0tKSB7XG5cdFx0XHRpZiAodGhpcy5kYXRhWyh0aGlzLnN0YXJ0ICsgaWR4KSAlIHRoaXMubGVuZ3RoXSA9PT0gYXJnKSByZXR1cm4gaWR4O1xuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cblx0Ly8gcmV0dXJuIHRoZSBpbmRleCBhbiBpdGVtIHdvdWxkIGJlIGluc2VydGVkIHRvIGlmIHRoaXNcblx0Ly8gaXMgYSBzb3J0ZWQgY2lyY3VsYXIgYnVmZmVyXG5cdHNvcnRlZEluZGV4IDogZnVuY3Rpb24odmFsdWUsIGNvbXBhcml0b3IsIGNvbnRleHQpIHtcblx0XHRjb21wYXJpdG9yID0gY29tcGFyaXRvciB8fCBkZWZhdWx0Q29tcGFyaXRvcjtcblx0XHR2YXIgbG93ID0gdGhpcy5zdGFydCxcblx0XHRcdGhpZ2ggPSB0aGlzLnNpemUgLSAxO1xuXG5cdFx0Ly8gVHJpY2t5IHBhcnQgaXMgZmluZGluZyBpZiBpdHMgYmVmb3JlIG9yIGFmdGVyIHRoZSBwaXZvdFxuXHRcdC8vIHdlIGNhbiBnZXQgdGhpcyBpbmZvIGJ5IGNoZWNraW5nIGlmIHRoZSB0YXJnZXQgaXMgbGVzcyB0aGFuXG5cdFx0Ly8gdGhlIGxhc3QgaXRlbS4gQWZ0ZXIgdGhhdCBpdCdzIGp1c3QgYSB0eXBpY2FsIGJpbmFyeSBzZWFyY2guXG5cdFx0aWYgKGxvdyAmJiBjb21wYXJpdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIHRoaXMuZGF0YVtoaWdoXSkgPiAwKSB7XG5cdFx0XHRsb3cgPSAwLCBoaWdoID0gdGhpcy5lbmQ7XG5cdFx0fVxuXG5cdFx0d2hpbGUgKGxvdyA8IGhpZ2gpIHtcblx0XHQgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG5cdFx0ICBpZiAoY29tcGFyaXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCB0aGlzLmRhdGFbbWlkXSkgPiAwKSBsb3cgPSBtaWQgKyAxO1xuXHRcdCAgZWxzZSBoaWdoID0gbWlkO1xuXHRcdH1cblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xODYxODI3My8xNTE3OTE5XG5cdFx0cmV0dXJuICgoKGxvdyAtIHRoaXMuc3RhcnQpICUgdGhpcy5zaXplKSArIHRoaXMuc2l6ZSkgJSB0aGlzLnNpemU7XG5cdH0sXG5cblx0LyogaXRlcmF0aW9uIG1ldGhvZHMgKi9cblx0Ly8gY2hlY2sgZXZlcnkgaXRlbSBpbiB0aGUgYXJyYXkgYWdhaW5zdCBhIHRlc3Rcblx0ZXZlcnkgOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Zm9yICg7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuXHRcdFx0aWYgKCFjYWxsYmFjay5jYWxsKGNvbnRleHQsIHRoaXMuZGF0YVsodGhpcy5zdGFydCArIGkpICUgdGhpcy5sZW5ndGhdLCBpLCB0aGlzKSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblx0Ly8gbG9vcCB0aHJvdWdoIGVhY2ggaXRlbSBpbiBidWZmZXJcblx0Ly8gVE9ETzogZmlndXJlIG91dCBob3cgdG8gZW11bGF0ZSBBcnJheSB1c2UgYmV0dGVyXG5cdGZvckVhY2ggOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0Zm9yICg7IGkgPCB0aGlzLnNpemU7IGkrKykge1xuXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0LCB0aGlzLmRhdGFbKHRoaXMuc3RhcnQgKyBpKSAlIHRoaXMubGVuZ3RoXSwgaSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXHQvLyBjaGVjayBpdGVtcyBhZ2FpbnMgdGVzdCB1bnRpbCBvbmUgcmV0dXJucyB0cnVlXG5cdC8vIFRPRE86IGZpZ3VyZSBvdXQgaG93IHRvIGVtdWxkYXRlIEFycmF5IHVzZSBiZXR0ZXJcblx0c29tZSA6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuXHRcdHZhciBpID0gMDtcblx0XHRmb3IgKDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG5cdFx0XHRpZiAoY2FsbGJhY2suY2FsbChjb250ZXh0LCB0aGlzLmRhdGFbKHRoaXMuc3RhcnQgKyBpKSAlIHRoaXMubGVuZ3RoXSwgaSwgdGhpcykpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cdC8vIGNhbGN1bGF0ZSB0aGUgYXZlcmFnZSB2YWx1ZSBvZiBhIGNpcmN1bGFyIGJ1ZmZlclxuXHRhdmcgOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc2l6ZSA9PSAwID8gMCA6ICh0aGlzLnN1bSgpIC8gdGhpcy5zaXplKTtcblx0fSxcblx0Ly8gbG9vcCB0aHJvdWdoIGVhY2ggaXRlbSBpbiBidWZmZXIgYW5kIGNhbGN1bGF0ZSBzdW1cblx0c3VtIDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuc2l6ZTtcblx0XHR2YXIgcyA9IDA7XG5cdFx0d2hpbGUgKGluZGV4LS0pIHMgKz0gdGhpcy5kYXRhW2luZGV4XTtcblx0XHRyZXR1cm4gcztcblx0fSxcblx0Ly8gbG9vcCB0aHJvdWdoIGVhY2ggaXRlbSBpbiBidWZmZXIgYW5kIGNhbGN1bGF0ZSBtZWRpYW5cblx0bWVkaWFuIDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLnNpemUgPT09IDApXG5cdFx0XHRyZXR1cm4gMDtcblx0XHR2YXIgdmFsdWVzID0gdGhpcy5zbGljZSgpLnNvcnQoZGVmYXVsdENvbXBhcml0b3IpO1xuXHRcdHZhciBoYWxmID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMik7XG5cdFx0aWYodmFsdWVzLmxlbmd0aCAlIDIpXG5cdFx0XHRyZXR1cm4gdmFsdWVzW2hhbGZdO1xuXHRcdGVsc2Vcblx0XHRcdHJldHVybiAodmFsdWVzW2hhbGYtMV0gKyB2YWx1ZXNbaGFsZl0pIC8gMi4wO1xuXHR9LFxuXHQvKiB1dGlsaXR5IG1ldGhvZHMgKi9cblx0Ly8gcmVzZXQgcG9pbnRlcnMgdG8gYnVmZmVyIHdpdGggemVybyBpdGVtc1xuXHQvLyBub3RlOiB0aGlzIHdpbGwgbm90IHJlbW92ZSB2YWx1ZXMgaW4gY2J1ZmZlciwgc28gaWYgZm9yIHNlY3VyaXR5IHZhbHVlc1xuXHQvLyAgICAgICBuZWVkIHRvIGJlIG92ZXJ3cml0dGVuLCBydW4gYC5maWxsKG51bGwpLmVtcHR5KClgXG5cdGVtcHR5IDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpID0gMDtcblx0XHR0aGlzLnNpemUgPSB0aGlzLnN0YXJ0ID0gMDtcblx0XHR0aGlzLmVuZCA9IHRoaXMubGVuZ3RoIC0gMTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0Ly8gZmlsbCBhbGwgcGxhY2VzIHdpdGggcGFzc2VkIHZhbHVlIG9yIGZ1bmN0aW9uXG5cdGZpbGwgOiBmdW5jdGlvbiAoYXJnKSB7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdGlmICh0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHR3aGlsZSh0aGlzLmRhdGFbaV0gPSBhcmcoKSwgKytpIDwgdGhpcy5sZW5ndGgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aGlsZSh0aGlzLmRhdGFbaV0gPSBhcmcsICsraSA8IHRoaXMubGVuZ3RoKTtcblx0XHR9XG5cdFx0Ly8gcmVwb3NpdGlvbiBzdGFydC9lbmRcblx0XHR0aGlzLnN0YXJ0ID0gMDtcblx0XHR0aGlzLmVuZCA9IHRoaXMubGVuZ3RoIC0gMTtcblx0XHR0aGlzLnNpemUgPSB0aGlzLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0Ly8gcmV0dXJuIGZpcnN0IGl0ZW0gaW4gYnVmZmVyXG5cdGZpcnN0IDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmRhdGFbdGhpcy5zdGFydF07XG5cdH0sXG5cdC8vIHJldHVybiBsYXN0IGl0ZW0gaW4gYnVmZmVyXG5cdGxhc3QgOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YVt0aGlzLmVuZF07XG5cdH0sXG5cdC8vIHJldHVybiBzcGVjaWZpYyBpbmRleCBpbiBidWZmZXJcblx0Z2V0IDogZnVuY3Rpb24gKGFyZykge1xuXHRcdHJldHVybiB0aGlzLmRhdGFbKHRoaXMuc3RhcnQgKyBhcmcpICUgdGhpcy5sZW5ndGhdO1xuXHR9LFxuXHRpc0Z1bGwgOiBmdW5jdGlvbiAoYXJnKSB7XG5cdFx0cmV0dXJuIHRoaXMubGVuZ3RoID09PSB0aGlzLnNpemU7XG5cdH0sXG5cdC8vIHNldCB2YWx1ZSBhdCBzcGVjaWZpZWQgaW5kZXhcblx0c2V0IDogZnVuY3Rpb24gKGlkeCwgYXJnKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YVsodGhpcy5zdGFydCArIGlkeCkgJSB0aGlzLmxlbmd0aF0gPSBhcmc7XG5cdH0sXG5cdC8vIHJldHVybiBjbGVhbiBhcnJheSBvZiB2YWx1ZXNcblx0dG9BcnJheSA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zbGljZSgpO1xuXHR9LFxuXHQvLyBzbGljZSB0aGUgYnVmZmVyIHRvIGFuIGFycmFheVxuXHRzbGljZSA6IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMuc2l6ZTtcblxuXHRcdHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG5cblx0XHRpZiAoc3RhcnQgPCAwKSB7XG5cdFx0XHRpZiAoc3RhcnQgPj0gZW5kKVxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHRzdGFydCA9ICgtc3RhcnQgPiBsZW5ndGgpID8gMCA6IGxlbmd0aCArIHN0YXJ0O1xuXHRcdH1cblxuXHRcdGlmIChlbmQgPT0gbnVsbCB8fCBlbmQgPiBsZW5ndGgpXG5cdFx0XHRlbmQgPSBsZW5ndGg7XG5cdFx0ZWxzZSBpZiAoZW5kIDwgMClcblx0XHRcdGVuZCArPSBsZW5ndGg7XG5cdFx0ZWxzZVxuXHRcdFx0ZW5kID0gK2VuZCB8fCAwO1xuXG5cdFx0bGVuZ3RoID0gc3RhcnQgPCBlbmQgPyBlbmQgLSBzdGFydCA6IDA7XG5cblx0XHR2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblx0XHRmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0XHRyZXN1bHRbaW5kZXhdID0gdGhpcy5kYXRhWyh0aGlzLnN0YXJ0ICsgc3RhcnQgKyBpbmRleCkgJSB0aGlzLmxlbmd0aF07XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cbn07XG5cbi8vaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IENCdWZmZXI7XG4vL2Vsc2UgZ2xvYmFsLkNCdWZmZXIgPSBDQnVmZmVyO1xuXG5leHBvcnQgZGVmYXVsdCBDQnVmZmVyOyIsIi8qIFxuICogIERTUC5qcyAtIGEgY29tcHJlaGVuc2l2ZSBkaWdpdGFsIHNpZ25hbCBwcm9jZXNzaW5nICBsaWJyYXJ5IGZvciBqYXZhc2NyaXB0XG4gKiBcbiAqICBDcmVhdGVkIGJ5IENvcmJhbiBCcm9vayA8Y29yYmFuYnJvb2tAZ21haWwuY29tPiBvbiAyMDEwLTAxLTAxLlxuICogIENvcHlyaWdodCAyMDEwIENvcmJhbiBCcm9vay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4gKiAgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiAgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiAgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuICogIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICogIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuICogIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbiAqICBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbiAqICBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09OU1RBTlRTICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogRFNQIGlzIGFuIG9iamVjdCB3aGljaCBjb250YWlucyBnZW5lcmFsIHB1cnBvc2UgdXRpbGl0eSBmdW5jdGlvbnMgYW5kIGNvbnN0YW50c1xuICovXG52YXIgRFNQID0ge1xuICAvLyBDaGFubmVsc1xuICBMRUZUOiAgICAgICAgICAgMCxcbiAgUklHSFQ6ICAgICAgICAgIDEsXG4gIE1JWDogICAgICAgICAgICAyLFxuXG4gIC8vIFdhdmVmb3Jtc1xuICBTSU5FOiAgICAgICAgICAgMSxcbiAgVFJJQU5HTEU6ICAgICAgIDIsXG4gIFNBVzogICAgICAgICAgICAzLFxuICBTUVVBUkU6ICAgICAgICAgNCxcblxuICAvLyBGaWx0ZXJzXG4gIExPV1BBU1M6ICAgICAgICAwLFxuICBISUdIUEFTUzogICAgICAgMSxcbiAgQkFORFBBU1M6ICAgICAgIDIsXG4gIE5PVENIOiAgICAgICAgICAzLFxuXG4gIC8vIFdpbmRvdyBmdW5jdGlvbnNcbiAgQkFSVExFVFQ6ICAgICAgIDEsXG4gIEJBUlRMRVRUSEFOTjogICAyLFxuICBCTEFDS01BTjogICAgICAgMyxcbiAgQ09TSU5FOiAgICAgICAgIDQsXG4gIEdBVVNTOiAgICAgICAgICA1LFxuICBIQU1NSU5HOiAgICAgICAgNixcbiAgSEFOTjogICAgICAgICAgIDcsXG4gIExBTkNaT1M6ICAgICAgICA4LFxuICBSRUNUQU5HVUxBUjogICAgOSxcbiAgVFJJQU5HVUxBUjogICAgIDEwLFxuXG4gIC8vIExvb3AgbW9kZXNcbiAgT0ZGOiAgICAgICAgICAgIDAsXG4gIEZXOiAgICAgICAgICAgICAxLFxuICBCVzogICAgICAgICAgICAgMixcbiAgRldCVzogICAgICAgICAgIDMsXG5cbiAgLy8gTWF0aFxuICBUV09fUEk6ICAgICAgICAgMipNYXRoLlBJXG59O1xuXG4vLyBTZXR1cCBhcnJheXMgZm9yIHBsYXRmb3JtcyB3aGljaCBkbyBub3Qgc3VwcG9ydCBieXRlIGFycmF5c1xuZnVuY3Rpb24gc2V0dXBUeXBlZEFycmF5KG5hbWUsIGZhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gd2luZG93O1xuICAvLyBjaGVjayBpZiBUeXBlZEFycmF5IGV4aXN0c1xuICAvLyB0eXBlb2Ygb24gTWluZWZpZWxkIGFuZCBDaHJvbWUgcmV0dXJuIGZ1bmN0aW9uLCB0eXBlb2Ygb24gV2Via2l0IHJldHVybnMgb2JqZWN0LlxuICBpZiAodHlwZW9mIHNlbGZbbmFtZV0gIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZltuYW1lXSAhPT0gXCJvYmplY3RcIikge1xuICAgIC8vIG5vcGUuLiBjaGVjayBpZiBXZWJHTEFycmF5IGV4aXN0c1xuICAgIGlmICh0eXBlb2Ygc2VsZltmYWxsYmFja10gPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygc2VsZltmYWxsYmFja10gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHNlbGZbbmFtZV0gPSBzZWxmW2ZhbGxiYWNrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm9wZS4uIHNldCBhcyBOYXRpdmUgSlMgYXJyYXlcbiAgICAgIHNlbGZbbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBcnJheShvYmopO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG5zZXR1cFR5cGVkQXJyYXkoXCJGbG9hdDMyQXJyYXlcIiwgXCJXZWJHTEZsb2F0QXJyYXlcIik7XG5zZXR1cFR5cGVkQXJyYXkoXCJJbnQzMkFycmF5XCIsICAgXCJXZWJHTEludEFycmF5XCIpO1xuc2V0dXBUeXBlZEFycmF5KFwiVWludDE2QXJyYXlcIiwgIFwiV2ViR0xVbnNpZ25lZFNob3J0QXJyYXlcIik7XG5zZXR1cFR5cGVkQXJyYXkoXCJVaW50OEFycmF5XCIsICAgXCJXZWJHTFVuc2lnbmVkQnl0ZUFycmF5XCIpO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICBEU1AgVVRJTElUWSBGVU5DVElPTlMgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBJbnZlcnRzIHRoZSBwaGFzZSBvZiBhIHNpZ25hbFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlciBBIHNhbXBsZSBidWZmZXJcbiAqXG4gKiBAcmV0dXJucyBUaGUgaW52ZXJ0ZWQgc2FtcGxlIGJ1ZmZlclxuICovXG5EU1AuaW52ZXJ0ID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWZmZXIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZmZXJbaV0gKj0gLTE7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBzcGxpdC1zdGVyZW8gKGR1YWwgbW9ubykgc2FtcGxlIGJ1ZmZlcnMgaW50byBhIHN0ZXJlbyBpbnRlcmxlYXZlZCBzYW1wbGUgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbGVmdCAgQSBzYW1wbGUgYnVmZmVyXG4gKiBAcGFyYW0ge0FycmF5fSByaWdodCBBIHNhbXBsZSBidWZmZXJcbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RlcmVvIGludGVybGVhdmVkIGJ1ZmZlclxuICovXG5EU1AuaW50ZXJsZWF2ZSA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gIGlmIChsZWZ0Lmxlbmd0aCAhPT0gcmlnaHQubGVuZ3RoKSB7XG4gICAgdGhyb3cgXCJDYW4gbm90IGludGVybGVhdmUuIENoYW5uZWwgbGVuZ3RocyBkaWZmZXIuXCI7XG4gIH1cbiBcbiAgdmFyIHN0ZXJlb0ludGVybGVhdmVkID0gbmV3IEZsb2F0MzJBcnJheShsZWZ0Lmxlbmd0aCAqIDIpO1xuIFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGVmdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHN0ZXJlb0ludGVybGVhdmVkWzIqaV0gICA9IGxlZnRbaV07XG4gICAgc3RlcmVvSW50ZXJsZWF2ZWRbMippKzFdID0gcmlnaHRbaV07XG4gIH1cbiBcbiAgcmV0dXJuIHN0ZXJlb0ludGVybGVhdmVkO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0ZXJlby1pbnRlcmxlYXZlZCBzYW1wbGUgYnVmZmVyIGludG8gc3BsaXQtc3RlcmVvIChkdWFsIG1vbm8pIHNhbXBsZSBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYnVmZmVyIEEgc3RlcmVvLWludGVybGVhdmVkIHNhbXBsZSBidWZmZXJcbiAqXG4gKiBAcmV0dXJucyBhbiBBcnJheSBjb250YWluaW5nIGxlZnQgYW5kIHJpZ2h0IGNoYW5uZWxzXG4gKi9cbkRTUC5kZWludGVybGVhdmUgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBsZWZ0LCByaWdodCwgbWl4LCBkZWludGVybGVhdmVDaGFubmVsID0gW107IFxuXG4gIGRlaW50ZXJsZWF2ZUNoYW5uZWxbRFNQLk1JWF0gPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmZmVyLmxlbmd0aC8yOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1peFtpXSA9IChidWZmZXJbMippXSArIGJ1ZmZlclsyKmkrMV0pIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIG1peDtcbiAgfTtcblxuICBkZWludGVybGVhdmVDaGFubmVsW0RTUC5MRUZUXSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWZmZXIubGVuZ3RoLzI7IGkgPCBsZW47IGkrKykge1xuICAgICAgbGVmdFtpXSAgPSBidWZmZXJbMippXTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH07XG5cbiAgZGVpbnRlcmxlYXZlQ2hhbm5lbFtEU1AuUklHSFRdID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1ZmZlci5sZW5ndGgvMjsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByaWdodFtpXSAgPSBidWZmZXJbMippKzFdO1xuICAgIH1cbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGNoYW5uZWwsIGJ1ZmZlcikgeyBcbiAgICBsZWZ0ICA9IGxlZnQgIHx8IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLmxlbmd0aC8yKTtcbiAgICByaWdodCA9IHJpZ2h0IHx8IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLmxlbmd0aC8yKTtcbiAgICBtaXggICA9IG1peCAgIHx8IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLmxlbmd0aC8yKTtcblxuICAgIGlmIChidWZmZXIubGVuZ3RoLzIgIT09IGxlZnQubGVuZ3RoKSB7XG4gICAgICBsZWZ0ICA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLmxlbmd0aC8yKTtcbiAgICAgIHJpZ2h0ID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIubGVuZ3RoLzIpO1xuICAgICAgbWl4ICAgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlci5sZW5ndGgvMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlaW50ZXJsZWF2ZUNoYW5uZWxbY2hhbm5lbF0oYnVmZmVyKTtcbiAgfTtcbn0oKSk7XG5cbi8qKlxuICogU2VwYXJhdGVzIGEgY2hhbm5lbCBmcm9tIGEgc3RlcmVvLWludGVybGVhdmVkIHNhbXBsZSBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSAgYnVmZmVyIEEgc3RlcmVvLWludGVybGVhdmVkIHNhbXBsZSBidWZmZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaGFubmVsIEEgY2hhbm5lbCBjb25zdGFudCAoTEVGVCwgUklHSFQsIE1JWClcbiAqXG4gKiBAcmV0dXJucyBhbiBBcnJheSBjb250YWluaW5nIGEgc2lnbmFsIG1vbm8gc2FtcGxlIGJ1ZmZlclxuICovXG5EU1AuZ2V0Q2hhbm5lbCA9IERTUC5kZWludGVybGVhdmU7XG5cbi8qKlxuICogSGVscGVyIG1ldGhvZCAoZm9yIFJldmVyYikgdG8gbWl4IHR3byAoaW50ZXJsZWF2ZWQpIHNhbXBsZWJ1ZmZlcnMuIEl0J3MgcG9zc2libGVcbiAqIHRvIG5lZ2F0ZSB0aGUgc2Vjb25kIGJ1ZmZlciB3aGlsZSBtaXhpbmcgYW5kIHRvIHBlcmZvcm0gYSB2b2x1bWUgY29ycmVjdGlvblxuICogb24gdGhlIGZpbmFsIHNpZ25hbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzYW1wbGVCdWZmZXIxIEFycmF5IGNvbnRhaW5pbmcgRmxvYXQgdmFsdWVzIG9yIGEgRmxvYXQzMkFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBzYW1wbGVCdWZmZXIyIEFycmF5IGNvbnRhaW5pbmcgRmxvYXQgdmFsdWVzIG9yIGEgRmxvYXQzMkFycmF5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IG5lZ2F0ZSBXaGVuIHRydWUgaW52ZXJ0cy9mbGlwcyB0aGUgYXVkaW8gc2lnbmFsXG4gKiBAcGFyYW0ge051bWJlcn0gdm9sdW1lQ29ycmVjdGlvbiBXaGVuIHlvdSBhZGQgbXVsdGlwbGUgc2FtcGxlIGJ1ZmZlcnMsIHVzZSB0aGlzIHRvIHRhbWUgeW91ciBzaWduYWwgOylcbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBGbG9hdDMyQXJyYXkgaW50ZXJsZWF2ZWQgYnVmZmVyLlxuICovXG5EU1AubWl4U2FtcGxlQnVmZmVycyA9IGZ1bmN0aW9uKHNhbXBsZUJ1ZmZlcjEsIHNhbXBsZUJ1ZmZlcjIsIG5lZ2F0ZSwgdm9sdW1lQ29ycmVjdGlvbil7XG4gIHZhciBvdXRwdXRTYW1wbGVzID0gbmV3IEZsb2F0MzJBcnJheShzYW1wbGVCdWZmZXIxKTtcblxuICBmb3IodmFyIGkgPSAwOyBpPHNhbXBsZUJ1ZmZlcjEubGVuZ3RoOyBpKyspe1xuICAgIG91dHB1dFNhbXBsZXNbaV0gKz0gKG5lZ2F0ZSA/IC1zYW1wbGVCdWZmZXIyW2ldIDogc2FtcGxlQnVmZmVyMltpXSkgLyB2b2x1bWVDb3JyZWN0aW9uO1xuICB9XG4gXG4gIHJldHVybiBvdXRwdXRTYW1wbGVzO1xufTsgXG5cbi8vIEJpcXVhZCBmaWx0ZXIgdHlwZXNcbkRTUC5MUEYgPSAwOyAgICAgICAgICAgICAgICAvLyBIKHMpID0gMSAvIChzXjIgKyBzL1EgKyAxKVxuRFNQLkhQRiA9IDE7ICAgICAgICAgICAgICAgIC8vIEgocykgPSBzXjIgLyAoc14yICsgcy9RICsgMSlcbkRTUC5CUEZfQ09OU1RBTlRfU0tJUlQgPSAyOyAvLyBIKHMpID0gcyAvIChzXjIgKyBzL1EgKyAxKSAgKGNvbnN0YW50IHNraXJ0IGdhaW4sIHBlYWsgZ2FpbiA9IFEpXG5EU1AuQlBGX0NPTlNUQU5UX1BFQUsgPSAzOyAgLy8gSChzKSA9IChzL1EpIC8gKHNeMiArIHMvUSArIDEpICAgICAgKGNvbnN0YW50IDAgZEIgcGVhayBnYWluKVxuRFNQLk5PVENIID0gNDsgICAgICAgICAgICAgIC8vIEgocykgPSAoc14yICsgMSkgLyAoc14yICsgcy9RICsgMSlcbkRTUC5BUEYgPSA1OyAgICAgICAgICAgICAgICAvLyBIKHMpID0gKHNeMiAtIHMvUSArIDEpIC8gKHNeMiArIHMvUSArIDEpXG5EU1AuUEVBS0lOR19FUSA9IDY7ICAgICAgICAgLy8gSChzKSA9IChzXjIgKyBzKihBL1EpICsgMSkgLyAoc14yICsgcy8oQSpRKSArIDEpXG5EU1AuTE9XX1NIRUxGID0gNzsgICAgICAgICAgLy8gSChzKSA9IEEgKiAoc14yICsgKHNxcnQoQSkvUSkqcyArIEEpLyhBKnNeMiArIChzcXJ0KEEpL1EpKnMgKyAxKVxuRFNQLkhJR0hfU0hFTEYgPSA4OyAgICAgICAgIC8vIEgocykgPSBBICogKEEqc14yICsgKHNxcnQoQSkvUSkqcyArIDEpLyhzXjIgKyAoc3FydChBKS9RKSpzICsgQSlcblxuLy8gQmlxdWFkIGZpbHRlciBwYXJhbWV0ZXIgdHlwZXNcbkRTUC5RID0gMTtcbkRTUC5CVyA9IDI7IC8vIFNIQVJFRCB3aXRoIEJBQ0tXQVJEUyBMT09QIE1PREVcbkRTUC5TID0gMztcblxuLy8gRmluZCBSTVMgb2Ygc2lnbmFsXG5EU1AuUk1TID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciB0b3RhbCA9IDA7XG4gIFxuICBmb3IgKHZhciBpID0gMCwgbiA9IGJ1ZmZlci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICB0b3RhbCArPSBidWZmZXJbaV0gKiBidWZmZXJbaV07XG4gIH1cbiAgXG4gIHJldHVybiBNYXRoLnNxcnQodG90YWwgLyBuKTtcbn07XG5cbi8vIEZpbmQgUGVhayBvZiBzaWduYWxcbkRTUC5QZWFrID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBwZWFrID0gMDtcbiAgXG4gIGZvciAodmFyIGkgPSAwLCBuID0gYnVmZmVyLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgIHBlYWsgPSAoTWF0aC5hYnMoYnVmZmVyW2ldKSA+IHBlYWspID8gTWF0aC5hYnMoYnVmZmVyW2ldKSA6IHBlYWs7IFxuICB9XG4gIFxuICByZXR1cm4gcGVhaztcbn07XG5cbi8vIEZvdXJpZXIgVHJhbnNmb3JtIE1vZHVsZSB1c2VkIGJ5IERGVCwgRkZULCBSRkZUXG5mdW5jdGlvbiBGb3VyaWVyVHJhbnNmb3JtKGJ1ZmZlclNpemUsIHNhbXBsZVJhdGUpIHtcbiAgdGhpcy5idWZmZXJTaXplID0gYnVmZmVyU2l6ZTtcbiAgdGhpcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcbiAgdGhpcy5iYW5kd2lkdGggID0gMiAvIGJ1ZmZlclNpemUgKiBzYW1wbGVSYXRlIC8gMjtcblxuICB0aGlzLnNwZWN0cnVtICAgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUvMik7XG4gIHRoaXMucmVhbCAgICAgICA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSk7XG4gIHRoaXMuaW1hZyAgICAgICA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSk7XG5cbiAgdGhpcy5wZWFrQmFuZCAgID0gMDtcbiAgdGhpcy5wZWFrICAgICAgID0gMDtcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgKm1pZGRsZSogZnJlcXVlbmN5IG9mIGFuIEZGVCBiYW5kLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBGRlQgYmFuZC5cbiAgICpcbiAgICogQHJldHVybnMgVGhlIG1pZGRsZSBmcmVxdWVuY3kgaW4gSHouXG4gICAqL1xuICB0aGlzLmdldEJhbmRGcmVxdWVuY3kgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmJhbmR3aWR0aCAqIGluZGV4ICsgdGhpcy5iYW5kd2lkdGggLyAyO1xuICB9O1xuXG4gIHRoaXMuY2FsY3VsYXRlU3BlY3RydW0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3BlY3RydW0gID0gdGhpcy5zcGVjdHJ1bSxcbiAgICAgICAgcmVhbCAgICAgID0gdGhpcy5yZWFsLFxuICAgICAgICBpbWFnICAgICAgPSB0aGlzLmltYWcsXG4gICAgICAgIGJTaSAgICAgICA9IDIgLyB0aGlzLmJ1ZmZlclNpemUsXG4gICAgICAgIHNxcnQgICAgICA9IE1hdGguc3FydCxcbiAgICAgICAgcnZhbCwgXG4gICAgICAgIGl2YWwsXG4gICAgICAgIG1hZztcblxuICAgIGZvciAodmFyIGkgPSAwLCBOID0gYnVmZmVyU2l6ZS8yOyBpIDwgTjsgaSsrKSB7XG4gICAgICBydmFsID0gcmVhbFtpXTtcbiAgICAgIGl2YWwgPSBpbWFnW2ldO1xuICAgICAgbWFnID0gYlNpICogc3FydChydmFsICogcnZhbCArIGl2YWwgKiBpdmFsKTtcblxuICAgICAgaWYgKG1hZyA+IHRoaXMucGVhaykge1xuICAgICAgICB0aGlzLnBlYWtCYW5kID0gaTtcbiAgICAgICAgdGhpcy5wZWFrID0gbWFnO1xuICAgICAgfVxuXG4gICAgICBzcGVjdHJ1bVtpXSA9IG1hZztcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogREZUIGlzIGEgY2xhc3MgZm9yIGNhbGN1bGF0aW5nIHRoZSBEaXNjcmV0ZSBGb3VyaWVyIFRyYW5zZm9ybSBvZiBhIHNpZ25hbC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYnVmZmVyU2l6ZSBUaGUgc2l6ZSBvZiB0aGUgc2FtcGxlIGJ1ZmZlciB0byBiZSBjb21wdXRlZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNhbXBsZVJhdGUgVGhlIHNhbXBsZVJhdGUgb2YgdGhlIGJ1ZmZlciAoZWcuIDQ0MTAwKVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBERlQoYnVmZmVyU2l6ZSwgc2FtcGxlUmF0ZSkge1xuICBGb3VyaWVyVHJhbnNmb3JtLmNhbGwodGhpcywgYnVmZmVyU2l6ZSwgc2FtcGxlUmF0ZSk7XG5cbiAgdmFyIE4gPSBidWZmZXJTaXplLzIgKiBidWZmZXJTaXplO1xuICB2YXIgVFdPX1BJID0gMiAqIE1hdGguUEk7XG5cbiAgdGhpcy5zaW5UYWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkoTik7XG4gIHRoaXMuY29zVGFibGUgPSBuZXcgRmxvYXQzMkFycmF5KE4pO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgdGhpcy5zaW5UYWJsZVtpXSA9IE1hdGguc2luKGkgKiBUV09fUEkgLyBidWZmZXJTaXplKTtcbiAgICB0aGlzLmNvc1RhYmxlW2ldID0gTWF0aC5jb3MoaSAqIFRXT19QSSAvIGJ1ZmZlclNpemUpO1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBmb3J3YXJkIHRyYW5zZm9ybSBvbiB0aGUgc2FtcGxlIGJ1ZmZlci5cbiAqIENvbnZlcnRzIGEgdGltZSBkb21haW4gc2lnbmFsIHRvIGZyZXF1ZW5jeSBkb21haW4gc3BlY3RyYS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXIgVGhlIHNhbXBsZSBidWZmZXJcbiAqXG4gKiBAcmV0dXJucyBUaGUgZnJlcXVlbmN5IHNwZWN0cnVtIGFycmF5XG4gKi9cbkRGVC5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVhbCA9IHRoaXMucmVhbCwgXG4gICAgICBpbWFnID0gdGhpcy5pbWFnLFxuICAgICAgcnZhbCxcbiAgICAgIGl2YWw7XG5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmJ1ZmZlclNpemUvMjsgaysrKSB7XG4gICAgcnZhbCA9IDAuMDtcbiAgICBpdmFsID0gMC4wO1xuXG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCBidWZmZXIubGVuZ3RoOyBuKyspIHtcbiAgICAgIHJ2YWwgKz0gdGhpcy5jb3NUYWJsZVtrKm5dICogYnVmZmVyW25dO1xuICAgICAgaXZhbCArPSB0aGlzLnNpblRhYmxlW2sqbl0gKiBidWZmZXJbbl07XG4gICAgfVxuXG4gICAgcmVhbFtrXSA9IHJ2YWw7XG4gICAgaW1hZ1trXSA9IGl2YWw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jYWxjdWxhdGVTcGVjdHJ1bSgpO1xufTtcblxuXG4vKipcbiAqIEZGVCBpcyBhIGNsYXNzIGZvciBjYWxjdWxhdGluZyB0aGUgRGlzY3JldGUgRm91cmllciBUcmFuc2Zvcm0gb2YgYSBzaWduYWxcbiAqIHdpdGggdGhlIEZhc3QgRm91cmllciBUcmFuc2Zvcm0gYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBidWZmZXJTaXplIFRoZSBzaXplIG9mIHRoZSBzYW1wbGUgYnVmZmVyIHRvIGJlIGNvbXB1dGVkLiBNdXN0IGJlIHBvd2VyIG9mIDJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzYW1wbGVSYXRlIFRoZSBzYW1wbGVSYXRlIG9mIHRoZSBidWZmZXIgKGVnLiA0NDEwMClcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRkZUKGJ1ZmZlclNpemUsIHNhbXBsZVJhdGUpIHtcbiAgRm91cmllclRyYW5zZm9ybS5jYWxsKHRoaXMsIGJ1ZmZlclNpemUsIHNhbXBsZVJhdGUpO1xuICAgXG4gIHRoaXMucmV2ZXJzZVRhYmxlID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlclNpemUpO1xuXG4gIHZhciBsaW1pdCA9IDE7XG4gIHZhciBiaXQgPSBidWZmZXJTaXplID4+IDE7XG5cbiAgdmFyIGk7XG5cbiAgd2hpbGUgKGxpbWl0IDwgYnVmZmVyU2l6ZSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsaW1pdDsgaSsrKSB7XG4gICAgICB0aGlzLnJldmVyc2VUYWJsZVtpICsgbGltaXRdID0gdGhpcy5yZXZlcnNlVGFibGVbaV0gKyBiaXQ7XG4gICAgfVxuXG4gICAgbGltaXQgPSBsaW1pdCA8PCAxO1xuICAgIGJpdCA9IGJpdCA+PiAxO1xuICB9XG5cbiAgdGhpcy5zaW5UYWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSk7XG4gIHRoaXMuY29zVGFibGUgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBidWZmZXJTaXplOyBpKyspIHtcbiAgICB0aGlzLnNpblRhYmxlW2ldID0gTWF0aC5zaW4oLU1hdGguUEkvaSk7XG4gICAgdGhpcy5jb3NUYWJsZVtpXSA9IE1hdGguY29zKC1NYXRoLlBJL2kpO1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSBmb3J3YXJkIHRyYW5zZm9ybSBvbiB0aGUgc2FtcGxlIGJ1ZmZlci5cbiAqIENvbnZlcnRzIGEgdGltZSBkb21haW4gc2lnbmFsIHRvIGZyZXF1ZW5jeSBkb21haW4gc3BlY3RyYS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXIgVGhlIHNhbXBsZSBidWZmZXIuIEJ1ZmZlciBMZW5ndGggbXVzdCBiZSBwb3dlciBvZiAyXG4gKlxuICogQHJldHVybnMgVGhlIGZyZXF1ZW5jeSBzcGVjdHJ1bSBhcnJheVxuICovXG5GRlQucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gTG9jYWxseSBzY29wZSB2YXJpYWJsZXMgZm9yIHNwZWVkIHVwXG4gIHZhciBidWZmZXJTaXplICAgICAgPSB0aGlzLmJ1ZmZlclNpemUsXG4gICAgICBjb3NUYWJsZSAgICAgICAgPSB0aGlzLmNvc1RhYmxlLFxuICAgICAgc2luVGFibGUgICAgICAgID0gdGhpcy5zaW5UYWJsZSxcbiAgICAgIHJldmVyc2VUYWJsZSAgICA9IHRoaXMucmV2ZXJzZVRhYmxlLFxuICAgICAgcmVhbCAgICAgICAgICAgID0gdGhpcy5yZWFsLFxuICAgICAgaW1hZyAgICAgICAgICAgID0gdGhpcy5pbWFnLFxuICAgICAgc3BlY3RydW0gICAgICAgID0gdGhpcy5zcGVjdHJ1bTtcblxuICB2YXIgayA9IE1hdGguZmxvb3IoTWF0aC5sb2coYnVmZmVyU2l6ZSkgLyBNYXRoLkxOMik7XG5cbiAgaWYgKE1hdGgucG93KDIsIGspICE9PSBidWZmZXJTaXplKSB7IHRocm93IFwiSW52YWxpZCBidWZmZXIgc2l6ZSwgbXVzdCBiZSBhIHBvd2VyIG9mIDIuXCI7IH1cbiAgaWYgKGJ1ZmZlclNpemUgIT09IGJ1ZmZlci5sZW5ndGgpICB7IHRocm93IFwiU3VwcGxpZWQgYnVmZmVyIGlzIG5vdCB0aGUgc2FtZSBzaXplIGFzIGRlZmluZWQgRkZULiBGRlQgU2l6ZTogXCIgKyBidWZmZXJTaXplICsgXCIgQnVmZmVyIFNpemU6IFwiICsgYnVmZmVyLmxlbmd0aDsgfVxuXG4gIHZhciBoYWxmU2l6ZSA9IDEsXG4gICAgICBwaGFzZVNoaWZ0U3RlcFJlYWwsXG4gICAgICBwaGFzZVNoaWZ0U3RlcEltYWcsXG4gICAgICBjdXJyZW50UGhhc2VTaGlmdFJlYWwsXG4gICAgICBjdXJyZW50UGhhc2VTaGlmdEltYWcsXG4gICAgICBvZmYsXG4gICAgICB0cixcbiAgICAgIHRpLFxuICAgICAgdG1wUmVhbCxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlclNpemU7IGkrKykge1xuICAgIHJlYWxbaV0gPSBidWZmZXJbcmV2ZXJzZVRhYmxlW2ldXTtcbiAgICBpbWFnW2ldID0gMDtcbiAgfVxuXG4gIHdoaWxlIChoYWxmU2l6ZSA8IGJ1ZmZlclNpemUpIHtcbiAgICAvL3BoYXNlU2hpZnRTdGVwUmVhbCA9IE1hdGguY29zKC1NYXRoLlBJL2hhbGZTaXplKTtcbiAgICAvL3BoYXNlU2hpZnRTdGVwSW1hZyA9IE1hdGguc2luKC1NYXRoLlBJL2hhbGZTaXplKTtcbiAgICBwaGFzZVNoaWZ0U3RlcFJlYWwgPSBjb3NUYWJsZVtoYWxmU2l6ZV07XG4gICAgcGhhc2VTaGlmdFN0ZXBJbWFnID0gc2luVGFibGVbaGFsZlNpemVdO1xuICAgIFxuICAgIGN1cnJlbnRQaGFzZVNoaWZ0UmVhbCA9IDE7XG4gICAgY3VycmVudFBoYXNlU2hpZnRJbWFnID0gMDtcblxuICAgIGZvciAodmFyIGZmdFN0ZXAgPSAwOyBmZnRTdGVwIDwgaGFsZlNpemU7IGZmdFN0ZXArKykge1xuICAgICAgaSA9IGZmdFN0ZXA7XG5cbiAgICAgIHdoaWxlIChpIDwgYnVmZmVyU2l6ZSkge1xuICAgICAgICBvZmYgPSBpICsgaGFsZlNpemU7XG4gICAgICAgIHRyID0gKGN1cnJlbnRQaGFzZVNoaWZ0UmVhbCAqIHJlYWxbb2ZmXSkgLSAoY3VycmVudFBoYXNlU2hpZnRJbWFnICogaW1hZ1tvZmZdKTtcbiAgICAgICAgdGkgPSAoY3VycmVudFBoYXNlU2hpZnRSZWFsICogaW1hZ1tvZmZdKSArIChjdXJyZW50UGhhc2VTaGlmdEltYWcgKiByZWFsW29mZl0pO1xuXG4gICAgICAgIHJlYWxbb2ZmXSA9IHJlYWxbaV0gLSB0cjtcbiAgICAgICAgaW1hZ1tvZmZdID0gaW1hZ1tpXSAtIHRpO1xuICAgICAgICByZWFsW2ldICs9IHRyO1xuICAgICAgICBpbWFnW2ldICs9IHRpO1xuXG4gICAgICAgIGkgKz0gaGFsZlNpemUgPDwgMTtcbiAgICAgIH1cblxuICAgICAgdG1wUmVhbCA9IGN1cnJlbnRQaGFzZVNoaWZ0UmVhbDtcbiAgICAgIGN1cnJlbnRQaGFzZVNoaWZ0UmVhbCA9ICh0bXBSZWFsICogcGhhc2VTaGlmdFN0ZXBSZWFsKSAtIChjdXJyZW50UGhhc2VTaGlmdEltYWcgKiBwaGFzZVNoaWZ0U3RlcEltYWcpO1xuICAgICAgY3VycmVudFBoYXNlU2hpZnRJbWFnID0gKHRtcFJlYWwgKiBwaGFzZVNoaWZ0U3RlcEltYWcpICsgKGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyAqIHBoYXNlU2hpZnRTdGVwUmVhbCk7XG4gICAgfVxuXG4gICAgaGFsZlNpemUgPSBoYWxmU2l6ZSA8PCAxO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlU3BlY3RydW0oKTtcbn07XG5cbkZGVC5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uKHJlYWwsIGltYWcsIGJ1ZmZlcikge1xuICAvLyBMb2NhbGx5IHNjb3BlIHZhcmlhYmxlcyBmb3Igc3BlZWQgdXBcbiAgdmFyIGJ1ZmZlclNpemUgICAgICA9IHRoaXMuYnVmZmVyU2l6ZSxcbiAgICAgIGNvc1RhYmxlICAgICAgICA9IHRoaXMuY29zVGFibGUsXG4gICAgICBzaW5UYWJsZSAgICAgICAgPSB0aGlzLnNpblRhYmxlLFxuICAgICAgcmV2ZXJzZVRhYmxlICAgID0gdGhpcy5yZXZlcnNlVGFibGUsXG4gICAgICBzcGVjdHJ1bSAgICAgICAgPSB0aGlzLnNwZWN0cnVtO1xuICAgICBcbiAgICAgIHJlYWwgPSByZWFsIHx8IHRoaXMucmVhbDtcbiAgICAgIGltYWcgPSBpbWFnIHx8IHRoaXMuaW1hZztcblxuICB2YXIgaGFsZlNpemUgPSAxLFxuICAgICAgcGhhc2VTaGlmdFN0ZXBSZWFsLFxuICAgICAgcGhhc2VTaGlmdFN0ZXBJbWFnLFxuICAgICAgY3VycmVudFBoYXNlU2hpZnRSZWFsLFxuICAgICAgY3VycmVudFBoYXNlU2hpZnRJbWFnLFxuICAgICAgb2ZmLFxuICAgICAgdHIsXG4gICAgICB0aSxcbiAgICAgIHRtcFJlYWwsXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBidWZmZXJTaXplOyBpKyspIHtcbiAgICBpbWFnW2ldICo9IC0xO1xuICB9XG5cbiAgdmFyIHJldlJlYWwgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUpO1xuICB2YXIgcmV2SW1hZyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSk7XG4gXG4gIGZvciAoaSA9IDA7IGkgPCByZWFsLmxlbmd0aDsgaSsrKSB7XG4gICAgcmV2UmVhbFtpXSA9IHJlYWxbcmV2ZXJzZVRhYmxlW2ldXTtcbiAgICByZXZJbWFnW2ldID0gaW1hZ1tyZXZlcnNlVGFibGVbaV1dO1xuICB9XG4gXG4gIHJlYWwgPSByZXZSZWFsO1xuICBpbWFnID0gcmV2SW1hZztcblxuICB3aGlsZSAoaGFsZlNpemUgPCBidWZmZXJTaXplKSB7XG4gICAgcGhhc2VTaGlmdFN0ZXBSZWFsID0gY29zVGFibGVbaGFsZlNpemVdO1xuICAgIHBoYXNlU2hpZnRTdGVwSW1hZyA9IHNpblRhYmxlW2hhbGZTaXplXTtcbiAgICBjdXJyZW50UGhhc2VTaGlmdFJlYWwgPSAxO1xuICAgIGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyA9IDA7XG5cbiAgICBmb3IgKHZhciBmZnRTdGVwID0gMDsgZmZ0U3RlcCA8IGhhbGZTaXplOyBmZnRTdGVwKyspIHtcbiAgICAgIGkgPSBmZnRTdGVwO1xuXG4gICAgICB3aGlsZSAoaSA8IGJ1ZmZlclNpemUpIHtcbiAgICAgICAgb2ZmID0gaSArIGhhbGZTaXplO1xuICAgICAgICB0ciA9IChjdXJyZW50UGhhc2VTaGlmdFJlYWwgKiByZWFsW29mZl0pIC0gKGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyAqIGltYWdbb2ZmXSk7XG4gICAgICAgIHRpID0gKGN1cnJlbnRQaGFzZVNoaWZ0UmVhbCAqIGltYWdbb2ZmXSkgKyAoY3VycmVudFBoYXNlU2hpZnRJbWFnICogcmVhbFtvZmZdKTtcblxuICAgICAgICByZWFsW29mZl0gPSByZWFsW2ldIC0gdHI7XG4gICAgICAgIGltYWdbb2ZmXSA9IGltYWdbaV0gLSB0aTtcbiAgICAgICAgcmVhbFtpXSArPSB0cjtcbiAgICAgICAgaW1hZ1tpXSArPSB0aTtcblxuICAgICAgICBpICs9IGhhbGZTaXplIDw8IDE7XG4gICAgICB9XG5cbiAgICAgIHRtcFJlYWwgPSBjdXJyZW50UGhhc2VTaGlmdFJlYWw7XG4gICAgICBjdXJyZW50UGhhc2VTaGlmdFJlYWwgPSAodG1wUmVhbCAqIHBoYXNlU2hpZnRTdGVwUmVhbCkgLSAoY3VycmVudFBoYXNlU2hpZnRJbWFnICogcGhhc2VTaGlmdFN0ZXBJbWFnKTtcbiAgICAgIGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyA9ICh0bXBSZWFsICogcGhhc2VTaGlmdFN0ZXBJbWFnKSArIChjdXJyZW50UGhhc2VTaGlmdEltYWcgKiBwaGFzZVNoaWZ0U3RlcFJlYWwpO1xuICAgIH1cblxuICAgIGhhbGZTaXplID0gaGFsZlNpemUgPDwgMTtcbiAgfVxuXG4gIC8vIHZhciBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUpOyAvLyB0aGlzIHNob3VsZCBiZSByZXVzZWQgaW5zdGVhZFxuICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyU2l6ZTsgaSsrKSB7XG4gICAgYnVmZmVyW2ldID0gcmVhbFtpXSAvIGJ1ZmZlclNpemU7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuLyoqXG4gKiBSRkZUIGlzIGEgY2xhc3MgZm9yIGNhbGN1bGF0aW5nIHRoZSBEaXNjcmV0ZSBGb3VyaWVyIFRyYW5zZm9ybSBvZiBhIHNpZ25hbFxuICogd2l0aCB0aGUgRmFzdCBGb3VyaWVyIFRyYW5zZm9ybSBhbGdvcml0aG0uXG4gKlxuICogVGhpcyBtZXRob2QgY3VycmVudGx5IG9ubHkgY29udGFpbnMgYSBmb3J3YXJkIHRyYW5zZm9ybSBidXQgaXMgaGlnaGx5IG9wdGltaXplZC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYnVmZmVyU2l6ZSBUaGUgc2l6ZSBvZiB0aGUgc2FtcGxlIGJ1ZmZlciB0byBiZSBjb21wdXRlZC4gTXVzdCBiZSBwb3dlciBvZiAyXG4gKiBAcGFyYW0ge051bWJlcn0gc2FtcGxlUmF0ZSBUaGUgc2FtcGxlUmF0ZSBvZiB0aGUgYnVmZmVyIChlZy4gNDQxMDApXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuLy8gbG9va3VwIHRhYmxlcyBkb24ndCByZWFsbHkgZ2FpbiB1cyBhbnkgc3BlZWQsIGJ1dCB0aGV5IGRvIGluY3JlYXNlXG4vLyBjYWNoZSBmb290cHJpbnQsIHNvIGRvbid0IHVzZSB0aGVtIGluIGhlcmVcblxuLy8gYWxzbyB3ZSBkb24ndCB1c2Ugc2VwZWFyYXRlIGFycmF5cyBmb3IgcmVhbC9pbWFnaW5hcnkgcGFydHNcblxuLy8gdGhpcyBvbmUgYSBsaXR0bGUgbW9yZSB0aGFuIHR3aWNlIGFzIGZhc3QgYXMgdGhlIG9uZSBpbiBGRlRcbi8vIGhvd2V2ZXIgSSBvbmx5IGRpZCB0aGUgZm9yd2FyZCB0cmFuc2Zvcm1cblxuLy8gdGhlIHJlc3Qgb2YgdGhpcyB3YXMgdHJhbnNsYXRlZCBmcm9tIEMsIHNlZSBodHRwOi8vd3d3Lmpqai5kZS9meHQvXG4vLyB0aGlzIGlzIHRoZSByZWFsIHNwbGl0IHJhZGl4IEZGVFxuXG5mdW5jdGlvbiBSRkZUKGJ1ZmZlclNpemUsIHNhbXBsZVJhdGUpIHtcbiAgRm91cmllclRyYW5zZm9ybS5jYWxsKHRoaXMsIGJ1ZmZlclNpemUsIHNhbXBsZVJhdGUpO1xuXG4gIHRoaXMudHJhbnMgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUpO1xuXG4gIHRoaXMucmV2ZXJzZVRhYmxlID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlclNpemUpO1xuXG4gIC8vIGRvbid0IHVzZSBhIGxvb2t1cCB0YWJsZSB0byBkbyB0aGUgcGVybXV0ZSwgdXNlIHRoaXMgaW5zdGVhZFxuICB0aGlzLnJldmVyc2VCaW5QZXJtdXRlID0gZnVuY3Rpb24gKGRlc3QsIHNvdXJjZSkge1xuICAgIHZhciBidWZmZXJTaXplICA9IHRoaXMuYnVmZmVyU2l6ZSwgXG4gICAgICAgIGhhbGZTaXplICAgID0gYnVmZmVyU2l6ZSA+Pj4gMSwgXG4gICAgICAgIG5tMSAgICAgICAgID0gYnVmZmVyU2l6ZSAtIDEsIFxuICAgICAgICBpID0gMSwgciA9IDAsIGg7XG5cbiAgICBkZXN0WzBdID0gc291cmNlWzBdO1xuXG4gICAgZG8ge1xuICAgICAgciArPSBoYWxmU2l6ZTtcbiAgICAgIGRlc3RbaV0gPSBzb3VyY2Vbcl07XG4gICAgICBkZXN0W3JdID0gc291cmNlW2ldO1xuICAgICAgXG4gICAgICBpKys7XG5cbiAgICAgIGggPSBoYWxmU2l6ZSA8PCAxO1xuICAgICAgd2hpbGUgKGggPSBoID4+IDEsICEoKHIgXj0gaCkgJiBoKSk7XG5cbiAgICAgIGlmIChyID49IGkpIHsgXG4gICAgICAgIGRlc3RbaV0gICAgID0gc291cmNlW3JdOyBcbiAgICAgICAgZGVzdFtyXSAgICAgPSBzb3VyY2VbaV07XG5cbiAgICAgICAgZGVzdFtubTEtaV0gPSBzb3VyY2Vbbm0xLXJdOyBcbiAgICAgICAgZGVzdFtubTEtcl0gPSBzb3VyY2Vbbm0xLWldO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH0gd2hpbGUgKGkgPCBoYWxmU2l6ZSk7XG4gICAgZGVzdFtubTFdID0gc291cmNlW25tMV07XG4gIH07XG5cbiAgdGhpcy5nZW5lcmF0ZVJldmVyc2VUYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYnVmZmVyU2l6ZSAgPSB0aGlzLmJ1ZmZlclNpemUsIFxuICAgICAgICBoYWxmU2l6ZSAgICA9IGJ1ZmZlclNpemUgPj4+IDEsIFxuICAgICAgICBubTEgICAgICAgICA9IGJ1ZmZlclNpemUgLSAxLCBcbiAgICAgICAgaSA9IDEsIHIgPSAwLCBoO1xuXG4gICAgdGhpcy5yZXZlcnNlVGFibGVbMF0gPSAwO1xuXG4gICAgZG8ge1xuICAgICAgciArPSBoYWxmU2l6ZTtcbiAgICAgIFxuICAgICAgdGhpcy5yZXZlcnNlVGFibGVbaV0gPSByO1xuICAgICAgdGhpcy5yZXZlcnNlVGFibGVbcl0gPSBpO1xuXG4gICAgICBpKys7XG5cbiAgICAgIGggPSBoYWxmU2l6ZSA8PCAxO1xuICAgICAgd2hpbGUgKGggPSBoID4+IDEsICEoKHIgXj0gaCkgJiBoKSk7XG5cbiAgICAgIGlmIChyID49IGkpIHsgXG4gICAgICAgIHRoaXMucmV2ZXJzZVRhYmxlW2ldID0gcjtcbiAgICAgICAgdGhpcy5yZXZlcnNlVGFibGVbcl0gPSBpO1xuXG4gICAgICAgIHRoaXMucmV2ZXJzZVRhYmxlW25tMS1pXSA9IG5tMS1yO1xuICAgICAgICB0aGlzLnJldmVyc2VUYWJsZVtubTEtcl0gPSBubTEtaTtcbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9IHdoaWxlIChpIDwgaGFsZlNpemUpO1xuXG4gICAgdGhpcy5yZXZlcnNlVGFibGVbbm0xXSA9IG5tMTtcbiAgfTtcblxuICB0aGlzLmdlbmVyYXRlUmV2ZXJzZVRhYmxlKCk7XG59XG5cblxuLy8gT3JkZXJpbmcgb2Ygb3V0cHV0OlxuLy9cbi8vIHRyYW5zWzBdICAgICA9IHJlWzBdICg9PXplcm8gZnJlcXVlbmN5LCBwdXJlbHkgcmVhbClcbi8vIHRyYW5zWzFdICAgICA9IHJlWzFdXG4vLyAgICAgICAgICAgICAuLi5cbi8vIHRyYW5zW24vMi0xXSA9IHJlW24vMi0xXVxuLy8gdHJhbnNbbi8yXSAgID0gcmVbbi8yXSAgICAoPT1ueXF1aXN0IGZyZXF1ZW5jeSwgcHVyZWx5IHJlYWwpXG4vL1xuLy8gdHJhbnNbbi8yKzFdID0gaW1bbi8yLTFdXG4vLyB0cmFuc1tuLzIrMl0gPSBpbVtuLzItMl1cbi8vICAgICAgICAgICAgIC4uLlxuLy8gdHJhbnNbbi0xXSAgID0gaW1bMV0gXG5cblJGRlQucHJvdG90eXBlLmZvcndhcmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIG4gICAgICAgICA9IHRoaXMuYnVmZmVyU2l6ZSwgXG4gICAgICBzcGVjdHJ1bSAgPSB0aGlzLnNwZWN0cnVtLFxuICAgICAgeCAgICAgICAgID0gdGhpcy50cmFucywgXG4gICAgICBUV09fUEkgICAgPSAyKk1hdGguUEksXG4gICAgICBzcXJ0ICAgICAgPSBNYXRoLnNxcnQsXG4gICAgICBpICAgICAgICAgPSBuID4+PiAxLFxuICAgICAgYlNpICAgICAgID0gMiAvIG4sXG4gICAgICBuMiwgbjQsIG44LCBubiwgXG4gICAgICB0MSwgdDIsIHQzLCB0NCwgXG4gICAgICBpMSwgaTIsIGkzLCBpNCwgaTUsIGk2LCBpNywgaTgsIFxuICAgICAgc3QxLCBjYzEsIHNzMSwgY2MzLCBzczMsXG4gICAgICBlLCBcbiAgICAgIGEsXG4gICAgICBydmFsLCBpdmFsLCBtYWc7IFxuXG4gIHRoaXMucmV2ZXJzZUJpblBlcm11dGUoeCwgYnVmZmVyKTtcblxuICAvKlxuICB2YXIgcmV2ZXJzZVRhYmxlID0gdGhpcy5yZXZlcnNlVGFibGU7XG5cbiAgZm9yICh2YXIgayA9IDAsIGxlbiA9IHJldmVyc2VUYWJsZS5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuICAgIHhba10gPSBidWZmZXJbcmV2ZXJzZVRhYmxlW2tdXTtcbiAgfVxuICAqL1xuXG4gIGZvciAodmFyIGl4ID0gMCwgaWQgPSA0OyBpeCA8IG47IGlkICo9IDQpIHtcbiAgICBmb3IgKHZhciBpMCA9IGl4OyBpMCA8IG47IGkwICs9IGlkKSB7XG4gICAgICAvL3N1bWRpZmYoeFtpMF0sIHhbaTArMV0pOyAvLyB7YSwgYn0gIDwtLXwge2ErYiwgYS1ifVxuICAgICAgc3QxID0geFtpMF0gLSB4W2kwKzFdO1xuICAgICAgeFtpMF0gKz0geFtpMCsxXTtcbiAgICAgIHhbaTArMV0gPSBzdDE7XG4gICAgfSBcbiAgICBpeCA9IDIqKGlkLTEpO1xuICB9XG5cbiAgbjIgPSAyO1xuICBubiA9IG4gPj4+IDE7XG5cbiAgd2hpbGUoKG5uID0gbm4gPj4+IDEpKSB7XG4gICAgaXggPSAwO1xuICAgIG4yID0gbjIgPDwgMTtcbiAgICBpZCA9IG4yIDw8IDE7XG4gICAgbjQgPSBuMiA+Pj4gMjtcbiAgICBuOCA9IG4yID4+PiAzO1xuICAgIGRvIHtcbiAgICAgIGlmKG40ICE9PSAxKSB7XG4gICAgICAgIGZvcihpMCA9IGl4OyBpMCA8IG47IGkwICs9IGlkKSB7XG4gICAgICAgICAgaTEgPSBpMDtcbiAgICAgICAgICBpMiA9IGkxICsgbjQ7XG4gICAgICAgICAgaTMgPSBpMiArIG40O1xuICAgICAgICAgIGk0ID0gaTMgKyBuNDtcbiAgICAgXG4gICAgICAgICAgLy9kaWZmc3VtM19yKHhbaTNdLCB4W2k0XSwgdDEpOyAvLyB7YSwgYiwgc30gPC0tfCB7YSwgYi1hLCBhK2J9XG4gICAgICAgICAgdDEgPSB4W2kzXSArIHhbaTRdO1xuICAgICAgICAgIHhbaTRdIC09IHhbaTNdO1xuICAgICAgICAgIC8vc3VtZGlmZjMoeFtpMV0sIHQxLCB4W2kzXSk7ICAgLy8ge2EsIGIsIGR9IDwtLXwge2ErYiwgYiwgYS1ifVxuICAgICAgICAgIHhbaTNdID0geFtpMV0gLSB0MTsgXG4gICAgICAgICAgeFtpMV0gKz0gdDE7XG4gICAgIFxuICAgICAgICAgIGkxICs9IG44O1xuICAgICAgICAgIGkyICs9IG44O1xuICAgICAgICAgIGkzICs9IG44O1xuICAgICAgICAgIGk0ICs9IG44O1xuICAgICAgICAgXG4gICAgICAgICAgLy9zdW1kaWZmKHhbaTNdLCB4W2k0XSwgdDEsIHQyKTsgLy8ge3MsIGR9ICA8LS18IHthK2IsIGEtYn1cbiAgICAgICAgICB0MSA9IHhbaTNdICsgeFtpNF07XG4gICAgICAgICAgdDIgPSB4W2kzXSAtIHhbaTRdO1xuICAgICAgICAgXG4gICAgICAgICAgdDEgPSAtdDEgKiBNYXRoLlNRUlQxXzI7XG4gICAgICAgICAgdDIgKj0gTWF0aC5TUVJUMV8yO1xuICAgICBcbiAgICAgICAgICAvLyBzdW1kaWZmKHQxLCB4W2kyXSwgeFtpNF0sIHhbaTNdKTsgLy8ge3MsIGR9ICA8LS18IHthK2IsIGEtYn1cbiAgICAgICAgICBzdDEgPSB4W2kyXTtcbiAgICAgICAgICB4W2k0XSA9IHQxICsgc3QxOyBcbiAgICAgICAgICB4W2kzXSA9IHQxIC0gc3QxO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vc3VtZGlmZjMoeFtpMV0sIHQyLCB4W2kyXSk7IC8vIHthLCBiLCBkfSA8LS18IHthK2IsIGIsIGEtYn1cbiAgICAgICAgICB4W2kyXSA9IHhbaTFdIC0gdDI7XG4gICAgICAgICAgeFtpMV0gKz0gdDI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcihpMCA9IGl4OyBpMCA8IG47IGkwICs9IGlkKSB7XG4gICAgICAgICAgaTEgPSBpMDtcbiAgICAgICAgICBpMiA9IGkxICsgbjQ7XG4gICAgICAgICAgaTMgPSBpMiArIG40O1xuICAgICAgICAgIGk0ID0gaTMgKyBuNDtcbiAgICAgXG4gICAgICAgICAgLy9kaWZmc3VtM19yKHhbaTNdLCB4W2k0XSwgdDEpOyAvLyB7YSwgYiwgc30gPC0tfCB7YSwgYi1hLCBhK2J9XG4gICAgICAgICAgdDEgPSB4W2kzXSArIHhbaTRdOyBcbiAgICAgICAgICB4W2k0XSAtPSB4W2kzXTtcbiAgICAgICAgICBcbiAgICAgICAgICAvL3N1bWRpZmYzKHhbaTFdLCB0MSwgeFtpM10pOyAgIC8vIHthLCBiLCBkfSA8LS18IHthK2IsIGIsIGEtYn1cbiAgICAgICAgICB4W2kzXSA9IHhbaTFdIC0gdDE7IFxuICAgICAgICAgIHhbaTFdICs9IHQxO1xuICAgICAgICB9XG4gICAgICB9XG4gICBcbiAgICAgIGl4ID0gKGlkIDw8IDEpIC0gbjI7XG4gICAgICBpZCA9IGlkIDw8IDI7XG4gICAgfSB3aGlsZSAoaXggPCBuKTtcbiBcbiAgICBlID0gVFdPX1BJIC8gbjI7XG5cbiAgICBmb3IgKHZhciBqID0gMTsgaiA8IG44OyBqKyspIHtcbiAgICAgIGEgPSBqICogZTtcbiAgICAgIHNzMSA9IE1hdGguc2luKGEpO1xuICAgICAgY2MxID0gTWF0aC5jb3MoYSk7XG5cbiAgICAgIC8vc3MzID0gc2luKDMqYSk7IGNjMyA9IGNvcygzKmEpO1xuICAgICAgY2MzID0gNCpjYzEqKGNjMSpjYzEtMC43NSk7XG4gICAgICBzczMgPSA0KnNzMSooMC43NS1zczEqc3MxKTtcbiAgIFxuICAgICAgaXggPSAwOyBpZCA9IG4yIDw8IDE7XG4gICAgICBkbyB7XG4gICAgICAgIGZvciAoaTAgPSBpeDsgaTAgPCBuOyBpMCArPSBpZCkge1xuICAgICAgICAgIGkxID0gaTAgKyBqO1xuICAgICAgICAgIGkyID0gaTEgKyBuNDtcbiAgICAgICAgICBpMyA9IGkyICsgbjQ7XG4gICAgICAgICAgaTQgPSBpMyArIG40O1xuICAgICAgIFxuICAgICAgICAgIGk1ID0gaTAgKyBuNCAtIGo7XG4gICAgICAgICAgaTYgPSBpNSArIG40O1xuICAgICAgICAgIGk3ID0gaTYgKyBuNDtcbiAgICAgICAgICBpOCA9IGk3ICsgbjQ7XG4gICAgICAgXG4gICAgICAgICAgLy9jbXVsdChjLCBzLCB4LCB5LCAmdSwgJnYpXG4gICAgICAgICAgLy9jbXVsdChjYzEsIHNzMSwgeFtpN10sIHhbaTNdLCB0MiwgdDEpOyAvLyB7dSx2fSA8LS18IHt4KmMteSpzLCB4KnMreSpjfVxuICAgICAgICAgIHQyID0geFtpN10qY2MxIC0geFtpM10qc3MxOyBcbiAgICAgICAgICB0MSA9IHhbaTddKnNzMSArIHhbaTNdKmNjMTtcbiAgICAgICAgICBcbiAgICAgICAgICAvL2NtdWx0KGNjMywgc3MzLCB4W2k4XSwgeFtpNF0sIHQ0LCB0Myk7XG4gICAgICAgICAgdDQgPSB4W2k4XSpjYzMgLSB4W2k0XSpzczM7IFxuICAgICAgICAgIHQzID0geFtpOF0qc3MzICsgeFtpNF0qY2MzO1xuICAgICAgIFxuICAgICAgICAgIC8vc3VtZGlmZih0MiwgdDQpOyAgIC8vIHthLCBifSA8LS18IHthK2IsIGEtYn1cbiAgICAgICAgICBzdDEgPSB0MiAtIHQ0O1xuICAgICAgICAgIHQyICs9IHQ0O1xuICAgICAgICAgIHQ0ID0gc3QxO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vc3VtZGlmZih0MiwgeFtpNl0sIHhbaThdLCB4W2kzXSk7IC8vIHtzLCBkfSAgPC0tfCB7YStiLCBhLWJ9XG4gICAgICAgICAgLy9zdDEgPSB4W2k2XTsgeFtpOF0gPSB0MiArIHN0MTsgeFtpM10gPSB0MiAtIHN0MTtcbiAgICAgICAgICB4W2k4XSA9IHQyICsgeFtpNl07IFxuICAgICAgICAgIHhbaTNdID0gdDIgLSB4W2k2XTtcbiAgICAgICAgIFxuICAgICAgICAgIC8vc3VtZGlmZl9yKHQxLCB0Myk7IC8vIHthLCBifSA8LS18IHthK2IsIGItYX1cbiAgICAgICAgICBzdDEgPSB0MyAtIHQxO1xuICAgICAgICAgIHQxICs9IHQzO1xuICAgICAgICAgIHQzID0gc3QxO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vc3VtZGlmZih0MywgeFtpMl0sIHhbaTRdLCB4W2k3XSk7IC8vIHtzLCBkfSAgPC0tfCB7YStiLCBhLWJ9XG4gICAgICAgICAgLy9zdDEgPSB4W2kyXTsgeFtpNF0gPSB0MyArIHN0MTsgeFtpN10gPSB0MyAtIHN0MTtcbiAgICAgICAgICB4W2k0XSA9IHQzICsgeFtpMl07IFxuICAgICAgICAgIHhbaTddID0gdDMgLSB4W2kyXTtcbiAgICAgICAgIFxuICAgICAgICAgIC8vc3VtZGlmZjMoeFtpMV0sIHQxLCB4W2k2XSk7ICAgLy8ge2EsIGIsIGR9IDwtLXwge2ErYiwgYiwgYS1ifVxuICAgICAgICAgIHhbaTZdID0geFtpMV0gLSB0MTsgXG4gICAgICAgICAgeFtpMV0gKz0gdDE7XG4gICAgICAgICAgXG4gICAgICAgICAgLy9kaWZmc3VtM19yKHQ0LCB4W2k1XSwgeFtpMl0pOyAvLyB7YSwgYiwgc30gPC0tfCB7YSwgYi1hLCBhK2J9XG4gICAgICAgICAgeFtpMl0gPSB0NCArIHhbaTVdOyBcbiAgICAgICAgICB4W2k1XSAtPSB0NDtcbiAgICAgICAgfVxuICAgICBcbiAgICAgICAgaXggPSAoaWQgPDwgMSkgLSBuMjtcbiAgICAgICAgaWQgPSBpZCA8PCAyO1xuICAgXG4gICAgICB9IHdoaWxlIChpeCA8IG4pO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlICgtLWkpIHtcbiAgICBydmFsID0geFtpXTtcbiAgICBpdmFsID0geFtuLWktMV07XG4gICAgbWFnID0gYlNpICogc3FydChydmFsICogcnZhbCArIGl2YWwgKiBpdmFsKTtcblxuICAgIGlmIChtYWcgPiB0aGlzLnBlYWspIHtcbiAgICAgIHRoaXMucGVha0JhbmQgPSBpO1xuICAgICAgdGhpcy5wZWFrID0gbWFnO1xuICAgIH1cblxuICAgIHNwZWN0cnVtW2ldID0gbWFnO1xuICB9XG5cbiAgc3BlY3RydW1bMF0gPSBiU2kgKiB4WzBdO1xuXG4gIHJldHVybiBzcGVjdHJ1bTtcbn07XG5cbmZ1bmN0aW9uIFNhbXBsZXIoZmlsZSwgYnVmZmVyU2l6ZSwgc2FtcGxlUmF0ZSwgcGxheVN0YXJ0LCBwbGF5RW5kLCBsb29wU3RhcnQsIGxvb3BFbmQsIGxvb3BNb2RlKSB7XG4gIHRoaXMuZmlsZSA9IGZpbGU7XG4gIHRoaXMuYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemU7XG4gIHRoaXMuc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7XG4gIHRoaXMucGxheVN0YXJ0ICA9IHBsYXlTdGFydCB8fCAwOyAvLyAwJVxuICB0aGlzLnBsYXlFbmQgICAgPSBwbGF5RW5kICAgfHwgMTsgLy8gMTAwJVxuICB0aGlzLmxvb3BTdGFydCAgPSBsb29wU3RhcnQgfHwgMDtcbiAgdGhpcy5sb29wRW5kICAgID0gbG9vcEVuZCAgIHx8IDE7XG4gIHRoaXMubG9vcE1vZGUgICA9IGxvb3BNb2RlICB8fCBEU1AuT0ZGO1xuICB0aGlzLmxvYWRlZCAgICAgPSBmYWxzZTtcbiAgdGhpcy5zYW1wbGVzICAgID0gW107XG4gIHRoaXMuc2lnbmFsICAgICA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSk7XG4gIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gIHRoaXMuZW52ZWxvcGUgICA9IG51bGw7XG4gIHRoaXMuYW1wbGl0dWRlICA9IDE7XG4gIHRoaXMucm9vdEZyZXF1ZW5jeSA9IDExMDsgLy8gQTIgMTEwXG4gIHRoaXMuZnJlcXVlbmN5ICA9IDU1MDtcbiAgdGhpcy5zdGVwICAgICAgID0gdGhpcy5mcmVxdWVuY3kgLyB0aGlzLnJvb3RGcmVxdWVuY3k7XG4gIHRoaXMuZHVyYXRpb24gICA9IDA7XG4gIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA9IDA7XG4gIHRoaXMucGxheWhlYWQgICA9IDA7XG4gXG4gIHZhciBhdWRpbyA9IC8qIG5ldyBBdWRpbygpOyovIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJBVURJT1wiKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuIFxuICB0aGlzLmxvYWRTYW1wbGVzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgYnVmZmVyID0gRFNQLmdldENoYW5uZWwoRFNQLk1JWCwgZXZlbnQuZnJhbWVCdWZmZXIpO1xuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgc2VsZi5zYW1wbGVzLnB1c2goYnVmZmVyW2ldKTtcbiAgICB9XG4gIH07XG4gXG4gIHRoaXMubG9hZENvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gY29udmVydCBmbGV4aWJsZSBqcyBhcnJheSBpbnRvIGEgZmFzdCB0eXBlZCBhcnJheVxuICAgIHNlbGYuc2FtcGxlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2VsZi5zYW1wbGVzKTtcbiAgICBzZWxmLmxvYWRlZCA9IHRydWU7XG4gIH07XG4gXG4gIHRoaXMubG9hZE1ldGFEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5kdXJhdGlvbiA9IGF1ZGlvLmR1cmF0aW9uO1xuICB9O1xuIFxuICBhdWRpby5hZGRFdmVudExpc3RlbmVyKFwiTW96QXVkaW9BdmFpbGFibGVcIiwgdGhpcy5sb2FkU2FtcGxlcywgZmFsc2UpO1xuICBhdWRpby5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIiwgdGhpcy5sb2FkTWV0YURhdGEsIGZhbHNlKTtcbiAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcihcImVuZGVkXCIsIHRoaXMubG9hZENvbXBsZXRlLCBmYWxzZSk7XG4gIGF1ZGlvLm11dGVkID0gdHJ1ZTtcbiAgYXVkaW8uc3JjID0gZmlsZTtcbiAgYXVkaW8ucGxheSgpO1xufVxuXG5TYW1wbGVyLnByb3RvdHlwZS5hcHBseUVudmVsb3BlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW52ZWxvcGUucHJvY2Vzcyh0aGlzLnNpZ25hbCk7XG4gIHJldHVybiB0aGlzLnNpZ25hbDtcbn07XG5cblNhbXBsZXIucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmcmFtZU9mZnNldCA9IHRoaXMuZnJhbWVDb3VudCAqIHRoaXMuYnVmZmVyU2l6ZTtcbiBcbiAgdmFyIGxvb3BXaWR0aCA9IHRoaXMucGxheUVuZCAqIHRoaXMuc2FtcGxlcy5sZW5ndGggLSB0aGlzLnBsYXlTdGFydCAqIHRoaXMuc2FtcGxlcy5sZW5ndGg7XG4gIHZhciBwbGF5U3RhcnRTYW1wbGVzID0gdGhpcy5wbGF5U3RhcnQgKiB0aGlzLnNhbXBsZXMubGVuZ3RoOyAvLyBpZSAwLjUgLT4gNTAlIG9mIHRoZSBsZW5ndGhcbiAgdmFyIHBsYXlFbmRTYW1wbGVzID0gdGhpcy5wbGF5RW5kICogdGhpcy5zYW1wbGVzLmxlbmd0aDsgLy8gaWUgMC41IC0+IDUwJSBvZiB0aGUgbGVuZ3RoXG4gIHZhciBvZmZzZXQ7XG5cbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5idWZmZXJTaXplOyBpKysgKSB7XG4gICAgc3dpdGNoICh0aGlzLmxvb3BNb2RlKSB7XG4gICAgICBjYXNlIERTUC5PRkY6XG4gICAgICAgIHRoaXMucGxheWhlYWQgPSBNYXRoLnJvdW5kKHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAqIHRoaXMuc3RlcCArIHBsYXlTdGFydFNhbXBsZXMpO1xuICAgICAgICBpZiAodGhpcy5wbGF5aGVhZCA8ICh0aGlzLnBsYXlFbmQgKiB0aGlzLnNhbXBsZXMubGVuZ3RoKSApIHtcbiAgICAgICAgICB0aGlzLnNpZ25hbFtpXSA9IHRoaXMuc2FtcGxlc1t0aGlzLnBsYXloZWFkXSAqIHRoaXMuYW1wbGl0dWRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2lnbmFsW2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgXG4gICAgICBjYXNlIERTUC5GVzpcbiAgICAgICAgdGhpcy5wbGF5aGVhZCA9IE1hdGgucm91bmQoKHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAqIHRoaXMuc3RlcCkgJSBsb29wV2lkdGggKyBwbGF5U3RhcnRTYW1wbGVzKTtcbiAgICAgICAgaWYgKHRoaXMucGxheWhlYWQgPCAodGhpcy5wbGF5RW5kICogdGhpcy5zYW1wbGVzLmxlbmd0aCkgKSB7XG4gICAgICAgICAgdGhpcy5zaWduYWxbaV0gPSB0aGlzLnNhbXBsZXNbdGhpcy5wbGF5aGVhZF0gKiB0aGlzLmFtcGxpdHVkZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICBcbiAgICAgIGNhc2UgRFNQLkJXOlxuICAgICAgICB0aGlzLnBsYXloZWFkID0gcGxheUVuZFNhbXBsZXMgLSBNYXRoLnJvdW5kKCh0aGlzLnNhbXBsZXNQcm9jZXNzZWQgKiB0aGlzLnN0ZXApICUgbG9vcFdpZHRoKTtcbiAgICAgICAgaWYgKHRoaXMucGxheWhlYWQgPCAodGhpcy5wbGF5RW5kICogdGhpcy5zYW1wbGVzLmxlbmd0aCkgKSB7XG4gICAgICAgICAgdGhpcy5zaWduYWxbaV0gPSB0aGlzLnNhbXBsZXNbdGhpcy5wbGF5aGVhZF0gKiB0aGlzLmFtcGxpdHVkZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgICBcbiAgICAgIGNhc2UgRFNQLkZXQlc6XG4gICAgICAgIGlmICggTWF0aC5mbG9vcih0aGlzLnNhbXBsZXNQcm9jZXNzZWQgKiB0aGlzLnN0ZXAgLyBsb29wV2lkdGgpICUgMiA9PT0gMCApIHtcbiAgICAgICAgICB0aGlzLnBsYXloZWFkID0gTWF0aC5yb3VuZCgodGhpcy5zYW1wbGVzUHJvY2Vzc2VkICogdGhpcy5zdGVwKSAlIGxvb3BXaWR0aCArIHBsYXlTdGFydFNhbXBsZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGxheWhlYWQgPSBwbGF5RW5kU2FtcGxlcyAtIE1hdGgucm91bmQoKHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAqIHRoaXMuc3RlcCkgJSBsb29wV2lkdGgpO1xuICAgICAgICB9ICBcbiAgICAgICAgaWYgKHRoaXMucGxheWhlYWQgPCAodGhpcy5wbGF5RW5kICogdGhpcy5zYW1wbGVzLmxlbmd0aCkgKSB7XG4gICAgICAgICAgdGhpcy5zaWduYWxbaV0gPSB0aGlzLnNhbXBsZXNbdGhpcy5wbGF5aGVhZF0gKiB0aGlzLmFtcGxpdHVkZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkKys7XG4gIH1cblxuICB0aGlzLmZyYW1lQ291bnQrKztcblxuICByZXR1cm4gdGhpcy5zaWduYWw7XG59O1xuXG5TYW1wbGVyLnByb3RvdHlwZS5zZXRGcmVxID0gZnVuY3Rpb24oZnJlcXVlbmN5KSB7XG4gICAgdmFyIHRvdGFsUHJvY2Vzc2VkID0gdGhpcy5zYW1wbGVzUHJvY2Vzc2VkICogdGhpcy5zdGVwO1xuICAgIHRoaXMuZnJlcXVlbmN5ID0gZnJlcXVlbmN5O1xuICAgIHRoaXMuc3RlcCA9IHRoaXMuZnJlcXVlbmN5IC8gdGhpcy5yb290RnJlcXVlbmN5O1xuICAgIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA9IE1hdGgucm91bmQodG90YWxQcm9jZXNzZWQvdGhpcy5zdGVwKTtcbn07XG5cblNhbXBsZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA9IDA7XG4gIHRoaXMucGxheWhlYWQgPSAwO1xufTtcblxuLyoqXG4gKiBPc2NpbGxhdG9yIGNsYXNzIGZvciBnZW5lcmF0aW5nIGFuZCBtb2RpZnlpbmcgc2lnbmFsc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlICAgICAgIEEgd2F2ZWZvcm0gY29uc3RhbnQgKGVnLiBEU1AuU0lORSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBmcmVxdWVuY3kgIEluaXRpYWwgZnJlcXVlbmN5IG9mIHRoZSBzaWduYWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbXBsaXR1ZGUgIEluaXRpYWwgYW1wbGl0dWRlIG9mIHRoZSBzaWduYWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBidWZmZXJTaXplIFNpemUgb2YgdGhlIHNhbXBsZSBidWZmZXIgdG8gZ2VuZXJhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBzYW1wbGVSYXRlIFRoZSBzYW1wbGUgcmF0ZSBvZiB0aGUgc2lnbmFsXG4gKlxuICogQGNvbnRydWN0b3JcbiAqL1xuZnVuY3Rpb24gT3NjaWxsYXRvcih0eXBlLCBmcmVxdWVuY3ksIGFtcGxpdHVkZSwgYnVmZmVyU2l6ZSwgc2FtcGxlUmF0ZSkge1xuICB0aGlzLmZyZXF1ZW5jeSAgPSBmcmVxdWVuY3k7XG4gIHRoaXMuYW1wbGl0dWRlICA9IGFtcGxpdHVkZTtcbiAgdGhpcy5idWZmZXJTaXplID0gYnVmZmVyU2l6ZTtcbiAgdGhpcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcbiAgLy90aGlzLnB1bHNlV2lkdGggPSBwdWxzZVdpZHRoO1xuICB0aGlzLmZyYW1lQ291bnQgPSAwO1xuIFxuICB0aGlzLndhdmVUYWJsZUxlbmd0aCA9IDIwNDg7XG5cbiAgdGhpcy5jeWNsZXNQZXJTYW1wbGUgPSBmcmVxdWVuY3kgLyBzYW1wbGVSYXRlO1xuXG4gIHRoaXMuc2lnbmFsID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplKTtcbiAgdGhpcy5lbnZlbG9wZSA9IG51bGw7XG5cbiAgc3dpdGNoKHBhcnNlSW50KHR5cGUsIDEwKSkge1xuICAgIGNhc2UgRFNQLlRSSUFOR0xFOlxuICAgICAgdGhpcy5mdW5jID0gT3NjaWxsYXRvci5UcmlhbmdsZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBEU1AuU0FXOlxuICAgICAgdGhpcy5mdW5jID0gT3NjaWxsYXRvci5TYXc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgRFNQLlNRVUFSRTpcbiAgICAgIHRoaXMuZnVuYyA9IE9zY2lsbGF0b3IuU3F1YXJlO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgIGNhc2UgRFNQLlNJTkU6XG4gICAgICB0aGlzLmZ1bmMgPSBPc2NpbGxhdG9yLlNpbmU7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHRoaXMuZ2VuZXJhdGVXYXZlVGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICBPc2NpbGxhdG9yLndhdmVUYWJsZVt0aGlzLmZ1bmNdID0gbmV3IEZsb2F0MzJBcnJheSgyMDQ4KTtcbiAgICB2YXIgd2F2ZVRhYmxlVGltZSA9IHRoaXMud2F2ZVRhYmxlTGVuZ3RoIC8gdGhpcy5zYW1wbGVSYXRlO1xuICAgIHZhciB3YXZlVGFibGVIeiA9IDEgLyB3YXZlVGFibGVUaW1lO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndhdmVUYWJsZUxlbmd0aDsgaSsrKSB7XG4gICAgICBPc2NpbGxhdG9yLndhdmVUYWJsZVt0aGlzLmZ1bmNdW2ldID0gdGhpcy5mdW5jKGkgKiB3YXZlVGFibGVIei90aGlzLnNhbXBsZVJhdGUpO1xuICAgIH1cbiAgfTtcblxuICBpZiAoIHR5cGVvZiBPc2NpbGxhdG9yLndhdmVUYWJsZSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgT3NjaWxsYXRvci53YXZlVGFibGUgPSB7fTtcbiAgfVxuXG4gIGlmICggdHlwZW9mIE9zY2lsbGF0b3Iud2F2ZVRhYmxlW3RoaXMuZnVuY10gPT09ICd1bmRlZmluZWQnICkge1xuICAgIHRoaXMuZ2VuZXJhdGVXYXZlVGFibGUoKTtcbiAgfVxuIFxuICB0aGlzLndhdmVUYWJsZSA9IE9zY2lsbGF0b3Iud2F2ZVRhYmxlW3RoaXMuZnVuY107XG59XG5cbi8qKlxuICogU2V0IHRoZSBhbXBsaXR1ZGUgb2YgdGhlIHNpZ25hbFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBhbXBsaXR1ZGUgVGhlIGFtcGxpdHVkZSBvZiB0aGUgc2lnbmFsIChiZXR3ZWVuIDAgYW5kIDEpXG4gKi9cbk9zY2lsbGF0b3IucHJvdG90eXBlLnNldEFtcCA9IGZ1bmN0aW9uKGFtcGxpdHVkZSkge1xuICBpZiAoYW1wbGl0dWRlID49IDAgJiYgYW1wbGl0dWRlIDw9IDEpIHtcbiAgICB0aGlzLmFtcGxpdHVkZSA9IGFtcGxpdHVkZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBcIkFtcGxpdHVkZSBvdXQgb2YgcmFuZ2UgKDAuLjEpLlwiO1xuICB9XG59O1xuICBcbi8qKlxuICogU2V0IHRoZSBmcmVxdWVuY3kgb2YgdGhlIHNpZ25hbFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBmcmVxdWVuY3kgVGhlIGZyZXF1ZW5jeSBvZiB0aGUgc2lnbmFsXG4gKi8gIFxuT3NjaWxsYXRvci5wcm90b3R5cGUuc2V0RnJlcSA9IGZ1bmN0aW9uKGZyZXF1ZW5jeSkge1xuICB0aGlzLmZyZXF1ZW5jeSA9IGZyZXF1ZW5jeTtcbiAgdGhpcy5jeWNsZXNQZXJTYW1wbGUgPSBmcmVxdWVuY3kgLyB0aGlzLnNhbXBsZVJhdGU7XG59O1xuICAgICBcbi8vIEFkZCBhbiBvc2NpbGxhdG9yXG5Pc2NpbGxhdG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvc2NpbGxhdG9yKSB7XG4gIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYnVmZmVyU2l6ZTsgaSsrICkge1xuICAgIC8vdGhpcy5zaWduYWxbaV0gKz0gb3NjaWxsYXRvci52YWx1ZUF0KGkpO1xuICAgIHRoaXMuc2lnbmFsW2ldICs9IG9zY2lsbGF0b3Iuc2lnbmFsW2ldO1xuICB9XG4gXG4gIHJldHVybiB0aGlzLnNpZ25hbDtcbn07XG4gICAgIFxuLy8gQWRkIGEgc2lnbmFsIHRvIHRoZSBjdXJyZW50IGdlbmVyYXRlZCBvc2Mgc2lnbmFsXG5Pc2NpbGxhdG9yLnByb3RvdHlwZS5hZGRTaWduYWwgPSBmdW5jdGlvbihzaWduYWwpIHtcbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgc2lnbmFsLmxlbmd0aDsgaSsrICkge1xuICAgIGlmICggaSA+PSB0aGlzLmJ1ZmZlclNpemUgKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5zaWduYWxbaV0gKz0gc2lnbmFsW2ldO1xuICAgXG4gICAgLypcbiAgICAvLyBDb25zdHJhaW4gYW1wbGl0dWRlXG4gICAgaWYgKCB0aGlzLnNpZ25hbFtpXSA+IDEgKSB7XG4gICAgICB0aGlzLnNpZ25hbFtpXSA9IDE7XG4gICAgfSBlbHNlIGlmICggdGhpcy5zaWduYWxbaV0gPCAtMSApIHtcbiAgICAgIHRoaXMuc2lnbmFsW2ldID0gLTE7XG4gICAgfVxuICAgICovXG4gIH1cbiAgcmV0dXJuIHRoaXMuc2lnbmFsO1xufTtcbiAgICAgXG4vLyBBZGQgYW4gZW52ZWxvcGUgdG8gdGhlIG9zY2lsbGF0b3Jcbk9zY2lsbGF0b3IucHJvdG90eXBlLmFkZEVudmVsb3BlID0gZnVuY3Rpb24oZW52ZWxvcGUpIHtcbiAgdGhpcy5lbnZlbG9wZSA9IGVudmVsb3BlO1xufTtcblxuT3NjaWxsYXRvci5wcm90b3R5cGUuYXBwbHlFbnZlbG9wZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVudmVsb3BlLnByb2Nlc3ModGhpcy5zaWduYWwpO1xufTtcbiAgICAgXG5Pc2NpbGxhdG9yLnByb3RvdHlwZS52YWx1ZUF0ID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLndhdmVUYWJsZVtvZmZzZXQgJSB0aGlzLndhdmVUYWJsZUxlbmd0aF07XG59O1xuICAgICBcbk9zY2lsbGF0b3IucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmcmFtZU9mZnNldCA9IHRoaXMuZnJhbWVDb3VudCAqIHRoaXMuYnVmZmVyU2l6ZTtcbiAgdmFyIHN0ZXAgPSB0aGlzLndhdmVUYWJsZUxlbmd0aCAqIHRoaXMuZnJlcXVlbmN5IC8gdGhpcy5zYW1wbGVSYXRlO1xuICB2YXIgb2Zmc2V0O1xuXG4gIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYnVmZmVyU2l6ZTsgaSsrICkge1xuICAgIC8vdmFyIHN0ZXAgPSAoZnJhbWVPZmZzZXQgKyBpKSAqIHRoaXMuY3ljbGVzUGVyU2FtcGxlICUgMTtcbiAgICAvL3RoaXMuc2lnbmFsW2ldID0gdGhpcy5mdW5jKHN0ZXApICogdGhpcy5hbXBsaXR1ZGU7XG4gICAgLy90aGlzLnNpZ25hbFtpXSA9IHRoaXMudmFsdWVBdChNYXRoLnJvdW5kKChmcmFtZU9mZnNldCArIGkpICogc3RlcCkpICogdGhpcy5hbXBsaXR1ZGU7XG4gICAgb2Zmc2V0ID0gTWF0aC5yb3VuZCgoZnJhbWVPZmZzZXQgKyBpKSAqIHN0ZXApO1xuICAgIHRoaXMuc2lnbmFsW2ldID0gdGhpcy53YXZlVGFibGVbb2Zmc2V0ICUgdGhpcy53YXZlVGFibGVMZW5ndGhdICogdGhpcy5hbXBsaXR1ZGU7XG4gIH1cblxuICB0aGlzLmZyYW1lQ291bnQrKztcblxuICByZXR1cm4gdGhpcy5zaWduYWw7XG59O1xuXG5Pc2NpbGxhdG9yLlNpbmUgPSBmdW5jdGlvbihzdGVwKSB7XG4gIHJldHVybiBNYXRoLnNpbihEU1AuVFdPX1BJICogc3RlcCk7XG59O1xuXG5Pc2NpbGxhdG9yLlNxdWFyZSA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgcmV0dXJuIHN0ZXAgPCAwLjUgPyAxIDogLTE7XG59O1xuXG5Pc2NpbGxhdG9yLlNhdyA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgcmV0dXJuIDIgKiAoc3RlcCAtIE1hdGgucm91bmQoc3RlcCkpO1xufTtcblxuT3NjaWxsYXRvci5UcmlhbmdsZSA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgcmV0dXJuIDEgLSA0ICogTWF0aC5hYnMoTWF0aC5yb3VuZChzdGVwKSAtIHN0ZXApO1xufTtcblxuT3NjaWxsYXRvci5QdWxzZSA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgLy8gc3R1YlxufTtcbiBcbmZ1bmN0aW9uIEFEU1IoYXR0YWNrTGVuZ3RoLCBkZWNheUxlbmd0aCwgc3VzdGFpbkxldmVsLCBzdXN0YWluTGVuZ3RoLCByZWxlYXNlTGVuZ3RoLCBzYW1wbGVSYXRlKSB7XG4gIHRoaXMuc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7XG4gIC8vIExlbmd0aCBpbiBzZWNvbmRzXG4gIHRoaXMuYXR0YWNrTGVuZ3RoICA9IGF0dGFja0xlbmd0aDtcbiAgdGhpcy5kZWNheUxlbmd0aCAgID0gZGVjYXlMZW5ndGg7XG4gIHRoaXMuc3VzdGFpbkxldmVsICA9IHN1c3RhaW5MZXZlbDtcbiAgdGhpcy5zdXN0YWluTGVuZ3RoID0gc3VzdGFpbkxlbmd0aDtcbiAgdGhpcy5yZWxlYXNlTGVuZ3RoID0gcmVsZWFzZUxlbmd0aDtcbiAgdGhpcy5zYW1wbGVSYXRlICAgID0gc2FtcGxlUmF0ZTtcbiBcbiAgLy8gTGVuZ3RoIGluIHNhbXBsZXNcbiAgdGhpcy5hdHRhY2tTYW1wbGVzICA9IGF0dGFja0xlbmd0aCAgKiBzYW1wbGVSYXRlO1xuICB0aGlzLmRlY2F5U2FtcGxlcyAgID0gZGVjYXlMZW5ndGggICAqIHNhbXBsZVJhdGU7XG4gIHRoaXMuc3VzdGFpblNhbXBsZXMgPSBzdXN0YWluTGVuZ3RoICogc2FtcGxlUmF0ZTtcbiAgdGhpcy5yZWxlYXNlU2FtcGxlcyA9IHJlbGVhc2VMZW5ndGggKiBzYW1wbGVSYXRlO1xuIFxuICAvLyBVcGRhdGVzIHRoZSBlbnZlbG9wZSBzYW1wbGUgcG9zaXRpb25zXG4gIHRoaXMudXBkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hdHRhY2sgICAgICAgICA9ICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNrU2FtcGxlcztcbiAgICB0aGlzLmRlY2F5ICAgICAgICAgID0gdGhpcy5hdHRhY2sgICsgdGhpcy5kZWNheVNhbXBsZXM7XG4gICAgdGhpcy5zdXN0YWluICAgICAgICA9IHRoaXMuZGVjYXkgICArIHRoaXMuc3VzdGFpblNhbXBsZXM7XG4gICAgdGhpcy5yZWxlYXNlICAgICAgICA9IHRoaXMuc3VzdGFpbiArIHRoaXMucmVsZWFzZVNhbXBsZXM7XG4gIH07XG4gXG4gIHRoaXMudXBkYXRlKCk7XG4gXG4gIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA9IDA7XG59XG5cbkFEU1IucHJvdG90eXBlLm5vdGVPbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPSAwO1xuICB0aGlzLnN1c3RhaW5TYW1wbGVzID0gdGhpcy5zdXN0YWluTGVuZ3RoICogdGhpcy5zYW1wbGVSYXRlO1xuICB0aGlzLnVwZGF0ZSgpO1xufTtcblxuLy8gU2VuZCBhIG5vdGUgb2ZmIHdoZW4gdXNpbmcgYSBzdXN0YWluIG9mIGluZmluaXR5IHRvIGxldCB0aGUgZW52ZWxvcGUgZW50ZXIgdGhlIHJlbGVhc2UgcGhhc2VcbkFEU1IucHJvdG90eXBlLm5vdGVPZmYgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zdXN0YWluU2FtcGxlcyA9IHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAtIHRoaXMuZGVjYXlTYW1wbGVzO1xuICB0aGlzLnVwZGF0ZSgpO1xufTtcblxuQURTUi5wcm90b3R5cGUucHJvY2Vzc1NhbXBsZSA9IGZ1bmN0aW9uKHNhbXBsZSkge1xuICB2YXIgYW1wbGl0dWRlID0gMDtcblxuICBpZiAoIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA8PSB0aGlzLmF0dGFjayApIHtcbiAgICBhbXBsaXR1ZGUgPSAwICsgKDEgLSAwKSAqICgodGhpcy5zYW1wbGVzUHJvY2Vzc2VkIC0gMCkgLyAodGhpcy5hdHRhY2sgLSAwKSk7XG4gIH0gZWxzZSBpZiAoIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA+IHRoaXMuYXR0YWNrICYmIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA8PSB0aGlzLmRlY2F5ICkge1xuICAgIGFtcGxpdHVkZSA9IDEgKyAodGhpcy5zdXN0YWluTGV2ZWwgLSAxKSAqICgodGhpcy5zYW1wbGVzUHJvY2Vzc2VkIC0gdGhpcy5hdHRhY2spIC8gKHRoaXMuZGVjYXkgLSB0aGlzLmF0dGFjaykpO1xuICB9IGVsc2UgaWYgKCB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPiB0aGlzLmRlY2F5ICYmIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA8PSB0aGlzLnN1c3RhaW4gKSB7XG4gICAgYW1wbGl0dWRlID0gdGhpcy5zdXN0YWluTGV2ZWw7XG4gIH0gZWxzZSBpZiAoIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA+IHRoaXMuc3VzdGFpbiAmJiB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPD0gdGhpcy5yZWxlYXNlICkge1xuICAgIGFtcGxpdHVkZSA9IHRoaXMuc3VzdGFpbkxldmVsICsgKDAgLSB0aGlzLnN1c3RhaW5MZXZlbCkgKiAoKHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAtIHRoaXMuc3VzdGFpbikgLyAodGhpcy5yZWxlYXNlIC0gdGhpcy5zdXN0YWluKSk7XG4gIH1cbiBcbiAgcmV0dXJuIHNhbXBsZSAqIGFtcGxpdHVkZTtcbn07XG5cbkFEU1IucHJvdG90eXBlLnZhbHVlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhbXBsaXR1ZGUgPSAwO1xuXG4gIGlmICggdGhpcy5zYW1wbGVzUHJvY2Vzc2VkIDw9IHRoaXMuYXR0YWNrICkge1xuICAgIGFtcGxpdHVkZSA9IDAgKyAoMSAtIDApICogKCh0aGlzLnNhbXBsZXNQcm9jZXNzZWQgLSAwKSAvICh0aGlzLmF0dGFjayAtIDApKTtcbiAgfSBlbHNlIGlmICggdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID4gdGhpcy5hdHRhY2sgJiYgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkIDw9IHRoaXMuZGVjYXkgKSB7XG4gICAgYW1wbGl0dWRlID0gMSArICh0aGlzLnN1c3RhaW5MZXZlbCAtIDEpICogKCh0aGlzLnNhbXBsZXNQcm9jZXNzZWQgLSB0aGlzLmF0dGFjaykgLyAodGhpcy5kZWNheSAtIHRoaXMuYXR0YWNrKSk7XG4gIH0gZWxzZSBpZiAoIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA+IHRoaXMuZGVjYXkgJiYgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkIDw9IHRoaXMuc3VzdGFpbiApIHtcbiAgICBhbXBsaXR1ZGUgPSB0aGlzLnN1c3RhaW5MZXZlbDtcbiAgfSBlbHNlIGlmICggdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID4gdGhpcy5zdXN0YWluICYmIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA8PSB0aGlzLnJlbGVhc2UgKSB7XG4gICAgYW1wbGl0dWRlID0gdGhpcy5zdXN0YWluTGV2ZWwgKyAoMCAtIHRoaXMuc3VzdGFpbkxldmVsKSAqICgodGhpcy5zYW1wbGVzUHJvY2Vzc2VkIC0gdGhpcy5zdXN0YWluKSAvICh0aGlzLnJlbGVhc2UgLSB0aGlzLnN1c3RhaW4pKTtcbiAgfVxuIFxuICByZXR1cm4gYW1wbGl0dWRlO1xufTtcbiAgICAgXG5BRFNSLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIGZvciAoIHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKyApIHtcbiAgICBidWZmZXJbaV0gKj0gdGhpcy52YWx1ZSgpO1xuXG4gICAgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkKys7XG4gIH1cbiBcbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG4gICAgIFxuICAgICBcbkFEU1IucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gIGlmICggdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID4gdGhpcy5yZWxlYXNlIHx8IHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA9PT0gLTEgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5BRFNSLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA9IC0xO1xufTtcbiBcbmZ1bmN0aW9uIElJUkZpbHRlcih0eXBlLCBjdXRvZmYsIHJlc29uYW5jZSwgc2FtcGxlUmF0ZSkge1xuICB0aGlzLnNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xuXG4gIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSBEU1AuTE9XUEFTUzpcbiAgICBjYXNlIERTUC5MUDEyOlxuICAgICAgdGhpcy5mdW5jID0gbmV3IElJUkZpbHRlci5MUDEyKGN1dG9mZiwgcmVzb25hbmNlLCBzYW1wbGVSYXRlKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbklJUkZpbHRlci5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXygnY3V0b2ZmJyxcbiAgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVuYy5jdXRvZmY7XG4gIH1cbik7XG5cbklJUkZpbHRlci5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXygncmVzb25hbmNlJyxcbiAgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZnVuYy5yZXNvbmFuY2U7XG4gIH1cbik7XG5cbklJUkZpbHRlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oY3V0b2ZmLCByZXNvbmFuY2UpIHtcbiAgdGhpcy5mdW5jLmNhbGNDb2VmZihjdXRvZmYsIHJlc29uYW5jZSk7XG59O1xuXG5JSVJGaWx0ZXIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdGhpcy5mdW5jLnByb2Nlc3MoYnVmZmVyKTtcbn07XG5cbi8vIEFkZCBhbiBlbnZlbG9wZSB0byB0aGUgZmlsdGVyXG5JSVJGaWx0ZXIucHJvdG90eXBlLmFkZEVudmVsb3BlID0gZnVuY3Rpb24oZW52ZWxvcGUpIHtcbiAgaWYgKCBlbnZlbG9wZSBpbnN0YW5jZW9mIEFEU1IgKSB7XG4gICAgdGhpcy5mdW5jLmFkZEVudmVsb3BlKGVudmVsb3BlKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBcIk5vdCBhbiBlbnZlbG9wZS5cIjtcbiAgfVxufTtcblxuSUlSRmlsdGVyLkxQMTIgPSBmdW5jdGlvbihjdXRvZmYsIHJlc29uYW5jZSwgc2FtcGxlUmF0ZSkge1xuICB0aGlzLnNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xuICB0aGlzLnZpYnJhUG9zICAgPSAwO1xuICB0aGlzLnZpYnJhU3BlZWQgPSAwO1xuICB0aGlzLmVudmVsb3BlID0gZmFsc2U7XG4gXG4gIHRoaXMuY2FsY0NvZWZmID0gZnVuY3Rpb24oY3V0b2ZmLCByZXNvbmFuY2UpIHtcbiAgICB0aGlzLncgPSAyLjAgKiBNYXRoLlBJICogY3V0b2ZmIC8gdGhpcy5zYW1wbGVSYXRlO1xuICAgIHRoaXMucSA9IDEuMCAtIHRoaXMudyAvICgyLjAgKiAocmVzb25hbmNlICsgMC41IC8gKDEuMCArIHRoaXMudykpICsgdGhpcy53IC0gMi4wKTtcbiAgICB0aGlzLnIgPSB0aGlzLnEgKiB0aGlzLnE7XG4gICAgdGhpcy5jID0gdGhpcy5yICsgMS4wIC0gMi4wICogTWF0aC5jb3ModGhpcy53KSAqIHRoaXMucTtcbiAgIFxuICAgIHRoaXMuY3V0b2ZmID0gY3V0b2ZmO1xuICAgIHRoaXMucmVzb25hbmNlID0gcmVzb25hbmNlO1xuICB9O1xuXG4gIHRoaXMuY2FsY0NvZWZmKGN1dG9mZiwgcmVzb25hbmNlKTtcblxuICB0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKysgKSB7XG4gICAgICB0aGlzLnZpYnJhU3BlZWQgKz0gKGJ1ZmZlcltpXSAtIHRoaXMudmlicmFQb3MpICogdGhpcy5jO1xuICAgICAgdGhpcy52aWJyYVBvcyAgICs9IHRoaXMudmlicmFTcGVlZDtcbiAgICAgIHRoaXMudmlicmFTcGVlZCAqPSB0aGlzLnI7XG4gICBcbiAgICAgIC8qXG4gICAgICB2YXIgdGVtcCA9IHRoaXMudmlicmFQb3M7XG4gICAgIFxuICAgICAgaWYgKCB0ZW1wID4gMS4wICkge1xuICAgICAgICB0ZW1wID0gMS4wO1xuICAgICAgfSBlbHNlIGlmICggdGVtcCA8IC0xLjAgKSB7XG4gICAgICAgIHRlbXAgPSAtMS4wO1xuICAgICAgfSBlbHNlIGlmICggdGVtcCAhPSB0ZW1wICkge1xuICAgICAgICB0ZW1wID0gMTtcbiAgICAgIH1cbiAgICAgXG4gICAgICBidWZmZXJbaV0gPSB0ZW1wO1xuICAgICAgKi9cblxuICAgICAgaWYgKHRoaXMuZW52ZWxvcGUpIHtcbiAgICAgICAgYnVmZmVyW2ldID0gKGJ1ZmZlcltpXSAqICgxIC0gdGhpcy5lbnZlbG9wZS52YWx1ZSgpKSkgKyAodGhpcy52aWJyYVBvcyAqIHRoaXMuZW52ZWxvcGUudmFsdWUoKSk7XG4gICAgICAgIHRoaXMuZW52ZWxvcGUuc2FtcGxlc1Byb2Nlc3NlZCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmZmVyW2ldID0gdGhpcy52aWJyYVBvcztcbiAgICAgIH1cbiAgICB9XG4gIH07XG59OyBcblxuSUlSRmlsdGVyLkxQMTIucHJvdG90eXBlLmFkZEVudmVsb3BlID0gZnVuY3Rpb24oZW52ZWxvcGUpIHtcbiAgdGhpcy5lbnZlbG9wZSA9IGVudmVsb3BlO1xufTtcblxuZnVuY3Rpb24gSUlSRmlsdGVyMih0eXBlLCBjdXRvZmYsIHJlc29uYW5jZSwgc2FtcGxlUmF0ZSkge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLmN1dG9mZiA9IGN1dG9mZjtcbiAgdGhpcy5yZXNvbmFuY2UgPSByZXNvbmFuY2U7XG4gIHRoaXMuc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7XG5cbiAgdGhpcy5mID0gRmxvYXQzMkFycmF5KDQpO1xuICB0aGlzLmZbMF0gPSAwLjA7IC8vIGxwXG4gIHRoaXMuZlsxXSA9IDAuMDsgLy8gaHBcbiAgdGhpcy5mWzJdID0gMC4wOyAvLyBicFxuICB0aGlzLmZbM10gPSAwLjA7IC8vIGJyIFxuIFxuICB0aGlzLmNhbGNDb2VmZiA9IGZ1bmN0aW9uKGN1dG9mZiwgcmVzb25hbmNlKSB7XG4gICAgdGhpcy5mcmVxID0gMiAqIE1hdGguc2luKE1hdGguUEkgKiBNYXRoLm1pbigwLjI1LCBjdXRvZmYvKHRoaXMuc2FtcGxlUmF0ZSoyKSkpOyAgXG4gICAgdGhpcy5kYW1wID0gTWF0aC5taW4oMiAqICgxIC0gTWF0aC5wb3cocmVzb25hbmNlLCAwLjI1KSksIE1hdGgubWluKDIsIDIvdGhpcy5mcmVxIC0gdGhpcy5mcmVxICogMC41KSk7XG4gIH07XG5cbiAgdGhpcy5jYWxjQ29lZmYoY3V0b2ZmLCByZXNvbmFuY2UpO1xufVxuXG5JSVJGaWx0ZXIyLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBpbnB1dCwgb3V0cHV0O1xuICB2YXIgZiA9IHRoaXMuZjtcblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKysgKSB7XG4gICAgaW5wdXQgPSBidWZmZXJbaV07XG5cbiAgICAvLyBmaXJzdCBwYXNzXG4gICAgZlszXSA9IGlucHV0IC0gdGhpcy5kYW1wICogZlsyXTtcbiAgICBmWzBdID0gZlswXSArIHRoaXMuZnJlcSAqIGZbMl07XG4gICAgZlsxXSA9IGZbM10gLSBmWzBdO1xuICAgIGZbMl0gPSB0aGlzLmZyZXEgKiBmWzFdICsgZlsyXTtcbiAgICBvdXRwdXQgPSAwLjUgKiBmW3RoaXMudHlwZV07XG5cbiAgICAvLyBzZWNvbmQgcGFzc1xuICAgIGZbM10gPSBpbnB1dCAtIHRoaXMuZGFtcCAqIGZbMl07XG4gICAgZlswXSA9IGZbMF0gKyB0aGlzLmZyZXEgKiBmWzJdO1xuICAgIGZbMV0gPSBmWzNdIC0gZlswXTtcbiAgICBmWzJdID0gdGhpcy5mcmVxICogZlsxXSArIGZbMl07XG4gICAgb3V0cHV0ICs9IDAuNSAqIGZbdGhpcy50eXBlXTtcblxuICAgIGlmICh0aGlzLmVudmVsb3BlKSB7XG4gICAgICBidWZmZXJbaV0gPSAoYnVmZmVyW2ldICogKDEgLSB0aGlzLmVudmVsb3BlLnZhbHVlKCkpKSArIChvdXRwdXQgKiB0aGlzLmVudmVsb3BlLnZhbHVlKCkpO1xuICAgICAgdGhpcy5lbnZlbG9wZS5zYW1wbGVzUHJvY2Vzc2VkKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlcltpXSA9IG91dHB1dDtcbiAgICB9XG4gIH1cbn07XG5cbklJUkZpbHRlcjIucHJvdG90eXBlLmFkZEVudmVsb3BlID0gZnVuY3Rpb24oZW52ZWxvcGUpIHtcbiAgaWYgKCBlbnZlbG9wZSBpbnN0YW5jZW9mIEFEU1IgKSB7XG4gICAgdGhpcy5lbnZlbG9wZSA9IGVudmVsb3BlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IFwiVGhpcyBpcyBub3QgYW4gZW52ZWxvcGUuXCI7XG4gIH1cbn07XG5cbklJUkZpbHRlcjIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGN1dG9mZiwgcmVzb25hbmNlKSB7XG4gIHRoaXMuY2FsY0NvZWZmKGN1dG9mZiwgcmVzb25hbmNlKTtcbn07XG5cblxuXG5mdW5jdGlvbiBXaW5kb3dGdW5jdGlvbih0eXBlLCBhbHBoYSkge1xuICB0aGlzLmFscGhhID0gYWxwaGE7XG4gXG4gIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSBEU1AuQkFSVExFVFQ6XG4gICAgICB0aGlzLmZ1bmMgPSBXaW5kb3dGdW5jdGlvbi5CYXJ0bGV0dDtcbiAgICAgIGJyZWFrO1xuICAgICBcbiAgICBjYXNlIERTUC5CQVJUTEVUVEhBTk46XG4gICAgICB0aGlzLmZ1bmMgPSBXaW5kb3dGdW5jdGlvbi5CYXJ0bGV0dEhhbm47XG4gICAgICBicmVhaztcbiAgICAgXG4gICAgY2FzZSBEU1AuQkxBQ0tNQU46XG4gICAgICB0aGlzLmZ1bmMgPSBXaW5kb3dGdW5jdGlvbi5CbGFja21hbjtcbiAgICAgIHRoaXMuYWxwaGEgPSB0aGlzLmFscGhhIHx8IDAuMTY7XG4gICAgICBicmVhaztcbiAgIFxuICAgIGNhc2UgRFNQLkNPU0lORTpcbiAgICAgIHRoaXMuZnVuYyA9IFdpbmRvd0Z1bmN0aW9uLkNvc2luZTtcbiAgICAgIGJyZWFrO1xuICAgICBcbiAgICBjYXNlIERTUC5HQVVTUzpcbiAgICAgIHRoaXMuZnVuYyA9IFdpbmRvd0Z1bmN0aW9uLkdhdXNzO1xuICAgICAgdGhpcy5hbHBoYSA9IHRoaXMuYWxwaGEgfHwgMC4yNTtcbiAgICAgIGJyZWFrO1xuICAgICBcbiAgICBjYXNlIERTUC5IQU1NSU5HOlxuICAgICAgdGhpcy5mdW5jID0gV2luZG93RnVuY3Rpb24uSGFtbWluZztcbiAgICAgIGJyZWFrO1xuICAgICBcbiAgICBjYXNlIERTUC5IQU5OOlxuICAgICAgdGhpcy5mdW5jID0gV2luZG93RnVuY3Rpb24uSGFubjtcbiAgICAgIGJyZWFrO1xuICAgXG4gICAgY2FzZSBEU1AuTEFOQ1pPUzpcbiAgICAgIHRoaXMuZnVuYyA9IFdpbmRvd0Z1bmN0aW9uLkxhbmN6b3o7XG4gICAgICBicmVhaztcbiAgICAgXG4gICAgY2FzZSBEU1AuUkVDVEFOR1VMQVI6XG4gICAgICB0aGlzLmZ1bmMgPSBXaW5kb3dGdW5jdGlvbi5SZWN0YW5ndWxhcjtcbiAgICAgIGJyZWFrO1xuICAgICBcbiAgICBjYXNlIERTUC5UUklBTkdVTEFSOlxuICAgICAgdGhpcy5mdW5jID0gV2luZG93RnVuY3Rpb24uVHJpYW5ndWxhcjtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbldpbmRvd0Z1bmN0aW9uLnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyApIHtcbiAgICBidWZmZXJbaV0gKj0gdGhpcy5mdW5jKGxlbmd0aCwgaSwgdGhpcy5hbHBoYSk7XG4gIH1cbiAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbldpbmRvd0Z1bmN0aW9uLkJhcnRsZXR0ID0gZnVuY3Rpb24obGVuZ3RoLCBpbmRleCkge1xuICByZXR1cm4gMiAvIChsZW5ndGggLSAxKSAqICgobGVuZ3RoIC0gMSkgLyAyIC0gTWF0aC5hYnMoaW5kZXggLSAobGVuZ3RoIC0gMSkgLyAyKSk7XG59O1xuXG5XaW5kb3dGdW5jdGlvbi5CYXJ0bGV0dEhhbm4gPSBmdW5jdGlvbihsZW5ndGgsIGluZGV4KSB7XG4gIHJldHVybiAwLjYyIC0gMC40OCAqIE1hdGguYWJzKGluZGV4IC8gKGxlbmd0aCAtIDEpIC0gMC41KSAtIDAuMzggKiBNYXRoLmNvcyhEU1AuVFdPX1BJICogaW5kZXggLyAobGVuZ3RoIC0gMSkpO1xufTtcblxuV2luZG93RnVuY3Rpb24uQmxhY2ttYW4gPSBmdW5jdGlvbihsZW5ndGgsIGluZGV4LCBhbHBoYSkge1xuICB2YXIgYTAgPSAoMSAtIGFscGhhKSAvIDI7XG4gIHZhciBhMSA9IDAuNTtcbiAgdmFyIGEyID0gYWxwaGEgLyAyO1xuXG4gIHJldHVybiBhMCAtIGExICogTWF0aC5jb3MoRFNQLlRXT19QSSAqIGluZGV4IC8gKGxlbmd0aCAtIDEpKSArIGEyICogTWF0aC5jb3MoNCAqIE1hdGguUEkgKiBpbmRleCAvIChsZW5ndGggLSAxKSk7XG59O1xuXG5XaW5kb3dGdW5jdGlvbi5Db3NpbmUgPSBmdW5jdGlvbihsZW5ndGgsIGluZGV4KSB7XG4gIHJldHVybiBNYXRoLmNvcyhNYXRoLlBJICogaW5kZXggLyAobGVuZ3RoIC0gMSkgLSBNYXRoLlBJIC8gMik7XG59O1xuXG5XaW5kb3dGdW5jdGlvbi5HYXVzcyA9IGZ1bmN0aW9uKGxlbmd0aCwgaW5kZXgsIGFscGhhKSB7XG4gIHJldHVybiBNYXRoLnBvdyhNYXRoLkUsIC0wLjUgKiBNYXRoLnBvdygoaW5kZXggLSAobGVuZ3RoIC0gMSkgLyAyKSAvIChhbHBoYSAqIChsZW5ndGggLSAxKSAvIDIpLCAyKSk7XG59O1xuXG5XaW5kb3dGdW5jdGlvbi5IYW1taW5nID0gZnVuY3Rpb24obGVuZ3RoLCBpbmRleCkge1xuICByZXR1cm4gMC41NCAtIDAuNDYgKiBNYXRoLmNvcyhEU1AuVFdPX1BJICogaW5kZXggLyAobGVuZ3RoIC0gMSkpO1xufTtcblxuV2luZG93RnVuY3Rpb24uSGFubiA9IGZ1bmN0aW9uKGxlbmd0aCwgaW5kZXgpIHtcbiAgcmV0dXJuIDAuNSAqICgxIC0gTWF0aC5jb3MoRFNQLlRXT19QSSAqIGluZGV4IC8gKGxlbmd0aCAtIDEpKSk7XG59O1xuXG5XaW5kb3dGdW5jdGlvbi5MYW5jem9zID0gZnVuY3Rpb24obGVuZ3RoLCBpbmRleCkge1xuICB2YXIgeCA9IDIgKiBpbmRleCAvIChsZW5ndGggLSAxKSAtIDE7XG4gIHJldHVybiBNYXRoLnNpbihNYXRoLlBJICogeCkgLyAoTWF0aC5QSSAqIHgpO1xufTtcblxuV2luZG93RnVuY3Rpb24uUmVjdGFuZ3VsYXIgPSBmdW5jdGlvbihsZW5ndGgsIGluZGV4KSB7XG4gIHJldHVybiAxO1xufTtcblxuV2luZG93RnVuY3Rpb24uVHJpYW5ndWxhciA9IGZ1bmN0aW9uKGxlbmd0aCwgaW5kZXgpIHtcbiAgcmV0dXJuIDIgLyBsZW5ndGggKiAobGVuZ3RoIC8gMiAtIE1hdGguYWJzKGluZGV4IC0gKGxlbmd0aCAtIDEpIC8gMikpO1xufTtcblxuZnVuY3Rpb24gc2luaCAoYXJnKSB7XG4gIC8vIFJldHVybnMgdGhlIGh5cGVyYm9saWMgc2luZSBvZiB0aGUgbnVtYmVyLCBkZWZpbmVkIGFzIChleHAobnVtYmVyKSAtIGV4cCgtbnVtYmVyKSkvMiBcbiAgLy9cbiAgLy8gdmVyc2lvbjogMTAwNC4yMzE0XG4gIC8vIGRpc2N1c3MgYXQ6IGh0dHA6Ly9waHBqcy5vcmcvZnVuY3Rpb25zL3NpbmggICAgLy8gKyAgIG9yaWdpbmFsIGJ5OiBPbm5vIE1hcnNtYW5cbiAgLy8gKiAgICAgZXhhbXBsZSAxOiBzaW5oKC0wLjk4MzQzMzAzNDg4MjU5MDkpO1xuICAvLyAqICAgICByZXR1cm5zIDE6IC0xLjE0OTc5NzE0MDI2MzY1MDJcbiAgcmV0dXJuIChNYXRoLmV4cChhcmcpIC0gTWF0aC5leHAoLWFyZykpLzI7XG59XG5cbi8qIFxuICogIEJpcXVhZCBmaWx0ZXJcbiAqIFxuICogIENyZWF0ZWQgYnkgUmljYXJkIE1hcnhlciA8ZW1haWxAcmljYXJkbWFyeGVyLmNvbT4gb24gMjAxMC0wNS0yMy5cbiAqICBDb3B5cmlnaHQgMjAxMCBSaWNhcmQgTWFyeGVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqL1xuLy8gSW1wbGVtZW50YXRpb24gYmFzZWQgb246XG4vLyBodHRwOi8vd3d3Lm11c2ljZHNwLm9yZy9maWxlcy9BdWRpby1FUS1Db29rYm9vay50eHRcbmZ1bmN0aW9uIEJpcXVhZCh0eXBlLCBzYW1wbGVSYXRlKSB7XG4gIHRoaXMuRnMgPSBzYW1wbGVSYXRlO1xuICB0aGlzLnR5cGUgPSB0eXBlOyAgLy8gdHlwZSBvZiB0aGUgZmlsdGVyXG4gIHRoaXMucGFyYW1ldGVyVHlwZSA9IERTUC5ROyAvLyB0eXBlIG9mIHRoZSBwYXJhbWV0ZXJcblxuICB0aGlzLnhfMV9sID0gMDtcbiAgdGhpcy54XzJfbCA9IDA7XG4gIHRoaXMueV8xX2wgPSAwO1xuICB0aGlzLnlfMl9sID0gMDtcblxuICB0aGlzLnhfMV9yID0gMDtcbiAgdGhpcy54XzJfciA9IDA7XG4gIHRoaXMueV8xX3IgPSAwO1xuICB0aGlzLnlfMl9yID0gMDtcblxuICB0aGlzLmIwID0gMTtcbiAgdGhpcy5hMCA9IDE7XG5cbiAgdGhpcy5iMSA9IDA7XG4gIHRoaXMuYTEgPSAwO1xuXG4gIHRoaXMuYjIgPSAwO1xuICB0aGlzLmEyID0gMDtcblxuICB0aGlzLmIwYTAgPSB0aGlzLmIwIC8gdGhpcy5hMDtcbiAgdGhpcy5iMWEwID0gdGhpcy5iMSAvIHRoaXMuYTA7XG4gIHRoaXMuYjJhMCA9IHRoaXMuYjIgLyB0aGlzLmEwO1xuICB0aGlzLmExYTAgPSB0aGlzLmExIC8gdGhpcy5hMDtcbiAgdGhpcy5hMmEwID0gdGhpcy5hMiAvIHRoaXMuYTA7XG5cbiAgdGhpcy5mMCA9IDMwMDA7ICAgLy8gXCJ3aGVyZXZlciBpdCdzIGhhcHBlbmluJywgbWFuLlwiICBDZW50ZXIgRnJlcXVlbmN5IG9yXG4gICAgICAgICAgICAgICAgICAgIC8vIENvcm5lciBGcmVxdWVuY3ksIG9yIHNoZWxmIG1pZHBvaW50IGZyZXF1ZW5jeSwgZGVwZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIHdoaWNoIGZpbHRlciB0eXBlLiAgVGhlIFwic2lnbmlmaWNhbnQgZnJlcXVlbmN5XCIuXG5cbiAgdGhpcy5kQmdhaW4gPSAxMjsgLy8gdXNlZCBvbmx5IGZvciBwZWFraW5nIGFuZCBzaGVsdmluZyBmaWx0ZXJzXG5cbiAgdGhpcy5RID0gMTsgICAgICAgLy8gdGhlIEVFIGtpbmQgb2YgZGVmaW5pdGlvbiwgZXhjZXB0IGZvciBwZWFraW5nRVEgaW4gd2hpY2ggQSpRIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjbGFzc2ljIEVFIFEuICBUaGF0IGFkanVzdG1lbnQgaW4gZGVmaW5pdGlvbiB3YXMgbWFkZSBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGEgYm9vc3Qgb2YgTiBkQiBmb2xsb3dlZCBieSBhIGN1dCBvZiBOIGRCIGZvciBpZGVudGljYWwgUSBhbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gZjAvRnMgcmVzdWx0cyBpbiBhIHByZWNpc2VseSBmbGF0IHVuaXR5IGdhaW4gZmlsdGVyIG9yIFwid2lyZVwiLlxuXG4gIHRoaXMuQlcgPSAtMzsgICAgIC8vIHRoZSBiYW5kd2lkdGggaW4gb2N0YXZlcyAoYmV0d2VlbiAtMyBkQiBmcmVxdWVuY2llcyBmb3IgQlBGXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBub3RjaCBvciBiZXR3ZWVuIG1pZHBvaW50IChkQmdhaW4vMikgZ2FpbiBmcmVxdWVuY2llcyBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVha2luZyBFUVxuXG4gIHRoaXMuUyA9IDE7ICAgICAgIC8vIGEgXCJzaGVsZiBzbG9wZVwiIHBhcmFtZXRlciAoZm9yIHNoZWx2aW5nIEVRIG9ubHkpLiAgV2hlbiBTID0gMSxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNoZWxmIHNsb3BlIGlzIGFzIHN0ZWVwIGFzIGl0IGNhbiBiZSBhbmQgcmVtYWluIG1vbm90b25pY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5jcmVhc2luZyBvciBkZWNyZWFzaW5nIGdhaW4gd2l0aCBmcmVxdWVuY3kuICBUaGUgc2hlbGYgc2xvcGUsIGluXG4gICAgICAgICAgICAgICAgICAgIC8vIGRCL29jdGF2ZSwgcmVtYWlucyBwcm9wb3J0aW9uYWwgdG8gUyBmb3IgYWxsIG90aGVyIHZhbHVlcyBmb3IgYVxuICAgICAgICAgICAgICAgICAgICAvLyBmaXhlZCBmMC9GcyBhbmQgZEJnYWluLlxuXG4gIHRoaXMuY29lZmZpY2llbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGIgPSBbdGhpcy5iMCwgdGhpcy5iMSwgdGhpcy5iMl07XG4gICAgdmFyIGEgPSBbdGhpcy5hMCwgdGhpcy5hMSwgdGhpcy5hMl07XG4gICAgcmV0dXJuIHtiOiBiLCBhOmF9O1xuICB9O1xuXG4gIHRoaXMuc2V0RmlsdGVyVHlwZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMucmVjYWxjdWxhdGVDb2VmZmljaWVudHMoKTtcbiAgfTtcblxuICB0aGlzLnNldFNhbXBsZVJhdGUgPSBmdW5jdGlvbihyYXRlKSB7XG4gICAgdGhpcy5GcyA9IHJhdGU7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUNvZWZmaWNpZW50cygpO1xuICB9O1xuXG4gIHRoaXMuc2V0USA9IGZ1bmN0aW9uKHEpIHtcbiAgICB0aGlzLnBhcmFtZXRlclR5cGUgPSBEU1AuUTtcbiAgICB0aGlzLlEgPSBNYXRoLm1heChNYXRoLm1pbihxLCAxMTUuMCksIDAuMDAxKTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlQ29lZmZpY2llbnRzKCk7XG4gIH07XG5cbiAgdGhpcy5zZXRCVyA9IGZ1bmN0aW9uKGJ3KSB7XG4gICAgdGhpcy5wYXJhbWV0ZXJUeXBlID0gRFNQLkJXO1xuICAgIHRoaXMuQlcgPSBidztcbiAgICB0aGlzLnJlY2FsY3VsYXRlQ29lZmZpY2llbnRzKCk7XG4gIH07XG5cbiAgdGhpcy5zZXRTID0gZnVuY3Rpb24ocykge1xuICAgIHRoaXMucGFyYW1ldGVyVHlwZSA9IERTUC5TO1xuICAgIHRoaXMuUyA9IE1hdGgubWF4KE1hdGgubWluKHMsIDUuMCksIDAuMDAwMSk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUNvZWZmaWNpZW50cygpO1xuICB9O1xuXG4gIHRoaXMuc2V0RjAgPSBmdW5jdGlvbihmcmVxKSB7XG4gICAgdGhpcy5mMCA9IGZyZXE7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUNvZWZmaWNpZW50cygpO1xuICB9OyBcbiBcbiAgdGhpcy5zZXREYkdhaW4gPSBmdW5jdGlvbihnKSB7XG4gICAgdGhpcy5kQmdhaW4gPSBnO1xuICAgIHRoaXMucmVjYWxjdWxhdGVDb2VmZmljaWVudHMoKTtcbiAgfTtcblxuICB0aGlzLnJlY2FsY3VsYXRlQ29lZmZpY2llbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEE7XG4gICAgaWYgKHR5cGUgPT09IERTUC5QRUFLSU5HX0VRIHx8IHR5cGUgPT09IERTUC5MT1dfU0hFTEYgfHwgdHlwZSA9PT0gRFNQLkhJR0hfU0hFTEYgKSB7XG4gICAgICBBID0gTWF0aC5wb3coMTAsICh0aGlzLmRCZ2Fpbi80MCkpOyAgLy8gZm9yIHBlYWtpbmcgYW5kIHNoZWx2aW5nIEVRIGZpbHRlcnMgb25seVxuICAgIH0gZWxzZSB7XG4gICAgICBBICA9IE1hdGguc3FydCggTWF0aC5wb3coMTAsICh0aGlzLmRCZ2Fpbi8yMCkpICk7ICAgXG4gICAgfVxuXG4gICAgdmFyIHcwID0gRFNQLlRXT19QSSAqIHRoaXMuZjAgLyB0aGlzLkZzO1xuXG4gICAgdmFyIGNvc3cwID0gTWF0aC5jb3ModzApO1xuICAgIHZhciBzaW53MCA9IE1hdGguc2luKHcwKTtcblxuICAgIHZhciBhbHBoYSA9IDA7XG4gICBcbiAgICBzd2l0Y2ggKHRoaXMucGFyYW1ldGVyVHlwZSkge1xuICAgICAgY2FzZSBEU1AuUTpcbiAgICAgICAgYWxwaGEgPSBzaW53MC8oMip0aGlzLlEpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgICAgXG4gICAgICBjYXNlIERTUC5CVzpcbiAgICAgICAgYWxwaGEgPSBzaW53MCAqIHNpbmgoIE1hdGguTE4yLzIgKiB0aGlzLkJXICogdzAvc2ludzAgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRFNQLlM6XG4gICAgICAgIGFscGhhID0gc2ludzAvMiAqIE1hdGguc3FydCggKEEgKyAxL0EpKigxL3RoaXMuUyAtIDEpICsgMiApO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAgRllJOiBUaGUgcmVsYXRpb25zaGlwIGJldHdlZW4gYmFuZHdpZHRoIGFuZCBRIGlzXG4gICAgICAgICAgICAgMS9RID0gMipzaW5oKGxuKDIpLzIqQlcqdzAvc2luKHcwKSkgICAgIChkaWdpdGFsIGZpbHRlciB3IEJMVClcbiAgICAgICAgb3IgICAxL1EgPSAyKnNpbmgobG4oMikvMipCVykgICAgICAgICAgICAgKGFuYWxvZyBmaWx0ZXIgcHJvdG90eXBlKVxuXG4gICAgICAgIFRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBzaGVsZiBzbG9wZSBhbmQgUSBpc1xuICAgICAgICAgICAgIDEvUSA9IHNxcnQoKEEgKyAxL0EpKigxL1MgLSAxKSArIDIpXG4gICAgKi9cblxuICAgIHZhciBjb2VmZjtcblxuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlIERTUC5MUEY6ICAgICAgIC8vIEgocykgPSAxIC8gKHNeMiArIHMvUSArIDEpXG4gICAgICAgIHRoaXMuYjAgPSAgKDEgLSBjb3N3MCkvMjtcbiAgICAgICAgdGhpcy5iMSA9ICAgMSAtIGNvc3cwO1xuICAgICAgICB0aGlzLmIyID0gICgxIC0gY29zdzApLzI7XG4gICAgICAgIHRoaXMuYTAgPSAgIDEgKyBhbHBoYTtcbiAgICAgICAgdGhpcy5hMSA9ICAtMiAqIGNvc3cwO1xuICAgICAgICB0aGlzLmEyID0gICAxIC0gYWxwaGE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERTUC5IUEY6ICAgICAgIC8vIEgocykgPSBzXjIgLyAoc14yICsgcy9RICsgMSlcbiAgICAgICAgdGhpcy5iMCA9ICAoMSArIGNvc3cwKS8yO1xuICAgICAgICB0aGlzLmIxID0gLSgxICsgY29zdzApO1xuICAgICAgICB0aGlzLmIyID0gICgxICsgY29zdzApLzI7XG4gICAgICAgIHRoaXMuYTAgPSAgIDEgKyBhbHBoYTtcbiAgICAgICAgdGhpcy5hMSA9ICAtMiAqIGNvc3cwO1xuICAgICAgICB0aGlzLmEyID0gICAxIC0gYWxwaGE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERTUC5CUEZfQ09OU1RBTlRfU0tJUlQ6ICAgICAgIC8vIEgocykgPSBzIC8gKHNeMiArIHMvUSArIDEpICAoY29uc3RhbnQgc2tpcnQgZ2FpbiwgcGVhayBnYWluID0gUSlcbiAgICAgICAgdGhpcy5iMCA9ICAgc2ludzAvMjtcbiAgICAgICAgdGhpcy5iMSA9ICAgMDtcbiAgICAgICAgdGhpcy5iMiA9ICAtc2ludzAvMjtcbiAgICAgICAgdGhpcy5hMCA9ICAgMSArIGFscGhhO1xuICAgICAgICB0aGlzLmExID0gIC0yKmNvc3cwO1xuICAgICAgICB0aGlzLmEyID0gICAxIC0gYWxwaGE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERTUC5CUEZfQ09OU1RBTlRfUEVBSzogICAgICAgLy8gSChzKSA9IChzL1EpIC8gKHNeMiArIHMvUSArIDEpICAgICAgKGNvbnN0YW50IDAgZEIgcGVhayBnYWluKVxuICAgICAgICB0aGlzLmIwID0gICBhbHBoYTtcbiAgICAgICAgdGhpcy5iMSA9ICAgMDtcbiAgICAgICAgdGhpcy5iMiA9ICAtYWxwaGE7XG4gICAgICAgIHRoaXMuYTAgPSAgIDEgKyBhbHBoYTtcbiAgICAgICAgdGhpcy5hMSA9ICAtMipjb3N3MDtcbiAgICAgICAgdGhpcy5hMiA9ICAgMSAtIGFscGhhO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEU1AuTk9UQ0g6ICAgICAvLyBIKHMpID0gKHNeMiArIDEpIC8gKHNeMiArIHMvUSArIDEpXG4gICAgICAgIHRoaXMuYjAgPSAgIDE7XG4gICAgICAgIHRoaXMuYjEgPSAgLTIqY29zdzA7XG4gICAgICAgIHRoaXMuYjIgPSAgIDE7XG4gICAgICAgIHRoaXMuYTAgPSAgIDEgKyBhbHBoYTtcbiAgICAgICAgdGhpcy5hMSA9ICAtMipjb3N3MDtcbiAgICAgICAgdGhpcy5hMiA9ICAgMSAtIGFscGhhO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEU1AuQVBGOiAgICAgICAvLyBIKHMpID0gKHNeMiAtIHMvUSArIDEpIC8gKHNeMiArIHMvUSArIDEpXG4gICAgICAgIHRoaXMuYjAgPSAgIDEgLSBhbHBoYTtcbiAgICAgICAgdGhpcy5iMSA9ICAtMipjb3N3MDtcbiAgICAgICAgdGhpcy5iMiA9ICAgMSArIGFscGhhO1xuICAgICAgICB0aGlzLmEwID0gICAxICsgYWxwaGE7XG4gICAgICAgIHRoaXMuYTEgPSAgLTIqY29zdzA7XG4gICAgICAgIHRoaXMuYTIgPSAgIDEgLSBhbHBoYTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRFNQLlBFQUtJTkdfRVE6ICAvLyBIKHMpID0gKHNeMiArIHMqKEEvUSkgKyAxKSAvIChzXjIgKyBzLyhBKlEpICsgMSlcbiAgICAgICAgdGhpcy5iMCA9ICAgMSArIGFscGhhKkE7XG4gICAgICAgIHRoaXMuYjEgPSAgLTIqY29zdzA7XG4gICAgICAgIHRoaXMuYjIgPSAgIDEgLSBhbHBoYSpBO1xuICAgICAgICB0aGlzLmEwID0gICAxICsgYWxwaGEvQTtcbiAgICAgICAgdGhpcy5hMSA9ICAtMipjb3N3MDtcbiAgICAgICAgdGhpcy5hMiA9ICAgMSAtIGFscGhhL0E7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERTUC5MT1dfU0hFTEY6ICAgLy8gSChzKSA9IEEgKiAoc14yICsgKHNxcnQoQSkvUSkqcyArIEEpLyhBKnNeMiArIChzcXJ0KEEpL1EpKnMgKyAxKVxuICAgICAgICBjb2VmZiA9IHNpbncwICogTWF0aC5zcXJ0KCAoQV4yICsgMSkqKDEvdGhpcy5TIC0gMSkgKyAyKkEgKTtcbiAgICAgICAgdGhpcy5iMCA9ICAgIEEqKChBKzEpIC0gKEEtMSkqY29zdzAgKyBjb2VmZik7XG4gICAgICAgIHRoaXMuYjEgPSAgMipBKigoQS0xKSAtIChBKzEpKmNvc3cwKTtcbiAgICAgICAgdGhpcy5iMiA9ICAgIEEqKChBKzEpIC0gKEEtMSkqY29zdzAgLSBjb2VmZik7XG4gICAgICAgIHRoaXMuYTAgPSAgICAgICAoQSsxKSArIChBLTEpKmNvc3cwICsgY29lZmY7XG4gICAgICAgIHRoaXMuYTEgPSAgIC0yKigoQS0xKSArIChBKzEpKmNvc3cwKTtcbiAgICAgICAgdGhpcy5hMiA9ICAgICAgIChBKzEpICsgKEEtMSkqY29zdzAgLSBjb2VmZjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRFNQLkhJR0hfU0hFTEY6ICAgLy8gSChzKSA9IEEgKiAoQSpzXjIgKyAoc3FydChBKS9RKSpzICsgMSkvKHNeMiArIChzcXJ0KEEpL1EpKnMgKyBBKVxuICAgICAgICBjb2VmZiA9IHNpbncwICogTWF0aC5zcXJ0KCAoQV4yICsgMSkqKDEvdGhpcy5TIC0gMSkgKyAyKkEgKTtcbiAgICAgICAgdGhpcy5iMCA9ICAgIEEqKChBKzEpICsgKEEtMSkqY29zdzAgKyBjb2VmZik7XG4gICAgICAgIHRoaXMuYjEgPSAtMipBKigoQS0xKSArIChBKzEpKmNvc3cwKTtcbiAgICAgICAgdGhpcy5iMiA9ICAgIEEqKChBKzEpICsgKEEtMSkqY29zdzAgLSBjb2VmZik7XG4gICAgICAgIHRoaXMuYTAgPSAgICAgICAoQSsxKSAtIChBLTEpKmNvc3cwICsgY29lZmY7XG4gICAgICAgIHRoaXMuYTEgPSAgICAyKigoQS0xKSAtIChBKzEpKmNvc3cwKTtcbiAgICAgICAgdGhpcy5hMiA9ICAgICAgIChBKzEpIC0gKEEtMSkqY29zdzAgLSBjb2VmZjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgXG4gICAgdGhpcy5iMGEwID0gdGhpcy5iMC90aGlzLmEwO1xuICAgIHRoaXMuYjFhMCA9IHRoaXMuYjEvdGhpcy5hMDtcbiAgICB0aGlzLmIyYTAgPSB0aGlzLmIyL3RoaXMuYTA7XG4gICAgdGhpcy5hMWEwID0gdGhpcy5hMS90aGlzLmEwO1xuICAgIHRoaXMuYTJhMCA9IHRoaXMuYTIvdGhpcy5hMDtcbiAgfTtcblxuICB0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIC8veVtuXSA9IChiMC9hMCkqeFtuXSArIChiMS9hMCkqeFtuLTFdICsgKGIyL2EwKSp4W24tMl1cbiAgICAgIC8vICAgICAgIC0gKGExL2EwKSp5W24tMV0gLSAoYTIvYTApKnlbbi0yXVxuXG4gICAgICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIHZhciBvdXRwdXQgPSBuZXcgRmxvYXQzMkFycmF5KGxlbik7XG5cbiAgICAgIGZvciAoIHZhciBpPTA7IGk8YnVmZmVyLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBvdXRwdXRbaV0gPSB0aGlzLmIwYTAqYnVmZmVyW2ldICsgdGhpcy5iMWEwKnRoaXMueF8xX2wgKyB0aGlzLmIyYTAqdGhpcy54XzJfbCAtIHRoaXMuYTFhMCp0aGlzLnlfMV9sIC0gdGhpcy5hMmEwKnRoaXMueV8yX2w7XG4gICAgICAgIHRoaXMueV8yX2wgPSB0aGlzLnlfMV9sO1xuICAgICAgICB0aGlzLnlfMV9sID0gb3V0cHV0W2ldO1xuICAgICAgICB0aGlzLnhfMl9sID0gdGhpcy54XzFfbDtcbiAgICAgICAgdGhpcy54XzFfbCA9IGJ1ZmZlcltpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICB0aGlzLnByb2Nlc3NTdGVyZW8gPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIC8veVtuXSA9IChiMC9hMCkqeFtuXSArIChiMS9hMCkqeFtuLTFdICsgKGIyL2EwKSp4W24tMl1cbiAgICAgIC8vICAgICAgIC0gKGExL2EwKSp5W24tMV0gLSAoYTIvYTApKnlbbi0yXVxuXG4gICAgICB2YXIgbGVuID0gYnVmZmVyLmxlbmd0aDtcbiAgICAgIHZhciBvdXRwdXQgPSBuZXcgRmxvYXQzMkFycmF5KGxlbik7XG4gICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4vMjsgaSsrKSB7XG4gICAgICAgIG91dHB1dFsyKmldID0gdGhpcy5iMGEwKmJ1ZmZlclsyKmldICsgdGhpcy5iMWEwKnRoaXMueF8xX2wgKyB0aGlzLmIyYTAqdGhpcy54XzJfbCAtIHRoaXMuYTFhMCp0aGlzLnlfMV9sIC0gdGhpcy5hMmEwKnRoaXMueV8yX2w7XG4gICAgICAgIHRoaXMueV8yX2wgPSB0aGlzLnlfMV9sO1xuICAgICAgICB0aGlzLnlfMV9sID0gb3V0cHV0WzIqaV07XG4gICAgICAgIHRoaXMueF8yX2wgPSB0aGlzLnhfMV9sO1xuICAgICAgICB0aGlzLnhfMV9sID0gYnVmZmVyWzIqaV07XG5cbiAgICAgICAgb3V0cHV0WzIqaSsxXSA9IHRoaXMuYjBhMCpidWZmZXJbMippKzFdICsgdGhpcy5iMWEwKnRoaXMueF8xX3IgKyB0aGlzLmIyYTAqdGhpcy54XzJfciAtIHRoaXMuYTFhMCp0aGlzLnlfMV9yIC0gdGhpcy5hMmEwKnRoaXMueV8yX3I7XG4gICAgICAgIHRoaXMueV8yX3IgPSB0aGlzLnlfMV9yO1xuICAgICAgICB0aGlzLnlfMV9yID0gb3V0cHV0WzIqaSsxXTtcbiAgICAgICAgdGhpcy54XzJfciA9IHRoaXMueF8xX3I7XG4gICAgICAgIHRoaXMueF8xX3IgPSBidWZmZXJbMippKzFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufVxuXG4vKiBcbiAqICBNYWduaXR1ZGUgdG8gZGVjaWJlbHNcbiAqIFxuICogIENyZWF0ZWQgYnkgUmljYXJkIE1hcnhlciA8ZW1haWxAcmljYXJkbWFyeGVyLmNvbT4gb24gMjAxMC0wNS0yMy5cbiAqICBDb3B5cmlnaHQgMjAxMCBSaWNhcmQgTWFyeGVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBAYnVmZmVyIGFycmF5IG9mIG1hZ25pdHVkZXMgdG8gY29udmVydCB0byBkZWNpYmVsc1xuICpcbiAqICBAcmV0dXJucyB0aGUgYXJyYXkgaW4gZGVjaWJlbHNcbiAqXG4gKi9cbkRTUC5tYWcyZGIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIG1pbkRiID0gLTEyMDtcbiAgdmFyIG1pbk1hZyA9IE1hdGgucG93KDEwLjAsIG1pbkRiIC8gMjAuMCk7XG5cbiAgdmFyIGxvZyA9IE1hdGgubG9nO1xuICB2YXIgbWF4ID0gTWF0aC5tYXg7XG4gXG4gIHZhciByZXN1bHQgPSBGbG9hdDMyQXJyYXkoYnVmZmVyLmxlbmd0aCk7XG4gIGZvciAodmFyIGk9MDsgaTxidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSAyMC4wKmxvZyhtYXgoYnVmZmVyW2ldLCBtaW5NYWcpKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKiBcbiAqICBGcmVxdWVuY3kgcmVzcG9uc2VcbiAqIFxuICogIENyZWF0ZWQgYnkgUmljYXJkIE1hcnhlciA8ZW1haWxAcmljYXJkbWFyeGVyLmNvbT4gb24gMjAxMC0wNS0yMy5cbiAqICBDb3B5cmlnaHQgMjAxMCBSaWNhcmQgTWFyeGVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBDYWxjdWxhdGVzIHRoZSBmcmVxdWVuY3kgcmVzcG9uc2UgYXQgdGhlIGdpdmVuIHBvaW50cy5cbiAqXG4gKiAgQGIgYiBjb2VmZmljaWVudHMgb2YgdGhlIGZpbHRlclxuICogIEBhIGEgY29lZmZpY2llbnRzIG9mIHRoZSBmaWx0ZXJcbiAqICBAdyB3IHBvaW50cyAobm9ybWFsbHkgYmV0d2VlbiAtUEkgYW5kIFBJKSB3aGVyZSB0byBjYWxjdWxhdGUgdGhlIGZyZXF1ZW5jeSByZXNwb25zZVxuICpcbiAqICBAcmV0dXJucyB0aGUgZnJlcXVlbmN5IHJlc3BvbnNlIGluIG1hZ25pdHVkZVxuICpcbiAqL1xuRFNQLmZyZXF6ID0gZnVuY3Rpb24oYiwgYSwgdykge1xuICB2YXIgaSwgajtcblxuICBpZiAoIXcpIHtcbiAgICB3ID0gRmxvYXQzMkFycmF5KDIwMCk7XG4gICAgZm9yIChpPTA7aTx3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB3W2ldID0gRFNQLlRXT19QSS93Lmxlbmd0aCAqIGkgLSBNYXRoLlBJO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHQgPSBGbG9hdDMyQXJyYXkody5sZW5ndGgpO1xuIFxuICB2YXIgc3FydCA9IE1hdGguc3FydDtcbiAgdmFyIGNvcyA9IE1hdGguY29zO1xuICB2YXIgc2luID0gTWF0aC5zaW47XG4gXG4gIGZvciAoaT0wOyBpPHcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbnVtZXJhdG9yID0ge3JlYWw6MC4wLCBpbWFnOjAuMH07XG4gICAgZm9yIChqPTA7IGo8Yi5sZW5ndGg7IGorKykge1xuICAgICAgbnVtZXJhdG9yLnJlYWwgKz0gYltqXSAqIGNvcygtaip3W2ldKTtcbiAgICAgIG51bWVyYXRvci5pbWFnICs9IGJbal0gKiBzaW4oLWoqd1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIGRlbm9taW5hdG9yID0ge3JlYWw6MC4wLCBpbWFnOjAuMH07XG4gICAgZm9yIChqPTA7IGo8YS5sZW5ndGg7IGorKykge1xuICAgICAgZGVub21pbmF0b3IucmVhbCArPSBhW2pdICogY29zKC1qKndbaV0pO1xuICAgICAgZGVub21pbmF0b3IuaW1hZyArPSBhW2pdICogc2luKC1qKndbaV0pO1xuICAgIH1cbiBcbiAgICByZXN1bHRbaV0gPSAgc3FydChudW1lcmF0b3IucmVhbCpudW1lcmF0b3IucmVhbCArIG51bWVyYXRvci5pbWFnKm51bWVyYXRvci5pbWFnKSAvIHNxcnQoZGVub21pbmF0b3IucmVhbCpkZW5vbWluYXRvci5yZWFsICsgZGVub21pbmF0b3IuaW1hZypkZW5vbWluYXRvci5pbWFnKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKiBcbiAqICBHcmFwaGljYWwgRXF1YWxpemVyXG4gKlxuICogIEltcGxlbWVudGF0aW9uIG9mIGEgZ3JhcGhpYyBlcXVhbGl6ZXIgd2l0aCBhIGNvbmZpZ3VyYWJsZSBiYW5kcy1wZXItb2N0YXZlXG4gKiAgYW5kIG1pbmltdW0gYW5kIG1heGltdW0gZnJlcXVlbmNpZXNcbiAqIFxuICogIENyZWF0ZWQgYnkgUmljYXJkIE1hcnhlciA8ZW1haWxAcmljYXJkbWFyeGVyLmNvbT4gb24gMjAxMC0wNS0yMy5cbiAqICBDb3B5cmlnaHQgMjAxMCBSaWNhcmQgTWFyeGVyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqL1xuZnVuY3Rpb24gR3JhcGhpY2FsRXEoc2FtcGxlUmF0ZSkge1xuICB0aGlzLkZTID0gc2FtcGxlUmF0ZTtcbiAgdGhpcy5taW5GcmVxID0gNDAuMDtcbiAgdGhpcy5tYXhGcmVxID0gMTYwMDAuMDtcblxuICB0aGlzLmJhbmRzUGVyT2N0YXZlID0gMS4wO1xuXG4gIHRoaXMuZmlsdGVycyA9IFtdO1xuICB0aGlzLmZyZXF6cyA9IFtdO1xuXG4gIHRoaXMuY2FsY3VsYXRlRnJlcXpzID0gdHJ1ZTtcblxuICB0aGlzLnJlY2FsY3VsYXRlRmlsdGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiYW5kQ291bnQgPSBNYXRoLnJvdW5kKE1hdGgubG9nKHRoaXMubWF4RnJlcS90aGlzLm1pbkZyZXEpICogdGhpcy5iYW5kc1Blck9jdGF2ZS8gTWF0aC5MTjIpO1xuXG4gICAgdGhpcy5maWx0ZXJzID0gW107XG4gICAgZm9yICh2YXIgaT0wOyBpPGJhbmRDb3VudDsgaSsrKSB7XG4gICAgICB2YXIgZnJlcSA9IHRoaXMubWluRnJlcSooTWF0aC5wb3coMiwgaS90aGlzLmJhbmRzUGVyT2N0YXZlKSk7XG4gICAgICB2YXIgbmV3RmlsdGVyID0gbmV3IEJpcXVhZChEU1AuUEVBS0lOR19FUSwgdGhpcy5GUyk7XG4gICAgICBuZXdGaWx0ZXIuc2V0RGJHYWluKDApO1xuICAgICAgbmV3RmlsdGVyLnNldEJXKDEvdGhpcy5iYW5kc1Blck9jdGF2ZSk7XG4gICAgICBuZXdGaWx0ZXIuc2V0RjAoZnJlcSk7XG4gICAgICB0aGlzLmZpbHRlcnNbaV0gPSBuZXdGaWx0ZXI7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlRnJlcXooaSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuc2V0TWluaW11bUZyZXF1ZW5jeSA9IGZ1bmN0aW9uKGZyZXEpIHtcbiAgICB0aGlzLm1pbkZyZXEgPSBmcmVxO1xuICAgIHRoaXMucmVjYWxjdWxhdGVGaWx0ZXJzKCk7XG4gIH07XG5cbiAgdGhpcy5zZXRNYXhpbXVtRnJlcXVlbmN5ID0gZnVuY3Rpb24oZnJlcSkge1xuICAgIHRoaXMubWF4RnJlcSA9IGZyZXE7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUZpbHRlcnMoKTtcbiAgfTtcblxuICB0aGlzLnNldEJhbmRzUGVyT2N0YXZlID0gZnVuY3Rpb24oYmFuZHMpIHtcbiAgICB0aGlzLmJhbmRzUGVyT2N0YXZlID0gYmFuZHM7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUZpbHRlcnMoKTtcbiAgfTtcblxuICB0aGlzLnNldEJhbmRHYWluID0gZnVuY3Rpb24oYmFuZEluZGV4LCBnYWluKSB7XG4gICAgaWYgKGJhbmRJbmRleCA8IDAgfHwgYmFuZEluZGV4ID4gKHRoaXMuZmlsdGVycy5sZW5ndGgtMSkpIHtcbiAgICAgIHRocm93IFwiVGhlIGJhbmQgaW5kZXggb2YgdGhlIGdyYXBoaWNhbCBlcXVhbGl6ZXIgaXMgb3V0IG9mIGJvdW5kcy5cIjtcbiAgICB9XG5cbiAgICBpZiAoIWdhaW4pIHtcbiAgICAgIHRocm93IFwiQSBnYWluIG11c3QgYmUgcGFzc2VkLlwiO1xuICAgIH1cbiAgIFxuICAgIHRoaXMuZmlsdGVyc1tiYW5kSW5kZXhdLnNldERiR2FpbihnYWluKTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlRnJlcXooYmFuZEluZGV4KTtcbiAgfTtcbiBcbiAgdGhpcy5yZWNhbGN1bGF0ZUZyZXF6ID0gZnVuY3Rpb24oYmFuZEluZGV4KSB7XG4gICAgaWYgKCF0aGlzLmNhbGN1bGF0ZUZyZXF6cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChiYW5kSW5kZXggPCAwIHx8IGJhbmRJbmRleCA+ICh0aGlzLmZpbHRlcnMubGVuZ3RoLTEpKSB7XG4gICAgICB0aHJvdyBcIlRoZSBiYW5kIGluZGV4IG9mIHRoZSBncmFwaGljYWwgZXF1YWxpemVyIGlzIG91dCBvZiBib3VuZHMuIFwiICsgYmFuZEluZGV4ICsgXCIgaXMgb3V0IG9mIFtcIiArIDAgKyBcIiwgXCIgKyB0aGlzLmZpbHRlcnMubGVuZ3RoLTEgKyBcIl1cIjtcbiAgICB9XG4gICAgICAgXG4gICAgaWYgKCF0aGlzLncpIHtcbiAgICAgIHRoaXMudyA9IEZsb2F0MzJBcnJheSg0MDApO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMudy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgdGhpcy53W2ldID0gTWF0aC5QSS90aGlzLncubGVuZ3RoICogaTtcbiAgICAgIH1cbiAgICB9XG4gICBcbiAgICB2YXIgYiA9IFt0aGlzLmZpbHRlcnNbYmFuZEluZGV4XS5iMCwgdGhpcy5maWx0ZXJzW2JhbmRJbmRleF0uYjEsIHRoaXMuZmlsdGVyc1tiYW5kSW5kZXhdLmIyXTtcbiAgICB2YXIgYSA9IFt0aGlzLmZpbHRlcnNbYmFuZEluZGV4XS5hMCwgdGhpcy5maWx0ZXJzW2JhbmRJbmRleF0uYTEsIHRoaXMuZmlsdGVyc1tiYW5kSW5kZXhdLmEyXTtcblxuICAgIHRoaXMuZnJlcXpzW2JhbmRJbmRleF0gPSBEU1AubWFnMmRiKERTUC5mcmVxeihiLCBhLCB0aGlzLncpKTtcbiAgfTtcblxuICB0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICB2YXIgb3V0cHV0ID0gYnVmZmVyO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dHB1dCA9IHRoaXMuZmlsdGVyc1tpXS5wcm9jZXNzKG91dHB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICB0aGlzLnByb2Nlc3NTdGVyZW8gPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICB2YXIgb3V0cHV0ID0gYnVmZmVyO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG91dHB1dCA9IHRoaXMuZmlsdGVyc1tpXS5wcm9jZXNzU3RlcmVvKG91dHB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn1cblxuLyoqXG4gKiBNdWx0aURlbGF5IGVmZmVjdCBieSBBbG1lciBUaGllIChodHRwOi8vY29kZS5hbG1lcm9zLmNvbSkuXG4gKiBDb3B5cmlnaHQgMjAxMCBBbG1lciBUaGllLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogRXhhbXBsZTogaHR0cDovL2NvZGUuYWxtZXJvcy5jb20vY29kZS1leGFtcGxlcy9kZWxheS1maXJlZm94LWF1ZGlvLWFwaS9cbiAqXG4gKiBUaGlzIGlzIGEgZGVsYXkgdGhhdCBmZWVkcyBpdCdzIG93biBkZWxheWVkIHNpZ25hbCBiYWNrIGludG8gaXRzIGNpcmN1bGFyXG4gKiBidWZmZXIuIEFsc28ga25vd24gYXMgYSBDb21iRmlsdGVyLlxuICpcbiAqIENvbXBhdGlibGUgd2l0aCBpbnRlcmxlYXZlZCBzdGVyZW8gKG9yIG1vcmUgY2hhbm5lbCkgYnVmZmVycyBhbmRcbiAqIG5vbi1pbnRlcmxlYXZlZCBtb25vIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heERlbGF5SW5TYW1wbGVzU2l6ZSBNYXhpbXVtIHBvc3NpYmxlIGRlbGF5IGluIHNhbXBsZXMgKHNpemUgb2YgY2lyY3VsYXIgYnVmZmVyKVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5SW5TYW1wbGVzIEluaXRpYWwgZGVsYXkgaW4gc2FtcGxlc1xuICogQHBhcmFtIHtOdW1iZXJ9IG1hc3RlclZvbHVtZSBJbml0aWFsIG1hc3RlciB2b2x1bWUuIEZsb2F0IHZhbHVlOiAwLjAgKHNpbGVuY2UpLCAxLjAgKG5vcm1hbCksID4xLjAgKGFtcGxpZnkpXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlWb2x1bWUgSW5pdGlhbCBmZWVkYmFjayBkZWxheSB2b2x1bWUuIEZsb2F0IHZhbHVlOiAwLjAgKHNpbGVuY2UpLCAxLjAgKG5vcm1hbCksID4xLjAgKGFtcGxpZnkpXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIE11bHRpRGVsYXkobWF4RGVsYXlJblNhbXBsZXNTaXplLCBkZWxheUluU2FtcGxlcywgbWFzdGVyVm9sdW1lLCBkZWxheVZvbHVtZSkge1xuICB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlcyAgID0gbmV3IEZsb2F0MzJBcnJheShtYXhEZWxheUluU2FtcGxlc1NpemUpOyAvLyBUaGUgbWF4aW11bSBzaXplIG9mIGRlbGF5XG4gIHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgICAgID0gZGVsYXlJblNhbXBsZXM7XG4gIHRoaXMuZGVsYXlPdXRwdXRQb2ludGVyICAgPSAwO1xuIFxuICB0aGlzLmRlbGF5SW5TYW1wbGVzICAgPSBkZWxheUluU2FtcGxlcztcbiAgdGhpcy5tYXN0ZXJWb2x1bWUgICAgID0gbWFzdGVyVm9sdW1lO1xuICB0aGlzLmRlbGF5Vm9sdW1lICAgICA9IGRlbGF5Vm9sdW1lO1xufVxuXG4vKipcbiAqIENoYW5nZSB0aGUgZGVsYXkgdGltZSBpbiBzYW1wbGVzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheUluU2FtcGxlcyBEZWxheSBpbiBzYW1wbGVzXG4gKi9cbk11bHRpRGVsYXkucHJvdG90eXBlLnNldERlbGF5SW5TYW1wbGVzID0gZnVuY3Rpb24gKGRlbGF5SW5TYW1wbGVzKSB7XG4gIHRoaXMuZGVsYXlJblNhbXBsZXMgPSBkZWxheUluU2FtcGxlcztcbiBcbiAgdGhpcy5kZWxheUlucHV0UG9pbnRlciA9IHRoaXMuZGVsYXlPdXRwdXRQb2ludGVyICsgZGVsYXlJblNhbXBsZXM7XG5cbiAgaWYgKHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgPj0gdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXMubGVuZ3RoLTEpIHtcbiAgICB0aGlzLmRlbGF5SW5wdXRQb2ludGVyID0gdGhpcy5kZWxheUlucHV0UG9pbnRlciAtIHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzLmxlbmd0aDsgXG4gIH1cbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBtYXN0ZXIgdm9sdW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXN0ZXJWb2x1bWUgRmxvYXQgdmFsdWU6IDAuMCAoc2lsZW5jZSksIDEuMCAobm9ybWFsKSwgPjEuMCAoYW1wbGlmeSlcbiAqL1xuTXVsdGlEZWxheS5wcm90b3R5cGUuc2V0TWFzdGVyVm9sdW1lID0gZnVuY3Rpb24obWFzdGVyVm9sdW1lKSB7XG4gIHRoaXMubWFzdGVyVm9sdW1lID0gbWFzdGVyVm9sdW1lO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGRlbGF5IGZlZWRiYWNrIHZvbHVtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlWb2x1bWUgRmxvYXQgdmFsdWU6IDAuMCAoc2lsZW5jZSksIDEuMCAobm9ybWFsKSwgPjEuMCAoYW1wbGlmeSlcbiAqL1xuTXVsdGlEZWxheS5wcm90b3R5cGUuc2V0RGVsYXlWb2x1bWUgPSBmdW5jdGlvbihkZWxheVZvbHVtZSkge1xuICB0aGlzLmRlbGF5Vm9sdW1lID0gZGVsYXlWb2x1bWU7XG59O1xuXG4vKipcbiAqIFByb2Nlc3MgYSBnaXZlbiBpbnRlcmxlYXZlZCBvciBtb25vIG5vbi1pbnRlcmxlYXZlZCBmbG9hdCB2YWx1ZSBBcnJheSBhbmQgYWRkcyB0aGUgZGVsYXllZCBhdWRpby5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzYW1wbGVzIEFycmF5IGNvbnRhaW5pbmcgRmxvYXQgdmFsdWVzIG9yIGEgRmxvYXQzMkFycmF5XG4gKlxuICogQHJldHVybnMgQSBuZXcgRmxvYXQzMkFycmF5IGludGVybGVhdmVkIG9yIG1vbm8gbm9uLWludGVybGVhdmVkIGFzIHdhcyBmZWQgdG8gdGhpcyBmdW5jdGlvbi5cbiAqL1xuTXVsdGlEZWxheS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKHNhbXBsZXMpIHtcbiAgLy8gTkIuIE1ha2UgYSBjb3B5IHRvIHB1dCBpbiB0aGUgb3V0cHV0IHNhbXBsZXMgdG8gcmV0dXJuLlxuICB2YXIgb3V0cHV0U2FtcGxlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2FtcGxlcy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGk9MDsgaTxzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZGVsYXlCdWZmZXJTYW1wbGVzIGNvdWxkIGNvbnRhaW4gaW5pdGlhbCBOVUxMJ3MsIHJldHVybiBzaWxlbmNlIGluIHRoYXQgY2FzZVxuICAgIHZhciBkZWxheVNhbXBsZSA9ICh0aGlzLmRlbGF5QnVmZmVyU2FtcGxlc1t0aGlzLmRlbGF5T3V0cHV0UG9pbnRlcl0gPT09IG51bGwgPyAwLjAgOiB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlc1t0aGlzLmRlbGF5T3V0cHV0UG9pbnRlcl0pO1xuICAgXG4gICAgLy8gTWl4IG5vcm1hbCBhdWRpbyBkYXRhIHdpdGggZGVsYXllZCBhdWRpb1xuICAgIHZhciBzYW1wbGUgPSAoZGVsYXlTYW1wbGUgKiB0aGlzLmRlbGF5Vm9sdW1lKSArIHNhbXBsZXNbaV07XG4gICBcbiAgICAvLyBBZGQgYXVkaW8gZGF0YSB3aXRoIHRoZSBkZWxheSBpbiB0aGUgZGVsYXkgYnVmZmVyXG4gICAgdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXNbdGhpcy5kZWxheUlucHV0UG9pbnRlcl0gPSBzYW1wbGU7XG4gICBcbiAgICAvLyBSZXR1cm4gdGhlIGF1ZGlvIHdpdGggZGVsYXkgbWl4XG4gICAgb3V0cHV0U2FtcGxlc1tpXSA9IHNhbXBsZSAqIHRoaXMubWFzdGVyVm9sdW1lO1xuICAgXG4gICAgLy8gTWFuYWdlIGNpcmN1bGFpciBkZWxheSBidWZmZXIgcG9pbnRlcnNcbiAgICB0aGlzLmRlbGF5SW5wdXRQb2ludGVyKys7XG4gICAgaWYgKHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgPj0gdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXMubGVuZ3RoLTEpIHtcbiAgICAgIHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgPSAwO1xuICAgIH1cbiAgICAgXG4gICAgdGhpcy5kZWxheU91dHB1dFBvaW50ZXIrKztcbiAgICBpZiAodGhpcy5kZWxheU91dHB1dFBvaW50ZXIgPj0gdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXMubGVuZ3RoLTEpIHtcbiAgICAgIHRoaXMuZGVsYXlPdXRwdXRQb2ludGVyID0gMDsgXG4gICAgfSBcbiAgfVxuIFxuICByZXR1cm4gb3V0cHV0U2FtcGxlcztcbn07XG5cbi8qKlxuICogU2luZ2xlRGVsYXkgZWZmZWN0IGJ5IEFsbWVyIFRoaWUgKGh0dHA6Ly9jb2RlLmFsbWVyb3MuY29tKS5cbiAqIENvcHlyaWdodCAyMDEwIEFsbWVyIFRoaWUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBFeGFtcGxlOiBTZWUgdXNhZ2UgaW4gUmV2ZXJiIGNsYXNzXG4gKlxuICogVGhpcyBpcyBhIGRlbGF5IHRoYXQgZG9lcyBOT1QgZmVlZHMgaXQncyBvd24gZGVsYXllZCBzaWduYWwgYmFjayBpbnRvIGl0cyBcbiAqIGNpcmN1bGFyIGJ1ZmZlciwgbmVpdGhlciBkb2VzIGl0IHJldHVybiB0aGUgb3JpZ2luYWwgc2lnbmFsLiBBbHNvIGtub3duIGFzXG4gKiBhbiBBbGxQYXNzRmlsdGVyKD8pLlxuICpcbiAqIENvbXBhdGlibGUgd2l0aCBpbnRlcmxlYXZlZCBzdGVyZW8gKG9yIG1vcmUgY2hhbm5lbCkgYnVmZmVycyBhbmRcbiAqIG5vbi1pbnRlcmxlYXZlZCBtb25vIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heERlbGF5SW5TYW1wbGVzU2l6ZSBNYXhpbXVtIHBvc3NpYmxlIGRlbGF5IGluIHNhbXBsZXMgKHNpemUgb2YgY2lyY3VsYXIgYnVmZmVyKVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5SW5TYW1wbGVzIEluaXRpYWwgZGVsYXkgaW4gc2FtcGxlc1xuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5Vm9sdW1lIEluaXRpYWwgZmVlZGJhY2sgZGVsYXkgdm9sdW1lLiBGbG9hdCB2YWx1ZTogMC4wIChzaWxlbmNlKSwgMS4wIChub3JtYWwpLCA+MS4wIChhbXBsaWZ5KVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbmZ1bmN0aW9uIFNpbmdsZURlbGF5KG1heERlbGF5SW5TYW1wbGVzU2l6ZSwgZGVsYXlJblNhbXBsZXMsIGRlbGF5Vm9sdW1lKSB7XG4gIHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzID0gbmV3IEZsb2F0MzJBcnJheShtYXhEZWxheUluU2FtcGxlc1NpemUpOyAvLyBUaGUgbWF4aW11bSBzaXplIG9mIGRlbGF5XG4gIHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgID0gZGVsYXlJblNhbXBsZXM7XG4gIHRoaXMuZGVsYXlPdXRwdXRQb2ludGVyID0gMDtcbiBcbiAgdGhpcy5kZWxheUluU2FtcGxlcyAgICAgPSBkZWxheUluU2FtcGxlcztcbiAgdGhpcy5kZWxheVZvbHVtZSAgICAgICAgPSBkZWxheVZvbHVtZTtcbn1cblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGRlbGF5IHRpbWUgaW4gc2FtcGxlcy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlJblNhbXBsZXMgRGVsYXkgaW4gc2FtcGxlc1xuICovXG5TaW5nbGVEZWxheS5wcm90b3R5cGUuc2V0RGVsYXlJblNhbXBsZXMgPSBmdW5jdGlvbihkZWxheUluU2FtcGxlcykge1xuICB0aGlzLmRlbGF5SW5TYW1wbGVzID0gZGVsYXlJblNhbXBsZXM7XG4gIHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgPSB0aGlzLmRlbGF5T3V0cHV0UG9pbnRlciArIGRlbGF5SW5TYW1wbGVzO1xuXG4gIGlmICh0aGlzLmRlbGF5SW5wdXRQb2ludGVyID49IHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzLmxlbmd0aC0xKSB7XG4gICAgdGhpcy5kZWxheUlucHV0UG9pbnRlciA9IHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgLSB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlcy5sZW5ndGg7IFxuICB9XG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgcmV0dXJuIHNpZ25hbCB2b2x1bWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5Vm9sdW1lIEZsb2F0IHZhbHVlOiAwLjAgKHNpbGVuY2UpLCAxLjAgKG5vcm1hbCksID4xLjAgKGFtcGxpZnkpXG4gKi9cblNpbmdsZURlbGF5LnByb3RvdHlwZS5zZXREZWxheVZvbHVtZSA9IGZ1bmN0aW9uKGRlbGF5Vm9sdW1lKSB7XG4gIHRoaXMuZGVsYXlWb2x1bWUgPSBkZWxheVZvbHVtZTtcbn07XG5cbi8qKlxuICogUHJvY2VzcyBhIGdpdmVuIGludGVybGVhdmVkIG9yIG1vbm8gbm9uLWludGVybGVhdmVkIGZsb2F0IHZhbHVlIEFycmF5IGFuZFxuICogcmV0dXJucyB0aGUgZGVsYXllZCBhdWRpby5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzYW1wbGVzIEFycmF5IGNvbnRhaW5pbmcgRmxvYXQgdmFsdWVzIG9yIGEgRmxvYXQzMkFycmF5XG4gKlxuICogQHJldHVybnMgQSBuZXcgRmxvYXQzMkFycmF5IGludGVybGVhdmVkIG9yIG1vbm8gbm9uLWludGVybGVhdmVkIGFzIHdhcyBmZWQgdG8gdGhpcyBmdW5jdGlvbi5cbiAqL1xuU2luZ2xlRGVsYXkucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbihzYW1wbGVzKSB7XG4gIC8vIE5CLiBNYWtlIGEgY29weSB0byBwdXQgaW4gdGhlIG91dHB1dCBzYW1wbGVzIHRvIHJldHVybi5cbiAgdmFyIG91dHB1dFNhbXBsZXMgPSBuZXcgRmxvYXQzMkFycmF5KHNhbXBsZXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpPTA7IGk8c2FtcGxlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgLy8gQWRkIGF1ZGlvIGRhdGEgd2l0aCB0aGUgZGVsYXkgaW4gdGhlIGRlbGF5IGJ1ZmZlclxuICAgIHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzW3RoaXMuZGVsYXlJbnB1dFBvaW50ZXJdID0gc2FtcGxlc1tpXTtcbiAgIFxuICAgIC8vIGRlbGF5QnVmZmVyU2FtcGxlcyBjb3VsZCBjb250YWluIGluaXRpYWwgTlVMTCdzLCByZXR1cm4gc2lsZW5jZSBpbiB0aGF0IGNhc2VcbiAgICB2YXIgZGVsYXlTYW1wbGUgPSB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlc1t0aGlzLmRlbGF5T3V0cHV0UG9pbnRlcl07XG5cbiAgICAvLyBSZXR1cm4gdGhlIGF1ZGlvIHdpdGggZGVsYXkgbWl4XG4gICAgb3V0cHV0U2FtcGxlc1tpXSA9IGRlbGF5U2FtcGxlICogdGhpcy5kZWxheVZvbHVtZTtcblxuICAgIC8vIE1hbmFnZSBjaXJjdWxhaXIgZGVsYXkgYnVmZmVyIHBvaW50ZXJzXG4gICAgdGhpcy5kZWxheUlucHV0UG9pbnRlcisrO1xuXG4gICAgaWYgKHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgPj0gdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXMubGVuZ3RoLTEpIHtcbiAgICAgIHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgPSAwO1xuICAgIH1cbiAgICAgXG4gICAgdGhpcy5kZWxheU91dHB1dFBvaW50ZXIrKztcblxuICAgIGlmICh0aGlzLmRlbGF5T3V0cHV0UG9pbnRlciA+PSB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlcy5sZW5ndGgtMSkge1xuICAgICAgdGhpcy5kZWxheU91dHB1dFBvaW50ZXIgPSAwOyBcbiAgICB9IFxuICB9XG4gXG4gIHJldHVybiBvdXRwdXRTYW1wbGVzO1xufTtcblxuLyoqXG4gKiBSZXZlcmIgZWZmZWN0IGJ5IEFsbWVyIFRoaWUgKGh0dHA6Ly9jb2RlLmFsbWVyb3MuY29tKS5cbiAqIENvcHlyaWdodCAyMDEwIEFsbWVyIFRoaWUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBFeGFtcGxlOiBodHRwOi8vY29kZS5hbG1lcm9zLmNvbS9jb2RlLWV4YW1wbGVzL3JldmVyYi1maXJlZm94LWF1ZGlvLWFwaS9cbiAqXG4gKiBUaGlzIHJldmVyYiBjb25zaXN0cyBvZiA2IFNpbmdsZURlbGF5cywgNiBNdWx0aURlbGF5cyBhbmQgYW4gSUlSRmlsdGVyMlxuICogZm9yIGVhY2ggb2YgdGhlIHR3byBzdGVyZW8gY2hhbm5lbHMuXG4gKlxuICogQ29tcGF0aWJsZSB3aXRoIGludGVybGVhdmVkIHN0ZXJlbyBidWZmZXJzIG9ubHkhXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heERlbGF5SW5TYW1wbGVzU2l6ZSBNYXhpbXVtIHBvc3NpYmxlIGRlbGF5IGluIHNhbXBsZXMgKHNpemUgb2YgY2lyY3VsYXIgYnVmZmVycylcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheUluU2FtcGxlcyBJbml0aWFsIGRlbGF5IGluIHNhbXBsZXMgZm9yIGludGVybmFsIChTaW5nbGUvTXVsdGkpZGVsYXlzXG4gKiBAcGFyYW0ge051bWJlcn0gbWFzdGVyVm9sdW1lIEluaXRpYWwgbWFzdGVyIHZvbHVtZS4gRmxvYXQgdmFsdWU6IDAuMCAoc2lsZW5jZSksIDEuMCAobm9ybWFsKSwgPjEuMCAoYW1wbGlmeSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaXhWb2x1bWUgSW5pdGlhbCByZXZlcmIgc2lnbmFsIG1peCB2b2x1bWUuIEZsb2F0IHZhbHVlOiAwLjAgKHNpbGVuY2UpLCAxLjAgKG5vcm1hbCksID4xLjAgKGFtcGxpZnkpXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlWb2x1bWUgSW5pdGlhbCBmZWVkYmFjayBkZWxheSB2b2x1bWUgZm9yIGludGVybmFsIChTaW5nbGUvTXVsdGkpZGVsYXlzLiBGbG9hdCB2YWx1ZTogMC4wIChzaWxlbmNlKSwgMS4wIChub3JtYWwpLCA+MS4wIChhbXBsaWZ5KVxuICogQHBhcmFtIHtOdW1iZXJ9IGRhbXBGcmVxdWVuY3kgSW5pdGlhbCBsb3cgcGFzcyBmaWx0ZXIgZnJlcXVlbmN5LiAwIHRvIDQ0MTAwIChkZXBlbmRpbmcgb24geW91ciBtYXhpbXVtIHNhbXBsaW5nIGZyZXF1ZW5jeSlcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmV2ZXJiKG1heERlbGF5SW5TYW1wbGVzU2l6ZSwgZGVsYXlJblNhbXBsZXMsIG1hc3RlclZvbHVtZSwgbWl4Vm9sdW1lLCBkZWxheVZvbHVtZSwgZGFtcEZyZXF1ZW5jeSkge1xuICB0aGlzLmRlbGF5SW5TYW1wbGVzICAgPSBkZWxheUluU2FtcGxlcztcbiAgdGhpcy5tYXN0ZXJWb2x1bWUgICAgID0gbWFzdGVyVm9sdW1lO1xuICB0aGlzLm1peFZvbHVtZSAgICAgICA9IG1peFZvbHVtZTtcbiAgdGhpcy5kZWxheVZvbHVtZSAgICAgPSBkZWxheVZvbHVtZTtcbiAgdGhpcy5kYW1wRnJlcXVlbmN5ICAgICA9IGRhbXBGcmVxdWVuY3k7XG4gXG4gIHRoaXMuTlJfT0ZfTVVMVElERUxBWVMgPSA2O1xuICB0aGlzLk5SX09GX1NJTkdMRURFTEFZUyA9IDY7XG4gXG4gIHRoaXMuTE9XUEFTU0wgPSBuZXcgSUlSRmlsdGVyMihEU1AuTE9XUEFTUywgZGFtcEZyZXF1ZW5jeSwgMCwgNDQxMDApO1xuICB0aGlzLkxPV1BBU1NSID0gbmV3IElJUkZpbHRlcjIoRFNQLkxPV1BBU1MsIGRhbXBGcmVxdWVuY3ksIDAsIDQ0MTAwKTtcbiBcbiAgdGhpcy5zaW5nbGVEZWxheXMgPSBbXTtcbiAgXG4gIHZhciBpLCBkZWxheU11bHRpcGx5O1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLk5SX09GX1NJTkdMRURFTEFZUzsgaSsrKSB7XG4gICAgZGVsYXlNdWx0aXBseSA9IDEuMCArIChpLzcuMCk7IC8vIDEuMCwgMS4xLCAxLjIuLi5cbiAgICB0aGlzLnNpbmdsZURlbGF5c1tpXSA9IG5ldyBTaW5nbGVEZWxheShtYXhEZWxheUluU2FtcGxlc1NpemUsIE1hdGgucm91bmQodGhpcy5kZWxheUluU2FtcGxlcyAqIGRlbGF5TXVsdGlwbHkpLCB0aGlzLmRlbGF5Vm9sdW1lKTtcbiAgfVxuIFxuICB0aGlzLm11bHRpRGVsYXlzID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuTlJfT0ZfTVVMVElERUxBWVM7IGkrKykge1xuICAgIGRlbGF5TXVsdGlwbHkgPSAxLjAgKyAoaS8xMC4wKTsgLy8gMS4wLCAxLjEsIDEuMi4uLiBcbiAgICB0aGlzLm11bHRpRGVsYXlzW2ldID0gbmV3IE11bHRpRGVsYXkobWF4RGVsYXlJblNhbXBsZXNTaXplLCBNYXRoLnJvdW5kKHRoaXMuZGVsYXlJblNhbXBsZXMgKiBkZWxheU11bHRpcGx5KSwgdGhpcy5tYXN0ZXJWb2x1bWUsIHRoaXMuZGVsYXlWb2x1bWUpO1xuICB9XG59XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBkZWxheSB0aW1lIGluIHNhbXBsZXMgYXMgYSBiYXNlIGZvciBhbGwgZGVsYXlzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheUluU2FtcGxlcyBEZWxheSBpbiBzYW1wbGVzXG4gKi9cblJldmVyYi5wcm90b3R5cGUuc2V0RGVsYXlJblNhbXBsZXMgPSBmdW5jdGlvbiAoZGVsYXlJblNhbXBsZXMpe1xuICB0aGlzLmRlbGF5SW5TYW1wbGVzID0gZGVsYXlJblNhbXBsZXM7XG5cbiAgdmFyIGksIGRlbGF5TXVsdGlwbHk7XG4gXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLk5SX09GX1NJTkdMRURFTEFZUzsgaSsrKSB7XG4gICAgZGVsYXlNdWx0aXBseSA9IDEuMCArIChpLzcuMCk7IC8vIDEuMCwgMS4xLCAxLjIuLi5cbiAgICB0aGlzLnNpbmdsZURlbGF5c1tpXS5zZXREZWxheUluU2FtcGxlcyggTWF0aC5yb3VuZCh0aGlzLmRlbGF5SW5TYW1wbGVzICogZGVsYXlNdWx0aXBseSkgKTtcbiAgfVxuICAgXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLk5SX09GX01VTFRJREVMQVlTOyBpKyspIHtcbiAgICBkZWxheU11bHRpcGx5ID0gMS4wICsgKGkvMTAuMCk7IC8vIDEuMCwgMS4xLCAxLjIuLi5cbiAgICB0aGlzLm11bHRpRGVsYXlzW2ldLnNldERlbGF5SW5TYW1wbGVzKCBNYXRoLnJvdW5kKHRoaXMuZGVsYXlJblNhbXBsZXMgKiBkZWxheU11bHRpcGx5KSApO1xuICB9XG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgbWFzdGVyIHZvbHVtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWFzdGVyVm9sdW1lIEZsb2F0IHZhbHVlOiAwLjAgKHNpbGVuY2UpLCAxLjAgKG5vcm1hbCksID4xLjAgKGFtcGxpZnkpXG4gKi9cblJldmVyYi5wcm90b3R5cGUuc2V0TWFzdGVyVm9sdW1lID0gZnVuY3Rpb24gKG1hc3RlclZvbHVtZSl7XG4gIHRoaXMubWFzdGVyVm9sdW1lID0gbWFzdGVyVm9sdW1lO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHJldmVyYiBzaWduYWwgbWl4IGxldmVsLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaXhWb2x1bWUgRmxvYXQgdmFsdWU6IDAuMCAoc2lsZW5jZSksIDEuMCAobm9ybWFsKSwgPjEuMCAoYW1wbGlmeSlcbiAqL1xuUmV2ZXJiLnByb3RvdHlwZS5zZXRNaXhWb2x1bWUgPSBmdW5jdGlvbiAobWl4Vm9sdW1lKXtcbiAgdGhpcy5taXhWb2x1bWUgPSBtaXhWb2x1bWU7XG59O1xuXG4vKipcbiAqIENoYW5nZSBhbGwgZGVsYXlzIGZlZWRiYWNrIHZvbHVtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlWb2x1bWUgRmxvYXQgdmFsdWU6IDAuMCAoc2lsZW5jZSksIDEuMCAobm9ybWFsKSwgPjEuMCAoYW1wbGlmeSlcbiAqL1xuUmV2ZXJiLnByb3RvdHlwZS5zZXREZWxheVZvbHVtZSA9IGZ1bmN0aW9uIChkZWxheVZvbHVtZSl7XG4gIHRoaXMuZGVsYXlWb2x1bWUgPSBkZWxheVZvbHVtZTtcbiBcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMDsgaTx0aGlzLk5SX09GX1NJTkdMRURFTEFZUzsgaSsrKSB7XG4gICAgdGhpcy5zaW5nbGVEZWxheXNbaV0uc2V0RGVsYXlWb2x1bWUodGhpcy5kZWxheVZvbHVtZSk7XG4gIH0gXG4gXG4gIGZvciAoaSA9IDA7IGk8dGhpcy5OUl9PRl9NVUxUSURFTEFZUzsgaSsrKSB7XG4gICAgdGhpcy5tdWx0aURlbGF5c1tpXS5zZXREZWxheVZvbHVtZSh0aGlzLmRlbGF5Vm9sdW1lKTtcbiAgfSBcbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBMb3cgUGFzcyBmaWx0ZXIgZnJlcXVlbmN5LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkYW1wRnJlcXVlbmN5IGxvdyBwYXNzIGZpbHRlciBmcmVxdWVuY3kuIDAgdG8gNDQxMDAgKGRlcGVuZGluZyBvbiB5b3VyIG1heGltdW0gc2FtcGxpbmcgZnJlcXVlbmN5KVxuICovXG5SZXZlcmIucHJvdG90eXBlLnNldERhbXBGcmVxdWVuY3kgPSBmdW5jdGlvbiAoZGFtcEZyZXF1ZW5jeSl7XG4gIHRoaXMuZGFtcEZyZXF1ZW5jeSA9IGRhbXBGcmVxdWVuY3k7XG4gXG4gIHRoaXMuTE9XUEFTU0wuc2V0KGRhbXBGcmVxdWVuY3ksIDApO1xuICB0aGlzLkxPV1BBU1NSLnNldChkYW1wRnJlcXVlbmN5LCAwKTsgXG59O1xuXG4vKipcbiAqIFByb2Nlc3MgYSBnaXZlbiBpbnRlcmxlYXZlZCBmbG9hdCB2YWx1ZSBBcnJheSBhbmQgY29waWVzIGFuZCBhZGRzIHRoZSByZXZlcmIgc2lnbmFsLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNhbXBsZXMgQXJyYXkgY29udGFpbmluZyBGbG9hdCB2YWx1ZXMgb3IgYSBGbG9hdDMyQXJyYXlcbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBGbG9hdDMyQXJyYXkgaW50ZXJsZWF2ZWQgYnVmZmVyLlxuICovXG5SZXZlcmIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoaW50ZXJsZWF2ZWRTYW1wbGVzKXsgXG4gIC8vIE5CLiBNYWtlIGEgY29weSB0byBwdXQgaW4gdGhlIG91dHB1dCBzYW1wbGVzIHRvIHJldHVybi5cbiAgdmFyIG91dHB1dFNhbXBsZXMgPSBuZXcgRmxvYXQzMkFycmF5KGludGVybGVhdmVkU2FtcGxlcy5sZW5ndGgpO1xuIFxuICAvLyBQZXJmb3JtIGxvdyBwYXNzIG9uIHRoZSBpbnB1dCBzYW1wbGVzIHRvIG1pbWljayBkYW1wXG4gIHZhciBsZWZ0UmlnaHRNaXggPSBEU1AuZGVpbnRlcmxlYXZlKGludGVybGVhdmVkU2FtcGxlcyk7XG4gIHRoaXMuTE9XUEFTU0wucHJvY2VzcyggbGVmdFJpZ2h0TWl4W0RTUC5MRUZUXSApO1xuICB0aGlzLkxPV1BBU1NSLnByb2Nlc3MoIGxlZnRSaWdodE1peFtEU1AuUklHSFRdICk7IFxuICB2YXIgZmlsdGVyZWRTYW1wbGVzID0gRFNQLmludGVybGVhdmUobGVmdFJpZ2h0TWl4W0RTUC5MRUZUXSwgbGVmdFJpZ2h0TWl4W0RTUC5SSUdIVF0pO1xuXG4gIHZhciBpO1xuXG4gIC8vIFByb2Nlc3MgTXVsdGlEZWxheXMgaW4gcGFyYWxsZWxcbiAgZm9yIChpID0gMDsgaTx0aGlzLk5SX09GX01VTFRJREVMQVlTOyBpKyspIHtcbiAgICAvLyBJbnZlcnQgdGhlIHNpZ25hbCBvZiBldmVyeSBldmVuIG11bHRpRGVsYXlcbiAgICBvdXRwdXRTYW1wbGVzID0gRFNQLm1peFNhbXBsZUJ1ZmZlcnMob3V0cHV0U2FtcGxlcywgdGhpcy5tdWx0aURlbGF5c1tpXS5wcm9jZXNzKGZpbHRlcmVkU2FtcGxlcyksIDIlaSA9PT0gMCwgdGhpcy5OUl9PRl9NVUxUSURFTEFZUyk7XG4gIH1cbiBcbiAgLy8gUHJvY2VzcyBTaW5nbGVEZWxheXMgaW4gc2VyaWVzXG4gIHZhciBzaW5nbGVEZWxheVNhbXBsZXMgPSBuZXcgRmxvYXQzMkFycmF5KG91dHB1dFNhbXBsZXMubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaTx0aGlzLk5SX09GX1NJTkdMRURFTEFZUzsgaSsrKSB7XG4gICAgLy8gSW52ZXJ0IHRoZSBzaWduYWwgb2YgZXZlcnkgZXZlbiBzaW5nbGVEZWxheVxuICAgIHNpbmdsZURlbGF5U2FtcGxlcyA9IERTUC5taXhTYW1wbGVCdWZmZXJzKHNpbmdsZURlbGF5U2FtcGxlcywgdGhpcy5zaW5nbGVEZWxheXNbaV0ucHJvY2VzcyhvdXRwdXRTYW1wbGVzKSwgMiVpID09PSAwLCAxKTtcbiAgfVxuXG4gIC8vIEFwcGx5IHRoZSB2b2x1bWUgb2YgdGhlIHJldmVyYiBzaWduYWxcbiAgZm9yIChpID0gMDsgaTxzaW5nbGVEZWxheVNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzaW5nbGVEZWxheVNhbXBsZXNbaV0gKj0gdGhpcy5taXhWb2x1bWU7XG4gIH1cbiBcbiAgLy8gTWl4IHRoZSBvcmlnaW5hbCBzaWduYWwgd2l0aCB0aGUgcmV2ZXJiIHNpZ25hbFxuICBvdXRwdXRTYW1wbGVzID0gRFNQLm1peFNhbXBsZUJ1ZmZlcnMoc2luZ2xlRGVsYXlTYW1wbGVzLCBpbnRlcmxlYXZlZFNhbXBsZXMsIDAsIDEpO1xuXG4gIC8vIEFwcGx5IHRoZSBtYXN0ZXIgdm9sdW1lIHRvIHRoZSBjb21wbGV0ZSBzaWduYWxcbiAgZm9yIChpID0gMDsgaTxvdXRwdXRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgb3V0cHV0U2FtcGxlc1tpXSAqPSB0aGlzLm1hc3RlclZvbHVtZTtcbiAgfVxuICAgXG4gIHJldHVybiBvdXRwdXRTYW1wbGVzO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRFNQO1xuZXhwb3J0IHsgRkZUIGFzIEZGVCB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3NldFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2xcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3dlYWstbWFwXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2RlZmluZVByb3BlcnR5ID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZWZpbmVQcm9wZXJ0eSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAoMCwgX2RlZmluZVByb3BlcnR5Mi5kZWZhdWx0KSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIik7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2dldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIik7XG5cbnZhciBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldE93blByb3BlcnR5RGVzY3JpcHRvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciBkZXNjID0gKDAsIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IyLmRlZmF1bHQpKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcGFyZW50ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3NldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2ZcIik7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9jcmVhdGVcIik7XG5cbnZhciBfY3JlYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZSk7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKHN1cGVyQ2xhc3MpKSk7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSAoMCwgX2NyZWF0ZTIuZGVmYXVsdCkoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCA/ICgwLCBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZjIgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkge1xuICBpZiAoIXNlbGYpIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gY2FsbCAmJiAoKHR5cGVvZiBjYWxsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6ICgwLCBfdHlwZW9mMy5kZWZhdWx0KShjYWxsKSkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfaXRlcmF0b3IgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9zeW1ib2wvaXRlcmF0b3JcIik7XG5cbnZhciBfaXRlcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXRlcmF0b3IpO1xuXG52YXIgX3N5bWJvbCA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbFwiKTtcblxudmFyIF9zeW1ib2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc3ltYm9sKTtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBfaXRlcmF0b3IyLmRlZmF1bHQgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBfdHlwZW9mKF9pdGVyYXRvcjIuZGVmYXVsdCkgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yob2JqKTtcbn07IiwicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkge1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoVCwgRCkge1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFQsIEQpO1xufTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYykge1xuICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIHJldHVybiAkT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5zZXRQcm90b3R5cGVPZjtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC50by1qc29uJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnNldC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5TZXQ7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi53ZWFrLW1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcud2Vhay1tYXAub2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLldlYWtNYXA7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBDb25zdHJ1Y3RvciwgbmFtZSwgZm9yYmlkZGVuRmllbGQpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikgfHwgKGZvcmJpZGRlbkZpZWxkICE9PSB1bmRlZmluZWQgJiYgZm9yYmlkZGVuRmllbGQgaW4gaXQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKG5hbWUgKyAnOiBpbmNvcnJlY3QgaW52b2NhdGlvbiEnKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXIsIElURVJBVE9SKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yT2YoaXRlciwgZmFsc2UsIHJlc3VsdC5wdXNoLCByZXN1bHQsIElURVJBVE9SKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4vX3RvLWFic29sdXRlLWluZGV4Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0lPYmplY3QoJHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gQXJyYXkjaW5jbHVkZXMgdXNlcyBTYW1lVmFsdWVaZXJvIGVxdWFsaXR5IGFsZ29yaXRobVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykge1xuICAgICAgaWYgKE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcbiIsIi8vIDAgLT4gQXJyYXkjZm9yRWFjaFxuLy8gMSAtPiBBcnJheSNtYXBcbi8vIDIgLT4gQXJyYXkjZmlsdGVyXG4vLyAzIC0+IEFycmF5I3NvbWVcbi8vIDQgLT4gQXJyYXkjZXZlcnlcbi8vIDUgLT4gQXJyYXkjZmluZFxuLy8gNiAtPiBBcnJheSNmaW5kSW5kZXhcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciBhc2MgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVFlQRSwgJGNyZWF0ZSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuICB2YXIgSVNfRklMVEVSID0gVFlQRSA9PSAyO1xuICB2YXIgSVNfU09NRSA9IFRZUEUgPT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuICB2YXIgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNjtcbiAgdmFyIE5PX0hPTEVTID0gVFlQRSA9PSA1IHx8IElTX0ZJTkRfSU5ERVg7XG4gIHZhciBjcmVhdGUgPSAkY3JlYXRlIHx8IGFzYztcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSU9iamVjdChPKTtcbiAgICB2YXIgZiA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbCwgcmVzO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgcmVzdWx0W2luZGV4XSA9IHJlczsgICAvLyBtYXBcbiAgICAgICAgZWxzZSBpZiAocmVzKSBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAvLyBzb21lXG4gICAgICAgICAgY2FzZSA1OiByZXR1cm4gdmFsOyAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgIC8vIGZpbHRlclxuICAgICAgICB9IGVsc2UgaWYgKElTX0VWRVJZKSByZXR1cm4gZmFsc2U7IC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9yaWdpbmFsKSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbCkpIHtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZiAodHlwZW9mIEMgPT0gJ2Z1bmN0aW9uJyAmJiAoQyA9PT0gQXJyYXkgfHwgaXNBcnJheShDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07XG4iLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCwgbGVuZ3RoKSB7XG4gIHJldHVybiBuZXcgKHNwZWNpZXNDb25zdHJ1Y3RvcihvcmlnaW5hbCkpKGxlbmd0aCk7XG59O1xuIiwiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xudmFyICRpdGVyRGVmaW5lID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKTtcbnZhciBzdGVwID0gcmVxdWlyZSgnLi9faXRlci1zdGVwJyk7XG52YXIgc2V0U3BlY2llcyA9IHJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIGZhc3RLZXkgPSByZXF1aXJlKCcuL19tZXRhJykuZmFzdEtleTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTSVpFID0gREVTQ1JJUFRPUlMgPyAnX3MnIDogJ3NpemUnO1xuXG52YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gIC8vIGZhc3QgY2FzZVxuICB2YXIgaW5kZXggPSBmYXN0S2V5KGtleSk7XG4gIHZhciBlbnRyeTtcbiAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiB0aGF0Ll9pW2luZGV4XTtcbiAgLy8gZnJvemVuIG9iamVjdCBjYXNlXG4gIGZvciAoZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgaWYgKGVudHJ5LmsgPT0ga2V5KSByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gY3JlYXRlKG51bGwpOyAvLyBpbmRleFxuICAgICAgdGhhdC5fZiA9IHVuZGVmaW5lZDsgICAgLy8gZmlyc3QgZW50cnlcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7ICAgIC8vIGxhc3QgZW50cnlcbiAgICAgIHRoYXRbU0laRV0gPSAwOyAgICAgICAgIC8vIHNpemVcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRoYXRbQURERVJdLCB0aGF0KTtcbiAgICB9KTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgZm9yICh2YXIgdGhhdCA9IHZhbGlkYXRlKHRoaXMsIE5BTUUpLCBkYXRhID0gdGhhdC5faSwgZW50cnkgPSB0aGF0Ll9mOyBlbnRyeTsgZW50cnkgPSBlbnRyeS5uKSB7XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnApIGVudHJ5LnAgPSBlbnRyeS5wLm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5fZiA9IHRoYXQuX2wgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoYXRbU0laRV0gPSAwO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjEuMy4zIE1hcC5wcm90b3R5cGUuZGVsZXRlKGtleSlcbiAgICAgIC8vIDIzLjIuMy40IFNldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uO1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucDtcbiAgICAgICAgICBkZWxldGUgdGhhdC5faVtlbnRyeS5pXTtcbiAgICAgICAgICBlbnRyeS5yID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wID0gcHJldjtcbiAgICAgICAgICBpZiAodGhhdC5fZiA9PSBlbnRyeSkgdGhhdC5fZiA9IG5leHQ7XG4gICAgICAgICAgaWYgKHRoYXQuX2wgPT0gZW50cnkpIHRoYXQuX2wgPSBwcmV2O1xuICAgICAgICAgIHRoYXRbU0laRV0tLTtcbiAgICAgICAgfSByZXR1cm4gISFlbnRyeTtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4yLjMuNiBTZXQucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIC8vIDIzLjEuMy41IE1hcC5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxuICAgICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhhdCA9IHVuZGVmaW5lZCAqLykge1xuICAgICAgICB2YWxpZGF0ZSh0aGlzLCBOQU1FKTtcbiAgICAgICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDMpO1xuICAgICAgICB2YXIgZW50cnk7XG4gICAgICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoaXMuX2YpIHtcbiAgICAgICAgICBmKGVudHJ5LnYsIGVudHJ5LmssIHRoaXMpO1xuICAgICAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yKSBlbnRyeSA9IGVudHJ5LnA7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSwga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpIGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUodGhpcywgTkFNRSlbU0laRV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgIHZhciBwcmV2LCBpbmRleDtcbiAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGVudHJ5LnYgPSB2YWx1ZTtcbiAgICAvLyBjcmVhdGUgbmV3IGVudHJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoYXQuX2wgPSBlbnRyeSA9IHtcbiAgICAgICAgaTogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksIC8vIDwtIGluZGV4XG4gICAgICAgIGs6IGtleSwgICAgICAgICAgICAgICAgICAgICAgICAvLyA8LSBrZXlcbiAgICAgICAgdjogdmFsdWUsICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHZhbHVlXG4gICAgICAgIHA6IHByZXYgPSB0aGF0Ll9sLCAgICAgICAgICAgICAvLyA8LSBwcmV2aW91cyBlbnRyeVxuICAgICAgICBuOiB1bmRlZmluZWQsICAgICAgICAgICAgICAgICAgLy8gPC0gbmV4dCBlbnRyeVxuICAgICAgICByOiBmYWxzZSAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0gcmVtb3ZlZFxuICAgICAgfTtcbiAgICAgIGlmICghdGhhdC5fZikgdGhhdC5fZiA9IGVudHJ5O1xuICAgICAgaWYgKHByZXYpIHByZXYubiA9IGVudHJ5O1xuICAgICAgdGhhdFtTSVpFXSsrO1xuICAgICAgLy8gYWRkIHRvIGluZGV4XG4gICAgICBpZiAoaW5kZXggIT09ICdGJykgdGhhdC5faVtpbmRleF0gPSBlbnRyeTtcbiAgICB9IHJldHVybiB0aGF0O1xuICB9LFxuICBnZXRFbnRyeTogZ2V0RW50cnksXG4gIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIE5BTUUsIElTX01BUCkge1xuICAgIC8vIGFkZCAua2V5cywgLnZhbHVlcywgLmVudHJpZXMsIFtAQGl0ZXJhdG9yXVxuICAgIC8vIDIzLjEuMy40LCAyMy4xLjMuOCwgMjMuMS4zLjExLCAyMy4xLjMuMTIsIDIzLjIuMy41LCAyMy4yLjMuOCwgMjMuMi4zLjEwLCAyMy4yLjMuMTFcbiAgICAkaXRlckRlZmluZShDLCBOQU1FLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgICAgIHRoaXMuX3QgPSB2YWxpZGF0ZShpdGVyYXRlZCwgTkFNRSk7IC8vIHRhcmdldFxuICAgICAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgICAgICAgLy8ga2luZFxuICAgICAgdGhpcy5fbCA9IHVuZGVmaW5lZDsgICAgICAgICAgICAgICAgLy8gcHJldmlvdXNcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB2YXIga2luZCA9IHRoYXQuX2s7XG4gICAgICB2YXIgZW50cnkgPSB0aGF0Ll9sO1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgLy8gZ2V0IG5leHQgZW50cnlcbiAgICAgIGlmICghdGhhdC5fdCB8fCAhKHRoYXQuX2wgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubiA6IHRoYXQuX3QuX2YpKSB7XG4gICAgICAgIC8vIG9yIGZpbmlzaCB0aGUgaXRlcmF0aW9uXG4gICAgICAgIHRoYXQuX3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBzdGVwKDEpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHN0ZXAgYnkga2luZFxuICAgICAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS5rKTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBlbnRyeS52KTtcbiAgICAgIHJldHVybiBzdGVwKDAsIFtlbnRyeS5rLCBlbnRyeS52XSk7XG4gICAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuXG4gICAgLy8gYWRkIFtAQHNwZWNpZXNdLCAyMy4xLjIuMiwgMjMuMi4yLjJcbiAgICBzZXRTcGVjaWVzKE5BTUUpO1xuICB9XG59O1xuIiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL0RhdmlkQnJ1YW50L01hcC1TZXQucHJvdG90eXBlLnRvSlNPTlxudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgZnJvbSA9IHJlcXVpcmUoJy4vX2FycmF5LWZyb20taXRlcmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICBpZiAoY2xhc3NvZih0aGlzKSAhPSBOQU1FKSB0aHJvdyBUeXBlRXJyb3IoTkFNRSArIFwiI3RvSlNPTiBpc24ndCBnZW5lcmljXCIpO1xuICAgIHJldHVybiBmcm9tKHRoaXMpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGdldFdlYWsgPSByZXF1aXJlKCcuL19tZXRhJykuZ2V0V2VhaztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBjcmVhdGVBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKTtcbnZhciAkaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgYXJyYXlGaW5kID0gY3JlYXRlQXJyYXlNZXRob2QoNSk7XG52YXIgYXJyYXlGaW5kSW5kZXggPSBjcmVhdGVBcnJheU1ldGhvZCg2KTtcbnZhciBpZCA9IDA7XG5cbi8vIGZhbGxiYWNrIGZvciB1bmNhdWdodCBmcm96ZW4ga2V5c1xudmFyIHVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAodGhhdCkge1xuICByZXR1cm4gdGhhdC5fbCB8fCAodGhhdC5fbCA9IG5ldyBVbmNhdWdodEZyb3plblN0b3JlKCkpO1xufTtcbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmEgPSBbXTtcbn07XG52YXIgZmluZFVuY2F1Z2h0RnJvemVuID0gZnVuY3Rpb24gKHN0b3JlLCBrZXkpIHtcbiAgcmV0dXJuIGFycmF5RmluZChzdG9yZS5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuVW5jYXVnaHRGcm96ZW5TdG9yZS5wcm90b3R5cGUgPSB7XG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgcmV0dXJuIGVudHJ5WzFdO1xuICB9LFxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gISFmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBlbnRyeSA9IGZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICAgIGlmIChlbnRyeSkgZW50cnlbMV0gPSB2YWx1ZTtcbiAgICBlbHNlIHRoaXMuYS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0sXG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGluZGV4ID0gYXJyYXlGaW5kSW5kZXgodGhpcy5hLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHRoaXMuYS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgTkFNRSwgJ19pJyk7XG4gICAgICB0aGF0Ll90ID0gTkFNRTsgICAgICAvLyBjb2xsZWN0aW9uIHR5cGVcbiAgICAgIHRoYXQuX2kgPSBpZCsrOyAgICAgIC8vIGNvbGxlY3Rpb24gaWRcbiAgICAgIHRoYXQuX2wgPSB1bmRlZmluZWQ7IC8vIGxlYWsgc3RvcmUgZm9yIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RzXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSkgJiYgZGVsZXRlIGRhdGFbdGhpcy5faV07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrKGtleSk7XG4gICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBOQU1FKSkuaGFzKGtleSk7XG4gICAgICAgIHJldHVybiBkYXRhICYmICRoYXMoZGF0YSwgdGhpcy5faSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIEM7XG4gIH0sXG4gIGRlZjogZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWsoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgaWYgKGRhdGEgPT09IHRydWUpIHVuY2F1Z2h0RnJvemVuU3RvcmUodGhhdCkuc2V0KGtleSwgdmFsdWUpO1xuICAgIGVsc2UgZGF0YVt0aGF0Ll9pXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGF0O1xuICB9LFxuICB1ZnN0b3JlOiB1bmNhdWdodEZyb3plblN0b3JlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnLi9fbWV0YScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi9fYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgZWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUsIHdyYXBwZXIsIG1ldGhvZHMsIGNvbW1vbiwgSVNfTUFQLCBJU19XRUFLKSB7XG4gIHZhciBCYXNlID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgQyA9IEJhc2U7XG4gIHZhciBBRERFUiA9IElTX01BUCA/ICdzZXQnIDogJ2FkZCc7XG4gIHZhciBwcm90byA9IEMgJiYgQy5wcm90b3R5cGU7XG4gIHZhciBPID0ge307XG4gIGlmICghREVTQ1JJUFRPUlMgfHwgdHlwZW9mIEMgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgcHJvdG8uZm9yRWFjaCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBDKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSB7XG4gICAgLy8gY3JlYXRlIGNvbGxlY3Rpb24gY29uc3RydWN0b3JcbiAgICBDID0gY29tbW9uLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICBtZXRhLk5FRUQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0YXJnZXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRhcmdldCwgQywgTkFNRSwgJ19jJyk7XG4gICAgICB0YXJnZXQuX2MgPSBuZXcgQmFzZSgpO1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGFyZ2V0W0FEREVSXSwgdGFyZ2V0KTtcbiAgICB9KTtcbiAgICBlYWNoKCdhZGQsY2xlYXIsZGVsZXRlLGZvckVhY2gsZ2V0LGhhcyxzZXQsa2V5cyx2YWx1ZXMsZW50cmllcyx0b0pTT04nLnNwbGl0KCcsJyksIGZ1bmN0aW9uIChLRVkpIHtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PSAnYWRkJyB8fCBLRVkgPT0gJ3NldCc7XG4gICAgICBpZiAoS0VZIGluIHByb3RvICYmICEoSVNfV0VBSyAmJiBLRVkgPT0gJ2NsZWFyJykpIGhpZGUoQy5wcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgYW5JbnN0YW5jZSh0aGlzLCBDLCBLRVkpO1xuICAgICAgICBpZiAoIUlTX0FEREVSICYmIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpKSByZXR1cm4gS0VZID09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9jW0tFWV0oYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIElTX0FEREVSID8gdGhpcyA6IHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIElTX1dFQUsgfHwgZFAoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jLnNpemU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZXRUb1N0cmluZ1RhZyhDLCBOQU1FKTtcblxuICBPW05BTUVdID0gQztcbiAgJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYsIE8pO1xuXG4gIGlmICghSVNfV0VBSykgY29tbW9uLnNldFN0cm9uZyhDLCBOQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDO1xufTtcbiIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuNCcgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYik7XG4gICAgfTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07XG4iLCIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcbiIsIi8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gKFxuICAnY29uc3RydWN0b3IsaGFzT3duUHJvcGVydHksaXNQcm90b3R5cGVPZixwcm9wZXJ0eUlzRW51bWVyYWJsZSx0b0xvY2FsZVN0cmluZyx0b1N0cmluZyx2YWx1ZU9mJ1xuKS5zcGxpdCgnLCcpO1xuIiwiLy8gYWxsIGVudW1lcmFibGUgb2JqZWN0IGtleXMsIGluY2x1ZGVzIHN5bWJvbHNcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICBpZiAoZ2V0U3ltYm9scykge1xuICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7XG4gICAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChzeW1ib2xzLmxlbmd0aCA+IGkpIGlmIChpc0VudW0uY2FsbChpdCwga2V5ID0gc3ltYm9sc1tpKytdKSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBoYXMoZXhwb3J0cywga2V5KSkgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwidmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGNhbGwgPSByZXF1aXJlKCcuL19pdGVyLWNhbGwnKTtcbnZhciBpc0FycmF5SXRlciA9IHJlcXVpcmUoJy4vX2lzLWFycmF5LWl0ZXInKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgZ2V0SXRlckZuID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBCUkVBSyA9IHt9O1xudmFyIFJFVFVSTiA9IHt9O1xudmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZW50cmllcywgZm4sIHRoYXQsIElURVJBVE9SKSB7XG4gIHZhciBpdGVyRm4gPSBJVEVSQVRPUiA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXJhYmxlOyB9IDogZ2V0SXRlckZuKGl0ZXJhYmxlKTtcbiAgdmFyIGYgPSBjdHgoZm4sIHRoYXQsIGVudHJpZXMgPyAyIDogMSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGgsIHN0ZXAsIGl0ZXJhdG9yLCByZXN1bHQ7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdGVyYWJsZSArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICAvLyBmYXN0IGNhc2UgZm9yIGFycmF5cyB3aXRoIGRlZmF1bHQgaXRlcmF0b3JcbiAgaWYgKGlzQXJyYXlJdGVyKGl0ZXJGbikpIGZvciAobGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBlbnRyaWVzID8gZihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBmKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSBmb3IgKGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpOyAhKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7KSB7XG4gICAgcmVzdWx0ID0gY2FsbChpdGVyYXRvciwgZiwgc3RlcC52YWx1ZSwgZW50cmllcyk7XG4gICAgaWYgKHJlc3VsdCA9PT0gQlJFQUsgfHwgcmVzdWx0ID09PSBSRVRVUk4pIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5leHBvcnRzLkJSRUFLID0gQlJFQUs7XG5leHBvcnRzLlJFVFVSTiA9IFJFVFVSTjtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG52YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGhcbiAgPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGZcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmICh0eXBlb2YgX19nID09ICdudW1iZXInKSBfX2cgPSBnbG9iYWw7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iLCJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIiwibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iLCIvLyBjaGVjayBvbiBkZWZhdWx0IEFycmF5IGl0ZXJhdG9yXG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG4iLCIvLyBjYWxsIHNvbWV0aGluZyBvbiBpdGVyYXRvciBzdGVwIHdpdGggc2FmZSBjbG9zaW5nIG9uIGVycm9yXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIGVudHJpZXMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZW50cmllcyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuICAvLyA3LjQuNiBJdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCBjb21wbGV0aW9uKVxuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIHJldCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyICRpdGVyQ3JlYXRlID0gcmVxdWlyZSgnLi9faXRlci1jcmVhdGUnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19vYmplY3QtZ3BvJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxudmFyIEZGX0lURVJBVE9SID0gJ0BAaXRlcmF0b3InO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQmFzZSwgTkFNRSwgQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gICRpdGVyQ3JlYXRlKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcbiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgaWYgKCFCVUdHWSAmJiBraW5kIGluIHByb3RvKSByZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gZW50cmllcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgfTtcbiAgdmFyIFRBRyA9IE5BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIERFRl9WQUxVRVMgPSBERUZBVUxUID09IFZBTFVFUztcbiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTtcbiAgdmFyIHByb3RvID0gQmFzZS5wcm90b3R5cGU7XG4gIHZhciAkbmF0aXZlID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdO1xuICB2YXIgJGRlZmF1bHQgPSAkbmF0aXZlIHx8IGdldE1ldGhvZChERUZBVUxUKTtcbiAgdmFyICRlbnRyaWVzID0gREVGQVVMVCA/ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKSA6IHVuZGVmaW5lZDtcbiAgdmFyICRhbnlOYXRpdmUgPSBOQU1FID09ICdBcnJheScgPyBwcm90by5lbnRyaWVzIHx8ICRuYXRpdmUgOiAkbmF0aXZlO1xuICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZiAoJGFueU5hdGl2ZSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTtcbiAgICBpZiAoSXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgSXRlcmF0b3JQcm90b3R5cGUubmV4dCkge1xuICAgICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7XG4gICAgICAvLyBmaXggZm9yIHNvbWUgb2xkIGVuZ2luZXNcbiAgICAgIGlmICghTElCUkFSWSAmJiB0eXBlb2YgSXRlcmF0b3JQcm90b3R5cGVbSVRFUkFUT1JdICE9ICdmdW5jdGlvbicpIGhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gIH1cbiAgLy8gZml4IEFycmF5I3t2YWx1ZXMsIEBAaXRlcmF0b3J9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7XG4gICAgVkFMVUVTX0JVRyA9IHRydWU7XG4gICAgJGRlZmF1bHQgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gIH1cbiAgLy8gRGVmaW5lIGl0ZXJhdG9yXG4gIGlmICgoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSkge1xuICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7XG4gIH1cbiAgLy8gUGx1ZyBmb3IgbGlicmFyeVxuICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDtcbiAgSXRlcmF0b3JzW1RBR10gPSByZXR1cm5UaGlzO1xuICBpZiAoREVGQVVMVCkge1xuICAgIG1ldGhvZHMgPSB7XG4gICAgICB2YWx1ZXM6IERFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogSVNfU0VUID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoS0VZUyksXG4gICAgICBlbnRyaWVzOiAkZW50cmllc1xuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChrZXkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7fTtcbiIsIm1vZHVsZS5leHBvcnRzID0gdHJ1ZTtcbiIsInZhciBNRVRBID0gcmVxdWlyZSgnLi9fdWlkJykoJ21ldGEnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHNldERlc2MgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIEZSRUVaRSA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xudmFyIHNldE1ldGEgPSBmdW5jdGlvbiAoaXQpIHtcbiAgc2V0RGVzYyhpdCwgTUVUQSwgeyB2YWx1ZToge1xuICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRFxuICAgIHc6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xudmFyIGZhc3RLZXkgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuICAvLyByZXR1cm4gcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0O1xuICBpZiAoIWhhcyhpdCwgTUVUQSkpIHtcbiAgICAvLyBjYW4ndCBzZXQgbWV0YWRhdGEgdG8gdW5jYXVnaHQgZnJvemVuIG9iamVjdFxuICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJztcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gJ0UnO1xuICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhXG4gICAgc2V0TWV0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQV0uaTtcbn07XG52YXIgZ2V0V2VhayA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIGhhc2ggd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQV0udztcbn07XG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIEtFWTogTUVUQSxcbiAgTkVFRDogZmFsc2UsXG4gIGZhc3RLZXk6IGZhc3RLZXksXG4gIGdldFdlYWs6IGdldFdlYWssXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BTID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKTtcbnZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHZhciBBID0ge307XG4gIHZhciBCID0ge307XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgUyA9IFN5bWJvbCgpO1xuICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IEJba10gPSBrOyB9KTtcbiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7XG59KSA/IGZ1bmN0aW9uIGFzc2lnbih0YXJnZXQsIHNvdXJjZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUID0gdG9PYmplY3QodGFyZ2V0KTtcbiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAxO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgdmFyIGlzRW51bSA9IHBJRS5mO1xuICB3aGlsZSAoYUxlbiA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikgaWYgKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpIFRba2V5XSA9IFNba2V5XTtcbiAgfSByZXR1cm4gVDtcbn0gOiAkYXNzaWduO1xuIiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBkUHMgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKTtcbiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gIHZhciBsdCA9ICc8JztcbiAgdmFyIGd0ID0gJz4nO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUgKGktLSkgZGVsZXRlIGNyZWF0ZURpY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tpXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5cyA9IGdldEtleXMoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgUDtcbiAgd2hpbGUgKGxlbmd0aCA+IGkpIGRQLmYoTywgUCA9IGtleXNbaSsrXSwgUHJvcGVydGllc1tQXSk7XG4gIHJldHVybiBPO1xufTtcbiIsInZhciBwSUUgPSByZXF1aXJlKCcuL19vYmplY3QtcGllJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBnT1BEIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGdPUEQoTywgUCk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuIiwiLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvd1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBnT1BOID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZ09QTihpdCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIHRvU3RyaW5nLmNhbGwoaXQpID09ICdbb2JqZWN0IFdpbmRvd10nID8gZ2V0V2luZG93TmFtZXMoaXQpIDogZ09QTih0b0lPYmplY3QoaXQpKTtcbn07XG4iLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsIi8vIDE5LjEuMi45IC8gMTUuMi4zLjIgT2JqZWN0LmdldFByb3RvdHlwZU9mKE8pXG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIChPKSB7XG4gIE8gPSB0b09iamVjdChPKTtcbiAgaWYgKGhhcyhPLCBJRV9QUk9UTykpIHJldHVybiBPW0lFX1BST1RPXTtcbiAgaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gIH0gcmV0dXJuIE8gaW5zdGFuY2VvZiBPYmplY3QgPyBPYmplY3RQcm90byA6IG51bGw7XG59O1xuIiwidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4iLCIvLyBtb3N0IE9iamVjdCBtZXRob2RzIGJ5IEVTNiBzaG91bGQgYWNjZXB0IHByaW1pdGl2ZXNcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHtcbiAgdmFyIGZuID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldO1xuICB2YXIgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24gKCkgeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iLCJ2YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc3JjLCBzYWZlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAoc2FmZSAmJiB0YXJnZXRba2V5XSkgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTtcbiAgICBlbHNlIGhpZGUodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfSByZXR1cm4gdGFyZ2V0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBmcm9tOiBmdW5jdGlvbiBmcm9tKHNvdXJjZSAvKiAsIG1hcEZuLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIG1hcEZuID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwaW5nLCBBLCBuLCBjYjtcbiAgICBhRnVuY3Rpb24odGhpcyk7XG4gICAgbWFwcGluZyA9IG1hcEZuICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG1hcHBpbmcpIGFGdW5jdGlvbihtYXBGbik7XG4gICAgaWYgKHNvdXJjZSA9PSB1bmRlZmluZWQpIHJldHVybiBuZXcgdGhpcygpO1xuICAgIEEgPSBbXTtcbiAgICBpZiAobWFwcGluZykge1xuICAgICAgbiA9IDA7XG4gICAgICBjYiA9IGN0eChtYXBGbiwgYXJndW1lbnRzWzJdLCAyKTtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIGZ1bmN0aW9uIChuZXh0SXRlbSkge1xuICAgICAgICBBLnB1c2goY2IobmV4dEl0ZW0sIG4rKykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvck9mKHNvdXJjZSwgZmFsc2UsIEEucHVzaCwgQSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT0xMRUNUSU9OKSB7XG4gICRleHBvcnQoJGV4cG9ydC5TLCBDT0xMRUNUSU9OLCB7IG9mOiBmdW5jdGlvbiBvZigpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgQSA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIHdoaWxlIChsZW5ndGgtLSkgQVtsZW5ndGhdID0gYXJndW1lbnRzW2xlbmd0aF07XG4gICAgcmV0dXJuIG5ldyB0aGlzKEEpO1xuICB9IH0pO1xufTtcbiIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGlmICghaXNPYmplY3QocHJvdG8pICYmIHByb3RvICE9PSBudWxsKSB0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbiAodGVzdCwgYnVnZ3ksIHNldCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0ID0gcmVxdWlyZSgnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpO1xuICAgICAgICBzZXQodGVzdCwgW10pO1xuICAgICAgICBidWdneSA9ICEodGVzdCBpbnN0YW5jZW9mIEFycmF5KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgICAgICAgY2hlY2soTywgcHJvdG8pO1xuICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgdmFyIEMgPSB0eXBlb2YgY29yZVtLRVldID09ICdmdW5jdGlvbicgPyBjb3JlW0tFWV0gOiBnbG9iYWxbS0VZXTtcbiAgaWYgKERFU0NSSVBUT1JTICYmIEMgJiYgIUNbU1BFQ0lFU10pIGRQLmYoQywgU1BFQ0lFUywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgfSk7XG59O1xuIiwidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG4iLCJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcbiIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07XG4iLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIiwidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBUWVBFKSB7XG4gIGlmICghaXNPYmplY3QoaXQpIHx8IGl0Ll90ICE9PSBUWVBFKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgTElCUkFSWSA9IHJlcXVpcmUoJy4vX2xpYnJhcnknKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICB2YXIgJFN5bWJvbCA9IGNvcmUuU3ltYm9sIHx8IChjb3JlLlN5bWJvbCA9IExJQlJBUlkgPyB7fSA6IGdsb2JhbC5TeW1ib2wgfHwge30pO1xuICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7XG59O1xuIiwiZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fd2tzJyk7XG4iLCJ2YXIgc3RvcmUgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sO1xudmFyIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBJVEVSQVRPUiA9IHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3JNZXRob2QgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ICE9IHVuZGVmaW5lZCkgcmV0dXJuIGl0W0lURVJBVE9SXVxuICAgIHx8IGl0WydAQGl0ZXJhdG9yJ11cbiAgICB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGdldCA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXRlckZuID0gZ2V0KGl0KTtcbiAgaWYgKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgaXRlcmFibGUhJyk7XG4gIHJldHVybiBhbk9iamVjdChpdGVyRm4uY2FsbChpdCkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgY3JlYXRlOiByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykgfSk7XG4iLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjMgLyAxNS4yLjMuNyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydGllczogcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcbiIsIi8vIDE5LjEuMi42IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUClcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZjtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3InLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSU9iamVjdChpdCksIGtleSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcbiIsIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG4iLCIiLCIndXNlIHN0cmljdCc7XG52YXIgc3Ryb25nID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbi1zdHJvbmcnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBTRVQgPSAnU2V0JztcblxuLy8gMjMuMiBTZXQgT2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoU0VULCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwge1xuICAvLyAyMy4yLjMuMSBTZXQucHJvdG90eXBlLmFkZCh2YWx1ZSlcbiAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gc3Ryb25nLmRlZih2YWxpZGF0ZSh0aGlzLCBTRVQpLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gIH1cbn0sIHN0cm9uZyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIEVDTUFTY3JpcHQgNiBzeW1ib2xzIHNoaW1cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyk7XG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBNRVRBID0gcmVxdWlyZSgnLi9fbWV0YScpLktFWTtcbnZhciAkZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi9fc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciB3a3NFeHQgPSByZXF1aXJlKCcuL193a3MtZXh0Jyk7XG52YXIgd2tzRGVmaW5lID0gcmVxdWlyZSgnLi9fd2tzLWRlZmluZScpO1xudmFyIGVudW1LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1rZXlzJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vX2lzLWFycmF5Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgX2NyZWF0ZSA9IHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKTtcbnZhciBnT1BORXh0ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4tZXh0Jyk7XG52YXIgJEdPUEQgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpO1xudmFyICREUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciBnT1BEID0gJEdPUEQuZjtcbnZhciBkUCA9ICREUC5mO1xudmFyIGdPUE4gPSBnT1BORXh0LmY7XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBfc3RyaW5naWZ5ID0gJEpTT04gJiYgJEpTT04uc3RyaW5naWZ5O1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIEhJRERFTiA9IHdrcygnX2hpZGRlbicpO1xudmFyIFRPX1BSSU1JVElWRSA9IHdrcygndG9QcmltaXRpdmUnKTtcbnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBTeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgVVNFX05BVElWRSA9IHR5cGVvZiAkU3ltYm9sID09ICdmdW5jdGlvbic7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgc2V0dGVyID0gIVFPYmplY3QgfHwgIVFPYmplY3RbUFJPVE9UWVBFXSB8fCAhUU9iamVjdFtQUk9UT1RZUEVdLmZpbmRDaGlsZDtcblxuLy8gZmFsbGJhY2sgZm9yIG9sZCBBbmRyb2lkLCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9Njg3XG52YXIgc2V0U3ltYm9sRGVzYyA9IERFU0NSSVBUT1JTICYmICRmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRQKHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hOyB9XG4gIH0pKS5hICE9IDc7XG59KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7XG4gIHZhciBwcm90b0Rlc2MgPSBnT1BEKE9iamVjdFByb3RvLCBrZXkpO1xuICBpZiAocHJvdG9EZXNjKSBkZWxldGUgT2JqZWN0UHJvdG9ba2V5XTtcbiAgZFAoaXQsIGtleSwgRCk7XG4gIGlmIChwcm90b0Rlc2MgJiYgaXQgIT09IE9iamVjdFByb3RvKSBkUChPYmplY3RQcm90bywga2V5LCBwcm90b0Rlc2MpO1xufSA6IGRQO1xuXG52YXIgd3JhcCA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgdmFyIHN5bSA9IEFsbFN5bWJvbHNbdGFnXSA9IF9jcmVhdGUoJFN5bWJvbFtQUk9UT1RZUEVdKTtcbiAgc3ltLl9rID0gdGFnO1xuICByZXR1cm4gc3ltO1xufTtcblxudmFyIGlzU3ltYm9sID0gVVNFX05BVElWRSAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIEQpIHtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90bykgJGRlZmluZVByb3BlcnR5KE9QU3ltYm9scywga2V5LCBEKTtcbiAgYW5PYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBhbk9iamVjdChEKTtcbiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7XG4gICAgaWYgKCFELmVudW1lcmFibGUpIHtcbiAgICAgIGlmICghaGFzKGl0LCBISURERU4pKSBkUChpdCwgSElEREVOLCBjcmVhdGVEZXNjKDEsIHt9KSk7XG4gICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkgaXRbSElEREVOXVtrZXldID0gZmFsc2U7XG4gICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pO1xuICAgIH0gcmV0dXJuIHNldFN5bWJvbERlc2MoaXQsIGtleSwgRCk7XG4gIH0gcmV0dXJuIGRQKGl0LCBrZXksIEQpO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoaXQsIFApIHtcbiAgYW5PYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsID4gaSkgJGRlZmluZVByb3BlcnR5KGl0LCBrZXkgPSBrZXlzW2krK10sIFBba2V5XSk7XG4gIHJldHVybiBpdDtcbn07XG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpdCwgUCkge1xuICByZXR1cm4gUCA9PT0gdW5kZWZpbmVkID8gX2NyZWF0ZShpdCkgOiAkZGVmaW5lUHJvcGVydGllcyhfY3JlYXRlKGl0KSwgUCk7XG59O1xudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKGtleSkge1xuICB2YXIgRSA9IGlzRW51bS5jYWxsKHRoaXMsIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSkpO1xuICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIEUgfHwgIWhhcyh0aGlzLCBrZXkpIHx8ICFoYXMoQWxsU3ltYm9scywga2V5KSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1ba2V5XSA/IEUgOiB0cnVlO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgaXQgPSB0b0lPYmplY3QoaXQpO1xuICBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBEID0gZ09QRChpdCwga2V5KTtcbiAgaWYgKEQgJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXMoaXQsIEhJRERFTikgJiYgaXRbSElEREVOXVtrZXldKSkgRC5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgcmV0dXJuIEQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoIWhhcyhBbGxTeW1ib2xzLCBrZXkgPSBuYW1lc1tpKytdKSAmJiBrZXkgIT0gSElEREVOICYmIGtleSAhPSBNRVRBKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvO1xuICB2YXIgbmFtZXMgPSBnT1BOKElTX09QID8gT1BTeW1ib2xzIDogdG9JT2JqZWN0KGl0KSk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkge1xuICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIDE5LjQuMS4xIFN5bWJvbChbZGVzY3JpcHRpb25dKVxuaWYgKCFVU0VfTkFUSVZFKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvciEnKTtcbiAgICB2YXIgdGFnID0gdWlkKGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvKSAkc2V0LmNhbGwoT1BTeW1ib2xzLCB2YWx1ZSk7XG4gICAgICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgc2V0dGVyKSBzZXRTeW1ib2xEZXNjKE9iamVjdFByb3RvLCB0YWcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCBzZXQ6ICRzZXQgfSk7XG4gICAgcmV0dXJuIHdyYXAodGFnKTtcbiAgfTtcbiAgcmVkZWZpbmUoJFN5bWJvbFtQUk9UT1RZUEVdLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5faztcbiAgfSk7XG5cbiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICREUC5mID0gJGRlZmluZVByb3BlcnR5O1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmYgPSBnT1BORXh0LmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJykuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgaWYgKERFU0NSSVBUT1JTICYmICFyZXF1aXJlKCcuL19saWJyYXJ5JykpIHtcbiAgICByZWRlZmluZShPYmplY3RQcm90bywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJHByb3BlcnR5SXNFbnVtZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIHdrc0V4dC5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3a3MobmFtZSkpO1xuICB9O1xufVxuXG4kZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTtcblxuZm9yICh2YXIgZXM2U3ltYm9scyA9IChcbiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTRcbiAgJ2hhc0luc3RhbmNlLGlzQ29uY2F0U3ByZWFkYWJsZSxpdGVyYXRvcixtYXRjaCxyZXBsYWNlLHNlYXJjaCxzcGVjaWVzLHNwbGl0LHRvUHJpbWl0aXZlLHRvU3RyaW5nVGFnLHVuc2NvcGFibGVzJ1xuKS5zcGxpdCgnLCcpLCBqID0gMDsgZXM2U3ltYm9scy5sZW5ndGggPiBqOyl3a3MoZXM2U3ltYm9sc1tqKytdKTtcblxuZm9yICh2YXIgd2VsbEtub3duU3ltYm9scyA9ICRrZXlzKHdrcy5zdG9yZSksIGsgPSAwOyB3ZWxsS25vd25TeW1ib2xzLmxlbmd0aCA+IGs7KSB3a3NEZWZpbmUod2VsbEtub3duU3ltYm9sc1trKytdKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHtcbiAgLy8gMTkuNC4yLjEgU3ltYm9sLmZvcihrZXkpXG4gICdmb3InOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKVxuICAgICAgPyBTeW1ib2xSZWdpc3RyeVtrZXldXG4gICAgICA6IFN5bWJvbFJlZ2lzdHJ5W2tleV0gPSAkU3ltYm9sKGtleSk7XG4gIH0sXG4gIC8vIDE5LjQuMi41IFN5bWJvbC5rZXlGb3Ioc3ltKVxuICBrZXlGb3I6IGZ1bmN0aW9uIGtleUZvcihzeW0pIHtcbiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gU3ltYm9sUmVnaXN0cnkpIGlmIChTeW1ib2xSZWdpc3RyeVtrZXldID09PSBzeW0pIHJldHVybiBrZXk7XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LFxuICB1c2VTaW1wbGU6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gZmFsc2U7IH1cbn0pO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCAnT2JqZWN0Jywge1xuICAvLyAxOS4xLjIuMiBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG4gIGNyZWF0ZTogJGNyZWF0ZSxcbiAgLy8gMTkuMS4yLjQgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvcixcbiAgLy8gMTkuMS4yLjcgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTylcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzOiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzXG59KTtcblxuLy8gMjQuMy4yIEpTT04uc3RyaW5naWZ5KHZhbHVlIFssIHJlcGxhY2VyIFssIHNwYWNlXV0pXG4kSlNPTiAmJiAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICghVVNFX05BVElWRSB8fCAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgUyA9ICRTeW1ib2woKTtcbiAgLy8gTVMgRWRnZSBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMge31cbiAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gIHJldHVybiBfc3RyaW5naWZ5KFtTXSkgIT0gJ1tudWxsXScgfHwgX3N0cmluZ2lmeSh7IGE6IFMgfSkgIT0gJ3t9JyB8fCBfc3RyaW5naWZ5KE9iamVjdChTKSkgIT0gJ3t9Jztcbn0pKSwgJ0pTT04nLCB7XG4gIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7XG4gICAgdmFyIGFyZ3MgPSBbaXRdO1xuICAgIHZhciBpID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpIGFyZ3MucHVzaChhcmd1bWVudHNbaSsrXSk7XG4gICAgJHJlcGxhY2VyID0gcmVwbGFjZXIgPSBhcmdzWzFdO1xuICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWRcbiAgICBpZiAoIWlzQXJyYXkocmVwbGFjZXIpKSByZXBsYWNlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKSB2YWx1ZSA9ICRyZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7XG4gIH1cbn0pO1xuXG4vLyAxOS40LjMuNCBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdKGhpbnQpXG4kU3ltYm9sW1BST1RPVFlQRV1bVE9fUFJJTUlUSVZFXSB8fCByZXF1aXJlKCcuL19oaWRlJykoJFN5bWJvbFtQUk9UT1RZUEVdLCBUT19QUklNSVRJVkUsICRTeW1ib2xbUFJPVE9UWVBFXS52YWx1ZU9mKTtcbi8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKCRTeW1ib2wsICdTeW1ib2wnKTtcbi8vIDIwLjIuMS45IE1hdGhbQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4vLyAyNC4zLjMgSlNPTltAQHRvU3RyaW5nVGFnXVxuc2V0VG9TdHJpbmdUYWcoZ2xvYmFsLkpTT04sICdKU09OJywgdHJ1ZSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5LW1ldGhvZHMnKSgwKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyk7XG52YXIgd2VhayA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24td2VhaycpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIFdFQUtfTUFQID0gJ1dlYWtNYXAnO1xudmFyIGdldFdlYWsgPSBtZXRhLmdldFdlYWs7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gd2Vhay51ZnN0b3JlO1xudmFyIHRtcCA9IHt9O1xudmFyIEludGVybmFsTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtNYXAoKSB7XG4gICAgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gIH07XG59O1xuXG52YXIgbWV0aG9kcyA9IHtcbiAgLy8gMjMuMy4zLjMgV2Vha01hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KGtleSkpIHtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHZhbGlkYXRlKHRoaXMsIFdFQUtfTUFQKSkuZ2V0KGtleSk7XG4gICAgICByZXR1cm4gZGF0YSA/IGRhdGFbdGhpcy5faV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LFxuICAvLyAyMy4zLjMuNSBXZWFrTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiB3ZWFrLmRlZih2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCksIGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vLyAyMy4zIFdlYWtNYXAgT2JqZWN0c1xudmFyICRXZWFrTWFwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uJykoV0VBS19NQVAsIHdyYXBwZXIsIG1ldGhvZHMsIHdlYWssIHRydWUsIHRydWUpO1xuXG4vLyBJRTExIFdlYWtNYXAgZnJvemVuIGtleXMgZml4XG5pZiAoZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3ICRXZWFrTWFwKCkuc2V0KChPYmplY3QuZnJlZXplIHx8IE9iamVjdCkodG1wKSwgNykuZ2V0KHRtcCkgIT0gNzsgfSkpIHtcbiAgSW50ZXJuYWxNYXAgPSB3ZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsIFdFQUtfTUFQKTtcbiAgYXNzaWduKEludGVybmFsTWFwLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gIG1ldGEuTkVFRCA9IHRydWU7XG4gIGVhY2goWydkZWxldGUnLCAnaGFzJywgJ2dldCcsICdzZXQnXSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBwcm90byA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbiAgICB2YXIgbWV0aG9kID0gcHJvdG9ba2V5XTtcbiAgICByZWRlZmluZShwcm90bywga2V5LCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gc3RvcmUgZnJvemVuIG9iamVjdHMgb24gaW50ZXJuYWwgd2Vha21hcCBzaGltXG4gICAgICBpZiAoaXNPYmplY3QoYSkgJiYgIWlzRXh0ZW5zaWJsZShhKSkge1xuICAgICAgICBpZiAoIXRoaXMuX2YpIHRoaXMuX2YgPSBuZXcgSW50ZXJuYWxNYXAoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Zba2V5XShhLCBiKTtcbiAgICAgICAgcmV0dXJuIGtleSA9PSAnc2V0JyA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAvLyBzdG9yZSBhbGwgdGhlIHJlc3Qgb24gbmF0aXZlIHdlYWttYXBcbiAgICAgIH0gcmV0dXJuIG1ldGhvZC5jYWxsKHRoaXMsIGEsIGIpO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1NldCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtc2V0Lm9mXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1vZicpKCdTZXQnKTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5SLCAnU2V0JywgeyB0b0pTT046IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tdG8tanNvbicpKCdTZXQnKSB9KTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpO1xuIiwicmVxdWlyZSgnLi9fd2tzLWRlZmluZScpKCdvYnNlcnZhYmxlJyk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy13ZWFrbWFwLmZyb21cbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLWZyb20nKSgnV2Vha01hcCcpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnV2Vha01hcCcpO1xuIiwicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIFRPX1NUUklOR19UQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxudmFyIERPTUl0ZXJhYmxlcyA9ICgnQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCwnICtcbiAgJ0RPTVRva2VuTGlzdCxEYXRhVHJhbnNmZXJJdGVtTGlzdCxGaWxlTGlzdCxIVE1MQWxsQ29sbGVjdGlvbixIVE1MQ29sbGVjdGlvbixIVE1MRm9ybUVsZW1lbnQsSFRNTFNlbGVjdEVsZW1lbnQsJyArXG4gICdNZWRpYUxpc3QsTWltZVR5cGVBcnJheSxOYW1lZE5vZGVNYXAsTm9kZUxpc3QsUGFpbnRSZXF1ZXN0TGlzdCxQbHVnaW4sUGx1Z2luQXJyYXksU1ZHTGVuZ3RoTGlzdCxTVkdOdW1iZXJMaXN0LCcgK1xuICAnU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsJyArXG4gICdUZXh0VHJhY2tMaXN0LFRvdWNoTGlzdCcpLnNwbGl0KCcsJyk7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgRE9NSXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gRE9NSXRlcmFibGVzW2ldO1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTtcbiAgaWYgKHByb3RvICYmICFwcm90b1tUT19TVFJJTkdfVEFHXSkgaGlkZShwcm90bywgVE9fU1RSSU5HX1RBRywgTkFNRSk7XG4gIEl0ZXJhdG9yc1tOQU1FXSA9IEl0ZXJhdG9ycy5BcnJheTtcbn1cbiIsIi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgd2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcbiAgcmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG4gICAgLy8gZG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuXG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gIHZhciBoYXNoID0gMCwgaTtcblxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XG4gICAgaGFzaCAgPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAvLyBkaXNhYmxlZD9cbiAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHJldHVybjtcblxuICAgIHZhciBzZWxmID0gZGVidWc7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIHR1cm4gdGhlIGBhcmd1bWVudHNgIGludG8gYSBwcm9wZXIgQXJyYXlcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcbiAgICBleHBvcnRzLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG5cbiAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICBkZWJ1Zy5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblxuICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xuICAgIGV4cG9ydHMuaW5pdChkZWJ1Zyk7XG4gIH1cblxuICByZXR1cm4gZGVidWc7XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgZXhwb3J0cy5uYW1lcyA9IFtdO1xuICBleHBvcnRzLnNraXBzID0gW107XG5cbiAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl19
