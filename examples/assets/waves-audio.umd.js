(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.wavesAudio = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var AudioContext = window.AudioContext || window.webkitAudioContext;

/**
 * Expose a unique audio context singleton as the default audio
 * context used by the components of the Waves Audio library and
 * applications using the library.
 *
 * @type AudioContext
 * @name audioContext
 * @constant
 * @global
 * @instance
 *
 * @example
 * import * as audio from 'waves-audio';
 * const audioContext = audio.audioContext;
 */
var audioContext = null;

if (AudioContext) {
  audioContext = new AudioContext();

  if (/(iPhone|iPad)/i.test(navigator.userAgent) && audioContext.sampleRate < 44100) {
    var buffer = audioContext.createBuffer(1, 1, 44100);
    var dummy = audioContext.createBufferSource();
    dummy.buffer = buffer;
    dummy.connect(audioContext.destination);
    dummy.start(0);
    dummy.disconnect();
  }
}

exports.default = audioContext;

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _timeEngine = require('./time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _audioContext = require('./audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This is the base class for all audio related time engine components. It is
 * used to handle audio related events such as the playback of a media stream.
 * It extends the TimeEngine class by the standard web audio node methods
 * connect and disconnect.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/audio-time-engine.html}
 *
 * @extends TimeEngine
 * @example
 * import audio from 'waves-audio';
 *
 * class MyEngine extends audio.AudioTimeEngine {
 *   constructor() {
 *     super();
 *     // ...
 *   }
 * }
 */
var AudioTimeEngine = function (_TimeEngine) {
  (0, _inherits3.default)(AudioTimeEngine, _TimeEngine);

  function AudioTimeEngine() {
    var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;
    (0, _classCallCheck3.default)(this, AudioTimeEngine);

    /**
     * Audio context used by the TimeEngine, default to the global audioContext
     *
     * @name audioContext
     * @type AudioContext
     * @memberof AudioTimeEngine
     * @see audioContext
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (AudioTimeEngine.__proto__ || (0, _getPrototypeOf2.default)(AudioTimeEngine)).call(this));

    _this.audioContext = audioContext;

    /**
     * Output audio node. By default the connect method connects a given node
     * to this output node.
     *
     * @name outputNode
     * @type AudioNode
     * @memberof AudioTimeEngine
     * @default null
     */
    _this.outputNode = null;
    return _this;
  }

  /**
   * Connect to an audio node (e.g. audioContext.destination)
   *
   * @param {AudioNode} target - Target audio node
   */


  (0, _createClass3.default)(AudioTimeEngine, [{
    key: 'connect',
    value: function connect(target) {
      this.outputNode.connect(target);
      return this;
    }

    /**
     * Disconnect from an audio node (e.g. audioContext.destination). If undefined
     * disconnect from all target nodes.
     *
     * @param {AudioNode} target - Target audio node.
     */

  }, {
    key: 'disconnect',
    value: function disconnect(connection) {
      this.outputNode.disconnect(connection);
      return this;
    }
  }]);
  return AudioTimeEngine;
}(_timeEngine2.default);

exports.default = AudioTimeEngine;

},{"./audio-context":1,"./time-engine":5,"babel-runtime/core-js/object/get-prototype-of":28,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/possibleConstructorReturn":39}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// works by reference
function swap(arr, i1, i2) {
  var tmp = arr[i1];
  arr[i1] = arr[i2];
  arr[i2] = tmp;
}

// https://jsperf.com/js-for-loop-vs-array-indexof/346
function indexOf(arr, el) {
  var l = arr.length;
  // ignore first element as it can't be a entry
  for (var i = 1; i < l; i++) {
    if (arr[i] === el) {
      return i;
    }
  }

  return -1;
}

/**
 * Define if `time1` should be lower in the topography than `time2`.
 * Is dynamically affected to the priority queue according to handle `min` and `max` heap.
 *
 * @private
 * @param {Number} time1
 * @param {Number} time2
 * @return {Boolean}
 */
var _isLowerMaxHeap = function _isLowerMaxHeap(time1, time2) {
  return time1 < time2;
};

var _isLowerMinHeap = function _isLowerMinHeap(time1, time2) {
  return time1 > time2;
};

/**
 * Define if `time1` should be higher in the topography than `time2`.
 * Is dynamically affected to the priority queue according to handle `min` and `max` heap.
 *
 * @private
 * @param {Number} time1
 * @param {Number} time2
 * @return {Boolean}
 */
var _isHigherMaxHeap = function _isHigherMaxHeap(time1, time2) {
  return time1 > time2;
};

var _isHigherMinHeap = function _isHigherMinHeap(time1, time2) {
  return time1 < time2;
};

var POSITIVE_INFINITY = Number.POSITIVE_INFINITY;

/**
 * Priority queue implementing a binary heap.
 * Acts as a min heap by default, can be dynamically changed to a max heap
 * by setting `reverse` to true.
 *
 * _note_: the queue creates and maintains a new property (i.e. `queueTime`)
 * to each object added.
 *
 * @param {Number} [heapLength=100] - Default size of the array used to create the heap.
 */

var PriorityQueue = function () {
  function PriorityQueue() {
    var heapLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;
    (0, _classCallCheck3.default)(this, PriorityQueue);

    /**
     * Pointer to the first empty index of the heap.
     * @type {Number}
     * @memberof PriorityQueue
     * @name _currentLength
     * @private
     */
    this._currentLength = 1;

    /**
     * Array of the sorted indexes of the entries, the actual heap. Ignore the index 0.
     * @type {Array}
     * @memberof PriorityQueue
     * @name _heap
     * @private
     */
    this._heap = new Array(heapLength + 1);

    /**
     * Type of the queue: `min` heap if `false`, `max` heap if `true`
     * @type {Boolean}
     * @memberof PriorityQueue
     * @name _reverse
     * @private
     */
    this._reverse = null;

    // initialize compare functions
    this.reverse = false;
  }

  /**
   * Time of the first element in the binary heap.
   * @returns {Number}
   */


  (0, _createClass3.default)(PriorityQueue, [{
    key: "_bubbleUp",


    /**
     * Fix the heap by moving an entry to a new upper position.
     *
     * @private
     * @param {Number} startIndex - The index of the entry to move.
     */
    value: function _bubbleUp(startIndex) {
      var entry = this._heap[startIndex];

      var index = startIndex;
      var parentIndex = Math.floor(index / 2);
      var parent = this._heap[parentIndex];

      while (parent && this._isHigher(entry.queueTime, parent.queueTime)) {
        swap(this._heap, index, parentIndex);

        index = parentIndex;
        parentIndex = Math.floor(index / 2);
        parent = this._heap[parentIndex];
      }
    }

    /**
     * Fix the heap by moving an entry to a new lower position.
     *
     * @private
     * @param {Number} startIndex - The index of the entry to move.
     */

  }, {
    key: "_bubbleDown",
    value: function _bubbleDown(startIndex) {
      var entry = this._heap[startIndex];

      var index = startIndex;
      var c1index = index * 2;
      var c2index = c1index + 1;
      var child1 = this._heap[c1index];
      var child2 = this._heap[c2index];

      while (child1 && this._isLower(entry.queueTime, child1.queueTime) || child2 && this._isLower(entry.queueTime, child2.queueTime)) {
        // swap with the minimum child
        var targetIndex = void 0;

        if (child2) targetIndex = this._isHigher(child1.queueTime, child2.queueTime) ? c1index : c2index;else targetIndex = c1index;

        swap(this._heap, index, targetIndex);

        // update to find next children
        index = targetIndex;
        c1index = index * 2;
        c2index = c1index + 1;
        child1 = this._heap[c1index];
        child2 = this._heap[c2index];
      }
    }

    /**
     * Build the heap (from bottom up).
     */

  }, {
    key: "buildHeap",
    value: function buildHeap() {
      // find the index of the last internal node
      // @todo - make sure that's the right way to do.
      var maxIndex = Math.floor((this._currentLength - 1) / 2);

      for (var i = maxIndex; i > 0; i--) {
        this._bubbleDown(i);
      }
    }

    /**
     * Insert a new object in the binary heap and sort it.
     *
     * @param {Object} entry - Entry to insert.
     * @param {Number} time - Time at which the entry should be orderer.
     * @returns {Number} - Time of the first entry in the heap.
     */

  }, {
    key: "insert",
    value: function insert(entry, time) {
      if (Math.abs(time) !== POSITIVE_INFINITY) {
        entry.queueTime = time;
        // add the new entry at the end of the heap
        this._heap[this._currentLength] = entry;
        // bubble it up
        this._bubbleUp(this._currentLength);
        this._currentLength += 1;

        return this.time;
      }

      entry.queueTime = undefined;
      return this.remove(entry);
    }

    /**
     * Move a given entry to a new position.
     *
     * @param {Object} entry - Entry to move.
     * @param {Number} time - Time at which the entry should be orderer.
     * @return {Number} - Time of first entry in the heap.
     */

  }, {
    key: "move",
    value: function move(entry, time) {
      if (Math.abs(time) !== POSITIVE_INFINITY) {
        var index = indexOf(this._heap, entry);

        if (index !== -1) {
          entry.queueTime = time;
          // define if the entry should be bubbled up or down
          var parent = this._heap[Math.floor(index / 2)];

          if (parent && this._isHigher(time, parent.queueTime)) this._bubbleUp(index);else this._bubbleDown(index);
        }

        return this.time;
      }

      entry.queueTime = undefined;
      return this.remove(entry);
    }

    /**
     * Remove an entry from the heap and fix the heap.
     *
     * @param {Object} entry - Entry to remove.
     * @return {Number} - Time of first entry in the heap.
     */

  }, {
    key: "remove",
    value: function remove(entry) {
      // find the index of the entry
      var index = indexOf(this._heap, entry);

      if (index !== -1) {
        var lastIndex = this._currentLength - 1;

        // if the entry is the last one
        if (index === lastIndex) {
          // remove the element from heap
          this._heap[lastIndex] = undefined;
          // update current length
          this._currentLength = lastIndex;

          return this.time;
        } else {
          // swap with the last element of the heap
          swap(this._heap, index, lastIndex);
          // remove the element from heap
          this._heap[lastIndex] = undefined;

          if (index === 1) {
            this._bubbleDown(1);
          } else {
            // bubble the (ex last) element up or down according to its new context
            var _entry = this._heap[index];
            var parent = this._heap[Math.floor(index / 2)];

            if (parent && this._isHigher(_entry.queueTime, parent.queueTime)) this._bubbleUp(index);else this._bubbleDown(index);
          }
        }

        // update current length
        this._currentLength = lastIndex;
      }

      return this.time;
    }

    /**
     * Clear the queue.
     */

  }, {
    key: "clear",
    value: function clear() {
      this._currentLength = 1;
      this._heap = new Array(this._heap.length);
    }

    /**
     * Defines if the queue contains the given `entry`.
     *
     * @param {Object} entry - Entry to be checked
     * @return {Boolean}
     */

  }, {
    key: "has",
    value: function has(entry) {
      return this._heap.indexOf(entry) !== -1;
    }
  }, {
    key: "time",
    get: function get() {
      if (this._currentLength > 1) return this._heap[1].queueTime;

      return Infinity;
    }

    /**
     * First element in the binary heap.
     * @returns {Number}
     * @readonly
     */

  }, {
    key: "head",
    get: function get() {
      return this._heap[1];
    }

    /**
     * Change the order of the queue (max heap if true, min heap if false),
     * rebuild the heap with the existing entries.
     *
     * @type {Boolean}
     */

  }, {
    key: "reverse",
    set: function set(value) {
      if (value !== this._reverse) {
        this._reverse = value;

        if (this._reverse === true) {
          this._isLower = _isLowerMaxHeap;
          this._isHigher = _isHigherMaxHeap;
        } else {
          this._isLower = _isLowerMinHeap;
          this._isHigher = _isHigherMinHeap;
        }

        this.buildHeap();
      }
    },
    get: function get() {
      return this._reverse;
    }
  }]);
  return PriorityQueue;
}();

exports.default = PriorityQueue;

},{"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _priorityQueue = require('./priority-queue');

var _priorityQueue2 = _interopRequireDefault(_priorityQueue);

var _timeEngine = require('./time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @class SchedulingQueue
 * @extends TimeEngine
 */
/**
 * SchedulingQueue base class
 * http://wavesjs.github.io/audio/#audio-scheduling-queue
 *
 * Norbert.Schnell@ircam.fr
 * Copyright 2014, 2015 IRCAM – Centre Pompidou
 */

var SchedulingQueue = function (_TimeEngine) {
  (0, _inherits3.default)(SchedulingQueue, _TimeEngine);

  function SchedulingQueue() {
    (0, _classCallCheck3.default)(this, SchedulingQueue);

    var _this = (0, _possibleConstructorReturn3.default)(this, (SchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(SchedulingQueue)).call(this));

    _this.__queue = new _priorityQueue2.default();
    _this.__engines = new _set2.default();
    return _this;
  }

  // TimeEngine 'scheduled' interface


  (0, _createClass3.default)(SchedulingQueue, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var engine = this.__queue.head;
      var nextEngineTime = engine.advanceTime(time);

      if (!nextEngineTime) {
        engine.master = null;
        this.__engines.delete(engine);
        this.__queue.remove(engine);
      } else {
        this.__queue.move(engine, nextEngineTime);
      }

      return this.__queue.time;
    }

    // TimeEngine master method to be implemented by derived class

  }, {
    key: 'defer',


    // call a function at a given time
    value: function defer(fun) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!(fun instanceof Function)) throw new Error("object cannot be defered by scheduler");

      this.add({
        advanceTime: function advanceTime(time) {
          fun(time);
        } // make sur that the advanceTime method does not returm anything
      }, time);
    }

    // add a time engine to the scheduler

  }, {
    key: 'add',
    value: function add(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!_timeEngine2.default.implementsScheduled(engine)) throw new Error("object cannot be added to scheduler");

      if (engine.master) throw new Error("object has already been added to a master");

      engine.master = this;

      // add to engines and queue
      this.__engines.add(engine);
      var nextTime = this.__queue.insert(engine, time);

      // reschedule queue
      this.resetTime(nextTime);
    }

    // remove a time engine from the queue

  }, {
    key: 'remove',
    value: function remove(engine) {
      if (engine.master !== this) throw new Error("object has not been added to this scheduler");

      engine.master = null;

      // remove from array and queue
      this.__engines.delete(engine);
      var nextTime = this.__queue.remove(engine);

      // reschedule queue
      this.resetTime(nextTime);
    }

    // reset next engine time

  }, {
    key: 'resetEngineTime',
    value: function resetEngineTime(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (engine.master !== this) throw new Error("object has not been added to this scheduler");

      var nextTime = void 0;

      if (this.__queue.has(engine)) nextTime = this.__queue.move(engine, time);else nextTime = this.__queue.insert(engine, time);

      this.resetTime(nextTime);
    }

    // check whether a given engine is scheduled

  }, {
    key: 'has',
    value: function has(engine) {
      return this.__engines.has(engine);
    }

    // clear queue

  }, {
    key: 'clear',
    value: function clear() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.__engines), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var engine = _step.value;

          engine.master = null;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.__queue.clear();
      this.__engines.clear();
      this.resetTime(Infinity);
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return 0;
    }
  }]);
  return SchedulingQueue;
}(_timeEngine2.default);

exports.default = SchedulingQueue;

},{"./priority-queue":3,"./time-engine":5,"babel-runtime/core-js/get-iterator":23,"babel-runtime/core-js/object/get-prototype-of":28,"babel-runtime/core-js/set":31,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/possibleConstructorReturn":39}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Base class for time engines
 *
 * A time engine generates more or less regular events and/or plays back a
 * media stream. It implements one or multiple interfaces to be driven by a
 * master (i.e. a Scheduler, a Transport or a PlayControl) in synchronization
 * with other engines. The provided interfaces are scheduled, transported,
 * and play-controlled.
 *
 *
 * #### The `scheduled` interface
 *
 * The scheduled interface allows for synchronizing an engine to a monotonous time
 * as it is provided by the Scheduler master.
 *
 * ###### `advanceTime(time :Number) -> {Number}`
 *
 * The `advanceTime` method has to be implemented by an `TimeEngine` as part of the
 * scheduled interface. The method is called by the master (e.g. the scheduler).
 * It generates an event and to returns the time of the next event (i.e. the next
 * call of advanceTime). The returned time has to be greater than the time
 * received as argument of the method. In case that a TimeEngine has to generate
 * multiple events at the same time, the engine has to implement its own loop
 * while(event.time <= time) and return the time of the next event (if any).
 *
 * ###### `resetTime(time=undefined :Number)`
 *
 * The `resetTime` method is provided by the `TimeEngine` base class. An engine may
 * call this method to reset its next event time (e.g. when a parameter is
 * changed that influences the engine's temporal behavior). When no argument
 * is given, the time is reset to the current master time. When calling the
 * method with Infinity the engine is suspended without being removed from the
 * master.
 *
 *
 * #### The `transported` interface
 *
 * The transported interface allows for synchronizing an engine to a position
 * (i.e. media playback time) that can run forward and backward and jump as it
 * is provided by the Transport master.
 *
 * ###### `syncPosition(time :Number, position :Number, speed :Number) -> {Number}`
 *
 * The `syncPositon` method has to be implemented by a `TimeEngine` as part of the
 * transported interface. The method syncPositon is called whenever the master
 * of a transported engine has to (re-)synchronize the engine's position. This
 * is for example required when the master (re-)starts playback, jumps to an
 * arbitrary position, and when reversing playback direction. The method returns
 * the next position of the engine in the given playback direction
 * (i.e. `speed < 0` or `speed > 0`).
 *
 * ###### `advancePosition(time :Number, position :Number, speed :Number) -> {Number}`
 *
 * The `advancePosition` method has to be implemented by a `TimeEngine` as part
 * of the transported interface. The master calls the advancePositon method when
 * the engine's event position is reached. The method generates an event and
 * returns the next position in the given playback direction (i.e. speed < 0 or
 * speed > 0). The returned position has to be greater (i.e. when speed > 0)
 * or less (i.e. when speed < 0) than the position received as argument of the
 * method.
 *
 * ###### `resetPosition(position=undefined :Number)`
 *
 * The resetPosition method is provided by the TimeEngine base class. An engine
 * may call this method to reset its next event position. When no argument
 * is given, the time is reset to the current master time. When calling the
 * method with Infinity the engine is suspended without being removed from
 * the master.
 *
 *
 * #### The speed-controlled interface
 *
 * The "speed-controlled" interface allows for syncronizing an engine that is
 * neither driven through the scheduled nor the transported interface. The
 * interface allows in particular to synchronize engines that assure their own
 * scheduling (i.e. audio player or an oscillator) to the event-based scheduled
 * and transported engines.
 *
 * ###### `syncSpeed(time :Number, position :Number, speed :Number, seek=false :Boolean)`
 *
 * The syncSpeed method has to be implemented by a TimeEngine as part of the
 * speed-controlled interface. The method is called by the master whenever the
 * playback speed changes or the position jumps arbitarily (i.e. on a seek).
 *
 *
 * <hr />
 *
 * Example that shows a `TimeEngine` running in a `Scheduler` that counts up
 * at a given frequency:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/time-engine.html}
 *
 * @example
 * import * as audio from 'waves-audio';
 *
 * class MyEngine extends audio.TimeEngine {
 *   constructor() {
 *     super();
 *     // ...
 *   }
 * }
 *
 */
var TimeEngine = function () {
  function TimeEngine() {
    (0, _classCallCheck3.default)(this, TimeEngine);

    /**
     * The engine's master.
     *
     * @type {Mixed}
     * @name master
     * @memberof TimeEngine
     */
    this.master = null;
  }

  /**
   * The time engine's current (master) time.
   *
   * @type {Number}
   * @memberof TimeEngine
   * @readonly
   */


  (0, _createClass3.default)(TimeEngine, [{
    key: "resetTime",
    value: function resetTime() {
      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      if (this.master) this.master.resetEngineTime(this, time);
    }

    /**
     * Transported interface
     *   - syncPosition(time, position, speed), called to reposition TimeEngine, returns next position
     *   - advancePosition(time, position, speed), called to generate next event at given time and position, returns next position
     *
     * @static
     * @memberof TimeEngine
     */

  }, {
    key: "resetPosition",
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

      if (this.master) this.master.resetEnginePosition(this, position);
    }

    /**
     * Speed-controlled interface
     *   - syncSpeed(time, position, speed, ), called to
     *
     * @static
     * @memberof TimeEngine
     */

  }, {
    key: "currentTime",
    get: function get() {
      if (this.master) return this.master.currentTime;

      return undefined;
    }

    /**
     * The time engine's current (master) position.
     *
     * @type {Number}
     * @memberof TimeEngine
     * @readonly
     */

  }, {
    key: "currentPosition",
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return undefined;
    }

    /**
     * Scheduled interface
     *   - advanceTime(time), called to generate next event at given time, returns next time
     *
     * @static
     * @memberof TimeEngine
     */

  }], [{
    key: "implementsScheduled",
    value: function implementsScheduled(engine) {
      return engine.advanceTime && engine.advanceTime instanceof Function;
    }
  }, {
    key: "implementsTransported",
    value: function implementsTransported(engine) {
      return engine.syncPosition && engine.syncPosition instanceof Function && engine.advancePosition && engine.advancePosition instanceof Function;
    }
  }, {
    key: "implementsSpeedControlled",
    value: function implementsSpeedControlled(engine) {
      return engine.syncSpeed && engine.syncSpeed instanceof Function;
    }
  }]);
  return TimeEngine;
}();

exports.default = TimeEngine;

},{"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Granular synthesis TimeEngine implementing the scheduled interface.
 * The grain position (grain onset or center time in the audio buffer) is
 * optionally determined by the engine's currentPosition attribute.
 *
 * Example that shows a `GranularEngine` (with a few parameter controls) driven
 * by a `Scheduler` and a `PlayControl`:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/granular-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const granularEngine = new audio.GranularEngine();
 *
 * scheduler.add(granularEngine);
 *
 *
 * @param {Object} options={} - Parameters
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0.01] - Absolute grain period in sec
 * @param {Number} [options.periodRel=0] - Grain period relative to absolute
 *  duration
 * @param {Number} [options.periodVar=0] - Amout of random grain period
 *  variation relative to grain period
 * @param {Number} [options.periodMin=0.001] - Minimum grain period
 * @param {Number} [options.position=0] - Grain position (onset time in audio
 *  buffer) in sec
 * @param {Number} [options.positionVar=0.003] - Amout of random grain position
 *  variation in sec
 * @param {Number} [options.durationAbs=0.1] - Absolute grain duration in sec
 * @param {Number} [options.durationRel=0] - Grain duration relative to grain
 * @param {Number} [options.durationVar=0] - Amout of random grain duration
 *  period (overlap)
 * @param {Number} [options.attackAbs=0] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0.5] - Attack time relative to grain duration
 * @param {String} [options.attackShape='lin'] - Shape of attack
 * @param {Number} [options.releaseAbs=0] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0.5] - Release time relative to grain duration
 * @param {Number} [options.releaseShape='lin'] - Shape of release
 * @param {String} [options.expRampOffset=0.0001] - Offset (start/end value)
 *  for exponential attack/release
 * @param {Number} [options.resampling=0] - Grain resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Boolean} [options.centered=true] - Whether the grain position refers
 *  to the center of the grain (or the beginning)
 * @param {Boolean} [options.cyclic=false] - Whether the audio buffer and grain
 *  position are considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the
 *  audio buffer that has been copied from the beginning to assure cyclic behavior
 */

var GranularEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(GranularEngine, _AudioTimeEngine);

  function GranularEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, GranularEngine);

    /**
     * Audio buffer
     *
     * @type {AudioBuffer}
     * @name buffer
     * @default null
     * @memberof GranularEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (GranularEngine.__proto__ || (0, _getPrototypeOf2.default)(GranularEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute grain period in sec
     *
     * @type {Number}
     * @name periodAbs
     * @default 0.01
     * @memberof GranularEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0.01);

    /**
     * Grain period relative to absolute duration
     *
     * @type {Number}
     * @name periodRel
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 0);

    /**
     * Amout of random grain period variation relative to grain period
     *
     * @type {Number}
     * @name periodVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum grain period
     *
     * @type {Number}
     * @name periodMin
     * @default 0.001
     * @memberof GranularEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Grain position (onset time in audio buffer) in sec
     *
     * @type {Number}
     * @name position
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.position = optOrDef(options.position, 0);

    /**
     * Amout of random grain position variation in sec
     *
     * @type {Number}
     * @name positionVar
     * @default 0.003
     * @memberof GranularEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0.003);

    /**
     * Absolute grain duration in sec
     *
     * @type {Number}
     * @name durationAbs
     * @default 0.1
     * @memberof GranularEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0.1); // absolute grain duration

    /**
     * Grain duration relative to grain period (overlap)
     *
     * @type {Number}
     * @name durationRel
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 0);

    /**
     * Amout of random grain duration variation in sec
     *
     * @type {Number}
     * @name durationVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.durationVar = optOrDef(options.durationVar, 0);

    /**
     * Absolute attack time in sec
     *
     * @type {Number}
     * @name attackAbs
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0);

    /**
     * Attack time relative to grain duration
     *
     * @type {Number}
     * @name attackRel
     * @default 0.5
     * @memberof GranularEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0.5);

    /**
     * Shape of attack ('lin' for linear ramp, 'exp' for exponential ramp)
     *
     * @type {String}
     * @name attackShape
     * @default 'lin'
     * @memberof GranularEngine
     * @instance
     */
    _this.attackShape = optOrDef(options.attackShape, 'lin');

    /**
     * Absolute release time in sec
     *
     * @type {Number}
     * @name releaseAbs
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0);

    /**
     * Release time relative to grain duration
     *
     * @type {Number}
     * @name releaseRel
     * @default 0.5
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0.5);

    /**
     * Shape of release ('lin' for linear ramp, 'exp' for exponential ramp)
     *
     * @type {String}
     * @name releaseShape
     * @default 'lin'
     * @memberof GranularEngine
     * @instance
     */
    _this.releaseShape = optOrDef(options.releaseShape, 'lin');

    /**
     * Offset (start/end value) for exponential attack/release
     *
     * @type {Number}
     * @name expRampOffset
     * @default 0.0001
     * @memberof GranularEngine
     * @instance
     */
    _this.expRampOffset = optOrDef(options.expRampOffset, 0.0001);

    /**
     * Grain resampling in cent
     *
     * @type {Number}
     * @name resampling
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     *
     * @type {Number}
     * @name resamplingVar
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     *
     * @type {Number}
     * @name gain
     * @default 1
     * @memberof GranularEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Whether the grain position refers to the center of the grain (or the beginning)
     *
     * @type {Boolean}
     * @name centered
     * @default true
     * @memberof GranularEngine
     * @instance
     */
    _this.centered = optOrDef(options.centered, true);

    /**
     * Whether the audio buffer and grain position are considered as cyclic
     *
     * @type {Boolean}
     * @name cyclic
     * @default false
     * @memberof GranularEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);

    /**
     * Portion at the end of the audio buffer that has been copied from the
     * beginning to assure cyclic behavior
     *
     * @type {Number}
     * @name wrapAroundExtension
     * @default 0
     * @memberof GranularEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();
    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @name bufferDuration
   * @memberof GranularEngine
   * @instance
   * @readonly
   */


  (0, _createClass3.default)(GranularEngine, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    /**
     * Trigger a grain. This function can be called at any time (whether the
     * engine is scheduled or not) to generate a single grain according to the
     * current grain parameters.
     *
     * @param {Number} time - grain synthesis audio time
     * @return {Number} - period to next grain
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var grainTime = time || audioContext.currentTime;
      var grainPeriod = this.periodAbs;
      var grainPosition = this.currentPosition;
      var grainDuration = this.durationAbs;

      if (this.buffer) {
        var resamplingRate = 1.0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        // randomize grain duration
        if (this.durationVar > 0) grainDuration += (2.0 * Math.random() - 1) * this.durationVar;

        grainPeriod += this.periodRel * grainDuration;
        grainDuration += this.durationRel * grainPeriod;

        // grain period randon variation
        if (this.periodVar > 0.0) grainPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

        // center grain
        if (this.centered) grainPosition -= 0.5 * grainDuration;

        // randomize grain position
        if (this.positionVar > 0) grainPosition += (2.0 * Math.random() - 1) * this.positionVar;

        var bufferDuration = this.bufferDuration;

        // wrap or clip grain position and duration into buffer duration
        if (grainPosition < 0 || grainPosition >= bufferDuration) {
          if (this.cyclic) {
            var cycles = grainPosition / bufferDuration;
            grainPosition = (cycles - Math.floor(cycles)) * bufferDuration;

            if (grainPosition + grainDuration > this.buffer.duration) grainDuration = this.buffer.duration - grainPosition;
          } else {
            if (grainPosition < 0) {
              grainTime -= grainPosition;
              grainDuration += grainPosition;
              grainPosition = 0;
            }

            if (grainPosition + grainDuration > bufferDuration) grainDuration = bufferDuration - grainPosition;
          }
        }

        // make grain
        if (this.gain > 0 && grainDuration >= 0.001) {
          // make grain envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * grainDuration;
          var release = this.releaseAbs + this.releaseRel * grainDuration;

          if (attack + release > grainDuration) {
            var factor = grainDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = grainTime + attack;
          var grainEndTime = grainTime + grainDuration / resamplingRate;
          var releaseStartTime = grainEndTime - release;

          envelope.gain.value = 0;

          if (this.attackShape === 'lin') {
            envelope.gain.setValueAtTime(0.0, grainTime);
            envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);
          } else {
            envelope.gain.setValueAtTime(this.expRampOffset, grainTime);
            envelope.gain.exponentialRampToValueAtTime(this.gain, attackEndTime);
          }

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          if (this.releaseShape === 'lin') {
            envelope.gain.linearRampToValueAtTime(0.0, grainEndTime);
          } else {
            envelope.gain.exponentialRampToValueAtTime(this.expRampOffset, grainEndTime);
          }

          envelope.connect(this.outputNode);

          // make source
          var source = audioContext.createBufferSource();

          source.buffer = this.buffer;
          source.playbackRate.value = resamplingRate;
          source.connect(envelope);

          source.start(grainTime, grainPosition);
          source.stop(grainEndTime);
        }
      }

      return Math.max(this.periodMin, grainPeriod);
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }

    /**
     * Current position
     *
     * @type {Number}
     * @name currentPosition
     * @memberof GranularEngine
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return this.position;
    }
  }]);
  return GranularEngine;
}(_audioTimeEngine2.default);

exports.default = GranularEngine;

},{"../core/audio-time-engine":2,"babel-runtime/core-js/object/get-prototype-of":28,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/possibleConstructorReturn":39}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Metronome audio engine. It extends Time Engine as a transported interface.
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/metronome.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const metronome = new audio.Metronome({period: 0.333});
 *
 * scheduler.add(metronome);
 *
 * @param {Object} [options={}] - Default options
 * @param {Number} [options.period=1] - Metronome period
 * @param {Number} [options.clickFreq=600] - Metronome click frequency
 * @param {Number} [options.clickAttack=0.002] - Metronome click attack time
 * @param {Number} [options.clickRelease=0.098] - Metronome click release time
 * @param {Number} [options.gain=1] - Gain
 */

var Metronome = function (_AudioTimeEngine) {
  (0, _inherits3.default)(Metronome, _AudioTimeEngine);

  function Metronome() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Metronome);

    /**
     * Metronome period
     * @type {Number}
     * @private
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (Metronome.__proto__ || (0, _getPrototypeOf2.default)(Metronome)).call(this, options.audioContext));

    _this.__period = optOrDef(options.period, 1);

    /**
     * Metronome click frequency
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickFreq
     * @instance
     */
    _this.clickFreq = optOrDef(options.clickFreq, 600);

    /**
     * Metronome click attack time
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickAttack
     * @instance
     */
    _this.clickAttack = optOrDef(options.clickAttack, 0.002);

    /**
     * Metronome click release time
     *
     * @type {Number}
     * @memberof Metronome
     * @name clickRelease
     * @instance
     */
    _this.clickRelease = optOrDef(options.clickRelease, 0.098);

    _this.__lastTime = 0;
    _this.__phase = 0;

    _this.__gainNode = _this.audioContext.createGain();
    _this.__gainNode.gain.value = optOrDef(options.gain, 1);

    _this.outputNode = _this.__gainNode;
    return _this;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(Metronome, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      this.trigger(time);
      this.__lastTime = time;
      return time + this.__period;
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (this.__period > 0) {
        var nextPosition = (Math.floor(position / this.__period) + this.__phase) * this.__period;

        if (speed > 0 && nextPosition < position) nextPosition += this.__period;else if (speed < 0 && nextPosition > position) nextPosition -= this.__period;

        return nextPosition;
      }

      return Infinity * speed;
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      this.trigger(time);

      if (speed < 0) return position - this.__period;

      return position + this.__period;
    }

    /**
     * Trigger metronome click
     * @param {Number} time metronome click synthesis audio time
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var clickAttack = this.clickAttack;
      var clickRelease = this.clickRelease;

      var env = audioContext.createGain();
      env.gain.value = 0.0;
      env.gain.setValueAtTime(0, time);
      env.gain.linearRampToValueAtTime(1.0, time + clickAttack);
      env.gain.exponentialRampToValueAtTime(0.0000001, time + clickAttack + clickRelease);
      env.gain.setValueAtTime(0, time);
      env.connect(this.outputNode);

      var osc = audioContext.createOscillator();
      osc.frequency.value = this.clickFreq;
      osc.start(time);
      osc.stop(time + clickAttack + clickRelease);
      osc.connect(env);
    }

    /**
     * linear gain factor
     *
     * @type {Number}
     * @name gain
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'gain',
    set: function set(value) {
      this.__gainNode.gain.value = value;
    },
    get: function get() {
      return this.__gainNode.gain.value;
    }

    /**
     * metronome period
     *
     * @type {Number}
     * @name period
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'period',
    set: function set(period) {
      this.__period = period;

      var master = this.master;

      if (master) {
        if (master.resetEngineTime) master.resetEngineTime(this, this.__lastTime + period);else if (master.resetEnginePosition) master.resetEnginePosition(this);
      }
    },
    get: function get() {
      return this.__period;
    }

    /**
     * Set phase parameter (available only when 'transported'), should be
     * between [0, 1[
     *
     * @type {Number}
     * @name phase
     * @memberof Metronome
     * @instance
     */

  }, {
    key: 'phase',
    set: function set(phase) {
      this.__phase = phase - Math.floor(phase);

      var master = this.master;

      if (master && master.resetEnginePosition !== undefined) master.resetEnginePosition(this);
    },
    get: function get() {
      return this.__phase;
    }
  }]);
  return Metronome;
}(_audioTimeEngine2.default);

exports.default = Metronome;

},{"../core/audio-time-engine":2,"babel-runtime/core-js/object/get-prototype-of":28,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/possibleConstructorReturn":39}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

var _bufferedPv = require('../utils/buffered-pv');

var _bufferedPv2 = _interopRequireDefault(_bufferedPv);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//import PV from '../utils/simple-pv';


function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

function getCurrentOrPreviousIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value < firstVal) index = -1;else if (value >= lastVal) index = size - 1;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] > value) {
        index--;
      }while (sortedArray[index + 1] <= value) {
        index++;
      }
    }
  }

  return index;
}

function getCurrentOrNextIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value <= firstVal) index = 0;else if (value >= lastVal) index = size;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] < value) {
        index++;
      }while (sortedArray[index - 1] >= value) {
        index--;
      }
    }
  }

  return index;
}

/**
 * Used with a buffer to serve audio files via granular synthesis.
 *
 * The engine implements the "scheduled" and "transported" interfaces.
 * When "scheduled", the engine  generates segments more or less periodically
 * (controlled by the periodAbs, periodRel, and perioVar attributes).
 * When "transported", the engine generates segments at the position of their onset time.
 *
 * Example that shows a `PhasevocoderEngine` with a few parameter controls running in a `Scheduler`.
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/phasevocoder-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const PhasevocoderEngine = new audio.PhasevocoderEngine();
 *
 * scheduler.add(PhasevocoderEngine);
 *
 * @param {Object} [options={}] - Default options
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0] - Absolute segment period in sec
 * @param {Number} [options.periodRel=1] - Segment period relative to inter-segment distance
 * @param {Number} [options.periodVar=0] - Amout of random segment period variation relative
 *  to segment period
 * @param {Number} [options.periodMin=0.001] - Minimum segment period
 * @param {Number} [options.positionArray=[0.0]] - Array of segment positions (onset times
 *  in audio buffer) in sec
 * @param {Number} [options.positionVar=0] - Amout of random segment position variation in sec
 * @param {Number} [options.durationArray=[0.0]] - Array of segment durations in sec
 * @param {Number} [options.durationAbs=0] - Absolute segment duration in sec
 * @param {Number} [options.durationRel=1] - Segment duration relative to given segment
 *  duration or inter-segment distance
 * @param {Array} [options.offsetArray=[0.0]] - Array of segment offsets in sec
 * @param {Number} [options.offsetAbs=-0.005] - Absolute segment offset in sec
 * @param {Number} [options.offsetRel=0] - Segment offset relative to segment duration
 * @param {Number} [options.delay=0.005] - Time by which all segments are delayed (especially
 *  to realize segment offsets)
 * @param {Number} [options.attackAbs=0.005] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0] - Attack time relative to segment duration
 * @param {Number} [options.releaseAbs=0.005] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0] - Release time relative to segment duration
 * @param {Number} [options.resampling=0] - Segment resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Number} [options.abortTime=0.005] - fade-out time when aborted
 * @param {Number} [options.segmentIndex=0] - Index of the segment to synthesize (i.e. of
 *  this.positionArray/durationArray/offsetArray)
 * @param {Bool} [options.cyclic=false] - Whether the audio buffer and segment indices are
 *  considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the audio buffer
 *  that has been copied from the beginning to assure cyclic behavior
 */

var PhasevocoderEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(PhasevocoderEngine, _AudioTimeEngine);

  function PhasevocoderEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, PhasevocoderEngine);

    /**
     * Audio buffer
     * @name buffer
     * @type {AudioBuffer}
     * @default null
     * @memberof PhasevocoderEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (PhasevocoderEngine.__proto__ || (0, _getPrototypeOf2.default)(PhasevocoderEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute segment period in sec
     * @name periodAbs
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0);

    /**
     * Segment period relative to inter-segment distance
     * @name periodRel
     * @type {Number}
     * @default 1
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 1);

    /**
     * Amout of random segment period variation relative to segment period
     * @name periodVar
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum segment period
     * @name periodMin
     * @type {Number}
     * @default 0.001
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Array of segment positions (onset times in audio buffer) in sec
     * @name positionArray
     * @type {Number}
     * @default [0.0]
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.positionArray = optOrDef(options.positionArray, [0.0]);

    /**
     * Amout of random segment position variation in sec
     * @name positionVar
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0);

    /**
     * Array of segment durations in sec
     * @name durationArray
     * @type {Number}
     * @default [0.0]
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.durationArray = optOrDef(options.durationArray, [0.0]);

    /**
     * Absolute segment duration in sec
     * @name durationAbs
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0);

    /**
     * Segment duration relative to given segment duration or inter-segment distance
     * @name durationRel
     * @type {Number}
     * @default 1
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 1);

    /**
     * Array of segment offsets in sec
     *
     * offset > 0: the segment's reference position is after the given segment position
     * offset < 0: the given segment position is the segment's reference position
     * and the duration has to be corrected by the offset
     *
     * @name offsetArray
     * @type {Array}
     * @default [0.0]
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.offsetArray = optOrDef(options.offsetArray, [0.0]);

    /**
     * Absolute segment offset in sec
     * @name offsetAbs
     * @type {Number}
     * @default -0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.offsetAbs = optOrDef(options.offsetAbs, 0.000);

    /**
     * Segment offset relative to segment duration
     * @name offsetRel
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.offsetRel = optOrDef(options.offsetRel, 0);

    /**
     * Time by which all segments are delayed (especially to realize segment offsets)
     * @name delay
     * @type {Number}
     * @default 0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.delay = optOrDef(options.delay, 0.0);

    /**
     * Absolute attack time in sec
     * @name attackAbs
     * @type {Number}
     * @default 0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0.0);

    /**
     * Attack time relative to segment duration
     * @name attackRel
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0);

    /**
     * Absolute release time in sec
     * @name releaseAbs
     * @type {Number}
     * @default 0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0.0);

    /**
     * Release time relative to segment duration
     * @name releaseRel
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0);

    /**
     * Segment resampling in cent
     * @name resampling
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     * @name resamplingVar
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     * @name gain
     * @type {Number}
     * @default 1
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Index of the segment to synthesize (i.e. of this.positionArray/durationArray/offsetArray)
     * @name segmentIndex
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.segmentIndex = optOrDef(options.segmentIndex, 0);

    /**
     * Whether the audio buffer and segment indices are considered as cyclic
     * @name cyclic
     * @type {Bool}
     * @default false
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);
    _this.__cyclicOffset = 0;

    /**
     * Whether the last segment is aborted when triggering the next
     * @name monophonic
     * @type {Number}
     * @default false
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.monophonic = optOrDef(options.monophonic, false);
    _this.__currentSrc = null;
    _this.__currentEnv = null;
    _this.__releaseStartTime = 0;
    _this.__currentGain = 0;
    _this.__currentEndTime = 0;

    /**
     * Fade-out time (when aborted)
     * @name abortTime
     * @type {Number}
     * @default 0.005
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.abortTime = optOrDef(options.abortTime, 0.005);

    /**
     * Portion at the end of the audio buffer that has been copied from the beginning to assure cyclic behavior
     * @name wrapAroundExtension
     * @type {Number}
     * @default 0
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();

    /**
    * Optionally set function to use for FFT transform
    * @name setSTFT
    * @type {function}
    * @default null
    * @memberof PhasevocoderEngine
    * @instance
    */
    _this.setSTFT = function (_STFT) {
      this._pv.STFT = _STFT;
    };

    /**
    * Optionally set function to use for inverse FFT transform
    * @name setSTFT
    * @type {function}
    * @default null
    * @memberof PhasevocoderEngine
    * @instance
    */
    _this.setISTFT = function (_ISTFT) {
      this._pv.ISTFT = _ISTFT;
    };

    /**
     * Size of phasevocoder analysis frame
     * @name frameSize
     * @type {Number}
     * @default 4096
     * @memberof PhasevocoderEngine
     * @instance
     */
    _this.frameSize = optOrDef(options.frameSize, 2048);

    // Setup vocoder
    _this._pv = new _bufferedPv2.default(_this.frameSize); // new BufferedPV(this.frameSize);
    _this._pv.set_audio_buffer(_this.buffer);
    _this._pv.alpha = 2;

    // FIXME: BUFFER_SIZE not in use yet...
    // Thinking that if user dont provide segments (ie markerbuffer), 
    // then the engine just chops the buffer into chunks whith this size.
    _this.BUFFER_SIZE = 4096;

    /**
    * The amount to stretch the audio segments with
    * @name stretchFactor
    * @type {Number}
    * @default 1
    * @memberof PhasevocoderEngine
    * @instance
    */
    _this.stretchFactor = optOrDef(options.stretchFactor, 1);

    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @default 0
   * @memberof PhasevocoderEngine
   * @instance
   */


  (0, _createClass3.default)(PhasevocoderEngine, [{
    key: 'advanceTime',


    // TimeEngine method (transported interface)
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = 0;
      var bufferDuration = this.bufferDuration;

      if (this.cyclic) {
        var cycles = position / bufferDuration;

        cyclicOffset = Math.floor(cycles) * bufferDuration;
        position -= cyclicOffset;
      }

      if (speed > 0) {
        index = getCurrentOrNextIndex(this.positionArray, position);

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else if (speed < 0) {
        index = getCurrentOrPreviousIndex(this.positionArray, position);

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      } else {
        return Infinity;
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = this.__cyclicOffset;

      this.trigger(time);

      if (speed > 0) {
        index++;

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += this.bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else {
        index--;

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= this.bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    /**
     * Trigger a segment.
     * This function can be called at any time (whether the engine is scheduled/transported or not)
     * to generate a single segment according to the current segment parameters.
     *
     * @param {Number} time segment synthesis audio time
     * @return {Number} period to next segment
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var segmentTime = (time || audioContext.currentTime) + this.delay;
      var segmentPeriod = this.periodAbs;
      var segmentIndex = this.segmentIndex;

      if (this.buffer) {
        var segmentPosition = 0.0;
        var segmentDuration = 0.0;
        var segmentOffset = 0.0;
        var resamplingRate = 1.0;
        var bufferDuration = this.bufferDuration;

        if (this.cyclic) segmentIndex = segmentIndex % this.positionArray.length;else segmentIndex = Math.max(0, Math.min(segmentIndex, this.positionArray.length - 1));

        if (this.positionArray) segmentPosition = this.positionArray[segmentIndex] || 0;

        if (this.durationArray) segmentDuration = this.durationArray[segmentIndex] || 0;

        if (this.offsetArray) segmentOffset = this.offsetArray[segmentIndex] || 0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        // calculate inter-segment distance
        if (segmentDuration === 0 || this.periodRel > 0) {
          var nextSegmentIndex = segmentIndex + 1;
          var nextPosition, nextOffset;

          if (nextSegmentIndex === this.positionArray.length) {
            if (this.cyclic) {
              nextPosition = this.positionArray[0] + bufferDuration;
              nextOffset = this.offsetArray[0];
            } else {
              nextPosition = bufferDuration;
              nextOffset = 0;
            }
          } else {
            nextPosition = this.positionArray[nextSegmentIndex];
            nextOffset = this.offsetArray[nextSegmentIndex];
          }

          var interSegmentDistance = nextPosition - segmentPosition;

          // correct inter-segment distance by offsets
          //   offset > 0: the segment's reference position is after the given segment position
          if (segmentOffset > 0) interSegmentDistance -= segmentOffset;

          if (nextOffset > 0) interSegmentDistance += nextOffset;

          if (interSegmentDistance < 0) interSegmentDistance = 0;

          // use inter-segment distance instead of segment duration
          if (segmentDuration === 0) segmentDuration = interSegmentDistance;

          // calculate period relative to inter marker distance
          segmentPeriod += this.periodRel * interSegmentDistance;
        }

        // add relative and absolute segment duration
        segmentDuration *= this.durationRel;
        segmentDuration += this.durationAbs;

        // add relative and absolute segment offset
        segmentOffset *= this.offsetRel;
        segmentOffset += this.offsetAbs;

        // apply segment offset
        //   offset > 0: the segment's reference position is after the given segment position
        //   offset < 0: the given segment position is the segment's reference position and the duration has to be corrected by the offset
        if (segmentOffset < 0) {
          segmentDuration -= segmentOffset;
          segmentPosition += segmentOffset;
          segmentTime += segmentOffset / resamplingRate;
        } else {
          segmentTime -= segmentOffset / resamplingRate;
        }

        // randomize segment position
        if (this.positionVar > 0) segmentPosition += 2.0 * (Math.random() - 0.5) * this.positionVar;

        // shorten duration of segments over the edges of the buffer
        if (segmentPosition < 0) {
          //segmentTime -= grainPosition; hm, not sure if we want to do this
          segmentDuration += segmentPosition;
          segmentPosition = 0;
        }

        if (segmentPosition + segmentDuration > this.buffer.duration) segmentDuration = this.buffer.duration - segmentPosition;

        segmentDuration /= resamplingRate;

        if (this.monophonic) this.abort(segmentTime);

        // make segment
        if (this.gain > 0 && segmentDuration > 0) {
          // make segment envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * segmentDuration;
          var release = this.releaseAbs + this.releaseRel * segmentDuration;

          if (attack + release > segmentDuration) {
            var factor = segmentDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = segmentTime + attack;
          var segmentEndTime = segmentTime + segmentDuration;
          var releaseStartTime = segmentEndTime - release;

          envelope.gain.value = 0;
          envelope.gain.setValueAtTime(0.0, segmentTime);
          envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          envelope.gain.linearRampToValueAtTime(0.0, segmentEndTime);
          envelope.connect(this.outputNode);

          this.__currentEnv = envelope;

          // make source
          var source = audioContext.createBufferSource();

          // Buffer to save the stretch audio into

          var stretchedBuffer = audioContext.createBuffer(2, segmentDuration * audioContext.sampleRate, audioContext.sampleRate);

          // Set the phasevocoder's position in source buffer (ie this.buffer).
          this._pv.position = segmentPosition * audioContext.sampleRate;
          this._pv.process(stretchedBuffer);
          // FIXME: If phase is not reset, the audio is silenced when looped... dont know why...
          if (this.positionArray) {
            if (segmentIndex == this.positionArray.length - 1) {
              this._pv.resetPhase();
            }
          }

          source.buffer = stretchedBuffer;
          source.playbackRate.value = resamplingRate;
          //source.connect(envelope); //FIXME: Using envelope causes "tremolo" even if all ramping is 0.
          source.connect(audioContext.destination);

          source.start(segmentTime);
          source.stop(segmentTime + segmentDuration);

          this.__currentSrc = source;
          this.__releaseStartTime = releaseStartTime;
          this.__currentGain = this.gain;
          this.__currentEndTime = segmentEndTime;
        }
      }

      // grain period randon variation
      if (this.periodVar > 0.0) segmentPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

      return Math.max(this.periodMin, segmentPeriod);
    }

    /**
     * Abort the current segment at given time, fade out duration
     *
     * @param {Number} time - abort time
     */

  }, {
    key: 'abort',
    value: function abort(time) {
      var audioContext = this.audioContext;
      var endTime = this.__currentEndTime;
      var abortTime = time || audioContext.currentTime;

      if (abortTime < endTime) {
        var segmentEndTime = Math.min(abortTime + this.abortTime, endTime);
        var envelope = this.__currentEnv;
        var currentGainValue = this.__currentGain;

        if (abortTime > this.__releaseStartTime) {
          var releaseStart = this.__releaseStartTime;
          currentGainValue *= (abortTime - releaseStart) / (endTime - releaseStart);
        }

        envelope.gain.cancelScheduledValues(abortTime);
        envelope.gain.setValueAtTime(currentGainValue, abortTime);
        envelope.gain.linearRampToValueAtTime(0, segmentEndTime);

        this.__currentSrc = null;
        this.__currentEnv = null;
        this.__releaseStartTime = 0;
        this.__currentGain = 0;
        this.__currentEndTime = 0;
      }
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }
  }, {
    key: 'stretchFactor',
    set: function set(newAlpha) {
      if (this._pv) this._pv.alpha = newAlpha;
    }
  }]);
  return PhasevocoderEngine;
}(_audioTimeEngine2.default);

exports.default = PhasevocoderEngine;

},{"../core/audio-time-engine":2,"../utils/buffered-pv":19,"babel-runtime/core-js/object/get-prototype-of":28,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/possibleConstructorReturn":39}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

/**
 * Used with a buffer to serve audio files.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/player-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const playerEngine = audio.PlayerEngine();
 * const playControl = new audio.PlayControl(playerEngine);
 *
 * playControl.start();
 *
 * @param {Object} [options={}] - Default options
 * @param {Number} [options.buffer=1] - Audio buffer
 * @param {Number} [options.fadeTime=600] - Fade time for chaining segments
 * @param {Number} [options.cyclic=false] - Loop mode
 * @param {Number} [options.gain=1] - Gain
 */

var PlayerEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(PlayerEngine, _AudioTimeEngine);

  function PlayerEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, PlayerEngine);

    var _this = (0, _possibleConstructorReturn3.default)(this, (PlayerEngine.__proto__ || (0, _getPrototypeOf2.default)(PlayerEngine)).call(this, options.audioContext));

    _this.transport = null; // set when added to transporter

    /**
     * Audio buffer
     *
     * @type {AudioBuffer}
     * @name buffer
     * @memberof PlayerEngine
     * @instance
     * @default null
     */
    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Fade time for chaining segments (e.g. in start, stop, and seek)
     *
     * @type {Number}
     * @name fadeTime
     * @memberof PlayerEngine
     * @instance
     * @default 0.005
     */
    _this.fadeTime = optOrDef(options.fadeTime, 0.005);

    _this.__time = 0;
    _this.__position = 0;
    _this.__speed = 0;

    _this.__bufferSource = null;
    _this.__envNode = null;

    _this.__gainNode = _this.audioContext.createGain();
    _this.__gainNode.gain.value = optOrDef(options.gain, 1);

    _this.__cyclic = optOrDef(options.cyclic, false);

    _this.outputNode = _this.__gainNode;
    return _this;
  }

  (0, _createClass3.default)(PlayerEngine, [{
    key: '__start',
    value: function __start(time, position, speed) {
      var audioContext = this.audioContext;

      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.__cyclic && (position < 0 || position >= bufferDuration)) {
          var phase = position / bufferDuration;
          position = (phase - Math.floor(phase)) * bufferDuration;
        }

        if (position >= 0 && position < bufferDuration && speed > 0) {
          this.__envNode = audioContext.createGain();
          this.__envNode.gain.setValueAtTime(0, time);
          this.__envNode.gain.linearRampToValueAtTime(1, time + this.fadeTime);
          this.__envNode.connect(this.__gainNode);

          this.__bufferSource = audioContext.createBufferSource();
          this.__bufferSource.buffer = this.buffer;
          this.__bufferSource.playbackRate.value = speed;
          this.__bufferSource.loop = this.__cyclic;
          this.__bufferSource.loopStart = 0;
          this.__bufferSource.loopEnd = bufferDuration;
          this.__bufferSource.start(time, position);
          this.__bufferSource.connect(this.__envNode);
        }
      }
    }
  }, {
    key: '__halt',
    value: function __halt(time) {
      if (this.__bufferSource) {
        this.__envNode.gain.cancelScheduledValues(time);
        this.__envNode.gain.setValueAtTime(this.__envNode.gain.value, time);
        this.__envNode.gain.linearRampToValueAtTime(0, time + this.fadeTime);
        this.__bufferSource.stop(time + this.fadeTime);

        this.__bufferSource = null;
        this.__envNode = null;
      }
    }

    // TimeEngine method (speed-controlled interface)

  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      if (speed !== lastSpeed || seek) {
        if (seek || lastSpeed * speed < 0) {
          this.__halt(time);
          this.__start(time, position, speed);
        } else if (lastSpeed === 0 || seek) {
          this.__start(time, position, speed);
        } else if (speed === 0) {
          this.__halt(time);
        } else if (this.__bufferSource) {
          this.__bufferSource.playbackRate.setValueAtTime(speed, time);
        }

        this.__speed = speed;
      }
    }

    /**
     * Set whether the audio buffer is considered as cyclic
     * @type {Bool}
     * @name cyclic
     * @memberof PlayerEngine
     * @instance
     */

  }, {
    key: 'cyclic',
    set: function set(cyclic) {
      if (cyclic !== this.__cyclic) {
        var time = this.currentTime;
        var position = this.currentosition;

        this.__halt(time);
        this.__cyclic = cyclic;

        if (this.__speed !== 0) this.__start(time, position, this.__speed);
      }
    },
    get: function get() {
      return this.__cyclic;
    }

    /**
     * Linear gain factor
     * @type {Number}
     * @name gain
     * @memberof PlayerEngine
     * @instance
     */

  }, {
    key: 'gain',
    set: function set(value) {
      var time = this.currentTime;
      this.__gainNode.cancelScheduledValues(time);
      this.__gainNode.setValueAtTime(this.__gainNode.gain.value, time);
      this.__gainNode.linearRampToValueAtTime(0, time + this.fadeTime);
    },
    get: function get() {
      return this.__gainNode.gain.value;
    }

    /**
     * Get buffer duration
     * @type {Number}
     * @name bufferDuration
     * @memberof PlayerEngine
     * @instance
     * @readonly
     */

  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) return this.buffer.duration;

      return 0;
    }
  }]);
  return PlayerEngine;
}(_audioTimeEngine2.default);

exports.default = PlayerEngine;

},{"../core/audio-time-engine":2,"babel-runtime/core-js/object/get-prototype-of":28,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/possibleConstructorReturn":39}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
  if (opt !== undefined) return opt;

  return def;
}

function getCurrentOrPreviousIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value < firstVal) index = -1;else if (value >= lastVal) index = size - 1;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] > value) {
        index--;
      }while (sortedArray[index + 1] <= value) {
        index++;
      }
    }
  }

  return index;
}

function getCurrentOrNextIndex(sortedArray, value) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

  var size = sortedArray.length;

  if (size > 0) {
    var firstVal = sortedArray[0];
    var lastVal = sortedArray[size - 1];

    if (value <= firstVal) index = 0;else if (value >= lastVal) index = size;else {
      if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

      while (sortedArray[index] < value) {
        index++;
      }while (sortedArray[index - 1] >= value) {
        index--;
      }
    }
  }

  return index;
}

/**
 * Used with a buffer to serve audio files via granular synthesis.
 *
 * The engine implements the "scheduled" and "transported" interfaces.
 * When "scheduled", the engine  generates segments more or less periodically
 * (controlled by the periodAbs, periodRel, and perioVar attributes).
 * When "transported", the engine generates segments at the position of their onset time.
 *
 * Example that shows a `SegmentEngine` with a few parameter controls running in a `Scheduler`.
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/segment-engine.html}
 *
 * @extends AudioTimeEngine
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 * const segmentEngine = new audio.SegmentEngine();
 *
 * scheduler.add(segmentEngine);
 *
 * @param {Object} [options={}] - Default options
 * @param {AudioBuffer} [options.buffer=null] - Audio buffer
 * @param {Number} [options.periodAbs=0] - Absolute segment period in sec
 * @param {Number} [options.periodRel=1] - Segment period relative to inter-segment distance
 * @param {Number} [options.periodVar=0] - Amout of random segment period variation relative
 *  to segment period
 * @param {Number} [options.periodMin=0.001] - Minimum segment period
 * @param {Number} [options.positionArray=[0.0]] - Array of segment positions (onset times
 *  in audio buffer) in sec
 * @param {Number} [options.positionVar=0] - Amout of random segment position variation in sec
 * @param {Number} [options.durationArray=[0.0]] - Array of segment durations in sec
 * @param {Number} [options.durationAbs=0] - Absolute segment duration in sec
 * @param {Number} [options.durationRel=1] - Segment duration relative to given segment
 *  duration or inter-segment distance
 * @param {Array} [options.offsetArray=[0.0]] - Array of segment offsets in sec
 * @param {Number} [options.offsetAbs=-0.005] - Absolute segment offset in sec
 * @param {Number} [options.offsetRel=0] - Segment offset relative to segment duration
 * @param {Number} [options.delay=0.005] - Time by which all segments are delayed (especially
 *  to realize segment offsets)
 * @param {Number} [options.attackAbs=0.005] - Absolute attack time in sec
 * @param {Number} [options.attackRel=0] - Attack time relative to segment duration
 * @param {Number} [options.releaseAbs=0.005] - Absolute release time in sec
 * @param {Number} [options.releaseRel=0] - Release time relative to segment duration
 * @param {Number} [options.resampling=0] - Segment resampling in cent
 * @param {Number} [options.resamplingVar=0] - Amout of random resampling variation in cent
 * @param {Number} [options.gain=1] - Linear gain factor
 * @param {Number} [options.abortTime=0.005] - fade-out time when aborted
 * @param {Number} [options.segmentIndex=0] - Index of the segment to synthesize (i.e. of
 *  this.positionArray/durationArray/offsetArray)
 * @param {Bool} [options.cyclic=false] - Whether the audio buffer and segment indices are
 *  considered as cyclic
 * @param {Number} [options.wrapAroundExtension=0] - Portion at the end of the audio buffer
 *  that has been copied from the beginning to assure cyclic behavior
 */

var SegmentEngine = function (_AudioTimeEngine) {
  (0, _inherits3.default)(SegmentEngine, _AudioTimeEngine);

  function SegmentEngine() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SegmentEngine);

    /**
     * Audio buffer
     * @name buffer
     * @type {AudioBuffer}
     * @default null
     * @memberof SegmentEngine
     * @instance
     */
    var _this = (0, _possibleConstructorReturn3.default)(this, (SegmentEngine.__proto__ || (0, _getPrototypeOf2.default)(SegmentEngine)).call(this, options.audioContext));

    _this.buffer = optOrDef(options.buffer, null);

    /**
     * Absolute segment period in sec
     * @name periodAbs
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodAbs = optOrDef(options.periodAbs, 0);

    /**
     * Segment period relative to inter-segment distance
     * @name periodRel
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodRel = optOrDef(options.periodRel, 1);

    /**
     * Amout of random segment period variation relative to segment period
     * @name periodVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodVar = optOrDef(options.periodVar, 0);

    /**
     * Minimum segment period
     * @name periodMin
     * @type {Number}
     * @default 0.001
     * @memberof SegmentEngine
     * @instance
     */
    _this.periodMin = optOrDef(options.periodMin, 0.001);

    /**
     * Array of segment positions (onset times in audio buffer) in sec
     * @name positionArray
     * @type {Number}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.positionArray = optOrDef(options.positionArray, [0.0]);

    /**
     * Amout of random segment position variation in sec
     * @name positionVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.positionVar = optOrDef(options.positionVar, 0);

    /**
     * Array of segment durations in sec
     * @name durationArray
     * @type {Number}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationArray = optOrDef(options.durationArray, [0.0]);

    /**
     * Absolute segment duration in sec
     * @name durationAbs
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationAbs = optOrDef(options.durationAbs, 0);

    /**
     * Segment duration relative to given segment duration or inter-segment distance
     * @name durationRel
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.durationRel = optOrDef(options.durationRel, 1);

    /**
     * Array of segment offsets in sec
     *
     * offset > 0: the segment's reference position is after the given segment position
     * offset < 0: the given segment position is the segment's reference position
     * and the duration has to be corrected by the offset
     *
     * @name offsetArray
     * @type {Array}
     * @default [0.0]
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetArray = optOrDef(options.offsetArray, [0.0]);

    /**
     * Absolute segment offset in sec
     * @name offsetAbs
     * @type {Number}
     * @default -0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetAbs = optOrDef(options.offsetAbs, -0.005);

    /**
     * Segment offset relative to segment duration
     * @name offsetRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.offsetRel = optOrDef(options.offsetRel, 0);

    /**
     * Time by which all segments are delayed (especially to realize segment offsets)
     * @name delay
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.delay = optOrDef(options.delay, 0.005);

    /**
     * Absolute attack time in sec
     * @name attackAbs
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.attackAbs = optOrDef(options.attackAbs, 0.005);

    /**
     * Attack time relative to segment duration
     * @name attackRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.attackRel = optOrDef(options.attackRel, 0);

    /**
     * Absolute release time in sec
     * @name releaseAbs
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.releaseAbs = optOrDef(options.releaseAbs, 0.005);

    /**
     * Release time relative to segment duration
     * @name releaseRel
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.releaseRel = optOrDef(options.releaseRel, 0);

    /**
     * Segment resampling in cent
     * @name resampling
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.resampling = optOrDef(options.resampling, 0);

    /**
     * Amout of random resampling variation in cent
     * @name resamplingVar
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.resamplingVar = optOrDef(options.resamplingVar, 0);

    /**
     * Linear gain factor
     * @name gain
     * @type {Number}
     * @default 1
     * @memberof SegmentEngine
     * @instance
     */
    _this.gain = optOrDef(options.gain, 1);

    /**
     * Index of the segment to synthesize (i.e. of this.positionArray/durationArray/offsetArray)
     * @name segmentIndex
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.segmentIndex = optOrDef(options.segmentIndex, 0);

    /**
     * Whether the audio buffer and segment indices are considered as cyclic
     * @name cyclic
     * @type {Bool}
     * @default false
     * @memberof SegmentEngine
     * @instance
     */
    _this.cyclic = optOrDef(options.cyclic, false);
    _this.__cyclicOffset = 0;

    /**
     * Whether the last segment is aborted when triggering the next
     * @name monophonic
     * @type {Number}
     * @default false
     * @memberof SegmentEngine
     * @instance
     */
    _this.monophonic = optOrDef(options.monophonic, false);
    _this.__currentSrc = null;
    _this.__currentEnv = null;
    _this.__releaseStartTime = 0;
    _this.__currentGain = 0;
    _this.__currentEndTime = 0;

    /**
     * Fade-out time (when aborted)
     * @name abortTime
     * @type {Number}
     * @default 0.005
     * @memberof SegmentEngine
     * @instance
     */
    _this.abortTime = optOrDef(options.abortTime, 0.005);

    /**
     * Portion at the end of the audio buffer that has been copied from the beginning to assure cyclic behavior
     * @name wrapAroundExtension
     * @type {Number}
     * @default 0
     * @memberof SegmentEngine
     * @instance
     */
    _this.wrapAroundExtension = optOrDef(options.wrapAroundExtension, 0);

    _this.outputNode = _this.audioContext.createGain();
    return _this;
  }

  /**
   * Get buffer duration (excluding wrapAroundExtension)
   *
   * @type {Number}
   * @default 0
   * @memberof SegmentEngine
   * @instance
   */


  (0, _createClass3.default)(SegmentEngine, [{
    key: 'advanceTime',


    // TimeEngine method (transported interface)
    value: function advanceTime(time) {
      time = Math.max(time, this.audioContext.currentTime);
      return time + this.trigger(time);
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = 0;
      var bufferDuration = this.bufferDuration;

      if (this.cyclic) {
        var cycles = position / bufferDuration;

        cyclicOffset = Math.floor(cycles) * bufferDuration;
        position -= cyclicOffset;
      }

      if (speed > 0) {
        index = getCurrentOrNextIndex(this.positionArray, position);

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else if (speed < 0) {
        index = getCurrentOrPreviousIndex(this.positionArray, position);

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      } else {
        return Infinity;
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    // TimeEngine method (transported interface)

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var index = this.segmentIndex;
      var cyclicOffset = this.__cyclicOffset;

      this.trigger(time);

      if (speed > 0) {
        index++;

        if (index >= this.positionArray.length) {
          index = 0;
          cyclicOffset += this.bufferDuration;

          if (!this.cyclic) return Infinity;
        }
      } else {
        index--;

        if (index < 0) {
          index = this.positionArray.length - 1;
          cyclicOffset -= this.bufferDuration;

          if (!this.cyclic) return -Infinity;
        }
      }

      this.segmentIndex = index;
      this.__cyclicOffset = cyclicOffset;

      return cyclicOffset + this.positionArray[index];
    }

    /**
     * Trigger a segment.
     * This function can be called at any time (whether the engine is scheduled/transported or not)
     * to generate a single segment according to the current segment parameters.
     *
     * @param {Number} time segment synthesis audio time
     * @return {Number} period to next segment
     */

  }, {
    key: 'trigger',
    value: function trigger(time) {
      var audioContext = this.audioContext;
      var segmentTime = (time || audioContext.currentTime) + this.delay;
      var segmentPeriod = this.periodAbs;
      var segmentIndex = this.segmentIndex;

      if (this.buffer) {
        var segmentPosition = 0.0;
        var segmentDuration = 0.0;
        var segmentOffset = 0.0;
        var resamplingRate = 1.0;
        var bufferDuration = this.bufferDuration;

        if (this.cyclic) segmentIndex = segmentIndex % this.positionArray.length;else segmentIndex = Math.max(0, Math.min(segmentIndex, this.positionArray.length - 1));

        if (this.positionArray) segmentPosition = this.positionArray[segmentIndex] || 0;

        if (this.durationArray) segmentDuration = this.durationArray[segmentIndex] || 0;

        if (this.offsetArray) segmentOffset = this.offsetArray[segmentIndex] || 0;

        // calculate resampling
        if (this.resampling !== 0 || this.resamplingVar > 0) {
          var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
          resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
        }

        // calculate inter-segment distance
        if (segmentDuration === 0 || this.periodRel > 0) {
          var nextSegmentIndex = segmentIndex + 1;
          var nextPosition, nextOffset;

          if (nextSegmentIndex === this.positionArray.length) {
            if (this.cyclic) {
              nextPosition = this.positionArray[0] + bufferDuration;
              nextOffset = this.offsetArray[0];
            } else {
              nextPosition = bufferDuration;
              nextOffset = 0;
            }
          } else {
            nextPosition = this.positionArray[nextSegmentIndex];
            nextOffset = this.offsetArray[nextSegmentIndex];
          }

          var interSegmentDistance = nextPosition - segmentPosition;

          // correct inter-segment distance by offsets
          //   offset > 0: the segment's reference position is after the given segment position
          if (segmentOffset > 0) interSegmentDistance -= segmentOffset;

          if (nextOffset > 0) interSegmentDistance += nextOffset;

          if (interSegmentDistance < 0) interSegmentDistance = 0;

          // use inter-segment distance instead of segment duration
          if (segmentDuration === 0) segmentDuration = interSegmentDistance;

          // calculate period relative to inter marker distance
          segmentPeriod += this.periodRel * interSegmentDistance;
        }

        // add relative and absolute segment duration
        segmentDuration *= this.durationRel;
        segmentDuration += this.durationAbs;

        // add relative and absolute segment offset
        segmentOffset *= this.offsetRel;
        segmentOffset += this.offsetAbs;

        // apply segment offset
        //   offset > 0: the segment's reference position is after the given segment position
        //   offset < 0: the given segment position is the segment's reference position and the duration has to be corrected by the offset
        if (segmentOffset < 0) {
          segmentDuration -= segmentOffset;
          segmentPosition += segmentOffset;
          segmentTime += segmentOffset / resamplingRate;
        } else {
          segmentTime -= segmentOffset / resamplingRate;
        }

        // randomize segment position
        if (this.positionVar > 0) segmentPosition += 2.0 * (Math.random() - 0.5) * this.positionVar;

        // shorten duration of segments over the edges of the buffer
        if (segmentPosition < 0) {
          //segmentTime -= grainPosition; hm, not sure if we want to do this
          segmentDuration += segmentPosition;
          segmentPosition = 0;
        }

        if (segmentPosition + segmentDuration > this.buffer.duration) segmentDuration = this.buffer.duration - segmentPosition;

        segmentDuration /= resamplingRate;

        if (this.monophonic) this.abort(segmentTime);

        // make segment
        if (this.gain > 0 && segmentDuration > 0) {
          // make segment envelope
          var envelope = audioContext.createGain();
          var attack = this.attackAbs + this.attackRel * segmentDuration;
          var release = this.releaseAbs + this.releaseRel * segmentDuration;

          if (attack + release > segmentDuration) {
            var factor = segmentDuration / (attack + release);
            attack *= factor;
            release *= factor;
          }

          var attackEndTime = segmentTime + attack;
          var segmentEndTime = segmentTime + segmentDuration;
          var releaseStartTime = segmentEndTime - release;

          envelope.gain.value = 0;
          envelope.gain.setValueAtTime(0.0, segmentTime);
          envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);

          if (releaseStartTime > attackEndTime) envelope.gain.setValueAtTime(this.gain, releaseStartTime);

          envelope.gain.linearRampToValueAtTime(0.0, segmentEndTime);
          envelope.connect(this.outputNode);

          this.__currentEnv = envelope;

          // make source
          var source = audioContext.createBufferSource();

          source.buffer = this.buffer;
          source.playbackRate.value = resamplingRate;
          source.connect(envelope);

          source.start(segmentTime, segmentPosition);
          source.stop(segmentTime + segmentDuration);

          this.__currentSrc = source;
          this.__releaseStartTime = releaseStartTime;
          this.__currentGain = this.gain;
          this.__currentEndTime = segmentEndTime;
        }
      }

      // grain period randon variation
      if (this.periodVar > 0.0) segmentPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

      return Math.max(this.periodMin, segmentPeriod);
    }

    /**
     * Abort the current segment at given time, fade out duration
     *
     * @param {Number} time - abort time
     */

  }, {
    key: 'abort',
    value: function abort(time) {
      var audioContext = this.audioContext;
      var endTime = this.__currentEndTime;
      var abortTime = time || audioContext.currentTime;

      if (abortTime < endTime) {
        var segmentEndTime = Math.min(abortTime + this.abortTime, endTime);
        var envelope = this.__currentEnv;
        var currentGainValue = this.__currentGain;

        if (abortTime > this.__releaseStartTime) {
          var releaseStart = this.__releaseStartTime;
          currentGainValue *= (abortTime - releaseStart) / (endTime - releaseStart);
        }

        envelope.gain.cancelScheduledValues(abortTime);
        envelope.gain.setValueAtTime(currentGainValue, abortTime);
        envelope.gain.linearRampToValueAtTime(0, segmentEndTime);

        this.__currentSrc = null;
        this.__currentEnv = null;
        this.__releaseStartTime = 0;
        this.__currentGain = 0;
        this.__currentEndTime = 0;
      }
    }
  }, {
    key: 'bufferDuration',
    get: function get() {
      if (this.buffer) {
        var bufferDuration = this.buffer.duration;

        if (this.wrapAroundExtension) bufferDuration -= this.wrapAroundExtension;

        return bufferDuration;
      }

      return 0;
    }
  }]);
  return SegmentEngine;
}(_audioTimeEngine2.default);

exports.default = SegmentEngine;

},{"../core/audio-time-engine":2,"babel-runtime/core-js/object/get-prototype-of":28,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/possibleConstructorReturn":39}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioTimeEngine = require('../core/audio-time-engine');

var _audioTimeEngine2 = _interopRequireDefault(_audioTimeEngine);

var _segmentEngine = require('./segment-engine');

var _segmentEngine2 = _interopRequireDefault(_segmentEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optOrDef(opt, def) {
    if (opt !== undefined) return opt;

    return def;
}

function getCurrentOrPreviousIndex(sortedArray, value) {
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

    var size = sortedArray.length;

    if (size > 0) {
        var firstVal = sortedArray[0];
        var lastVal = sortedArray[size - 1];

        if (value < firstVal) index = -1;else if (value >= lastVal) index = size - 1;else {
            if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

            while (sortedArray[index] > value) {
                index--;
            }while (sortedArray[index + 1] <= value) {
                index++;
            }
        }
    }

    return index;
}

function getCurrentOrNextIndex(sortedArray, value) {
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

    var size = sortedArray.length;

    if (size > 0) {
        var firstVal = sortedArray[0];
        var lastVal = sortedArray[size - 1];

        if (value <= firstVal) index = 0;else if (value >= lastVal) index = size;else {
            if (index < 0 || index >= size) index = Math.floor((size - 1) * (value - firstVal) / (lastVal - firstVal));

            while (sortedArray[index] < value) {
                index++;
            }while (sortedArray[index - 1] >= value) {
                index--;
            }
        }
    }

    return index;
}

/**
 * @class SequencerEngine
 */

var SequencerEngine = function (_SegmentEngine) {
    (0, _inherits3.default)(SequencerEngine, _SegmentEngine);

    /**
     * @constructor
     * @param {AudioBuffer} buffer initial audio buffer for granular synthesis
     *
     * The engine implements the "scheduled" and "transported" interfaces.
     * When "scheduled", the engine  generates segments more or less periodically
     * (controlled by the periodAbs, periodRel, and perioVar attributes).
     * When "transported", the engine generates segments at the position of their onset time.
     */
    function SequencerEngine() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        (0, _classCallCheck3.default)(this, SequencerEngine);

        /**
         * A function callback that gets called from trigger().
         * This lets you set up events to be triggered by the sequencer.
         * @type {Function}
         */
        var _this = (0, _possibleConstructorReturn3.default)(this, (SequencerEngine.__proto__ || (0, _getPrototypeOf2.default)(SequencerEngine)).call(this, options));

        _this.callback = optOrDef(options.callback, null);

        return _this;
    }

    /**
     * Trigger a segment
     * @param {Number} time segment synthesis audio time
     * @return {Number} period to next segment
     *
     * This function can be called at any time (whether the engine is scheduled/transported or not)
     * to generate a single segment according to the current segment parameters.
     */


    (0, _createClass3.default)(SequencerEngine, [{
        key: 'trigger',
        value: function trigger(time) {
            var audioContext = this.audioContext;
            var segmentTime = (time || audioContext.currentTime) + this.delay;
            var segmentPeriod = this.periodAbs;
            var segmentIndex = this.segmentIndex;

            // Ignore buffer for now, this is a sequncer... no audio produced.
            if ( /*this.buffer*/true) {
                var segmentPosition = 0.0;
                var segmentDuration = 0.0;
                var segmentOffset = 0.0;
                var resamplingRate = 1.0;
                var bufferDuration = this.bufferDuration;

                if (this.cyclic) segmentIndex = segmentIndex % this.positionArray.length;else segmentIndex = Math.max(0, Math.min(segmentIndex, this.positionArray.length - 1));

                if (this.positionArray) segmentPosition = this.positionArray[segmentIndex] || 0;

                if (this.durationArray) segmentDuration = this.durationArray[segmentIndex] || 0;

                if (this.offsetArray) segmentOffset = this.offsetArray[segmentIndex] || 0;

                // calculate resampling
                if (this.resampling !== 0 || this.resamplingVar > 0) {
                    var randomResampling = (Math.random() - 0.5) * 2.0 * this.resamplingVar;
                    resamplingRate = Math.pow(2.0, (this.resampling + randomResampling) / 1200.0);
                }

                // calculate inter-segment distance
                if (segmentDuration === 0 || this.periodRel > 0) {
                    var nextSegmentIndex = segmentIndex + 1;
                    var nextPosition, nextOffset;

                    if (nextSegmentIndex === this.positionArray.length) {
                        if (this.cyclic) {
                            nextPosition = this.positionArray[0] + bufferDuration;
                            nextOffset = this.offsetArray[0];
                        } else {
                            nextPosition = bufferDuration;
                            nextOffset = 0;
                        }
                    } else {
                        nextPosition = this.positionArray[nextSegmentIndex];
                        nextOffset = this.offsetArray[nextSegmentIndex];
                    }

                    var interSegmentDistance = nextPosition - segmentPosition;

                    // correct inter-segment distance by offsets
                    //   offset > 0: the segment's reference position is after the given segment position
                    if (segmentOffset > 0) interSegmentDistance -= segmentOffset;

                    if (nextOffset > 0) interSegmentDistance += nextOffset;

                    if (interSegmentDistance < 0) interSegmentDistance = 0;

                    // use inter-segment distance instead of segment duration
                    if (segmentDuration === 0) segmentDuration = interSegmentDistance;

                    // calculate period relative to inter marker distance
                    segmentPeriod += this.periodRel * interSegmentDistance;
                }
                /*
                // add relative and absolute segment duration
                segmentDuration *= this.durationRel;
                segmentDuration += this.durationAbs;
                  // add relative and absolute segment offset
                segmentOffset *= this.offsetRel;
                segmentOffset += this.offsetAbs;
                  // apply segment offset
                //   offset > 0: the segment's reference position is after the given segment position
                //   offset < 0: the given segment position is the segment's reference position and the duration has to be corrected by the offset
                if (segmentOffset < 0) {
                    segmentDuration -= segmentOffset;
                    segmentPosition += segmentOffset;
                    segmentTime += (segmentOffset / resamplingRate);
                } else {
                    segmentTime -= (segmentOffset / resamplingRate);
                }
                  // randomize segment position
                if (this.positionVar > 0)
                    segmentPosition += 2.0 * (Math.random() - 0.5) * this.positionVar;
                  // shorten duration of segments over the edges of the buffer
                if (segmentPosition < 0) {
                    //segmentTime -= grainPosition; hm, not sure if we want to do this
                    segmentDuration += segmentPosition;
                    segmentPosition = 0;
                }
                  if (segmentPosition + segmentDuration > this.buffer.duration)
                    segmentDuration = this.buffer.duration - segmentPosition;
                  segmentDuration /= resamplingRate;
                  // make segment
                if (this.gain > 0 && segmentDuration > 0) {
                  // make segment envelope
                  var envelope = audioContext.createGain();
                  var attack = this.attackAbs + this.attackRel * segmentDuration;
                  var release = this.releaseAbs + this.releaseRel * segmentDuration;
                    if (attack + release > segmentDuration) {
                    var factor = segmentDuration / (attack + release);
                    attack *= factor;
                    release *= factor;
                  }
                    var attackEndTime = segmentTime + attack;
                  var segmentEndTime = segmentTime + segmentDuration;
                  var releaseStartTime = segmentEndTime - release;
                    envelope.gain.value = 0;
                  envelope.gain.setValueAtTime(0.0, segmentTime);
                  envelope.gain.linearRampToValueAtTime(this.gain, attackEndTime);
                    if (releaseStartTime > attackEndTime)
                    envelope.gain.setValueAtTime(this.gain, releaseStartTime);
                    envelope.gain.linearRampToValueAtTime(0.0, segmentEndTime);
                  envelope.connect(this.outputNode);
                    // make source
                  var source = audioContext.createBufferSource();
                    source.buffer = this.buffer;
                  source.playbackRate.value = resamplingRate;
                  source.connect(envelope);
                    source.start(segmentTime, segmentPosition);
                  source.stop(segmentTime + segmentDuration);
                }*/
            }

            if (this.callback && Object.prototype.toString.call(this.callback) == '[object Function]') {
                var result = this.callback(segmentIndex);
                //if (result)
                //    console.log(result);
            }

            //console.log("Sequencer.Trigger: " + segmentIndex + " Position: " + segmentPosition);

            // grain period randon variation
            if (this.periodVar > 0.0) segmentPeriod += 2.0 * (Math.random() - 0.5) * this.periodVar * grainPeriod;

            return Math.max(this.periodMin, segmentPeriod);
        }
    }]);
    return SequencerEngine;
}(_segmentEngine2.default);

exports.default = SequencerEngine;

},{"../core/audio-time-engine":2,"./segment-engine":10,"babel-runtime/core-js/object/get-prototype-of":28,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/possibleConstructorReturn":39}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _audioContext = require('./core/audio-context');

Object.defineProperty(exports, 'audioContext', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioContext).default;
  }
});

var _timeEngine = require('./core/time-engine');

Object.defineProperty(exports, 'TimeEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_timeEngine).default;
  }
});

var _audioTimeEngine = require('./core/audio-time-engine');

Object.defineProperty(exports, 'AudioTimeEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioTimeEngine).default;
  }
});

var _priorityQueue = require('./core/priority-queue');

Object.defineProperty(exports, 'PriorityQueue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_priorityQueue).default;
  }
});

var _schedulingQueue = require('./core/scheduling-queue');

Object.defineProperty(exports, 'SchedulingQueue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_schedulingQueue).default;
  }
});

var _granularEngine = require('./engines/granular-engine');

Object.defineProperty(exports, 'GranularEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_granularEngine).default;
  }
});

var _metronome = require('./engines/metronome');

Object.defineProperty(exports, 'Metronome', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_metronome).default;
  }
});

var _playerEngine = require('./engines/player-engine');

Object.defineProperty(exports, 'PlayerEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_playerEngine).default;
  }
});

var _segmentEngine = require('./engines/segment-engine');

Object.defineProperty(exports, 'SegmentEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_segmentEngine).default;
  }
});

var _sequencerEngine = require('./engines/sequencer-engine');

Object.defineProperty(exports, 'SequencerEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sequencerEngine).default;
  }
});

var _phasevocoderEngine = require('./engines/phasevocoder-engine');

Object.defineProperty(exports, 'PhasevocoderEngine', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_phasevocoderEngine).default;
  }
});

var _pulseTransforms = require('./utils/pulse-transforms');

Object.defineProperty(exports, 'PulseFFTTransforms', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_pulseTransforms).default;
  }
});

var _playControl = require('./masters/play-control');

Object.defineProperty(exports, 'PlayControl', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_playControl).default;
  }
});

var _transport = require('./masters/transport');

Object.defineProperty(exports, 'Transport', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_transport).default;
  }
});

var _scheduler = require('./masters/scheduler');

Object.defineProperty(exports, 'Scheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_scheduler).default;
  }
});

var _simpleScheduler = require('./masters/simple-scheduler');

Object.defineProperty(exports, 'SimpleScheduler', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_simpleScheduler).default;
  }
});

var _factories = require('./masters/factories');

Object.defineProperty(exports, 'getScheduler', {
  enumerable: true,
  get: function get() {
    return _factories.getScheduler;
  }
});
Object.defineProperty(exports, 'getSimpleScheduler', {
  enumerable: true,
  get: function get() {
    return _factories.getSimpleScheduler;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

},{"./core/audio-context":1,"./core/audio-time-engine":2,"./core/priority-queue":3,"./core/scheduling-queue":4,"./core/time-engine":5,"./engines/granular-engine":6,"./engines/metronome":7,"./engines/phasevocoder-engine":8,"./engines/player-engine":9,"./engines/segment-engine":10,"./engines/sequencer-engine":11,"./masters/factories":13,"./masters/play-control":14,"./masters/scheduler":15,"./masters/simple-scheduler":16,"./masters/transport":17,"./utils/pulse-transforms":22}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSimpleScheduler = exports.getScheduler = undefined;

var _weakMap = require('babel-runtime/core-js/weak-map');

var _weakMap2 = _interopRequireDefault(_weakMap);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _scheduler = require('./scheduler');

var _scheduler2 = _interopRequireDefault(_scheduler);

var _simpleScheduler = require('./simple-scheduler');

var _simpleScheduler2 = _interopRequireDefault(_simpleScheduler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var schedulerMap = new _weakMap2.default(); // schedulers should be singletons

var simpleSchedulerMap = new _weakMap2.default();

/**
 * Returns a unique instance of `Scheduler`
 *
 * @global
 * @function
 * @returns {Scheduler}
 * @see Scheduler
 */
var getScheduler = exports.getScheduler = function getScheduler() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;

  var scheduler = schedulerMap.get(audioContext);

  if (!scheduler) {
    scheduler = new _scheduler2.default({ audioContext: audioContext });
    schedulerMap.set(audioContext, scheduler);
  }

  return scheduler;
};

/**
 * Returns a unique instance of `SimpleScheduler`
 *
 * @global
 * @function
 * @returns {SimpleScheduler}
 * @see SimpleScheduler
 */
var getSimpleScheduler = exports.getSimpleScheduler = function getSimpleScheduler() {
  var audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _audioContext2.default;

  var simpleScheduler = simpleSchedulerMap.get(audioContext);

  if (!simpleScheduler) {
    simpleScheduler = new _simpleScheduler2.default({ audioContext: audioContext });
    simpleSchedulerMap.set(audioContext, simpleScheduler);
  }

  return simpleScheduler;
};

},{"../core/audio-context":1,"./scheduler":15,"./simple-scheduler":16,"babel-runtime/core-js/weak-map":34}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _factories = require('./factories');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EPSILON = 1e-8;

var LoopControl = function (_TimeEngine) {
  (0, _inherits3.default)(LoopControl, _TimeEngine);

  function LoopControl(playControl) {
    (0, _classCallCheck3.default)(this, LoopControl);

    var _this = (0, _possibleConstructorReturn3.default)(this, (LoopControl.__proto__ || (0, _getPrototypeOf2.default)(LoopControl)).call(this));

    _this.__playControl = playControl;
    _this.speed = 1;
    _this.lower = -Infinity;
    _this.upper = Infinity;
    return _this;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(LoopControl, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var playControl = this.__playControl;
      var speed = this.speed;
      var lower = this.lower;
      var upper = this.upper;

      if (speed > 0) time += EPSILON;else time -= EPSILON;

      if (speed > 0) {
        playControl.syncSpeed(time, lower, speed, true);
        return playControl.__getTimeAtPosition(upper) - EPSILON;
      } else if (speed < 0) {
        playControl.syncSpeed(time, upper, speed, true);
        return playControl.__getTimeAtPosition(lower) + EPSILON;
      }

      return Infinity;
    }
  }, {
    key: 'reschedule',
    value: function reschedule(speed) {
      var playControl = this.__playControl;
      var lower = Math.min(playControl.__loopStart, playControl.__loopEnd);
      var upper = Math.max(playControl.__loopStart, playControl.__loopEnd);

      this.speed = speed;
      this.lower = lower;
      this.upper = upper;

      if (lower === upper) speed = 0;

      if (speed > 0) this.resetTime(playControl.__getTimeAtPosition(upper) - EPSILON);else if (speed < 0) this.resetTime(playControl.__getTimeAtPosition(lower) + EPSILON);else this.resetTime(Infinity);
    }
  }, {
    key: 'applyLoopBoundaries',
    value: function applyLoopBoundaries(position, speed) {
      var lower = this.lower;
      var upper = this.upper;

      if (speed > 0 && position >= upper) return lower + (position - lower) % (upper - lower);else if (speed < 0 && position < lower) return upper - (upper - position) % (upper - lower);

      return position;
    }
  }]);
  return LoopControl;
}(_timeEngine2.default);

// play controlled base class


var PlayControlled = function () {
  function PlayControlled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlled);

    this.__playControl = playControl;

    engine.master = this;
    this.__engine = engine;
  }

  (0, _createClass3.default)(PlayControlled, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      this.__engine.syncSpeed(time, position, speed, seek);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__playControl = null;

      this.__engine.master = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlled;
}();

// play control for engines implementing the *speed-controlled* interface


var PlayControlledSpeedControlled = function (_PlayControlled) {
  (0, _inherits3.default)(PlayControlledSpeedControlled, _PlayControlled);

  function PlayControlledSpeedControlled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSpeedControlled);
    return (0, _possibleConstructorReturn3.default)(this, (PlayControlledSpeedControlled.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSpeedControlled)).call(this, playControl, engine));
  }

  return PlayControlledSpeedControlled;
}(PlayControlled);

// play control for engines implmenting the *transported* interface


var PlayControlledTransported = function (_PlayControlled2) {
  (0, _inherits3.default)(PlayControlledTransported, _PlayControlled2);

  function PlayControlledTransported(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledTransported);

    var _this3 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledTransported.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledTransported)).call(this, playControl, engine));

    _this3.__schedulerHook = new PlayControlledSchedulerHook(playControl, engine);
    return _this3;
  }

  (0, _createClass3.default)(PlayControlledTransported, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      if (speed !== lastSpeed || seek && speed !== 0) {
        var nextPosition;

        // resync transported engines
        if (seek || speed * lastSpeed < 0) {
          // seek or reverse direction
          nextPosition = this.__engine.syncPosition(time, position, speed);
        } else if (lastSpeed === 0) {
          // start
          nextPosition = this.__engine.syncPosition(time, position, speed);
        } else if (speed === 0) {
          // stop
          nextPosition = Infinity;

          if (this.__engine.syncSpeed) this.__engine.syncSpeed(time, position, 0);
        } else if (this.__engine.syncSpeed) {
          // change speed without reversing direction
          this.__engine.syncSpeed(time, position, speed);
        }

        this.__schedulerHook.resetPosition(nextPosition);
      }
    }
  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(engine) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (position === undefined) {
        var playControl = this.__playControl;
        var time = playControl.__sync();

        position = this.__engine.syncPosition(time, playControl.__position, playControl.__speed);
      }

      this.__schedulerHook.resetPosition(position);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__schedulerHook.destroy();
      this.__schedulerHook = null;

      (0, _get3.default)(PlayControlledTransported.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledTransported.prototype), 'destroy', this).call(this);
    }
  }]);
  return PlayControlledTransported;
}(PlayControlled);

// play control for time engines implementing the *scheduled* interface


var PlayControlledScheduled = function (_PlayControlled3) {
  (0, _inherits3.default)(PlayControlledScheduled, _PlayControlled3);

  function PlayControlledScheduled(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledScheduled);

    // scheduling queue becomes master of engine
    var _this4 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledScheduled.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledScheduled)).call(this, playControl, engine));

    engine.master = null;
    _this4.__schedulingQueue = new PlayControlledSchedulingQueue(playControl, engine);
    return _this4;
  }

  (0, _createClass3.default)(PlayControlledScheduled, [{
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed, seek, lastSpeed) {
      if (lastSpeed === 0 && speed !== 0) // start or seek
        this.__engine.resetTime();else if (lastSpeed !== 0 && speed === 0) // stop
        this.__engine.resetTime(Infinity);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__schedulingQueue.destroy();
      (0, _get3.default)(PlayControlledScheduled.prototype.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledScheduled.prototype), 'destroy', this).call(this);
    }
  }]);
  return PlayControlledScheduled;
}(PlayControlled);

// translates transported engine advancePosition into global scheduler times


var PlayControlledSchedulerHook = function (_TimeEngine2) {
  (0, _inherits3.default)(PlayControlledSchedulerHook, _TimeEngine2);

  function PlayControlledSchedulerHook(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSchedulerHook);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledSchedulerHook.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSchedulerHook)).call(this));

    _this5.__playControl = playControl;
    _this5.__engine = engine;

    _this5.__nextPosition = Infinity;
    playControl.__scheduler.add(_this5, Infinity);
    return _this5;
  }

  (0, _createClass3.default)(PlayControlledSchedulerHook, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var playControl = this.__playControl;
      var engine = this.__engine;
      var position = this.__nextPosition;
      var nextPosition = engine.advancePosition(time, position, playControl.__speed);
      var nextTime = playControl.__getTimeAtPosition(nextPosition);

      this.__nextPosition = nextPosition;
      return nextTime;
    }
  }, {
    key: 'resetPosition',
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__nextPosition;

      var time = this.__playControl.__getTimeAtPosition(position);
      this.__nextPosition = position;
      this.resetTime(time);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__playControl.__scheduler.remove(this);
      this.__playControl = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlledSchedulerHook;
}(_timeEngine2.default);

// internal scheduling queue that returns the current position (and time) of the play control


var PlayControlledSchedulingQueue = function (_SchedulingQueue) {
  (0, _inherits3.default)(PlayControlledSchedulingQueue, _SchedulingQueue);

  function PlayControlledSchedulingQueue(playControl, engine) {
    (0, _classCallCheck3.default)(this, PlayControlledSchedulingQueue);

    var _this6 = (0, _possibleConstructorReturn3.default)(this, (PlayControlledSchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(PlayControlledSchedulingQueue)).call(this));

    _this6.__playControl = playControl;
    _this6.__engine = engine;

    _this6.add(engine, Infinity);
    playControl.__scheduler.add(_this6, Infinity);
    return _this6;
  }

  (0, _createClass3.default)(PlayControlledSchedulingQueue, [{
    key: 'destroy',
    value: function destroy() {
      this.__playControl.__scheduler.remove(this);
      this.remove(this.__engine);

      this.__playControl = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__playControl.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__playControl.currentPosition;
    }
  }]);
  return PlayControlledSchedulingQueue;
}(_schedulingQueue2.default);

/**
 * Extends Time Engine to provide playback control of a Time Engine instance.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/play-control.html}
 *
 * @extends TimeEngine
 * @param {TimeEngine} engine - engine to control
 *
 * @example
 * import * as audio from 'waves-audio';
 * const playerEngine = audio.PlayerEngine();
 * const playControl = new audio.PlayControl(playerEngine);
 *
 * playControl.start();
 */


var PlayControl = function (_TimeEngine3) {
  (0, _inherits3.default)(PlayControl, _TimeEngine3);

  function PlayControl(engine) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (0, _classCallCheck3.default)(this, PlayControl);

    var _this7 = (0, _possibleConstructorReturn3.default)(this, (PlayControl.__proto__ || (0, _getPrototypeOf2.default)(PlayControl)).call(this));

    _this7.audioContext = options.audioContext || _audioContext2.default;
    _this7.__scheduler = (0, _factories.getScheduler)(_this7.audioContext);

    _this7.__playControlled = null;

    _this7.__loopControl = null;
    _this7.__loopStart = 0;
    _this7.__loopEnd = 1;

    // synchronized tie, position, and speed
    _this7.__time = 0;
    _this7.__position = 0;
    _this7.__speed = 0;

    // non-zero "user" speed
    _this7.__playingSpeed = 1;

    if (engine) _this7.__setEngine(engine);
    return _this7;
  }

  (0, _createClass3.default)(PlayControl, [{
    key: '__setEngine',
    value: function __setEngine(engine) {
      if (engine.master) throw new Error("object has already been added to a master");

      if (_timeEngine2.default.implementsSpeedControlled(engine)) this.__playControlled = new PlayControlledSpeedControlled(this, engine);else if (_timeEngine2.default.implementsTransported(engine)) this.__playControlled = new PlayControlledTransported(this, engine);else if (_timeEngine2.default.implementsScheduled(engine)) this.__playControlled = new PlayControlledScheduled(this, engine);else throw new Error("object cannot be added to play control");
    }
  }, {
    key: '__resetEngine',
    value: function __resetEngine() {
      this.__playControlled.destroy();
      this.__playControlled = null;
    }

    /**
     * Calculate/extrapolate playing time for given position
     *
     * @param {Number} position position
     * @return {Number} extrapolated time
     * @private
     */

  }, {
    key: '__getTimeAtPosition',
    value: function __getTimeAtPosition(position) {
      return this.__time + (position - this.__position) / this.__speed;
    }

    /**
     * Calculate/extrapolate playing position for given time
     *
     * @param {Number} time time
     * @return {Number} extrapolated position
     * @private
     */

  }, {
    key: '__getPositionAtTime',
    value: function __getPositionAtTime(time) {
      return this.__position + (time - this.__time) * this.__speed;
    }
  }, {
    key: '__sync',
    value: function __sync() {
      var now = this.currentTime;
      this.__position += (now - this.__time) * this.__speed;
      this.__time = now;
      return now;
    }

    /**
     * Get current master time.
     * This function will be replaced when the play-control is added to a master.
     *
     * @name currentTime
     * @type {Number}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'set',
    value: function set() {
      var engine = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var time = this.__sync();
      var speed = this.__speed;

      if (this.__playControlled !== null && this.__playControlled.__engine !== engine) {

        this.syncSpeed(time, this.__position, 0);

        if (this.__playControlled) this.__resetEngine();

        if (this.__playControlled === null && engine !== null) {
          this.__setEngine(engine);

          if (speed !== 0) this.syncSpeed(time, this.__position, speed);
        }
      }
    }

    /**
     * Sets the play control loop behavior.
     *
     * @type {Boolean}
     * @name loop
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'setLoopBoundaries',


    /**
     * Sets loop start and end time.
     *
     * @param {Number} loopStart - loop start value.
     * @param {Number} loopEnd - loop end value.
     */
    value: function setLoopBoundaries(loopStart, loopEnd) {
      this.__loopStart = loopStart;
      this.__loopEnd = loopEnd;

      this.loop = this.loop;
    }

    /**
     * Sets loop start value
     *
     * @type {Number}
     * @name loopStart
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'syncSpeed',


    // TimeEngine method (speed-controlled interface)
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      if (speed !== lastSpeed || seek) {
        if ((seek || lastSpeed === 0) && this.__loopControl) position = this.__loopControl.applyLoopBoundaries(position, speed);

        this.__time = time;
        this.__position = position;
        this.__speed = speed;

        if (this.__playControlled) this.__playControlled.syncSpeed(time, position, speed, seek, lastSpeed);

        if (this.__loopControl) this.__loopControl.reschedule(speed);
      }
    }

    /**
     * Starts playback
     */

  }, {
    key: 'start',
    value: function start() {
      var time = this.__sync();
      this.syncSpeed(time, this.__position, this.__playingSpeed);
    }

    /**
     * Pauses playback and stays at the same position.
     */

  }, {
    key: 'pause',
    value: function pause() {
      var time = this.__sync();
      this.syncSpeed(time, this.__position, 0);
    }

    /**
     * Stops playback and seeks to initial (0) position.
     */

  }, {
    key: 'stop',
    value: function stop() {
      var time = this.__sync();
      this.syncSpeed(time, 0, 0, true);
    }

    /**
     * If speed if provided, sets the playback speed. The speed value should
     * be non-zero between -16 and -1/16 or between 1/16 and 16.
     *
     * @type {Number}
     * @name speed
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'seek',


    /**
     * Set (jump to) playing position.
     *
     * @param {Number} position target position
     */
    value: function seek(position) {
      var time = this.__sync();
      this.__position = position;
      this.syncSpeed(time, position, this.__speed, true);
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__scheduler.currentTime;
    }

    /**
     * Get current master position.
     * This function will be replaced when the play-control is added to a master.
     *
     * @name currentPosition
     * @type {Number}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__position + (this.__scheduler.currentTime - this.__time) * this.__speed;
    }

    /**
     * Returns if the play control is runnin g.
     *
     * @name running
     * @type {Boolean}
     * @memberof PlayControl
     * @instance
     * @readonly
     */

  }, {
    key: 'running',
    get: function get() {
      return !(this.__speed === 0);
    }
  }, {
    key: 'loop',
    set: function set(enable) {
      if (enable && this.__loopStart > -Infinity && this.__loopEnd < Infinity) {
        if (!this.__loopControl) {
          this.__loopControl = new LoopControl(this);
          this.__scheduler.add(this.__loopControl, Infinity);
        }

        if (this.__speed !== 0) {
          var position = this.currentPosition;
          var lower = Math.min(this.__loopStart, this.__loopEnd);
          var upper = Math.max(this.__loopStart, this.__loopEnd);

          if (this.__speed > 0 && position > upper) this.seek(upper);else if (this.__speed < 0 && position < lower) this.seek(lower);else this.__loopControl.reschedule(this.__speed);
        }
      } else if (this.__loopControl) {
        this.__scheduler.remove(this.__loopControl);
        this.__loopControl = null;
      }
    },
    get: function get() {
      return !!this.__loopControl;
    }
  }, {
    key: 'loopStart',
    set: function set(loopStart) {
      this.setLoopBoundaries(loopStart, this.__loopEnd);
    },
    get: function get() {
      return this.__loopStart;
    }

    /**
     * Sets loop end value
     *
     * @type {Number}
     * @name loopEnd
     * @memberof PlayControl
     * @instance
     */

  }, {
    key: 'loopEnd',
    set: function set(loopEnd) {
      this.setLoopBoundaries(this.__loopStart, loopEnd);
    },
    get: function get() {
      return this.__loopEnd;
    }
  }, {
    key: 'speed',
    set: function set(speed) {
      var time = this.__sync();

      if (speed >= 0) {
        if (speed < 0.01) speed = 0.01;else if (speed > 100) speed = 100;
      } else {
        if (speed < -100) speed = -100;else if (speed > -0.01) speed = -0.01;
      }

      this.__playingSpeed = speed;

      if (!this.master && this.__speed !== 0) this.syncSpeed(time, this.__position, speed);
    },
    get: function get() {
      return this.__playingSpeed;
    }
  }]);
  return PlayControl;
}(_timeEngine2.default);

exports.default = PlayControl;

},{"../core/audio-context":1,"../core/scheduling-queue":4,"../core/time-engine":5,"./factories":13,"babel-runtime/core-js/object/get-prototype-of":28,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36,"babel-runtime/helpers/get":37,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/possibleConstructorReturn":39}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('wavesjs:audio');

/**
 * The `Scheduler` class implements a master for `TimeEngine` or `AudioTimeEngine`
 * instances that implement the *scheduled* interface such as the `Metronome`
 * `GranularEngine`.
 *
 * A `Scheduler` can also schedule simple callback functions.
 * The class is based on recursive calls to `setTimeOut` and uses the
 * `audioContext.currentTime` as logical passed to the `advanceTime` methods
 * of the scheduled engines or to the scheduled callback functions.
 * It extends the `SchedulingQueue` class that itself includes a `PriorityQueue`
 * to assure the order of the scheduled engines (see `SimpleScheduler` for a
 * simplified scheduler implementation without `PriorityQueue`).
 *
 * To get a unique instance of `Scheduler` as the global scheduler of an
 * application, the `getScheduler` factory function should be used. The
 * function accepts an audio context as optional argument and uses the Waves
 * default audio context (see `audioContext`) as
 * default. The factory creates a single scheduler for each audio context.
 *
 * Example that shows three Metronome engines running in a Scheduler:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/scheduler.html}
 *
 * @param {Object} [options={}] - default options
 * @param {Number} [options.period=0.025] - period of the scheduler.
 * @param {Number} [options.lookahead=0.1] - lookahead of the scheduler.
 *
 * @see TimeEngine
 * @see AudioTimeEngine
 * @see getScheduler
 * @see SimpleScheduler
 *
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getScheduler();
 *
 * scheduler.add(myEngine);
 */

var Scheduler = function (_SchedulingQueue) {
  (0, _inherits3.default)(Scheduler, _SchedulingQueue);

  function Scheduler() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Scheduler);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Scheduler.__proto__ || (0, _getPrototypeOf2.default)(Scheduler)).call(this));

    _this.audioContext = options.audioContext || _audioContext2.default;

    _this.__currentTime = null;
    _this.__nextTime = Infinity;
    _this.__timeout = null;

    /**
     * scheduler (setTimeout) period
     * @type {Number}
     * @name period
     * @memberof Scheduler
     * @instance
     */
    _this.period = options.period || 0.025;

    /**
     * scheduler lookahead time (> period)
     * @type {Number}
     * @name lookahead
     * @memberof Scheduler
     * @instance
     */
    _this.lookahead = options.lookahead || 0.1;
    return _this;
  }

  // setTimeout scheduling loop


  (0, _createClass3.default)(Scheduler, [{
    key: '__tick',
    value: function __tick() {
      var audioContext = this.audioContext;
      var currentTime = audioContext.currentTime;
      var time = this.__nextTime;

      this.__timeout = null;

      while (time <= currentTime + this.lookahead) {
        this.__currentTime = time;
        time = this.advanceTime(time);
      }

      this.__currentTime = null;
      this.resetTime(time);
    }
  }, {
    key: 'resetTime',
    value: function resetTime() {
      var _this2 = this;

      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentTime;

      if (this.master) {
        this.master.reset(this, time);
      } else {
        if (this.__timeout) {
          clearTimeout(this.__timeout);
          this.__timeout = null;
        }

        if (time !== Infinity) {
          if (this.__nextTime === Infinity) log('Scheduler Start');

          var timeOutDelay = Math.max(time - this.lookahead - this.audioContext.currentTime, this.period);

          this.__timeout = setTimeout(function () {
            _this2.__tick();
          }, Math.ceil(timeOutDelay * 1000));
        } else if (this.__nextTime !== Infinity) {
          log('Scheduler Stop');
        }

        this.__nextTime = time;
      }
    }

    /**
     * Scheduler current logical time.
     *
     * @name currentTime
     * @type {Number}
     * @memberof Scheduler
     * @instance
     */

  }, {
    key: 'currentTime',
    get: function get() {
      if (this.master) return this.master.currentTime;

      return this.__currentTime || this.audioContext.currentTime + this.lookahead;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return undefined;
    }

    // inherited from scheduling queue
    /**
     * Add a TimeEngine or a simple callback function to the scheduler at an
     * optionally given time. Whether the add method is called with a TimeEngine
     * or a callback function it returns a TimeEngine that can be used as argument
     * of the methods remove and resetEngineTime. A TimeEngine added to a scheduler
     * has to implement the scheduled interface. The callback function added to a
     * scheduler will be called at the given time and with the given time as
     * argument. The callback can return a new scheduling time (i.e. the next
     * time when it will be called) or it can return Infinity to suspend scheduling
     * without removing the function from the scheduler. A function that does
     * not return a value (or returns null or 0) is removed from the scheduler
     * and cannot be used as argument of the methods remove and resetEngineTime
     * anymore.
     *
     * @name add
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine|Function} engine - Engine to add to the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    /**
     * Remove a TimeEngine from the scheduler that has been added to the
     * scheduler using the add method.
     *
     * @name add
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine} engine - Engine to remove from the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    /**
     * Reschedule a scheduled time engine at a given time.
     *
     * @name resetEngineTime
     * @function
     * @memberof Scheduler
     * @instance
     * @param {TimeEngine} engine - Engine to reschedule
     * @param {Number} time - Schedule time
     */
    /**
     * Remove all scheduled callbacks and engines from the scheduler.
     *
     * @name clear
     * @function
     * @memberof Scheduler
     * @instance
     */

  }]);
  return Scheduler;
}(_schedulingQueue2.default);

exports.default = Scheduler;

},{"../core/audio-context":1,"../core/scheduling-queue":4,"babel-runtime/core-js/object/get-prototype-of":28,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/possibleConstructorReturn":39,"debug":162}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var log = (0, _debug2.default)('wavesjs:audio');

/**
 *
 *
 *
 * The SimpleScheduler class implements a simplified master for time engines
 * (see TimeEngine or AudioTimeEngine) that implement the scheduled interface
 * such as the Metronome and the GranularEngine. The API and funtionalities of
 * the SimpleScheduler class are identical to the Scheduler class. But, other
 * than the Scheduler, the SimpleScheduler class does not guarantee the order
 * of events (i.e. calls to the advanceTime method of scheduled time engines
 * and to scheduled callback functions) within a scheduling period (see period
 * attribute).
 *
 * To get a unique instance of SimpleScheduler as the global scheduler of an
 * application, the getSimpleScheduler factory function should be used. The
 * function accepts an audio context as optional argument and uses the Waves
 * default audio context (see Audio Context) as default. The factory creates
 * a single (simple) scheduler for each audio context.
 *
 * Example that shows three Metronome engines running in a SimpleScheduler:
 * {@link https://rawgit.com/wavesjs/waves-audio/master/examples/simple-scheduler.html}
 *
 * @param {Object} [options={}] - default options
 * @param {Number} [options.period=0.025] - period of the scheduler.
 * @param {Number} [options.lookahead=0.1] - lookahead of the scheduler.
 *
 * @see TimeEngine
 * @see AudioTimeEngine
 * @see getSimpleScheduler
 * @see Scheduler
 *
 * @example
 * import * as audio from 'waves-audio';
 * const scheduler = audio.getSimpleScheduler();
 *
 * scheduler.add(myEngine);
 */

var SimpleScheduler = function () {
  function SimpleScheduler() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, SimpleScheduler);

    this.audioContext = options.audioContext || _audioContext2.default;

    this.__engines = new _set2.default();

    this.__schedEngines = [];
    this.__schedTimes = [];

    this.__currentTime = null;
    this.__timeout = null;

    /**
     * scheduler (setTimeout) period
     * @type {Number}
     * @name period
     * @memberof Scheduler
     * @instance
     */
    this.period = options.period || 0.025;

    /**
     * scheduler lookahead time (> period)
     * @type {Number}
     * @name lookahead
     * @memberof Scheduler
     * @instance
     */
    this.lookahead = options.lookahead || 0.1;
  }

  (0, _createClass3.default)(SimpleScheduler, [{
    key: '__scheduleEngine',
    value: function __scheduleEngine(engine, time) {
      this.__schedEngines.push(engine);
      this.__schedTimes.push(time);
    }
  }, {
    key: '__rescheduleEngine',
    value: function __rescheduleEngine(engine, time) {
      var index = this.__schedEngines.indexOf(engine);

      if (index >= 0) {
        if (time !== Infinity) {
          this.__schedTimes[index] = time;
        } else {
          this.__schedEngines.splice(index, 1);
          this.__schedTimes.splice(index, 1);
        }
      } else if (time < Infinity) {
        this.__schedEngines.push(engine);
        this.__schedTimes.push(time);
      }
    }
  }, {
    key: '__unscheduleEngine',
    value: function __unscheduleEngine(engine) {
      var index = this.__schedEngines.indexOf(engine);

      if (index >= 0) {
        this.__schedEngines.splice(index, 1);
        this.__schedTimes.splice(index, 1);
      }
    }
  }, {
    key: '__resetTick',
    value: function __resetTick() {
      if (this.__schedEngines.length > 0) {
        if (!this.__timeout) {
          log('SimpleScheduler Start');
          this.__tick();
        }
      } else if (this.__timeout) {
        log('SimpleScheduler Stop');
        clearTimeout(this.__timeout);
        this.__timeout = null;
      }
    }
  }, {
    key: '__tick',
    value: function __tick() {
      var _this = this;

      var audioContext = this.audioContext;
      var currentTime = audioContext.currentTime;
      var i = 0;

      while (i < this.__schedEngines.length) {
        var engine = this.__schedEngines[i];
        var time = this.__schedTimes[i];

        while (time && time <= currentTime + this.lookahead) {
          time = Math.max(time, currentTime);
          this.__currentTime = time;
          time = engine.advanceTime(time);
        }

        if (time && time < Infinity) {
          this.__schedTimes[i++] = time;
        } else {
          this.__unscheduleEngine(engine);

          // remove engine from scheduler
          if (!time) {
            engine.master = null;
            this.__engines.delete(engine);
          }
        }
      }

      this.__currentTime = null;
      this.__timeout = null;

      if (this.__schedEngines.length > 0) {
        this.__timeout = setTimeout(function () {
          _this.__tick();
        }, this.period * 1000);
      }
    }

    /**
     * Scheduler current logical time.
     *
     * @name currentTime
     * @type {Number}
     * @memberof Scheduler
     * @instance
     */

  }, {
    key: 'defer',


    // call a function at a given time
    /**
     * Defer the execution of a function at a given time.
     *
     * @param {Function} fun - Function to defer
     * @param {Number} [time=this.currentTime] - Schedule time
     */
    value: function defer(fun) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!(fun instanceof Function)) throw new Error("object cannot be defered by scheduler");

      this.add({
        advanceTime: function advanceTime(time) {
          fun(time);
        } // make sur that the advanceTime method does not returm anything
      }, time);
    }

    /**
     * Add a TimeEngine function to the scheduler at an optionally given time.
     *
     * @param {TimeEngine} engine - Engine to add to the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */

  }, {
    key: 'add',
    value: function add(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      if (!_timeEngine2.default.implementsScheduled(engine)) throw new Error("object cannot be added to scheduler");

      if (engine.master) throw new Error("object has already been added to a master");

      // set master and add to array
      engine.master = this;
      this.__engines.add(engine);

      // schedule engine
      this.__scheduleEngine(engine, time);
      this.__resetTick();
    }

    /**
     * Remove a TimeEngine from the scheduler that has been added to the
     * scheduler using the add method.
     *
     * @param {TimeEngine} engine - Engine to remove from the scheduler
     * @param {Number} [time=this.currentTime] - Schedule time
     */

  }, {
    key: 'remove',
    value: function remove(engine) {
      if (!engine.master || engine.master !== this) throw new Error("engine has not been added to this scheduler");

      // reset master and remove from array
      engine.master = null;
      this.__engines.delete(engine);

      // unschedule engine
      this.__unscheduleEngine(engine);
      this.__resetTick();
    }

    /**
     * Reschedule a scheduled time engine at a given time.
     *
     * @param {TimeEngine} engine - Engine to reschedule
     * @param {Number} time - Schedule time
     */

  }, {
    key: 'resetEngineTime',
    value: function resetEngineTime(engine) {
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.currentTime;

      this.__rescheduleEngine(engine, time);
      this.__resetTick();
    }

    /**
     * Check whether a given engine is scheduled.
     *
     * @param {TimeEngine} engine - Engine to check
     */

  }, {
    key: 'has',
    value: function has(engine) {
      return this.__engines.has(engine);
    }

    /**
     * Remove all engines from the scheduler.
     */

  }, {
    key: 'clear',
    value: function clear() {
      if (this.__timeout) {
        clearTimeout(this.__timeout);
        this.__timeout = null;
      }

      this.__schedEngines.length = 0;
      this.__schedTimes.length = 0;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__currentTime || this.audioContext.currentTime + this.lookahead;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return undefined;
    }
  }]);
  return SimpleScheduler;
}();

exports.default = SimpleScheduler;

},{"../core/audio-context":1,"../core/time-engine":5,"babel-runtime/core-js/set":31,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36,"debug":162}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _get2 = require('babel-runtime/helpers/get');

var _get3 = _interopRequireDefault(_get2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

var _priorityQueue = require('../core/priority-queue');

var _priorityQueue2 = _interopRequireDefault(_priorityQueue);

var _schedulingQueue = require('../core/scheduling-queue');

var _schedulingQueue2 = _interopRequireDefault(_schedulingQueue);

var _timeEngine = require('../core/time-engine');

var _timeEngine2 = _interopRequireDefault(_timeEngine);

var _factories = require('./factories');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function addDuplet(firstArray, secondArray, firstElement, secondElement) {
  firstArray.push(firstElement);
  secondArray.push(secondElement);
}

function removeDuplet(firstArray, secondArray, firstElement) {
  var index = firstArray.indexOf(firstElement);

  if (index >= 0) {
    var secondElement = secondArray[index];

    firstArray.splice(index, 1);
    secondArray.splice(index, 1);

    return secondElement;
  }

  return null;
}

// The Transported call is the base class of the adapters between
// different types of engines (i.e. transported, scheduled, play-controlled)
// The adapters are at the same time masters for the engines added to the transport
// and transported TimeEngines inserted into the transport's position-based pritority queue.

var Transported = function (_TimeEngine) {
  (0, _inherits3.default)(Transported, _TimeEngine);

  function Transported(transport, engine, start, duration, offset) {
    var stretch = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
    (0, _classCallCheck3.default)(this, Transported);

    var _this = (0, _possibleConstructorReturn3.default)(this, (Transported.__proto__ || (0, _getPrototypeOf2.default)(Transported)).call(this));

    _this.master = transport;

    _this.__engine = engine;
    engine.master = _this;

    _this.__startPosition = start;
    _this.__endPosition = !isFinite(duration) ? Infinity : start + duration;
    _this.__offsetPosition = start + offset;
    _this.__stretchPosition = stretch;
    _this.__isRunning = false;
    return _this;
  }

  (0, _createClass3.default)(Transported, [{
    key: 'setBoundaries',
    value: function setBoundaries(start, duration) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var stretch = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

      this.__startPosition = start;
      this.__endPosition = start + duration;
      this.__offsetPosition = start + offset;
      this.__stretchPosition = stretch;
      this.resetPosition();
    }
  }, {
    key: 'start',
    value: function start(time, position, speed) {}
  }, {
    key: 'stop',
    value: function stop(time, position) {}
  }, {
    key: 'resetPosition',
    value: function resetPosition(position) {
      if (position !== undefined) position += this.__offsetPosition;

      this.master.resetEnginePosition(this, position);
    }
  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (speed > 0) {
        if (position < this.__startPosition) {

          if (this.__isRunning) this.stop(time, position - this.__offsetPosition);

          this.__isRunning = false;
          return this.__startPosition;
        } else if (position < this.__endPosition) {
          this.start(time, position - this.__offsetPosition, speed);

          this.__isRunning = true;
          return this.__endPosition;
        }
      } else {
        if (position > this.__endPosition) {
          if (this.__isRunning) // if engine is running
            this.stop(time, position - this.__offsetPosition);

          this.__isRunning = false;
          return this.__endPosition;
        } else if (position > this.__startPosition) {
          this.start(time, position - this.__offsetPosition, speed);

          this.__isRunning = true;
          return this.__startPosition;
        }
      }

      if (this.__isRunning) // if engine is running
        this.stop(time, position);

      this.__isRunning = false;
      return Infinity * speed;
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      if (!this.__isRunning) {
        this.start(time, position - this.__offsetPosition, speed);
        this.__isRunning = true;

        if (speed > 0) return this.__endPosition;

        return this.__startPosition;
      }

      // stop engine
      this.stop(time, position - this.__offsetPosition);

      this.__isRunning = false;
      return Infinity * speed;
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (speed === 0) // stop
        this.stop(time, position - this.__offsetPosition);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.master = null;

      this.__engine.master = null;
      this.__engine = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.master.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.master.currentPosition - this.__offsetPosition;
    }
  }]);
  return Transported;
}(_timeEngine2.default);

// TransportedTransported
// has to switch on and off the scheduled engines when the transport hits the engine's start and end position


var TransportedTransported = function (_Transported) {
  (0, _inherits3.default)(TransportedTransported, _Transported);

  function TransportedTransported(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedTransported);
    return (0, _possibleConstructorReturn3.default)(this, (TransportedTransported.__proto__ || (0, _getPrototypeOf2.default)(TransportedTransported)).call(this, transport, engine, startPosition, endPosition, offsetPosition));
  }

  (0, _createClass3.default)(TransportedTransported, [{
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      if (speed > 0 && position < this.__endPosition) position = Math.max(position, this.__startPosition);else if (speed < 0 && position >= this.__startPosition) position = Math.min(position, this.__endPosition);

      return this.__offsetPosition + this.__engine.syncPosition(time, position - this.__offsetPosition, speed);
    }
  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      position = this.__offsetPosition + this.__engine.advancePosition(time, position - this.__offsetPosition, speed);

      if (speed > 0 && position < this.__endPosition || speed < 0 && position >= this.__startPosition) return position;

      return Infinity * speed;
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (this.__engine.syncSpeed) this.__engine.syncSpeed(time, position, speed);
    }
  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(engine) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (position !== undefined) position += this.__offsetPosition;

      this.resetPosition(position);
    }
  }]);
  return TransportedTransported;
}(Transported);

// TransportedSpeedControlled
// has to start and stop the speed-controlled engines when the transport hits the engine's start and end position


var TransportedSpeedControlled = function (_Transported2) {
  (0, _inherits3.default)(TransportedSpeedControlled, _Transported2);

  function TransportedSpeedControlled(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedSpeedControlled);
    return (0, _possibleConstructorReturn3.default)(this, (TransportedSpeedControlled.__proto__ || (0, _getPrototypeOf2.default)(TransportedSpeedControlled)).call(this, transport, engine, startPosition, endPosition, offsetPosition));
  }

  (0, _createClass3.default)(TransportedSpeedControlled, [{
    key: 'start',
    value: function start(time, position, speed) {
      this.__engine.syncSpeed(time, position, speed, true);
    }
  }, {
    key: 'stop',
    value: function stop(time, position) {
      this.__engine.syncSpeed(time, position, 0);
    }
  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      if (this.__isRunning) this.__engine.syncSpeed(time, position, speed);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__engine.syncSpeed(this.master.currentTime, this.master.currentPosition - this.__offsetPosition, 0);
      (0, _get3.default)(TransportedSpeedControlled.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedSpeedControlled.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedSpeedControlled;
}(Transported);

// TransportedScheduled
// has to switch on and off the scheduled engines when the transport hits the engine's start and end position


var TransportedScheduled = function (_Transported3) {
  (0, _inherits3.default)(TransportedScheduled, _Transported3);

  function TransportedScheduled(transport, engine, startPosition, endPosition, offsetPosition) {
    (0, _classCallCheck3.default)(this, TransportedScheduled);

    // scheduling queue becomes master of engine
    var _this4 = (0, _possibleConstructorReturn3.default)(this, (TransportedScheduled.__proto__ || (0, _getPrototypeOf2.default)(TransportedScheduled)).call(this, transport, engine, startPosition, endPosition, offsetPosition));

    engine.master = null;
    transport.__schedulingQueue.add(engine, Infinity);
    return _this4;
  }

  (0, _createClass3.default)(TransportedScheduled, [{
    key: 'start',
    value: function start(time, position, speed) {
      this.master.__schedulingQueue.resetEngineTime(this.__engine, time);
    }
  }, {
    key: 'stop',
    value: function stop(time, position) {
      this.master.__schedulingQueue.resetEngineTime(this.__engine, Infinity);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.master.__schedulingQueue.remove(this.__engine);
      (0, _get3.default)(TransportedScheduled.prototype.__proto__ || (0, _getPrototypeOf2.default)(TransportedScheduled.prototype), 'destroy', this).call(this);
    }
  }]);
  return TransportedScheduled;
}(Transported);

// translates advancePosition of *transported* engines into global scheduler times


var TransportSchedulerHook = function (_TimeEngine2) {
  (0, _inherits3.default)(TransportSchedulerHook, _TimeEngine2);

  function TransportSchedulerHook(transport) {
    (0, _classCallCheck3.default)(this, TransportSchedulerHook);

    var _this5 = (0, _possibleConstructorReturn3.default)(this, (TransportSchedulerHook.__proto__ || (0, _getPrototypeOf2.default)(TransportSchedulerHook)).call(this));

    _this5.__transport = transport;

    _this5.__nextPosition = Infinity;
    _this5.__nextTime = Infinity;
    transport.__scheduler.add(_this5, Infinity);
    return _this5;
  }

  // TimeEngine method (scheduled interface)


  (0, _createClass3.default)(TransportSchedulerHook, [{
    key: 'advanceTime',
    value: function advanceTime(time) {
      var transport = this.__transport;
      var position = this.__nextPosition;
      var speed = transport.__speed;
      var nextPosition = transport.advancePosition(time, position, speed);
      var nextTime = transport.__getTimeAtPosition(nextPosition);

      this.__nextPosition = nextPosition;
      this.__nextTime = nextTime;

      return nextTime;
    }
  }, {
    key: 'resetPosition',
    value: function resetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__nextPosition;

      var transport = this.__transport;
      var time = transport.__getTimeAtPosition(position);

      this.__nextPosition = position;
      this.__nextTime = time;

      this.resetTime(time);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      this.__transport.__scheduler.remove(this);
      this.__transport = null;
    }
  }]);
  return TransportSchedulerHook;
}(_timeEngine2.default);

// internal scheduling queue that returns the current position (and time) of the play control


var TransportSchedulingQueue = function (_SchedulingQueue) {
  (0, _inherits3.default)(TransportSchedulingQueue, _SchedulingQueue);

  function TransportSchedulingQueue(transport) {
    (0, _classCallCheck3.default)(this, TransportSchedulingQueue);

    var _this6 = (0, _possibleConstructorReturn3.default)(this, (TransportSchedulingQueue.__proto__ || (0, _getPrototypeOf2.default)(TransportSchedulingQueue)).call(this));

    _this6.__transport = transport;
    transport.__scheduler.add(_this6, Infinity);
    return _this6;
  }

  (0, _createClass3.default)(TransportSchedulingQueue, [{
    key: 'destroy',
    value: function destroy() {
      this.__transport.__scheduler.remove(this);
      this.__transport = null;
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__transport.currentTime;
    }
  }, {
    key: 'currentPosition',
    get: function get() {
      return this.__transport.currentPosition;
    }
  }]);
  return TransportSchedulingQueue;
}(_schedulingQueue2.default);

/**
 * Provides synchronized scheduling of Time Engine instances.
 *
 * [example]{@link https://rawgit.com/wavesjs/waves-audio/master/examples/transport.html}
 *
 * @example
 * import * as audio from 'waves-audio';
 * const transport = audio.Transport();
 * const playControl = new audio.PlayControl(transport);
 * const myEngine = new MyEngine();
 * const yourEngine = new yourEngine();
 *
 * transport.add(myEngine);
 * transport.add(yourEngine);
 *
 * playControl.start();
 */


var Transport = function (_TimeEngine3) {
  (0, _inherits3.default)(Transport, _TimeEngine3);

  function Transport() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    (0, _classCallCheck3.default)(this, Transport);

    var _this7 = (0, _possibleConstructorReturn3.default)(this, (Transport.__proto__ || (0, _getPrototypeOf2.default)(Transport)).call(this));

    _this7.audioContext = options.audioContext || _audioContext2.default;

    _this7.__engines = [];
    _this7.__transported = [];

    _this7.__scheduler = (0, _factories.getScheduler)(_this7.audioContext);
    _this7.__schedulerHook = new TransportSchedulerHook(_this7);
    _this7.__transportedQueue = new _priorityQueue2.default();
    _this7.__schedulingQueue = new TransportSchedulingQueue(_this7);

    // syncronized time, position, and speed
    _this7.__time = 0;
    _this7.__position = 0;
    _this7.__speed = 0;
    return _this7;
  }

  (0, _createClass3.default)(Transport, [{
    key: '__getTimeAtPosition',
    value: function __getTimeAtPosition(position) {
      return this.__time + (position - this.__position) / this.__speed;
    }
  }, {
    key: '__getPositionAtTime',
    value: function __getPositionAtTime(time) {
      return this.__position + (time - this.__time) * this.__speed;
    }
  }, {
    key: '__syncTransportedPosition',
    value: function __syncTransportedPosition(time, position, speed) {
      var numTransportedEngines = this.__transported.length;
      var nextPosition = Infinity * speed;

      if (numTransportedEngines > 0) {
        this.__transportedQueue.clear();
        this.__transportedQueue.reverse = speed < 0;

        for (var i = 0; i < numTransportedEngines; i++) {
          var engine = this.__transported[i];
          var nextEnginePosition = engine.syncPosition(time, position, speed);
          this.__transportedQueue.insert(engine, nextEnginePosition);
        }

        nextPosition = this.__transportedQueue.time;
      }

      return nextPosition;
    }
  }, {
    key: '__syncTransportedSpeed',
    value: function __syncTransportedSpeed(time, position, speed) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.__transported), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var transported = _step.value;

          transported.syncSpeed(time, position, speed);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    /**
     * Get current master time. This getter will be replaced when the transport
     * is added to a master (i.e. transport or play-control).
     *
     * @type {Number}
     * @name currentTime
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'resetPosition',


    /**
     * Reset next transport position
     *
     * @param {Number} next - transport position
     */
    value: function resetPosition(position) {
      var master = this.master;

      if (master && master.resetEnginePosition !== undefined) master.resetEnginePosition(this, position);else this.__schedulerHook.resetPosition(position);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     */

  }, {
    key: 'syncPosition',
    value: function syncPosition(time, position, speed) {
      this.__time = time;
      this.__position = position;
      this.__speed = speed;

      return this.__syncTransportedPosition(time, position, speed);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     */

  }, {
    key: 'advancePosition',
    value: function advancePosition(time, position, speed) {
      var engine = this.__transportedQueue.head;
      var nextEnginePosition = engine.advancePosition(time, position, speed);
      return this.__transportedQueue.move(engine, nextEnginePosition);
    }

    /**
     * Implementation of the transported time engine interface.
     *
     * @param {Number} time
     * @param {Number} position
     * @param {Number} speed
     * @param {Boolean} [seek=false]
     */

  }, {
    key: 'syncSpeed',
    value: function syncSpeed(time, position, speed) {
      var seek = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      var lastSpeed = this.__speed;

      this.__time = time;
      this.__position = position;
      this.__speed = speed;

      if (speed !== lastSpeed || seek && speed !== 0) {
        var nextPosition = void 0;

        // resync transported engines
        if (seek || speed * lastSpeed < 0) {
          // seek or reverse direction
          nextPosition = this.__syncTransportedPosition(time, position, speed);
        } else if (lastSpeed === 0) {
          // start
          nextPosition = this.__syncTransportedPosition(time, position, speed);
        } else if (speed === 0) {
          // stop
          nextPosition = Infinity;
          this.__syncTransportedSpeed(time, position, 0);
        } else {
          // change speed without reversing direction
          this.__syncTransportedSpeed(time, position, speed);
        }

        this.resetPosition(nextPosition);
      }
    }

    /**
     * Add a time engine to the transport.
     *
     * @param {Object} engine - engine to be added to the transport
     * @param {Number} position - start position
     */

  }, {
    key: 'add',
    value: function add(engine) {
      var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var endPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
      var offsetPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

      var transported = null;

      if (offsetPosition === -Infinity) offsetPosition = 0;

      if (engine.master) throw new Error("object has already been added to a master");

      if (_timeEngine2.default.implementsTransported(engine)) transported = new TransportedTransported(this, engine, startPosition, endPosition, offsetPosition);else if (_timeEngine2.default.implementsSpeedControlled(engine)) transported = new TransportedSpeedControlled(this, engine, startPosition, endPosition, offsetPosition);else if (_timeEngine2.default.implementsScheduled(engine)) transported = new TransportedScheduled(this, engine, startPosition, endPosition, offsetPosition);else throw new Error("object cannot be added to a transport");

      if (transported) {
        var speed = this.__speed;

        addDuplet(this.__engines, this.__transported, engine, transported);

        if (speed !== 0) {
          // sync and start
          var nextEnginePosition = transported.syncPosition(this.currentTime, this.currentPosition, speed);
          var nextPosition = this.__transportedQueue.insert(transported, nextEnginePosition);

          this.resetPosition(nextPosition);
        }
      }

      return transported;
    }

    /**
     * Remove a time engine from the transport.
     *
     * @param {object} engineOrTransported - engine or transported to be removed from the transport
     */

  }, {
    key: 'remove',
    value: function remove(engineOrTransported) {
      var engine = engineOrTransported;
      var transported = removeDuplet(this.__engines, this.__transported, engineOrTransported);

      if (!transported) {
        engine = removeDuplet(this.__transported, this.__engines, engineOrTransported);
        transported = engineOrTransported;
      }

      if (engine && transported) {
        var nextPosition = this.__transportedQueue.remove(transported);

        transported.destroy();

        if (this.__speed !== 0) this.resetPosition(nextPosition);
      } else {
        throw new Error("object has not been added to this transport");
      }
    }

    /**
     * Reset position of the given engine.
     *
     * @param {TimeEngine} transported - Engine to reset
     * @param {Number} position - New position
     */

  }, {
    key: 'resetEnginePosition',
    value: function resetEnginePosition(transported) {
      var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      var speed = this.__speed;

      if (speed !== 0) {
        if (position === undefined) position = transported.syncPosition(this.currentTime, this.currentPosition, speed);

        var nextPosition = this.__transportedQueue.move(transported, position);
        this.resetPosition(nextPosition);
      }
    }

    /**
     * Remove all time engines from the transport.
     */

  }, {
    key: 'clear',
    value: function clear() {
      this.syncSpeed(this.currentTime, this.currentPosition, 0);

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this.__transported), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var transported = _step2.value;

          transported.destroy();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'currentTime',
    get: function get() {
      return this.__scheduler.currentTime;
    }

    /**
     * Get current master position. This getter will be replaced when the transport
     * is added to a master (i.e. transport or play-control).
     *
     * @type {Number}
     * @name currentPosition
     * @memberof Transport
     * @instance
     * @readonly
     */

  }, {
    key: 'currentPosition',
    get: function get() {
      var master = this.master;

      if (master && master.currentPosition !== undefined) return master.currentPosition;

      return this.__position + (this.__scheduler.currentTime - this.__time) * this.__speed;
    }
  }]);
  return Transport;
}(_timeEngine2.default);

exports.default = Transport;

},{"../core/audio-context":1,"../core/priority-queue":3,"../core/scheduling-queue":4,"../core/time-engine":5,"./factories":13,"babel-runtime/core-js/get-iterator":23,"babel-runtime/core-js/object/get-prototype-of":28,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36,"babel-runtime/helpers/get":37,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/possibleConstructorReturn":39}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _cbuffer = require('./cbuffer');

var _cbuffer2 = _interopRequireDefault(_cbuffer);

var _dsp = require('./dsp.js');

var _dsp2 = require('./dsp');

var _dsp3 = _interopRequireDefault(_dsp2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PhaseVocoder(winSize, sampleRate) {

	var _sampleRate = sampleRate;var _Hs = 0;var _Ha = 0;var _omega;

	var _previousInputPhase;var _previousOutputPhase;var _framingWindow;

	var _squaredFramingWindow;var _winSize = winSize;

	var _overlapBuffers;var _owOverlapBuffers;

	var _first = true;

	var _overlapFactor = 16;

	var _lastInputAlpha = 1;

	/*****************************************************/
	/******************* dsp.js FFT **********************/
	/*****************************************************/

	var fft = new _dsp.FFT(_winSize, sampleRate);
	/*****************************************************/
	/*****************************************************/
	/*****************************************************/

	var sqrt = Math.sqrt;var cos = Math.cos;
	var sin = Math.sin;var atan2 = Math.atan2;
	var round = Math.round;var max = Math.max;
	var ceil = Math.ceil;var pow = Math.pow;
	var PI = Math.PI;

	/*****************************************************/
	/***************PRE-ALLOCATE MEMORY*******************/
	/*****************************************************/

	//find_peaks
	var _hlfSize = round(_winSize / 2) + 1;

	// // process
	var _process = {
		fftObj: {
			real: new Float32Array(_hlfSize),
			imag: new Float32Array(_hlfSize),
			magnitude: new Float32Array(_hlfSize),
			phase: new Float32Array(_hlfSize)
		},
		pvOut: {
			real: create_constant_array(_winSize, 0, Float32Array),
			imag: create_constant_array(_winSize, 0, Float32Array),
			magnitude: create_constant_array(_winSize, 0, Float32Array),
			phase: create_constant_array(_winSize, 0, Float32Array)
		},
		processedFrame: new Float32Array(_winSize)
	};

	var _pv_step = {
		instPhaseAdv: new Float32Array(_hlfSize),
		phTh: new Float32Array(_hlfSize)
	};

	var _STFT = {
		_inputFrame: new Float32Array(_winSize),
		_zeros: new Float32Array(_winSize)
		/*****************************************************/
		/*****************************************************/
		/*****************************************************/

	};var phTh_idx = 0;
	var twoPI = 2 * PI;
	var expectedPhaseAdv, auxHeterodynedPhaseIncr, heterodynedPhaseIncr, instPhaseAdvPerSampleHop, instPhaseAdv_, prevInstPhaseAdv_;

	function overlap_and_slide(Hs, inF, squaredWinF, oBuf, owOBuf, windowSize, outF) {

		var owSample,
		    oSample = 0;

		for (var i = 0; i < Hs; i++) {
			owSample = owOBuf.shift() || 0;
			oSample = oBuf.shift() || 0;
			outF.push(oSample / (owSample < 10e-3 ? 1 : owSample));
			oBuf.push(0);
			owOBuf.push(0);
		}

		for (var i = 0; i < windowSize; i++) {
			oSample = oBuf.shift();
			oBuf.push(inF[i] + oSample);
			owSample = owOBuf.shift();
			owOBuf.push(squaredWinF[i] + owSample);
		}
	}

	function pv_step(fftObj, prevInPh, prevOutPh, omega, Ha, Hs, out) {

		var currInPh = fftObj.phase;
		var mag = fftObj.magnitude;
		var instPhaseAdv = _pv_step.instPhaseAdv;
		var phTh = _pv_step.phTh;

		var peak, prevPeak, reg, regStart, prevRegEnd, prevRegStart, d, i;
		phTh_idx = 0;

		for (i = 0; i < omega.length; i++) {
			expectedPhaseAdv = omega[i] * Ha;

			auxHeterodynedPhaseIncr = currInPh[i] - prevInPh[i] - expectedPhaseAdv;
			heterodynedPhaseIncr = auxHeterodynedPhaseIncr - twoPI * round(auxHeterodynedPhaseIncr / twoPI);

			instPhaseAdvPerSampleHop = omega[i] + heterodynedPhaseIncr / Ha;

			instPhaseAdv_ = instPhaseAdvPerSampleHop * Hs;

			if (mag[i] > max(mag[i - 2] | 0, mag[i - 1] | 0, mag[i + 1] | 0, mag[i + 2] | 0)) {
				// if (mag[i] > (mag[i-2]|0) && mag[i] > (mag[i-1]|0) && mag[i] > (mag[i+1]|0) && mag[i] > (mag[i+2]|0)) {
				peak = i;
				regStart = ceil((prevPeak + peak) / 2) | 0;
				prevRegEnd = regStart - 1;
				reg = max(0, prevRegEnd - prevRegStart + 1);
				prevRegStart = regStart;
				for (d = 0; d < reg; d++, phTh_idx++) {
					phTh[phTh_idx] = prevOutPh[prevPeak] + prevInstPhaseAdv_ - currInPh[prevPeak];
				}
				prevPeak = peak;
				prevInstPhaseAdv_ = instPhaseAdv_;
			}
		}

		for (var i = 0; i < phTh.length; i++) {
			var theta = phTh[i];

			var phThRe = cos(phTh[i]);
			var phThIm = sin(phTh[i]);

			out.real[i] = phThRe * fftObj.real[i] - phThIm * fftObj.imag[i];
			out.imag[i] = phThRe * fftObj.imag[i] + phThIm * fftObj.real[i];
			out.phase[i] = atan2(out.imag[i], out.real[i]);
		}

		return;
	}

	this.process = function (inputArray, outputArray) {

		var _ = this;

		var __Hs = _Hs;
		var __Ha = _Ha;

		// ----------------------------------
		// ----------ANALYSIS STEP-----------
		// ----------------------------------

		var processedFrame = _process.processedFrame;;
		var fftObj = _process.fftObj;
		// FOR SOME REASON, IF I DON'T CREATE A NEW "phase" ARHaY, I GET ARTIFACTS.
		// fftObj.phase = new Float32Array(_hlfSize); 
		var pvOut = _process.pvOut;
		_.STFT(inputArray, _framingWindow, _hlfSize, fftObj);
		pv_step(fftObj, _previousInputPhase, _previousOutputPhase, _omega, __Ha, __Hs, pvOut);
		_previousOutputPhase = pvOut.phase;
		// The "phase" issue mentioned above is related to this line. 
		// If I create a new Float array using the phase array, I get no issues.
		_previousInputPhase = new Float32Array(fftObj.phase);
		_.ISTFT(pvOut.real, pvOut.imag, _framingWindow, false, processedFrame);

		// ----------------------------------
		// ------OVERLAP AND SLIDE STEP------
		// ----------------------------------
		// var outputFrame = new Array(__Hs);

		overlap_and_slide(__Hs, processedFrame, _squaredFramingWindow, _overlapBuffers, _owOverlapBuffers, _winSize, outputArray);

		return __Hs;
	};

	this.STFT = function (inputFrame, windowFrame, wantedSize, out) {
		this.STFT_drom(inputFrame, windowFrame, wantedSize, out);
	};

	this.STFT_drom = function (inputFrame, windowFrame, wantedSize, out) {
		var winSize = windowFrame.length;
		var _inputFrame = _STFT._inputFrame;

		for (var i = 0; i < winSize; i++) {
			_inputFrame[i] = inputFrame[i] * windowFrame[i];
		}

		fft.forward(_inputFrame);
		out.real = fft.real;
		out.imag = fft.imag;

		var R = out.real;var I = out.imag;
		var P = out.phase;var M = out.magnitude;

		for (var p = 0; p < winSize && p < wantedSize; p++) {
			M[p] = sqrt(I[p] * I[p] + R[p] * R[p]) * 1000;
			P[p] = atan2(I[p], R[p]);
		}

		return;
	};

	this.ISTFT = function (real, imag, windowFrame, restoreEnergy, timeFrame) {
		this.ISTFT_drom(real, imag, windowFrame, restoreEnergy, timeFrame);
	};

	this.ISTFT_drom = function (real, imag, windowFrame, restoreEnergy, timeFrame) {

		fft.inverse(real, imag, timeFrame);

		return;
	};

	this.init = function () {

		_omega = create_omega_array(winSize);

		this.reset_phases_and_overlap_buffers();

		_framingWindow = create_sin_beta_window_array(winSize, 1);

		_squaredFramingWindow = _framingWindow.map(function (x, i) {
			return x * x;
		});

		this.set_alpha(1);
	};

	function create_omega_array(size) {
		return Array.apply(null, Array(size / 2 + 1)).map(function (x, i) {
			return twoPI * i / size;
		});
	}

	function create_sin_beta_window_array(size, beta) {
		return Array.apply(null, Array(size)).map(function (x, i) {
			return pow(sin(PI * i / size), beta);
		});
	}

	function create_constant_array(size, constant, ArrayType) {
		var arr = new (ArrayType ? ArrayType : Array)(size);
		for (var i = 0; i < size; i++) {
			arr[i] = constant;
		}return arr;
	}

	this.reset_phases_and_overlap_buffers = function () {

		_previousInputPhase = create_constant_array(winSize / 2, 0);
		_previousOutputPhase = create_constant_array(winSize / 2, 0);

		_overlapBuffers = new _cbuffer2.default(winSize);
		_owOverlapBuffers = new _cbuffer2.default(winSize);
		for (var i = 0; i < winSize; i++) {
			_overlapBuffers.push(0);
			_owOverlapBuffers.push(0);
		}

		_first = true;
	};

	this.reset_phases = function () {

		_previousInputPhase = create_constant_array(winSize / 2, 0);
		_previousOutputPhase = create_constant_array(winSize / 2, 0);

		_first = true;
	};

	this.get_previous_input_phase = function () {
		return _previousInputPhase;
	};

	this.get_previous_output_phase = function () {
		return _previousOutputPhase;
	};

	this.get_analysis_hop = function () {
		return _Ha;
	};

	this.get_synthesis_hop = function () {
		return _Hs;
	};

	this.get_alpha = function () {
		return _Hs / _Ha;
	};

	this.get_framing_window = function () {
		return _framingWindow;
	};

	this.get_squared_framing_window = function () {
		return _squaredFramingWindow;
	};

	this.set_alpha2 = function (newAlpha) {
		_lastInputAlpha = newAlpha;
		if (newAlpha <= 0.8) _overlapFactor = 2;else if (newAlpha <= 1) _overlapFactor = 4;else _overlapFactor = 5;

		/* "Fixed" synthesis hop size. */
		_Ha = round(_winSize / _overlapFactor);
		_Hs = round(newAlpha * _Ha);

		// _Hs = _Ha;

		// _Hs = round(_winSize/2);
		// _Ha = round(_Hs / newAlpha);
	};
	this.set_alpha = function (newAlpha) {
		_lastInputAlpha = newAlpha;
		_overlapFactor = Math.min(Math.floor(Math.pow(4, newAlpha / 4) * 2 / 1) * 2, 128);

		_Ha = Math.round(_winSize / _overlapFactor);
		_Hs = Math.round(newAlpha * _Ha);
		// _RS = Math.round(_winSize/2);
		// _RA = Math.round(_RS / newAlpha);
	};

	this.get_alpha_step = function () {
		return 1 / _Ha;
	};

	this.set_hops = function (Ha, Hs) {
		_Ha = Ha;
		_Hs = Hs;
	};

	this.get_specified_alpha = function () {
		return _lastInputAlpha;
	};

	this.set_overlap_factor = function (overlapFactor) {
		_overlapFactor = overlapFactor;
		this.set_alpha(_lastInputAlpha);
	};
} /*  From PhaseVocoder.js (c) 2015 by Echo66
      https://github.com/echo66/PhaseVocoderJS
  
      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
  	along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */

exports.default = PhaseVocoder;

},{"./cbuffer":20,"./dsp":21,"./dsp.js":21}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _defineProperties = require('babel-runtime/core-js/object/define-properties');

var _defineProperties2 = _interopRequireDefault(_defineProperties);

var _cbuffer = require('./cbuffer');

var _cbuffer2 = _interopRequireDefault(_cbuffer);

var _PV_fast_ = require('./PV_fast_5');

var _PV_fast_2 = _interopRequireDefault(_PV_fast_);

var _audioContext = require('../core/audio-context');

var _audioContext2 = _interopRequireDefault(_audioContext);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PV(frameSize) {

	var _frameSize = frameSize || 4096;

	var _pvL = new _PV_fast_2.default(_frameSize, _audioContext2.default.sampleRate);_pvL.init();
	var _pvR = new _PV_fast_2.default(_frameSize, _audioContext2.default.sampleRate);_pvR.init();

	var _buffer;
	var _position = 0;
	var _newAlpha = 1;

	var _midBufL = new _cbuffer2.default(Math.round(_frameSize * 2));
	var _midBufR = new _cbuffer2.default(Math.round(_frameSize * 2));

	this.processMono = function (outputAudioBuffer) {

		if (!_buffer) {
			console.error("No input buffer");
			return;
		}

		var sampleCounter = 0;

		var il = _buffer.getChannelData(0);
		var ir = _buffer.getChannelData(0);
		var ol = outputAudioBuffer.getChannelData(0);
		var or = outputAudioBuffer.getChannelData(1);

		while (_midBufR.size > 0 && sampleCounter < outputAudioBuffer.length) {
			var i = sampleCounter++;
			ol[i] = _midBufL.shift();
			or[i] = _midBufR.shift();
		}

		if (sampleCounter == outputAudioBuffer.length) return;

		do {

			var bufL = il.subarray(_position, _position + _frameSize);
			var bufR = ir.subarray(_position, _position + _frameSize);

			if (_newAlpha != undefined && _newAlpha != _pvL.get_alpha()) {
				_pvL.set_alpha(_newAlpha);
				_pvR.set_alpha(_newAlpha);
				_newAlpha = undefined;
			}

			/* LEFT */
			_pvL.process(bufL, _midBufL);
			_pvR.process(bufR, _midBufR);
			for (var i = sampleCounter; _midBufL.size > 0 && i < outputAudioBuffer.length; i++) {
				ol[i] = _midBufL.shift();
				or[i] = _midBufR.shift();
			}

			sampleCounter += _pvL.get_synthesis_hop();

			_position += _pvL.get_analysis_hop();
		} while (sampleCounter < outputAudioBuffer.length);
	};

	this.processStereo = function (outputAudioBuffer) {

		if (!_buffer || _buffer.numberOfChannels != 2) {
			console.error("No input buffer or wrong number of channels");
			return;
		}

		var sampleCounter = 0;

		var il = _buffer.getChannelData(0);
		var ir = _buffer.getChannelData(1);
		var ol = outputAudioBuffer.getChannelData(0);
		var or = outputAudioBuffer.getChannelData(1);

		while (_midBufR.size > 0 && sampleCounter < outputAudioBuffer.length) {
			var i = sampleCounter++;
			ol[i] = _midBufL.shift();
			or[i] = _midBufR.shift();
		}

		if (sampleCounter == outputAudioBuffer.length) return;

		do {

			var bufL = il.subarray(_position, _position + _frameSize);
			var bufR = ir.subarray(_position, _position + _frameSize);

			if (_newAlpha != undefined && _newAlpha != _pvL.get_alpha()) {
				_pvL.set_alpha(_newAlpha);
				_pvR.set_alpha(_newAlpha);
				_newAlpha = undefined;
			}

			/* LEFT */
			_pvL.process(bufL, _midBufL);
			_pvR.process(bufR, _midBufR);

			for (var i = sampleCounter; _midBufL.size > 0 && i < outputAudioBuffer.length; i++) {
				ol[i] = _midBufL.shift();
				or[i] = _midBufR.shift();
			}

			sampleCounter += _pvL.get_synthesis_hop();

			_position += _pvL.get_analysis_hop();
		} while (sampleCounter < outputAudioBuffer.length);
	};

	this.process = this.processMono;

	this.set_audio_buffer = function (newBuffer) {
		_buffer = newBuffer;
		if (_buffer.numberOfChannels == 2) this.process = this.processStereo;else this.process = this.processMono;
		_position = 0;
		_newAlpha = 1;
	};

	this.resetPhase = function () {
		_pvL.reset_phases();
		_pvR.reset_phases();
	};

	(0, _defineProperties2.default)(this, {
		'position': {
			get: function get() {
				return _position;
			},
			set: function set(newPosition) {
				_position = newPosition;
			}
		},
		'alpha': {
			get: function get() {
				return _pvL.get_alpha();
			},
			set: function set(newAlpha) {
				_newAlpha = newAlpha;
			}
		},
		'STFT': {
			get: function get() {
				return _pvL.STFT;
			},
			set: function set(newSTFT) {
				_pvL.STFT = newSTFT;
				_pvR.STFT = newSTFT;
			}
		},
		'ISTFT': {
			get: function get() {
				return _pvL.ISTFT;
			},
			set: function set(newISTFT) {
				_pvL.ISTFT = newISTFT;
				_pvR.ISTFT = newISTFT;
			}
		}
	});
}
//import PhaseVocoder from '../utils/PV_fast_pulsefft';
/*  From PhaseVocoder.js (c) 2015 by Echo66
    https://github.com/echo66/PhaseVocoderJS

	This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
	along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

exports.default = PV;

},{"../core/audio-context":1,"./PV_fast_5":18,"./cbuffer":20,"babel-runtime/core-js/object/define-properties":25}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
/*
	The MIT License (MIT)
	Copyright (c) 2013 Trevor Norris <trev.norris@gmail.com>

	Permission is hereby granted, free of charge, to any person obtaining a copy of
	this software and associated documentation files (the "Software"), to deal in
	the Software without restriction, including without limitation the rights to
	use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
	the Software, and to permit persons to whom the Software is furnished to do so,
	subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
	FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
	COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
	IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

function CBuffer() {
	// handle cases where "new" keyword wasn't used
	if (!(this instanceof CBuffer)) {
		// multiple conditions need to be checked to properly emulate Array
		if (arguments.length > 1 || typeof arguments[0] !== 'number') {
			return CBuffer.apply(new CBuffer(arguments.length), arguments);
		} else {
			return new CBuffer(arguments[0]);
		}
	}
	// if no arguments, then nothing needs to be set
	if (arguments.length === 0) throw new Error('Missing Argument: You must pass a valid buffer length');
	// this is the same in either scenario
	this.size = this.start = 0;
	// set to callback fn if data is about to be overwritten
	this.overflow = null;
	// emulate Array based on passed arguments
	if (arguments.length > 1 || typeof arguments[0] !== 'number') {
		this.data = new Float32Array(arguments.length);
		this.end = (this.length = arguments.length) - 1;
		this.push.apply(this, arguments);
	} else {
		this.data = new Float32Array(arguments[0]);
		this.end = (this.length = arguments[0]) - 1;
	}
	// need to `return this` so `return CBuffer.apply` works
	return this;
}

function defaultComparitor(a, b) {
	return a == b ? 0 : a > b ? 1 : -1;
}

CBuffer.prototype = {
	// properly set constructor
	constructor: CBuffer,

	/* mutator methods */
	// pop last item
	pop: function pop() {
		var item;
		if (this.size === 0) return;
		item = this.data[this.end];
		// remove the reference to the object so it can be garbage collected
		delete this.data[this.end];
		this.end = (this.end - 1 + this.length) % this.length;
		this.size--;
		return item;
	},
	// push item to the end
	push: function push() {
		var i = 0;
		// check if overflow is set, and if data is about to be overwritten
		if (this.overflow && this.size + arguments.length > this.length) {
			// call overflow function and send data that's about to be overwritten
			for (; i < this.size + arguments.length - this.length; i++) {
				this.overflow(this.data[(this.end + i + 1) % this.length], this);
			}
		}
		// push items to the end, wrapping and erasing existing items
		// using arguments variable directly to reduce gc footprint
		for (i = 0; i < arguments.length; i++) {
			this.data[(this.end + i + 1) % this.length] = arguments[i];
		}
		// recalculate size
		if (this.size < this.length) {
			if (this.size + i > this.length) this.size = this.length;else this.size += i;
		}
		// recalculate end
		this.end = (this.end + i) % this.length;
		// recalculate start
		this.start = (this.length + this.end - this.size + 1) % this.length;
		// return number current number of items in CBuffer
		return this.size;
	},
	// reverse order of the buffer
	reverse: function reverse() {
		var i = 0,
		    tmp;
		for (; i < ~~(this.size / 2); i++) {
			tmp = this.data[(this.start + i) % this.length];
			this.data[(this.start + i) % this.length] = this.data[(this.start + (this.size - i - 1)) % this.length];
			this.data[(this.start + (this.size - i - 1)) % this.length] = tmp;
		}
		return this;
	},
	// rotate buffer to the left by cntr, or by 1
	rotateLeft: function rotateLeft(cntr) {
		if (typeof cntr === 'undefined') cntr = 1;
		if (typeof cntr !== 'number') throw new Error("Argument must be a number");
		while (--cntr >= 0) {
			this.push(this.shift());
		}
		return this;
	},
	// rotate buffer to the right by cntr, or by 1
	rotateRight: function rotateRight(cntr) {
		if (typeof cntr === 'undefined') cntr = 1;
		if (typeof cntr !== 'number') throw new Error("Argument must be a number");
		while (--cntr >= 0) {
			this.unshift(this.pop());
		}
		return this;
	},
	// remove and return first item
	shift: function shift() {
		var item;
		// check if there are any items in CBuff
		if (this.size === 0) return;
		// store first item for return
		item = this.data[this.start];
		// recalculate start of CBuffer
		this.start = (this.start + 1) % this.length;
		// decrement size
		this.size--;
		return item;
	},
	// sort items
	sort: function sort(fn) {
		// this.data.sort(fn || defaultComparitor);
		// this.start = 0;
		// this.end = this.size - 1;
		return this;
	},
	// add item to beginning of buffer
	unshift: function unshift() {
		var i = 0;
		// check if overflow is set, and if data is about to be overwritten
		if (this.overflow && this.size + arguments.length > this.length) {
			// call overflow function and send data that's about to be overwritten
			for (; i < this.size + arguments.length - this.length; i++) {
				this.overflow(this.data[this.end - i % this.length], this);
			}
		}
		for (i = 0; i < arguments.length; i++) {
			this.data[(this.length + this.start - i % this.length - 1) % this.length] = arguments[i];
		}
		if (this.length - this.size - i < 0) {
			this.end += this.length - this.size - i;
			if (this.end < 0) this.end = this.length + this.end % this.length;
		}
		if (this.size < this.length) {
			if (this.size + i > this.length) this.size = this.length;else this.size += i;
		}
		this.start -= arguments.length;
		if (this.start < 0) this.start = this.length + this.start % this.length;
		return this.size;
	},

	/* accessor methods */
	// return index of first matched element
	indexOf: function indexOf(arg, idx) {
		if (!idx) idx = 0;
		for (; idx < this.size; idx++) {
			if (this.data[(this.start + idx) % this.length] === arg) return idx;
		}
		return -1;
	},
	// return last index of the first match
	lastIndexOf: function lastIndexOf(arg, idx) {
		if (!idx) idx = this.size - 1;
		for (; idx >= 0; idx--) {
			if (this.data[(this.start + idx) % this.length] === arg) return idx;
		}
		return -1;
	},

	// return the index an item would be inserted to if this
	// is a sorted circular buffer
	sortedIndex: function sortedIndex(value, comparitor, context) {
		comparitor = comparitor || defaultComparitor;
		var low = this.start,
		    high = this.size - 1;

		// Tricky part is finding if its before or after the pivot
		// we can get this info by checking if the target is less than
		// the last item. After that it's just a typical binary search.
		if (low && comparitor.call(context, value, this.data[high]) > 0) {
			low = 0, high = this.end;
		}

		while (low < high) {
			var mid = low + high >>> 1;
			if (comparitor.call(context, value, this.data[mid]) > 0) low = mid + 1;else high = mid;
		}
		// http://stackoverflow.com/a/18618273/1517919
		return ((low - this.start) % this.size + this.size) % this.size;
	},

	/* iteration methods */
	// check every item in the array against a test
	every: function every(callback, context) {
		var i = 0;
		for (; i < this.size; i++) {
			if (!callback.call(context, this.data[(this.start + i) % this.length], i, this)) return false;
		}
		return true;
	},
	// loop through each item in buffer
	// TODO: figure out how to emulate Array use better
	forEach: function forEach(callback, context) {
		var i = 0;
		for (; i < this.size; i++) {
			callback.call(context, this.data[(this.start + i) % this.length], i, this);
		}
	},
	// check items agains test until one returns true
	// TODO: figure out how to emuldate Array use better
	some: function some(callback, context) {
		var i = 0;
		for (; i < this.size; i++) {
			if (callback.call(context, this.data[(this.start + i) % this.length], i, this)) return true;
		}
		return false;
	},
	// calculate the average value of a circular buffer
	avg: function avg() {
		return this.size == 0 ? 0 : this.sum() / this.size;
	},
	// loop through each item in buffer and calculate sum
	sum: function sum() {
		var index = this.size;
		var s = 0;
		while (index--) {
			s += this.data[index];
		}return s;
	},
	// loop through each item in buffer and calculate median
	median: function median() {
		if (this.size === 0) return 0;
		var values = this.slice().sort(defaultComparitor);
		var half = Math.floor(values.length / 2);
		if (values.length % 2) return values[half];else return (values[half - 1] + values[half]) / 2.0;
	},
	/* utility methods */
	// reset pointers to buffer with zero items
	// note: this will not remove values in cbuffer, so if for security values
	//       need to be overwritten, run `.fill(null).empty()`
	empty: function empty() {
		var i = 0;
		this.size = this.start = 0;
		this.end = this.length - 1;
		return this;
	},
	// fill all places with passed value or function
	fill: function fill(arg) {
		var i = 0;
		if (typeof arg === 'function') {
			while (this.data[i] = arg(), ++i < this.length) {}
		} else {
			while (this.data[i] = arg, ++i < this.length) {}
		}
		// reposition start/end
		this.start = 0;
		this.end = this.length - 1;
		this.size = this.length;
		return this;
	},
	// return first item in buffer
	first: function first() {
		return this.data[this.start];
	},
	// return last item in buffer
	last: function last() {
		return this.data[this.end];
	},
	// return specific index in buffer
	get: function get(arg) {
		return this.data[(this.start + arg) % this.length];
	},
	isFull: function isFull(arg) {
		return this.length === this.size;
	},
	// set value at specified index
	set: function set(idx, arg) {
		return this.data[(this.start + idx) % this.length] = arg;
	},
	// return clean array of values
	toArray: function toArray() {
		return this.slice();
	},
	// slice the buffer to an arraay
	slice: function slice(start, end) {
		var length = this.size;

		start = +start || 0;

		if (start < 0) {
			if (start >= end) return [];
			start = -start > length ? 0 : length + start;
		}

		if (end == null || end > length) end = length;else if (end < 0) end += length;else end = +end || 0;

		length = start < end ? end - start : 0;

		var result = Array(length);
		for (var index = 0; index < length; index++) {
			result[index] = this.data[(this.start + start + index) % this.length];
		}
		return result;
	}
};

//if (typeof module === 'object' && module.exports) module.exports = CBuffer;
//else global.CBuffer = CBuffer;

exports.default = CBuffer;

},{}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FFT = undefined;

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* 
 *  DSP.js - a comprehensive digital signal processing  library for javascript
 * 
 *  Created by Corban Brook <corbanbrook@gmail.com> on 2010-01-01.
 *  Copyright 2010 Corban Brook. All rights reserved.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining
 *  a copy of this software and associated documentation files (the
 *  "Software"), to deal in the Software without restriction, including
 *  without limitation the rights to use, copy, modify, merge, publish,
 *  distribute, sublicense, and/or sell copies of the Software, and to
 *  permit persons to whom the Software is furnished to do so, subject to
 *  the following conditions:
 * 
 *  The above copyright notice and this permission notice shall be
 *  included in all copies or substantial portions of the Software.
 * 
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

////////////////////////////////////////////////////////////////////////////////
//                                  CONSTANTS                                 //
////////////////////////////////////////////////////////////////////////////////

/**
 * DSP is an object which contains general purpose utility functions and constants
 */
var DSP = {
  // Channels
  LEFT: 0,
  RIGHT: 1,
  MIX: 2,

  // Waveforms
  SINE: 1,
  TRIANGLE: 2,
  SAW: 3,
  SQUARE: 4,

  // Filters
  LOWPASS: 0,
  HIGHPASS: 1,
  BANDPASS: 2,
  NOTCH: 3,

  // Window functions
  BARTLETT: 1,
  BARTLETTHANN: 2,
  BLACKMAN: 3,
  COSINE: 4,
  GAUSS: 5,
  HAMMING: 6,
  HANN: 7,
  LANCZOS: 8,
  RECTANGULAR: 9,
  TRIANGULAR: 10,

  // Loop modes
  OFF: 0,
  FW: 1,
  BW: 2,
  FWBW: 3,

  // Math
  TWO_PI: 2 * Math.PI
};

// Setup arrays for platforms which do not support byte arrays
function setupTypedArray(name, fallback) {
  var self = window;
  // check if TypedArray exists
  // typeof on Minefield and Chrome return function, typeof on Webkit returns object.
  if (typeof self[name] !== "function" && (0, _typeof3.default)(self[name]) !== "object") {
    // nope.. check if WebGLArray exists
    if (typeof self[fallback] === "function" && (0, _typeof3.default)(self[fallback]) !== "object") {
      self[name] = self[fallback];
    } else {
      // nope.. set as Native JS array
      self[name] = function (obj) {
        if (obj instanceof Array) {
          return obj;
        } else if (typeof obj === "number") {
          return new Array(obj);
        }
      };
    }
  }
}

setupTypedArray("Float32Array", "WebGLFloatArray");
setupTypedArray("Int32Array", "WebGLIntArray");
setupTypedArray("Uint16Array", "WebGLUnsignedShortArray");
setupTypedArray("Uint8Array", "WebGLUnsignedByteArray");

////////////////////////////////////////////////////////////////////////////////
//                            DSP UTILITY FUNCTIONS                           //
////////////////////////////////////////////////////////////////////////////////

/**
 * Inverts the phase of a signal
 *
 * @param {Array} buffer A sample buffer
 *
 * @returns The inverted sample buffer
 */
DSP.invert = function (buffer) {
  for (var i = 0, len = buffer.length; i < len; i++) {
    buffer[i] *= -1;
  }

  return buffer;
};

/**
 * Converts split-stereo (dual mono) sample buffers into a stereo interleaved sample buffer
 *
 * @param {Array} left  A sample buffer
 * @param {Array} right A sample buffer
 *
 * @returns The stereo interleaved buffer
 */
DSP.interleave = function (left, right) {
  if (left.length !== right.length) {
    throw "Can not interleave. Channel lengths differ.";
  }

  var stereoInterleaved = new Float32Array(left.length * 2);

  for (var i = 0, len = left.length; i < len; i++) {
    stereoInterleaved[2 * i] = left[i];
    stereoInterleaved[2 * i + 1] = right[i];
  }

  return stereoInterleaved;
};

/**
 * Converts a stereo-interleaved sample buffer into split-stereo (dual mono) sample buffers
 *
 * @param {Array} buffer A stereo-interleaved sample buffer
 *
 * @returns an Array containing left and right channels
 */
DSP.deinterleave = function () {
  var left,
      right,
      mix,
      deinterleaveChannel = [];

  deinterleaveChannel[DSP.MIX] = function (buffer) {
    for (var i = 0, len = buffer.length / 2; i < len; i++) {
      mix[i] = (buffer[2 * i] + buffer[2 * i + 1]) / 2;
    }
    return mix;
  };

  deinterleaveChannel[DSP.LEFT] = function (buffer) {
    for (var i = 0, len = buffer.length / 2; i < len; i++) {
      left[i] = buffer[2 * i];
    }
    return left;
  };

  deinterleaveChannel[DSP.RIGHT] = function (buffer) {
    for (var i = 0, len = buffer.length / 2; i < len; i++) {
      right[i] = buffer[2 * i + 1];
    }
    return right;
  };

  return function (channel, buffer) {
    left = left || new Float32Array(buffer.length / 2);
    right = right || new Float32Array(buffer.length / 2);
    mix = mix || new Float32Array(buffer.length / 2);

    if (buffer.length / 2 !== left.length) {
      left = new Float32Array(buffer.length / 2);
      right = new Float32Array(buffer.length / 2);
      mix = new Float32Array(buffer.length / 2);
    }

    return deinterleaveChannel[channel](buffer);
  };
}();

/**
 * Separates a channel from a stereo-interleaved sample buffer
 *
 * @param {Array}  buffer A stereo-interleaved sample buffer
 * @param {Number} channel A channel constant (LEFT, RIGHT, MIX)
 *
 * @returns an Array containing a signal mono sample buffer
 */
DSP.getChannel = DSP.deinterleave;

/**
 * Helper method (for Reverb) to mix two (interleaved) samplebuffers. It's possible
 * to negate the second buffer while mixing and to perform a volume correction
 * on the final signal.
 *
 * @param {Array} sampleBuffer1 Array containing Float values or a Float32Array
 * @param {Array} sampleBuffer2 Array containing Float values or a Float32Array
 * @param {Boolean} negate When true inverts/flips the audio signal
 * @param {Number} volumeCorrection When you add multiple sample buffers, use this to tame your signal ;)
 *
 * @returns A new Float32Array interleaved buffer.
 */
DSP.mixSampleBuffers = function (sampleBuffer1, sampleBuffer2, negate, volumeCorrection) {
  var outputSamples = new Float32Array(sampleBuffer1);

  for (var i = 0; i < sampleBuffer1.length; i++) {
    outputSamples[i] += (negate ? -sampleBuffer2[i] : sampleBuffer2[i]) / volumeCorrection;
  }

  return outputSamples;
};

// Biquad filter types
DSP.LPF = 0; // H(s) = 1 / (s^2 + s/Q + 1)
DSP.HPF = 1; // H(s) = s^2 / (s^2 + s/Q + 1)
DSP.BPF_CONSTANT_SKIRT = 2; // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
DSP.BPF_CONSTANT_PEAK = 3; // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
DSP.NOTCH = 4; // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
DSP.APF = 5; // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
DSP.PEAKING_EQ = 6; // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
DSP.LOW_SHELF = 7; // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
DSP.HIGH_SHELF = 8; // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)

// Biquad filter parameter types
DSP.Q = 1;
DSP.BW = 2; // SHARED with BACKWARDS LOOP MODE
DSP.S = 3;

// Find RMS of signal
DSP.RMS = function (buffer) {
  var total = 0;

  for (var i = 0, n = buffer.length; i < n; i++) {
    total += buffer[i] * buffer[i];
  }

  return Math.sqrt(total / n);
};

// Find Peak of signal
DSP.Peak = function (buffer) {
  var peak = 0;

  for (var i = 0, n = buffer.length; i < n; i++) {
    peak = Math.abs(buffer[i]) > peak ? Math.abs(buffer[i]) : peak;
  }

  return peak;
};

// Fourier Transform Module used by DFT, FFT, RFFT
function FourierTransform(bufferSize, sampleRate) {
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.bandwidth = 2 / bufferSize * sampleRate / 2;

  this.spectrum = new Float32Array(bufferSize / 2);
  this.real = new Float32Array(bufferSize);
  this.imag = new Float32Array(bufferSize);

  this.peakBand = 0;
  this.peak = 0;

  /**
   * Calculates the *middle* frequency of an FFT band.
   *
   * @param {Number} index The index of the FFT band.
   *
   * @returns The middle frequency in Hz.
   */
  this.getBandFrequency = function (index) {
    return this.bandwidth * index + this.bandwidth / 2;
  };

  this.calculateSpectrum = function () {
    var spectrum = this.spectrum,
        real = this.real,
        imag = this.imag,
        bSi = 2 / this.bufferSize,
        sqrt = Math.sqrt,
        rval,
        ival,
        mag;

    for (var i = 0, N = bufferSize / 2; i < N; i++) {
      rval = real[i];
      ival = imag[i];
      mag = bSi * sqrt(rval * rval + ival * ival);

      if (mag > this.peak) {
        this.peakBand = i;
        this.peak = mag;
      }

      spectrum[i] = mag;
    }
  };
}

/**
 * DFT is a class for calculating the Discrete Fourier Transform of a signal.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function DFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  var N = bufferSize / 2 * bufferSize;
  var TWO_PI = 2 * Math.PI;

  this.sinTable = new Float32Array(N);
  this.cosTable = new Float32Array(N);

  for (var i = 0; i < N; i++) {
    this.sinTable[i] = Math.sin(i * TWO_PI / bufferSize);
    this.cosTable[i] = Math.cos(i * TWO_PI / bufferSize);
  }
}

/**
 * Performs a forward transform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer
 *
 * @returns The frequency spectrum array
 */
DFT.prototype.forward = function (buffer) {
  var real = this.real,
      imag = this.imag,
      rval,
      ival;

  for (var k = 0; k < this.bufferSize / 2; k++) {
    rval = 0.0;
    ival = 0.0;

    for (var n = 0; n < buffer.length; n++) {
      rval += this.cosTable[k * n] * buffer[n];
      ival += this.sinTable[k * n] * buffer[n];
    }

    real[k] = rval;
    imag[k] = ival;
  }

  return this.calculateSpectrum();
};

/**
 * FFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */
function FFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  this.reverseTable = new Uint32Array(bufferSize);

  var limit = 1;
  var bit = bufferSize >> 1;

  var i;

  while (limit < bufferSize) {
    for (i = 0; i < limit; i++) {
      this.reverseTable[i + limit] = this.reverseTable[i] + bit;
    }

    limit = limit << 1;
    bit = bit >> 1;
  }

  this.sinTable = new Float32Array(bufferSize);
  this.cosTable = new Float32Array(bufferSize);

  for (i = 0; i < bufferSize; i++) {
    this.sinTable[i] = Math.sin(-Math.PI / i);
    this.cosTable[i] = Math.cos(-Math.PI / i);
  }
}

/**
 * Performs a forward transform on the sample buffer.
 * Converts a time domain signal to frequency domain spectra.
 *
 * @param {Array} buffer The sample buffer. Buffer Length must be power of 2
 *
 * @returns The frequency spectrum array
 */
FFT.prototype.forward = function (buffer) {
  // Locally scope variables for speed up
  var bufferSize = this.bufferSize,
      cosTable = this.cosTable,
      sinTable = this.sinTable,
      reverseTable = this.reverseTable,
      real = this.real,
      imag = this.imag,
      spectrum = this.spectrum;

  var k = Math.floor(Math.log(bufferSize) / Math.LN2);

  if (Math.pow(2, k) !== bufferSize) {
    throw "Invalid buffer size, must be a power of 2.";
  }
  if (bufferSize !== buffer.length) {
    throw "Supplied buffer is not the same size as defined FFT. FFT Size: " + bufferSize + " Buffer Size: " + buffer.length;
  }

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    real[i] = buffer[reverseTable[i]];
    imag[i] = 0;
  }

  while (halfSize < bufferSize) {
    //phaseShiftStepReal = Math.cos(-Math.PI/halfSize);
    //phaseShiftStepImag = Math.sin(-Math.PI/halfSize);
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];

    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = currentPhaseShiftReal * real[off] - currentPhaseShiftImag * imag[off];
        ti = currentPhaseShiftReal * imag[off] + currentPhaseShiftImag * real[off];

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = tmpReal * phaseShiftStepReal - currentPhaseShiftImag * phaseShiftStepImag;
      currentPhaseShiftImag = tmpReal * phaseShiftStepImag + currentPhaseShiftImag * phaseShiftStepReal;
    }

    halfSize = halfSize << 1;
  }

  return this.calculateSpectrum();
};

FFT.prototype.inverse = function (real, imag, buffer) {
  // Locally scope variables for speed up
  var bufferSize = this.bufferSize,
      cosTable = this.cosTable,
      sinTable = this.sinTable,
      reverseTable = this.reverseTable,
      spectrum = this.spectrum;

  real = real || this.real;
  imag = imag || this.imag;

  var halfSize = 1,
      phaseShiftStepReal,
      phaseShiftStepImag,
      currentPhaseShiftReal,
      currentPhaseShiftImag,
      off,
      tr,
      ti,
      tmpReal,
      i;

  for (i = 0; i < bufferSize; i++) {
    imag[i] *= -1;
  }

  var revReal = new Float32Array(bufferSize);
  var revImag = new Float32Array(bufferSize);

  for (i = 0; i < real.length; i++) {
    revReal[i] = real[reverseTable[i]];
    revImag[i] = imag[reverseTable[i]];
  }

  real = revReal;
  imag = revImag;

  while (halfSize < bufferSize) {
    phaseShiftStepReal = cosTable[halfSize];
    phaseShiftStepImag = sinTable[halfSize];
    currentPhaseShiftReal = 1;
    currentPhaseShiftImag = 0;

    for (var fftStep = 0; fftStep < halfSize; fftStep++) {
      i = fftStep;

      while (i < bufferSize) {
        off = i + halfSize;
        tr = currentPhaseShiftReal * real[off] - currentPhaseShiftImag * imag[off];
        ti = currentPhaseShiftReal * imag[off] + currentPhaseShiftImag * real[off];

        real[off] = real[i] - tr;
        imag[off] = imag[i] - ti;
        real[i] += tr;
        imag[i] += ti;

        i += halfSize << 1;
      }

      tmpReal = currentPhaseShiftReal;
      currentPhaseShiftReal = tmpReal * phaseShiftStepReal - currentPhaseShiftImag * phaseShiftStepImag;
      currentPhaseShiftImag = tmpReal * phaseShiftStepImag + currentPhaseShiftImag * phaseShiftStepReal;
    }

    halfSize = halfSize << 1;
  }

  // var buffer = new Float32Array(bufferSize); // this should be reused instead
  for (i = 0; i < bufferSize; i++) {
    buffer[i] = real[i] / bufferSize;
  }

  return buffer;
};

/**
 * RFFT is a class for calculating the Discrete Fourier Transform of a signal
 * with the Fast Fourier Transform algorithm.
 *
 * This method currently only contains a forward transform but is highly optimized.
 *
 * @param {Number} bufferSize The size of the sample buffer to be computed. Must be power of 2
 * @param {Number} sampleRate The sampleRate of the buffer (eg. 44100)
 *
 * @constructor
 */

// lookup tables don't really gain us any speed, but they do increase
// cache footprint, so don't use them in here

// also we don't use sepearate arrays for real/imaginary parts

// this one a little more than twice as fast as the one in FFT
// however I only did the forward transform

// the rest of this was translated from C, see http://www.jjj.de/fxt/
// this is the real split radix FFT

function RFFT(bufferSize, sampleRate) {
  FourierTransform.call(this, bufferSize, sampleRate);

  this.trans = new Float32Array(bufferSize);

  this.reverseTable = new Uint32Array(bufferSize);

  // don't use a lookup table to do the permute, use this instead
  this.reverseBinPermute = function (dest, source) {
    var bufferSize = this.bufferSize,
        halfSize = bufferSize >>> 1,
        nm1 = bufferSize - 1,
        i = 1,
        r = 0,
        h;

    dest[0] = source[0];

    do {
      r += halfSize;
      dest[i] = source[r];
      dest[r] = source[i];

      i++;

      h = halfSize << 1;
      while (h = h >> 1, !((r ^= h) & h)) {}

      if (r >= i) {
        dest[i] = source[r];
        dest[r] = source[i];

        dest[nm1 - i] = source[nm1 - r];
        dest[nm1 - r] = source[nm1 - i];
      }
      i++;
    } while (i < halfSize);
    dest[nm1] = source[nm1];
  };

  this.generateReverseTable = function () {
    var bufferSize = this.bufferSize,
        halfSize = bufferSize >>> 1,
        nm1 = bufferSize - 1,
        i = 1,
        r = 0,
        h;

    this.reverseTable[0] = 0;

    do {
      r += halfSize;

      this.reverseTable[i] = r;
      this.reverseTable[r] = i;

      i++;

      h = halfSize << 1;
      while (h = h >> 1, !((r ^= h) & h)) {}

      if (r >= i) {
        this.reverseTable[i] = r;
        this.reverseTable[r] = i;

        this.reverseTable[nm1 - i] = nm1 - r;
        this.reverseTable[nm1 - r] = nm1 - i;
      }
      i++;
    } while (i < halfSize);

    this.reverseTable[nm1] = nm1;
  };

  this.generateReverseTable();
}

// Ordering of output:
//
// trans[0]     = re[0] (==zero frequency, purely real)
// trans[1]     = re[1]
//             ...
// trans[n/2-1] = re[n/2-1]
// trans[n/2]   = re[n/2]    (==nyquist frequency, purely real)
//
// trans[n/2+1] = im[n/2-1]
// trans[n/2+2] = im[n/2-2]
//             ...
// trans[n-1]   = im[1] 

RFFT.prototype.forward = function (buffer) {
  var n = this.bufferSize,
      spectrum = this.spectrum,
      x = this.trans,
      TWO_PI = 2 * Math.PI,
      sqrt = Math.sqrt,
      i = n >>> 1,
      bSi = 2 / n,
      n2,
      n4,
      n8,
      nn,
      t1,
      t2,
      t3,
      t4,
      i1,
      i2,
      i3,
      i4,
      i5,
      i6,
      i7,
      i8,
      st1,
      cc1,
      ss1,
      cc3,
      ss3,
      e,
      a,
      rval,
      ival,
      mag;

  this.reverseBinPermute(x, buffer);

  /*
  var reverseTable = this.reverseTable;
   for (var k = 0, len = reverseTable.length; k < len; k++) {
    x[k] = buffer[reverseTable[k]];
  }
  */

  for (var ix = 0, id = 4; ix < n; id *= 4) {
    for (var i0 = ix; i0 < n; i0 += id) {
      //sumdiff(x[i0], x[i0+1]); // {a, b}  <--| {a+b, a-b}
      st1 = x[i0] - x[i0 + 1];
      x[i0] += x[i0 + 1];
      x[i0 + 1] = st1;
    }
    ix = 2 * (id - 1);
  }

  n2 = 2;
  nn = n >>> 1;

  while (nn = nn >>> 1) {
    ix = 0;
    n2 = n2 << 1;
    id = n2 << 1;
    n4 = n2 >>> 2;
    n8 = n2 >>> 3;
    do {
      if (n4 !== 1) {
        for (i0 = ix; i0 < n; i0 += id) {
          i1 = i0;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;

          //diffsum3_r(x[i3], x[i4], t1); // {a, b, s} <--| {a, b-a, a+b}
          t1 = x[i3] + x[i4];
          x[i4] -= x[i3];
          //sumdiff3(x[i1], t1, x[i3]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i3] = x[i1] - t1;
          x[i1] += t1;

          i1 += n8;
          i2 += n8;
          i3 += n8;
          i4 += n8;

          //sumdiff(x[i3], x[i4], t1, t2); // {s, d}  <--| {a+b, a-b}
          t1 = x[i3] + x[i4];
          t2 = x[i3] - x[i4];

          t1 = -t1 * Math.SQRT1_2;
          t2 *= Math.SQRT1_2;

          // sumdiff(t1, x[i2], x[i4], x[i3]); // {s, d}  <--| {a+b, a-b}
          st1 = x[i2];
          x[i4] = t1 + st1;
          x[i3] = t1 - st1;

          //sumdiff3(x[i1], t2, x[i2]); // {a, b, d} <--| {a+b, b, a-b}
          x[i2] = x[i1] - t2;
          x[i1] += t2;
        }
      } else {
        for (i0 = ix; i0 < n; i0 += id) {
          i1 = i0;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;

          //diffsum3_r(x[i3], x[i4], t1); // {a, b, s} <--| {a, b-a, a+b}
          t1 = x[i3] + x[i4];
          x[i4] -= x[i3];

          //sumdiff3(x[i1], t1, x[i3]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i3] = x[i1] - t1;
          x[i1] += t1;
        }
      }

      ix = (id << 1) - n2;
      id = id << 2;
    } while (ix < n);

    e = TWO_PI / n2;

    for (var j = 1; j < n8; j++) {
      a = j * e;
      ss1 = Math.sin(a);
      cc1 = Math.cos(a);

      //ss3 = sin(3*a); cc3 = cos(3*a);
      cc3 = 4 * cc1 * (cc1 * cc1 - 0.75);
      ss3 = 4 * ss1 * (0.75 - ss1 * ss1);

      ix = 0;id = n2 << 1;
      do {
        for (i0 = ix; i0 < n; i0 += id) {
          i1 = i0 + j;
          i2 = i1 + n4;
          i3 = i2 + n4;
          i4 = i3 + n4;

          i5 = i0 + n4 - j;
          i6 = i5 + n4;
          i7 = i6 + n4;
          i8 = i7 + n4;

          //cmult(c, s, x, y, &u, &v)
          //cmult(cc1, ss1, x[i7], x[i3], t2, t1); // {u,v} <--| {x*c-y*s, x*s+y*c}
          t2 = x[i7] * cc1 - x[i3] * ss1;
          t1 = x[i7] * ss1 + x[i3] * cc1;

          //cmult(cc3, ss3, x[i8], x[i4], t4, t3);
          t4 = x[i8] * cc3 - x[i4] * ss3;
          t3 = x[i8] * ss3 + x[i4] * cc3;

          //sumdiff(t2, t4);   // {a, b} <--| {a+b, a-b}
          st1 = t2 - t4;
          t2 += t4;
          t4 = st1;

          //sumdiff(t2, x[i6], x[i8], x[i3]); // {s, d}  <--| {a+b, a-b}
          //st1 = x[i6]; x[i8] = t2 + st1; x[i3] = t2 - st1;
          x[i8] = t2 + x[i6];
          x[i3] = t2 - x[i6];

          //sumdiff_r(t1, t3); // {a, b} <--| {a+b, b-a}
          st1 = t3 - t1;
          t1 += t3;
          t3 = st1;

          //sumdiff(t3, x[i2], x[i4], x[i7]); // {s, d}  <--| {a+b, a-b}
          //st1 = x[i2]; x[i4] = t3 + st1; x[i7] = t3 - st1;
          x[i4] = t3 + x[i2];
          x[i7] = t3 - x[i2];

          //sumdiff3(x[i1], t1, x[i6]);   // {a, b, d} <--| {a+b, b, a-b}
          x[i6] = x[i1] - t1;
          x[i1] += t1;

          //diffsum3_r(t4, x[i5], x[i2]); // {a, b, s} <--| {a, b-a, a+b}
          x[i2] = t4 + x[i5];
          x[i5] -= t4;
        }

        ix = (id << 1) - n2;
        id = id << 2;
      } while (ix < n);
    }
  }

  while (--i) {
    rval = x[i];
    ival = x[n - i - 1];
    mag = bSi * sqrt(rval * rval + ival * ival);

    if (mag > this.peak) {
      this.peakBand = i;
      this.peak = mag;
    }

    spectrum[i] = mag;
  }

  spectrum[0] = bSi * x[0];

  return spectrum;
};

function Sampler(file, bufferSize, sampleRate, playStart, playEnd, loopStart, loopEnd, loopMode) {
  this.file = file;
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  this.playStart = playStart || 0; // 0%
  this.playEnd = playEnd || 1; // 100%
  this.loopStart = loopStart || 0;
  this.loopEnd = loopEnd || 1;
  this.loopMode = loopMode || DSP.OFF;
  this.loaded = false;
  this.samples = [];
  this.signal = new Float32Array(bufferSize);
  this.frameCount = 0;
  this.envelope = null;
  this.amplitude = 1;
  this.rootFrequency = 110; // A2 110
  this.frequency = 550;
  this.step = this.frequency / this.rootFrequency;
  this.duration = 0;
  this.samplesProcessed = 0;
  this.playhead = 0;

  var audio = /* new Audio();*/document.createElement("AUDIO");
  var self = this;

  this.loadSamples = function (event) {
    var buffer = DSP.getChannel(DSP.MIX, event.frameBuffer);
    for (var i = 0; i < buffer.length; i++) {
      self.samples.push(buffer[i]);
    }
  };

  this.loadComplete = function () {
    // convert flexible js array into a fast typed array
    self.samples = new Float32Array(self.samples);
    self.loaded = true;
  };

  this.loadMetaData = function () {
    self.duration = audio.duration;
  };

  audio.addEventListener("MozAudioAvailable", this.loadSamples, false);
  audio.addEventListener("loadedmetadata", this.loadMetaData, false);
  audio.addEventListener("ended", this.loadComplete, false);
  audio.muted = true;
  audio.src = file;
  audio.play();
}

Sampler.prototype.applyEnvelope = function () {
  this.envelope.process(this.signal);
  return this.signal;
};

Sampler.prototype.generate = function () {
  var frameOffset = this.frameCount * this.bufferSize;

  var loopWidth = this.playEnd * this.samples.length - this.playStart * this.samples.length;
  var playStartSamples = this.playStart * this.samples.length; // ie 0.5 -> 50% of the length
  var playEndSamples = this.playEnd * this.samples.length; // ie 0.5 -> 50% of the length
  var offset;

  for (var i = 0; i < this.bufferSize; i++) {
    switch (this.loopMode) {
      case DSP.OFF:
        this.playhead = Math.round(this.samplesProcessed * this.step + playStartSamples);
        if (this.playhead < this.playEnd * this.samples.length) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        } else {
          this.signal[i] = 0;
        }
        break;

      case DSP.FW:
        this.playhead = Math.round(this.samplesProcessed * this.step % loopWidth + playStartSamples);
        if (this.playhead < this.playEnd * this.samples.length) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;

      case DSP.BW:
        this.playhead = playEndSamples - Math.round(this.samplesProcessed * this.step % loopWidth);
        if (this.playhead < this.playEnd * this.samples.length) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;

      case DSP.FWBW:
        if (Math.floor(this.samplesProcessed * this.step / loopWidth) % 2 === 0) {
          this.playhead = Math.round(this.samplesProcessed * this.step % loopWidth + playStartSamples);
        } else {
          this.playhead = playEndSamples - Math.round(this.samplesProcessed * this.step % loopWidth);
        }
        if (this.playhead < this.playEnd * this.samples.length) {
          this.signal[i] = this.samples[this.playhead] * this.amplitude;
        }
        break;
    }
    this.samplesProcessed++;
  }

  this.frameCount++;

  return this.signal;
};

Sampler.prototype.setFreq = function (frequency) {
  var totalProcessed = this.samplesProcessed * this.step;
  this.frequency = frequency;
  this.step = this.frequency / this.rootFrequency;
  this.samplesProcessed = Math.round(totalProcessed / this.step);
};

Sampler.prototype.reset = function () {
  this.samplesProcessed = 0;
  this.playhead = 0;
};

/**
 * Oscillator class for generating and modifying signals
 *
 * @param {Number} type       A waveform constant (eg. DSP.SINE)
 * @param {Number} frequency  Initial frequency of the signal
 * @param {Number} amplitude  Initial amplitude of the signal
 * @param {Number} bufferSize Size of the sample buffer to generate
 * @param {Number} sampleRate The sample rate of the signal
 *
 * @contructor
 */
function Oscillator(type, frequency, amplitude, bufferSize, sampleRate) {
  this.frequency = frequency;
  this.amplitude = amplitude;
  this.bufferSize = bufferSize;
  this.sampleRate = sampleRate;
  //this.pulseWidth = pulseWidth;
  this.frameCount = 0;

  this.waveTableLength = 2048;

  this.cyclesPerSample = frequency / sampleRate;

  this.signal = new Float32Array(bufferSize);
  this.envelope = null;

  switch (parseInt(type, 10)) {
    case DSP.TRIANGLE:
      this.func = Oscillator.Triangle;
      break;

    case DSP.SAW:
      this.func = Oscillator.Saw;
      break;

    case DSP.SQUARE:
      this.func = Oscillator.Square;
      break;

    default:
    case DSP.SINE:
      this.func = Oscillator.Sine;
      break;
  }

  this.generateWaveTable = function () {
    Oscillator.waveTable[this.func] = new Float32Array(2048);
    var waveTableTime = this.waveTableLength / this.sampleRate;
    var waveTableHz = 1 / waveTableTime;

    for (var i = 0; i < this.waveTableLength; i++) {
      Oscillator.waveTable[this.func][i] = this.func(i * waveTableHz / this.sampleRate);
    }
  };

  if (typeof Oscillator.waveTable === 'undefined') {
    Oscillator.waveTable = {};
  }

  if (typeof Oscillator.waveTable[this.func] === 'undefined') {
    this.generateWaveTable();
  }

  this.waveTable = Oscillator.waveTable[this.func];
}

/**
 * Set the amplitude of the signal
 *
 * @param {Number} amplitude The amplitude of the signal (between 0 and 1)
 */
Oscillator.prototype.setAmp = function (amplitude) {
  if (amplitude >= 0 && amplitude <= 1) {
    this.amplitude = amplitude;
  } else {
    throw "Amplitude out of range (0..1).";
  }
};

/**
 * Set the frequency of the signal
 *
 * @param {Number} frequency The frequency of the signal
 */
Oscillator.prototype.setFreq = function (frequency) {
  this.frequency = frequency;
  this.cyclesPerSample = frequency / this.sampleRate;
};

// Add an oscillator
Oscillator.prototype.add = function (oscillator) {
  for (var i = 0; i < this.bufferSize; i++) {
    //this.signal[i] += oscillator.valueAt(i);
    this.signal[i] += oscillator.signal[i];
  }

  return this.signal;
};

// Add a signal to the current generated osc signal
Oscillator.prototype.addSignal = function (signal) {
  for (var i = 0; i < signal.length; i++) {
    if (i >= this.bufferSize) {
      break;
    }
    this.signal[i] += signal[i];

    /*
    // Constrain amplitude
    if ( this.signal[i] > 1 ) {
      this.signal[i] = 1;
    } else if ( this.signal[i] < -1 ) {
      this.signal[i] = -1;
    }
    */
  }
  return this.signal;
};

// Add an envelope to the oscillator
Oscillator.prototype.addEnvelope = function (envelope) {
  this.envelope = envelope;
};

Oscillator.prototype.applyEnvelope = function () {
  this.envelope.process(this.signal);
};

Oscillator.prototype.valueAt = function (offset) {
  return this.waveTable[offset % this.waveTableLength];
};

Oscillator.prototype.generate = function () {
  var frameOffset = this.frameCount * this.bufferSize;
  var step = this.waveTableLength * this.frequency / this.sampleRate;
  var offset;

  for (var i = 0; i < this.bufferSize; i++) {
    //var step = (frameOffset + i) * this.cyclesPerSample % 1;
    //this.signal[i] = this.func(step) * this.amplitude;
    //this.signal[i] = this.valueAt(Math.round((frameOffset + i) * step)) * this.amplitude;
    offset = Math.round((frameOffset + i) * step);
    this.signal[i] = this.waveTable[offset % this.waveTableLength] * this.amplitude;
  }

  this.frameCount++;

  return this.signal;
};

Oscillator.Sine = function (step) {
  return Math.sin(DSP.TWO_PI * step);
};

Oscillator.Square = function (step) {
  return step < 0.5 ? 1 : -1;
};

Oscillator.Saw = function (step) {
  return 2 * (step - Math.round(step));
};

Oscillator.Triangle = function (step) {
  return 1 - 4 * Math.abs(Math.round(step) - step);
};

Oscillator.Pulse = function (step) {
  // stub
};

function ADSR(attackLength, decayLength, sustainLevel, sustainLength, releaseLength, sampleRate) {
  this.sampleRate = sampleRate;
  // Length in seconds
  this.attackLength = attackLength;
  this.decayLength = decayLength;
  this.sustainLevel = sustainLevel;
  this.sustainLength = sustainLength;
  this.releaseLength = releaseLength;
  this.sampleRate = sampleRate;

  // Length in samples
  this.attackSamples = attackLength * sampleRate;
  this.decaySamples = decayLength * sampleRate;
  this.sustainSamples = sustainLength * sampleRate;
  this.releaseSamples = releaseLength * sampleRate;

  // Updates the envelope sample positions
  this.update = function () {
    this.attack = this.attackSamples;
    this.decay = this.attack + this.decaySamples;
    this.sustain = this.decay + this.sustainSamples;
    this.release = this.sustain + this.releaseSamples;
  };

  this.update();

  this.samplesProcessed = 0;
}

ADSR.prototype.noteOn = function () {
  this.samplesProcessed = 0;
  this.sustainSamples = this.sustainLength * this.sampleRate;
  this.update();
};

// Send a note off when using a sustain of infinity to let the envelope enter the release phase
ADSR.prototype.noteOff = function () {
  this.sustainSamples = this.samplesProcessed - this.decaySamples;
  this.update();
};

ADSR.prototype.processSample = function (sample) {
  var amplitude = 0;

  if (this.samplesProcessed <= this.attack) {
    amplitude = 0 + (1 - 0) * ((this.samplesProcessed - 0) / (this.attack - 0));
  } else if (this.samplesProcessed > this.attack && this.samplesProcessed <= this.decay) {
    amplitude = 1 + (this.sustainLevel - 1) * ((this.samplesProcessed - this.attack) / (this.decay - this.attack));
  } else if (this.samplesProcessed > this.decay && this.samplesProcessed <= this.sustain) {
    amplitude = this.sustainLevel;
  } else if (this.samplesProcessed > this.sustain && this.samplesProcessed <= this.release) {
    amplitude = this.sustainLevel + (0 - this.sustainLevel) * ((this.samplesProcessed - this.sustain) / (this.release - this.sustain));
  }

  return sample * amplitude;
};

ADSR.prototype.value = function () {
  var amplitude = 0;

  if (this.samplesProcessed <= this.attack) {
    amplitude = 0 + (1 - 0) * ((this.samplesProcessed - 0) / (this.attack - 0));
  } else if (this.samplesProcessed > this.attack && this.samplesProcessed <= this.decay) {
    amplitude = 1 + (this.sustainLevel - 1) * ((this.samplesProcessed - this.attack) / (this.decay - this.attack));
  } else if (this.samplesProcessed > this.decay && this.samplesProcessed <= this.sustain) {
    amplitude = this.sustainLevel;
  } else if (this.samplesProcessed > this.sustain && this.samplesProcessed <= this.release) {
    amplitude = this.sustainLevel + (0 - this.sustainLevel) * ((this.samplesProcessed - this.sustain) / (this.release - this.sustain));
  }

  return amplitude;
};

ADSR.prototype.process = function (buffer) {
  for (var i = 0; i < buffer.length; i++) {
    buffer[i] *= this.value();

    this.samplesProcessed++;
  }

  return buffer;
};

ADSR.prototype.isActive = function () {
  if (this.samplesProcessed > this.release || this.samplesProcessed === -1) {
    return false;
  } else {
    return true;
  }
};

ADSR.prototype.disable = function () {
  this.samplesProcessed = -1;
};

function IIRFilter(type, cutoff, resonance, sampleRate) {
  this.sampleRate = sampleRate;

  switch (type) {
    case DSP.LOWPASS:
    case DSP.LP12:
      this.func = new IIRFilter.LP12(cutoff, resonance, sampleRate);
      break;
  }
}

IIRFilter.prototype.__defineGetter__('cutoff', function () {
  return this.func.cutoff;
});

IIRFilter.prototype.__defineGetter__('resonance', function () {
  return this.func.resonance;
});

IIRFilter.prototype.set = function (cutoff, resonance) {
  this.func.calcCoeff(cutoff, resonance);
};

IIRFilter.prototype.process = function (buffer) {
  this.func.process(buffer);
};

// Add an envelope to the filter
IIRFilter.prototype.addEnvelope = function (envelope) {
  if (envelope instanceof ADSR) {
    this.func.addEnvelope(envelope);
  } else {
    throw "Not an envelope.";
  }
};

IIRFilter.LP12 = function (cutoff, resonance, sampleRate) {
  this.sampleRate = sampleRate;
  this.vibraPos = 0;
  this.vibraSpeed = 0;
  this.envelope = false;

  this.calcCoeff = function (cutoff, resonance) {
    this.w = 2.0 * Math.PI * cutoff / this.sampleRate;
    this.q = 1.0 - this.w / (2.0 * (resonance + 0.5 / (1.0 + this.w)) + this.w - 2.0);
    this.r = this.q * this.q;
    this.c = this.r + 1.0 - 2.0 * Math.cos(this.w) * this.q;

    this.cutoff = cutoff;
    this.resonance = resonance;
  };

  this.calcCoeff(cutoff, resonance);

  this.process = function (buffer) {
    for (var i = 0; i < buffer.length; i++) {
      this.vibraSpeed += (buffer[i] - this.vibraPos) * this.c;
      this.vibraPos += this.vibraSpeed;
      this.vibraSpeed *= this.r;

      /*
      var temp = this.vibraPos;
            if ( temp > 1.0 ) {
        temp = 1.0;
      } else if ( temp < -1.0 ) {
        temp = -1.0;
      } else if ( temp != temp ) {
        temp = 1;
      }
            buffer[i] = temp;
      */

      if (this.envelope) {
        buffer[i] = buffer[i] * (1 - this.envelope.value()) + this.vibraPos * this.envelope.value();
        this.envelope.samplesProcessed++;
      } else {
        buffer[i] = this.vibraPos;
      }
    }
  };
};

IIRFilter.LP12.prototype.addEnvelope = function (envelope) {
  this.envelope = envelope;
};

function IIRFilter2(type, cutoff, resonance, sampleRate) {
  this.type = type;
  this.cutoff = cutoff;
  this.resonance = resonance;
  this.sampleRate = sampleRate;

  this.f = Float32Array(4);
  this.f[0] = 0.0; // lp
  this.f[1] = 0.0; // hp
  this.f[2] = 0.0; // bp
  this.f[3] = 0.0; // br 

  this.calcCoeff = function (cutoff, resonance) {
    this.freq = 2 * Math.sin(Math.PI * Math.min(0.25, cutoff / (this.sampleRate * 2)));
    this.damp = Math.min(2 * (1 - Math.pow(resonance, 0.25)), Math.min(2, 2 / this.freq - this.freq * 0.5));
  };

  this.calcCoeff(cutoff, resonance);
}

IIRFilter2.prototype.process = function (buffer) {
  var input, output;
  var f = this.f;

  for (var i = 0; i < buffer.length; i++) {
    input = buffer[i];

    // first pass
    f[3] = input - this.damp * f[2];
    f[0] = f[0] + this.freq * f[2];
    f[1] = f[3] - f[0];
    f[2] = this.freq * f[1] + f[2];
    output = 0.5 * f[this.type];

    // second pass
    f[3] = input - this.damp * f[2];
    f[0] = f[0] + this.freq * f[2];
    f[1] = f[3] - f[0];
    f[2] = this.freq * f[1] + f[2];
    output += 0.5 * f[this.type];

    if (this.envelope) {
      buffer[i] = buffer[i] * (1 - this.envelope.value()) + output * this.envelope.value();
      this.envelope.samplesProcessed++;
    } else {
      buffer[i] = output;
    }
  }
};

IIRFilter2.prototype.addEnvelope = function (envelope) {
  if (envelope instanceof ADSR) {
    this.envelope = envelope;
  } else {
    throw "This is not an envelope.";
  }
};

IIRFilter2.prototype.set = function (cutoff, resonance) {
  this.calcCoeff(cutoff, resonance);
};

function WindowFunction(type, alpha) {
  this.alpha = alpha;

  switch (type) {
    case DSP.BARTLETT:
      this.func = WindowFunction.Bartlett;
      break;

    case DSP.BARTLETTHANN:
      this.func = WindowFunction.BartlettHann;
      break;

    case DSP.BLACKMAN:
      this.func = WindowFunction.Blackman;
      this.alpha = this.alpha || 0.16;
      break;

    case DSP.COSINE:
      this.func = WindowFunction.Cosine;
      break;

    case DSP.GAUSS:
      this.func = WindowFunction.Gauss;
      this.alpha = this.alpha || 0.25;
      break;

    case DSP.HAMMING:
      this.func = WindowFunction.Hamming;
      break;

    case DSP.HANN:
      this.func = WindowFunction.Hann;
      break;

    case DSP.LANCZOS:
      this.func = WindowFunction.Lanczoz;
      break;

    case DSP.RECTANGULAR:
      this.func = WindowFunction.Rectangular;
      break;

    case DSP.TRIANGULAR:
      this.func = WindowFunction.Triangular;
      break;
  }
}

WindowFunction.prototype.process = function (buffer) {
  var length = buffer.length;
  for (var i = 0; i < length; i++) {
    buffer[i] *= this.func(length, i, this.alpha);
  }
  return buffer;
};

WindowFunction.Bartlett = function (length, index) {
  return 2 / (length - 1) * ((length - 1) / 2 - Math.abs(index - (length - 1) / 2));
};

WindowFunction.BartlettHann = function (length, index) {
  return 0.62 - 0.48 * Math.abs(index / (length - 1) - 0.5) - 0.38 * Math.cos(DSP.TWO_PI * index / (length - 1));
};

WindowFunction.Blackman = function (length, index, alpha) {
  var a0 = (1 - alpha) / 2;
  var a1 = 0.5;
  var a2 = alpha / 2;

  return a0 - a1 * Math.cos(DSP.TWO_PI * index / (length - 1)) + a2 * Math.cos(4 * Math.PI * index / (length - 1));
};

WindowFunction.Cosine = function (length, index) {
  return Math.cos(Math.PI * index / (length - 1) - Math.PI / 2);
};

WindowFunction.Gauss = function (length, index, alpha) {
  return Math.pow(Math.E, -0.5 * Math.pow((index - (length - 1) / 2) / (alpha * (length - 1) / 2), 2));
};

WindowFunction.Hamming = function (length, index) {
  return 0.54 - 0.46 * Math.cos(DSP.TWO_PI * index / (length - 1));
};

WindowFunction.Hann = function (length, index) {
  return 0.5 * (1 - Math.cos(DSP.TWO_PI * index / (length - 1)));
};

WindowFunction.Lanczos = function (length, index) {
  var x = 2 * index / (length - 1) - 1;
  return Math.sin(Math.PI * x) / (Math.PI * x);
};

WindowFunction.Rectangular = function (length, index) {
  return 1;
};

WindowFunction.Triangular = function (length, index) {
  return 2 / length * (length / 2 - Math.abs(index - (length - 1) / 2));
};

function sinh(arg) {
  // Returns the hyperbolic sine of the number, defined as (exp(number) - exp(-number))/2 
  //
  // version: 1004.2314
  // discuss at: http://phpjs.org/functions/sinh    // +   original by: Onno Marsman
  // *     example 1: sinh(-0.9834330348825909);
  // *     returns 1: -1.1497971402636502
  return (Math.exp(arg) - Math.exp(-arg)) / 2;
}

/* 
 *  Biquad filter
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 */
// Implementation based on:
// http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt
function Biquad(type, sampleRate) {
  this.Fs = sampleRate;
  this.type = type; // type of the filter
  this.parameterType = DSP.Q; // type of the parameter

  this.x_1_l = 0;
  this.x_2_l = 0;
  this.y_1_l = 0;
  this.y_2_l = 0;

  this.x_1_r = 0;
  this.x_2_r = 0;
  this.y_1_r = 0;
  this.y_2_r = 0;

  this.b0 = 1;
  this.a0 = 1;

  this.b1 = 0;
  this.a1 = 0;

  this.b2 = 0;
  this.a2 = 0;

  this.b0a0 = this.b0 / this.a0;
  this.b1a0 = this.b1 / this.a0;
  this.b2a0 = this.b2 / this.a0;
  this.a1a0 = this.a1 / this.a0;
  this.a2a0 = this.a2 / this.a0;

  this.f0 = 3000; // "wherever it's happenin', man."  Center Frequency or
  // Corner Frequency, or shelf midpoint frequency, depending
  // on which filter type.  The "significant frequency".

  this.dBgain = 12; // used only for peaking and shelving filters

  this.Q = 1; // the EE kind of definition, except for peakingEQ in which A*Q is
  // the classic EE Q.  That adjustment in definition was made so that
  // a boost of N dB followed by a cut of N dB for identical Q and
  // f0/Fs results in a precisely flat unity gain filter or "wire".

  this.BW = -3; // the bandwidth in octaves (between -3 dB frequencies for BPF
  // and notch or between midpoint (dBgain/2) gain frequencies for
  // peaking EQ

  this.S = 1; // a "shelf slope" parameter (for shelving EQ only).  When S = 1,
  // the shelf slope is as steep as it can be and remain monotonically
  // increasing or decreasing gain with frequency.  The shelf slope, in
  // dB/octave, remains proportional to S for all other values for a
  // fixed f0/Fs and dBgain.

  this.coefficients = function () {
    var b = [this.b0, this.b1, this.b2];
    var a = [this.a0, this.a1, this.a2];
    return { b: b, a: a };
  };

  this.setFilterType = function (type) {
    this.type = type;
    this.recalculateCoefficients();
  };

  this.setSampleRate = function (rate) {
    this.Fs = rate;
    this.recalculateCoefficients();
  };

  this.setQ = function (q) {
    this.parameterType = DSP.Q;
    this.Q = Math.max(Math.min(q, 115.0), 0.001);
    this.recalculateCoefficients();
  };

  this.setBW = function (bw) {
    this.parameterType = DSP.BW;
    this.BW = bw;
    this.recalculateCoefficients();
  };

  this.setS = function (s) {
    this.parameterType = DSP.S;
    this.S = Math.max(Math.min(s, 5.0), 0.0001);
    this.recalculateCoefficients();
  };

  this.setF0 = function (freq) {
    this.f0 = freq;
    this.recalculateCoefficients();
  };

  this.setDbGain = function (g) {
    this.dBgain = g;
    this.recalculateCoefficients();
  };

  this.recalculateCoefficients = function () {
    var A;
    if (type === DSP.PEAKING_EQ || type === DSP.LOW_SHELF || type === DSP.HIGH_SHELF) {
      A = Math.pow(10, this.dBgain / 40); // for peaking and shelving EQ filters only
    } else {
      A = Math.sqrt(Math.pow(10, this.dBgain / 20));
    }

    var w0 = DSP.TWO_PI * this.f0 / this.Fs;

    var cosw0 = Math.cos(w0);
    var sinw0 = Math.sin(w0);

    var alpha = 0;

    switch (this.parameterType) {
      case DSP.Q:
        alpha = sinw0 / (2 * this.Q);
        break;

      case DSP.BW:
        alpha = sinw0 * sinh(Math.LN2 / 2 * this.BW * w0 / sinw0);
        break;

      case DSP.S:
        alpha = sinw0 / 2 * Math.sqrt((A + 1 / A) * (1 / this.S - 1) + 2);
        break;
    }

    /**
        FYI: The relationship between bandwidth and Q is
             1/Q = 2*sinh(ln(2)/2*BW*w0/sin(w0))     (digital filter w BLT)
        or   1/Q = 2*sinh(ln(2)/2*BW)             (analog filter prototype)
         The relationship between shelf slope and Q is
             1/Q = sqrt((A + 1/A)*(1/S - 1) + 2)
    */

    var coeff;

    switch (this.type) {
      case DSP.LPF:
        // H(s) = 1 / (s^2 + s/Q + 1)
        this.b0 = (1 - cosw0) / 2;
        this.b1 = 1 - cosw0;
        this.b2 = (1 - cosw0) / 2;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.HPF:
        // H(s) = s^2 / (s^2 + s/Q + 1)
        this.b0 = (1 + cosw0) / 2;
        this.b1 = -(1 + cosw0);
        this.b2 = (1 + cosw0) / 2;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.BPF_CONSTANT_SKIRT:
        // H(s) = s / (s^2 + s/Q + 1)  (constant skirt gain, peak gain = Q)
        this.b0 = sinw0 / 2;
        this.b1 = 0;
        this.b2 = -sinw0 / 2;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.BPF_CONSTANT_PEAK:
        // H(s) = (s/Q) / (s^2 + s/Q + 1)      (constant 0 dB peak gain)
        this.b0 = alpha;
        this.b1 = 0;
        this.b2 = -alpha;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.NOTCH:
        // H(s) = (s^2 + 1) / (s^2 + s/Q + 1)
        this.b0 = 1;
        this.b1 = -2 * cosw0;
        this.b2 = 1;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.APF:
        // H(s) = (s^2 - s/Q + 1) / (s^2 + s/Q + 1)
        this.b0 = 1 - alpha;
        this.b1 = -2 * cosw0;
        this.b2 = 1 + alpha;
        this.a0 = 1 + alpha;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha;
        break;

      case DSP.PEAKING_EQ:
        // H(s) = (s^2 + s*(A/Q) + 1) / (s^2 + s/(A*Q) + 1)
        this.b0 = 1 + alpha * A;
        this.b1 = -2 * cosw0;
        this.b2 = 1 - alpha * A;
        this.a0 = 1 + alpha / A;
        this.a1 = -2 * cosw0;
        this.a2 = 1 - alpha / A;
        break;

      case DSP.LOW_SHELF:
        // H(s) = A * (s^2 + (sqrt(A)/Q)*s + A)/(A*s^2 + (sqrt(A)/Q)*s + 1)
        coeff = sinw0 * Math.sqrt((A ^ 2 + 1) * (1 / this.S - 1) + 2 * A);
        this.b0 = A * (A + 1 - (A - 1) * cosw0 + coeff);
        this.b1 = 2 * A * (A - 1 - (A + 1) * cosw0);
        this.b2 = A * (A + 1 - (A - 1) * cosw0 - coeff);
        this.a0 = A + 1 + (A - 1) * cosw0 + coeff;
        this.a1 = -2 * (A - 1 + (A + 1) * cosw0);
        this.a2 = A + 1 + (A - 1) * cosw0 - coeff;
        break;

      case DSP.HIGH_SHELF:
        // H(s) = A * (A*s^2 + (sqrt(A)/Q)*s + 1)/(s^2 + (sqrt(A)/Q)*s + A)
        coeff = sinw0 * Math.sqrt((A ^ 2 + 1) * (1 / this.S - 1) + 2 * A);
        this.b0 = A * (A + 1 + (A - 1) * cosw0 + coeff);
        this.b1 = -2 * A * (A - 1 + (A + 1) * cosw0);
        this.b2 = A * (A + 1 + (A - 1) * cosw0 - coeff);
        this.a0 = A + 1 - (A - 1) * cosw0 + coeff;
        this.a1 = 2 * (A - 1 - (A + 1) * cosw0);
        this.a2 = A + 1 - (A - 1) * cosw0 - coeff;
        break;
    }

    this.b0a0 = this.b0 / this.a0;
    this.b1a0 = this.b1 / this.a0;
    this.b2a0 = this.b2 / this.a0;
    this.a1a0 = this.a1 / this.a0;
    this.a2a0 = this.a2 / this.a0;
  };

  this.process = function (buffer) {
    //y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
    //       - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]

    var len = buffer.length;
    var output = new Float32Array(len);

    for (var i = 0; i < buffer.length; i++) {
      output[i] = this.b0a0 * buffer[i] + this.b1a0 * this.x_1_l + this.b2a0 * this.x_2_l - this.a1a0 * this.y_1_l - this.a2a0 * this.y_2_l;
      this.y_2_l = this.y_1_l;
      this.y_1_l = output[i];
      this.x_2_l = this.x_1_l;
      this.x_1_l = buffer[i];
    }

    return output;
  };

  this.processStereo = function (buffer) {
    //y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
    //       - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]

    var len = buffer.length;
    var output = new Float32Array(len);

    for (var i = 0; i < len / 2; i++) {
      output[2 * i] = this.b0a0 * buffer[2 * i] + this.b1a0 * this.x_1_l + this.b2a0 * this.x_2_l - this.a1a0 * this.y_1_l - this.a2a0 * this.y_2_l;
      this.y_2_l = this.y_1_l;
      this.y_1_l = output[2 * i];
      this.x_2_l = this.x_1_l;
      this.x_1_l = buffer[2 * i];

      output[2 * i + 1] = this.b0a0 * buffer[2 * i + 1] + this.b1a0 * this.x_1_r + this.b2a0 * this.x_2_r - this.a1a0 * this.y_1_r - this.a2a0 * this.y_2_r;
      this.y_2_r = this.y_1_r;
      this.y_1_r = output[2 * i + 1];
      this.x_2_r = this.x_1_r;
      this.x_1_r = buffer[2 * i + 1];
    }

    return output;
  };
}

/* 
 *  Magnitude to decibels
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 *  @buffer array of magnitudes to convert to decibels
 *
 *  @returns the array in decibels
 *
 */
DSP.mag2db = function (buffer) {
  var minDb = -120;
  var minMag = Math.pow(10.0, minDb / 20.0);

  var log = Math.log;
  var max = Math.max;

  var result = Float32Array(buffer.length);
  for (var i = 0; i < buffer.length; i++) {
    result[i] = 20.0 * log(max(buffer[i], minMag));
  }

  return result;
};

/* 
 *  Frequency response
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 *  Calculates the frequency response at the given points.
 *
 *  @b b coefficients of the filter
 *  @a a coefficients of the filter
 *  @w w points (normally between -PI and PI) where to calculate the frequency response
 *
 *  @returns the frequency response in magnitude
 *
 */
DSP.freqz = function (b, a, w) {
  var i, j;

  if (!w) {
    w = Float32Array(200);
    for (i = 0; i < w.length; i++) {
      w[i] = DSP.TWO_PI / w.length * i - Math.PI;
    }
  }

  var result = Float32Array(w.length);

  var sqrt = Math.sqrt;
  var cos = Math.cos;
  var sin = Math.sin;

  for (i = 0; i < w.length; i++) {
    var numerator = { real: 0.0, imag: 0.0 };
    for (j = 0; j < b.length; j++) {
      numerator.real += b[j] * cos(-j * w[i]);
      numerator.imag += b[j] * sin(-j * w[i]);
    }

    var denominator = { real: 0.0, imag: 0.0 };
    for (j = 0; j < a.length; j++) {
      denominator.real += a[j] * cos(-j * w[i]);
      denominator.imag += a[j] * sin(-j * w[i]);
    }

    result[i] = sqrt(numerator.real * numerator.real + numerator.imag * numerator.imag) / sqrt(denominator.real * denominator.real + denominator.imag * denominator.imag);
  }

  return result;
};

/* 
 *  Graphical Equalizer
 *
 *  Implementation of a graphic equalizer with a configurable bands-per-octave
 *  and minimum and maximum frequencies
 * 
 *  Created by Ricard Marxer <email@ricardmarxer.com> on 2010-05-23.
 *  Copyright 2010 Ricard Marxer. All rights reserved.
 *
 */
function GraphicalEq(sampleRate) {
  this.FS = sampleRate;
  this.minFreq = 40.0;
  this.maxFreq = 16000.0;

  this.bandsPerOctave = 1.0;

  this.filters = [];
  this.freqzs = [];

  this.calculateFreqzs = true;

  this.recalculateFilters = function () {
    var bandCount = Math.round(Math.log(this.maxFreq / this.minFreq) * this.bandsPerOctave / Math.LN2);

    this.filters = [];
    for (var i = 0; i < bandCount; i++) {
      var freq = this.minFreq * Math.pow(2, i / this.bandsPerOctave);
      var newFilter = new Biquad(DSP.PEAKING_EQ, this.FS);
      newFilter.setDbGain(0);
      newFilter.setBW(1 / this.bandsPerOctave);
      newFilter.setF0(freq);
      this.filters[i] = newFilter;
      this.recalculateFreqz(i);
    }
  };

  this.setMinimumFrequency = function (freq) {
    this.minFreq = freq;
    this.recalculateFilters();
  };

  this.setMaximumFrequency = function (freq) {
    this.maxFreq = freq;
    this.recalculateFilters();
  };

  this.setBandsPerOctave = function (bands) {
    this.bandsPerOctave = bands;
    this.recalculateFilters();
  };

  this.setBandGain = function (bandIndex, gain) {
    if (bandIndex < 0 || bandIndex > this.filters.length - 1) {
      throw "The band index of the graphical equalizer is out of bounds.";
    }

    if (!gain) {
      throw "A gain must be passed.";
    }

    this.filters[bandIndex].setDbGain(gain);
    this.recalculateFreqz(bandIndex);
  };

  this.recalculateFreqz = function (bandIndex) {
    if (!this.calculateFreqzs) {
      return;
    }

    if (bandIndex < 0 || bandIndex > this.filters.length - 1) {
      throw "The band index of the graphical equalizer is out of bounds. " + bandIndex + " is out of [" + 0 + ", " + this.filters.length - 1 + "]";
    }

    if (!this.w) {
      this.w = Float32Array(400);
      for (var i = 0; i < this.w.length; i++) {
        this.w[i] = Math.PI / this.w.length * i;
      }
    }

    var b = [this.filters[bandIndex].b0, this.filters[bandIndex].b1, this.filters[bandIndex].b2];
    var a = [this.filters[bandIndex].a0, this.filters[bandIndex].a1, this.filters[bandIndex].a2];

    this.freqzs[bandIndex] = DSP.mag2db(DSP.freqz(b, a, this.w));
  };

  this.process = function (buffer) {
    var output = buffer;

    for (var i = 0; i < this.filters.length; i++) {
      output = this.filters[i].process(output);
    }

    return output;
  };

  this.processStereo = function (buffer) {
    var output = buffer;

    for (var i = 0; i < this.filters.length; i++) {
      output = this.filters[i].processStereo(output);
    }

    return output;
  };
}

/**
 * MultiDelay effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: http://code.almeros.com/code-examples/delay-firefox-audio-api/
 *
 * This is a delay that feeds it's own delayed signal back into its circular
 * buffer. Also known as a CombFilter.
 *
 * Compatible with interleaved stereo (or more channel) buffers and
 * non-interleaved mono buffers.
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffer)
 * @param {Number} delayInSamples Initial delay in samples
 * @param {Number} masterVolume Initial master volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} delayVolume Initial feedback delay volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 *
 * @constructor
 */
function MultiDelay(maxDelayInSamplesSize, delayInSamples, masterVolume, delayVolume) {
  this.delayBufferSamples = new Float32Array(maxDelayInSamplesSize); // The maximum size of delay
  this.delayInputPointer = delayInSamples;
  this.delayOutputPointer = 0;

  this.delayInSamples = delayInSamples;
  this.masterVolume = masterVolume;
  this.delayVolume = delayVolume;
}

/**
 * Change the delay time in samples.
 *
 * @param {Number} delayInSamples Delay in samples
 */
MultiDelay.prototype.setDelayInSamples = function (delayInSamples) {
  this.delayInSamples = delayInSamples;

  this.delayInputPointer = this.delayOutputPointer + delayInSamples;

  if (this.delayInputPointer >= this.delayBufferSamples.length - 1) {
    this.delayInputPointer = this.delayInputPointer - this.delayBufferSamples.length;
  }
};

/**
 * Change the master volume.
 *
 * @param {Number} masterVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
MultiDelay.prototype.setMasterVolume = function (masterVolume) {
  this.masterVolume = masterVolume;
};

/**
 * Change the delay feedback volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
MultiDelay.prototype.setDelayVolume = function (delayVolume) {
  this.delayVolume = delayVolume;
};

/**
 * Process a given interleaved or mono non-interleaved float value Array and adds the delayed audio.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved or mono non-interleaved as was fed to this function.
 */
MultiDelay.prototype.process = function (samples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(samples.length);

  for (var i = 0; i < samples.length; i++) {
    // delayBufferSamples could contain initial NULL's, return silence in that case
    var delaySample = this.delayBufferSamples[this.delayOutputPointer] === null ? 0.0 : this.delayBufferSamples[this.delayOutputPointer];

    // Mix normal audio data with delayed audio
    var sample = delaySample * this.delayVolume + samples[i];

    // Add audio data with the delay in the delay buffer
    this.delayBufferSamples[this.delayInputPointer] = sample;

    // Return the audio with delay mix
    outputSamples[i] = sample * this.masterVolume;

    // Manage circulair delay buffer pointers
    this.delayInputPointer++;
    if (this.delayInputPointer >= this.delayBufferSamples.length - 1) {
      this.delayInputPointer = 0;
    }

    this.delayOutputPointer++;
    if (this.delayOutputPointer >= this.delayBufferSamples.length - 1) {
      this.delayOutputPointer = 0;
    }
  }

  return outputSamples;
};

/**
 * SingleDelay effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: See usage in Reverb class
 *
 * This is a delay that does NOT feeds it's own delayed signal back into its 
 * circular buffer, neither does it return the original signal. Also known as
 * an AllPassFilter(?).
 *
 * Compatible with interleaved stereo (or more channel) buffers and
 * non-interleaved mono buffers.
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffer)
 * @param {Number} delayInSamples Initial delay in samples
 * @param {Number} delayVolume Initial feedback delay volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 *
 * @constructor
 */

function SingleDelay(maxDelayInSamplesSize, delayInSamples, delayVolume) {
  this.delayBufferSamples = new Float32Array(maxDelayInSamplesSize); // The maximum size of delay
  this.delayInputPointer = delayInSamples;
  this.delayOutputPointer = 0;

  this.delayInSamples = delayInSamples;
  this.delayVolume = delayVolume;
}

/**
 * Change the delay time in samples.
 *
 * @param {Number} delayInSamples Delay in samples
 */
SingleDelay.prototype.setDelayInSamples = function (delayInSamples) {
  this.delayInSamples = delayInSamples;
  this.delayInputPointer = this.delayOutputPointer + delayInSamples;

  if (this.delayInputPointer >= this.delayBufferSamples.length - 1) {
    this.delayInputPointer = this.delayInputPointer - this.delayBufferSamples.length;
  }
};

/**
 * Change the return signal volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
SingleDelay.prototype.setDelayVolume = function (delayVolume) {
  this.delayVolume = delayVolume;
};

/**
 * Process a given interleaved or mono non-interleaved float value Array and
 * returns the delayed audio.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved or mono non-interleaved as was fed to this function.
 */
SingleDelay.prototype.process = function (samples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(samples.length);

  for (var i = 0; i < samples.length; i++) {

    // Add audio data with the delay in the delay buffer
    this.delayBufferSamples[this.delayInputPointer] = samples[i];

    // delayBufferSamples could contain initial NULL's, return silence in that case
    var delaySample = this.delayBufferSamples[this.delayOutputPointer];

    // Return the audio with delay mix
    outputSamples[i] = delaySample * this.delayVolume;

    // Manage circulair delay buffer pointers
    this.delayInputPointer++;

    if (this.delayInputPointer >= this.delayBufferSamples.length - 1) {
      this.delayInputPointer = 0;
    }

    this.delayOutputPointer++;

    if (this.delayOutputPointer >= this.delayBufferSamples.length - 1) {
      this.delayOutputPointer = 0;
    }
  }

  return outputSamples;
};

/**
 * Reverb effect by Almer Thie (http://code.almeros.com).
 * Copyright 2010 Almer Thie. All rights reserved.
 * Example: http://code.almeros.com/code-examples/reverb-firefox-audio-api/
 *
 * This reverb consists of 6 SingleDelays, 6 MultiDelays and an IIRFilter2
 * for each of the two stereo channels.
 *
 * Compatible with interleaved stereo buffers only!
 *
 * @param {Number} maxDelayInSamplesSize Maximum possible delay in samples (size of circular buffers)
 * @param {Number} delayInSamples Initial delay in samples for internal (Single/Multi)delays
 * @param {Number} masterVolume Initial master volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} mixVolume Initial reverb signal mix volume. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} delayVolume Initial feedback delay volume for internal (Single/Multi)delays. Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 * @param {Number} dampFrequency Initial low pass filter frequency. 0 to 44100 (depending on your maximum sampling frequency)
 *
 * @constructor
 */
function Reverb(maxDelayInSamplesSize, delayInSamples, masterVolume, mixVolume, delayVolume, dampFrequency) {
  this.delayInSamples = delayInSamples;
  this.masterVolume = masterVolume;
  this.mixVolume = mixVolume;
  this.delayVolume = delayVolume;
  this.dampFrequency = dampFrequency;

  this.NR_OF_MULTIDELAYS = 6;
  this.NR_OF_SINGLEDELAYS = 6;

  this.LOWPASSL = new IIRFilter2(DSP.LOWPASS, dampFrequency, 0, 44100);
  this.LOWPASSR = new IIRFilter2(DSP.LOWPASS, dampFrequency, 0, 44100);

  this.singleDelays = [];

  var i, delayMultiply;

  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    delayMultiply = 1.0 + i / 7.0; // 1.0, 1.1, 1.2...
    this.singleDelays[i] = new SingleDelay(maxDelayInSamplesSize, Math.round(this.delayInSamples * delayMultiply), this.delayVolume);
  }

  this.multiDelays = [];

  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    delayMultiply = 1.0 + i / 10.0; // 1.0, 1.1, 1.2... 
    this.multiDelays[i] = new MultiDelay(maxDelayInSamplesSize, Math.round(this.delayInSamples * delayMultiply), this.masterVolume, this.delayVolume);
  }
}

/**
 * Change the delay time in samples as a base for all delays.
 *
 * @param {Number} delayInSamples Delay in samples
 */
Reverb.prototype.setDelayInSamples = function (delayInSamples) {
  this.delayInSamples = delayInSamples;

  var i, delayMultiply;

  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    delayMultiply = 1.0 + i / 7.0; // 1.0, 1.1, 1.2...
    this.singleDelays[i].setDelayInSamples(Math.round(this.delayInSamples * delayMultiply));
  }

  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    delayMultiply = 1.0 + i / 10.0; // 1.0, 1.1, 1.2...
    this.multiDelays[i].setDelayInSamples(Math.round(this.delayInSamples * delayMultiply));
  }
};

/**
 * Change the master volume.
 *
 * @param {Number} masterVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setMasterVolume = function (masterVolume) {
  this.masterVolume = masterVolume;
};

/**
 * Change the reverb signal mix level.
 *
 * @param {Number} mixVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setMixVolume = function (mixVolume) {
  this.mixVolume = mixVolume;
};

/**
 * Change all delays feedback volume.
 *
 * @param {Number} delayVolume Float value: 0.0 (silence), 1.0 (normal), >1.0 (amplify)
 */
Reverb.prototype.setDelayVolume = function (delayVolume) {
  this.delayVolume = delayVolume;

  var i;

  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    this.singleDelays[i].setDelayVolume(this.delayVolume);
  }

  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    this.multiDelays[i].setDelayVolume(this.delayVolume);
  }
};

/**
 * Change the Low Pass filter frequency.
 *
 * @param {Number} dampFrequency low pass filter frequency. 0 to 44100 (depending on your maximum sampling frequency)
 */
Reverb.prototype.setDampFrequency = function (dampFrequency) {
  this.dampFrequency = dampFrequency;

  this.LOWPASSL.set(dampFrequency, 0);
  this.LOWPASSR.set(dampFrequency, 0);
};

/**
 * Process a given interleaved float value Array and copies and adds the reverb signal.
 *
 * @param {Array} samples Array containing Float values or a Float32Array
 *
 * @returns A new Float32Array interleaved buffer.
 */
Reverb.prototype.process = function (interleavedSamples) {
  // NB. Make a copy to put in the output samples to return.
  var outputSamples = new Float32Array(interleavedSamples.length);

  // Perform low pass on the input samples to mimick damp
  var leftRightMix = DSP.deinterleave(interleavedSamples);
  this.LOWPASSL.process(leftRightMix[DSP.LEFT]);
  this.LOWPASSR.process(leftRightMix[DSP.RIGHT]);
  var filteredSamples = DSP.interleave(leftRightMix[DSP.LEFT], leftRightMix[DSP.RIGHT]);

  var i;

  // Process MultiDelays in parallel
  for (i = 0; i < this.NR_OF_MULTIDELAYS; i++) {
    // Invert the signal of every even multiDelay
    outputSamples = DSP.mixSampleBuffers(outputSamples, this.multiDelays[i].process(filteredSamples), 2 % i === 0, this.NR_OF_MULTIDELAYS);
  }

  // Process SingleDelays in series
  var singleDelaySamples = new Float32Array(outputSamples.length);
  for (i = 0; i < this.NR_OF_SINGLEDELAYS; i++) {
    // Invert the signal of every even singleDelay
    singleDelaySamples = DSP.mixSampleBuffers(singleDelaySamples, this.singleDelays[i].process(outputSamples), 2 % i === 0, 1);
  }

  // Apply the volume of the reverb signal
  for (i = 0; i < singleDelaySamples.length; i++) {
    singleDelaySamples[i] *= this.mixVolume;
  }

  // Mix the original signal with the reverb signal
  outputSamples = DSP.mixSampleBuffers(singleDelaySamples, interleavedSamples, 0, 1);

  // Apply the master volume to the complete signal
  for (i = 0; i < outputSamples.length; i++) {
    outputSamples[i] *= this.masterVolume;
  }

  return outputSamples;
};

exports.default = DSP;
exports.FFT = FFT;

},{"babel-runtime/helpers/typeof":40}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.Module = {};
window.script = {};
window.doneEvent = {};

var PulseFFTTransforms = function () {
    function PulseFFTTransforms(winSize) {
        (0, _classCallCheck3.default)(this, PulseFFTTransforms);

        if (this.instance) {
            return this.instance;
        }

        this.instance = this;
        this.winSize = winSize;
    }

    (0, _createClass3.default)(PulseFFTTransforms, [{
        key: "init",
        value: function init() {
            var _this = this;

            return new _promise2.default(function (resolve, reject) {
                fetch('assets/pulse/src/WASMkissFFT.wasm').then(console.log("made it into loadpulse")).then(function (response) {
                    return response.arrayBuffer();
                }).then(console.log("step into m")).then(function (m) {
                    Module.wasmBinary = m;

                    script = document.createElement('script');
                    script.src = 'assets/pulse/src/wasmkissfft.js';
                    script.type = 'text/javascript';
                    script.onload = function () {
                        console.log("Loaded Emscripten.");
                    };
                    doneEvent = new Event('done');
                    script.addEventListener('done', buildPulse);
                    document.body.appendChild(script);

                    function buildPulse() {
                        var pulse = {};

                        pulse['fftComplex'] = function (size) {
                            this.size = size;
                            this.fcfg = _kiss_fft_alloc(size, false);
                            this.icfg = _kiss_fft_alloc(size, true);

                            this.inptr = _malloc(size * 8 + size * 8);
                            this.outptr = this.inptr + size * 8;

                            this.cin = new Float32Array(HEAPU8.buffer, this.inptr, size * 2);
                            this.cout = new Float32Array(HEAPU8.buffer, this.outptr, size * 2);

                            this.forward = function (cin) {
                                this.cin.set(cin);
                                _kiss_fft(this.fcfg, this.inptr, this.outptr);
                                return new Float32Array(HEAPU8.buffer, this.outptr, this.size * 2);
                            };
                            this.inverse = function (cin) {
                                this.cin.set(cin); //was cpx?
                                _kiss_fft(this.icfg, this.inptr, this.outptr);
                                return new Float32Array(HEAPU8.buffer, this.outptr, this.size * 2);
                            };
                            this.dispose = function () {
                                _free(this.inptr);
                                _free(this.fcfg);
                                _free(this.icfg);
                            };
                        };
                        pulse['fftReal'] = function (size) {
                            this.size = size;
                            this.fcfg = _kiss_fftr_alloc(size, false);
                            this.icfg = _kiss_fftr_alloc(size, true);

                            this.rptr = _malloc(size * 4 + (size + 2) * 4);
                            this.cptr = this.rptr + size * 4;

                            this.ri = new Float32Array(HEAPU8.buffer, this.rptr, size);
                            this.ci = new Float32Array(HEAPU8.buffer, this.cptr, size + 2);

                            this.forward = function (real) {
                                this.ri.set(real);
                                _kiss_fftr(this.fcfg, this.rptr, this.cptr);
                                return new Float32Array(HEAPU8.buffer, this.cptr, this.size + 2); //changed here
                            };
                            this.inverse = function (cpx) {
                                this.ci.set(cpx);
                                _kiss_fftri(this.icfg, this.cptr, this.rptr);
                                return new Float32Array(HEAPU8.buffer, this.rptr, this.size);
                            };
                            this.dispose = function () {
                                _free(this.rptr);
                                _free(this.fcfg);
                                _free(this.icfg);
                            };
                        };

                        resolve(pulse);
                    }
                });
            }).then(function (pulse) {

                _this._fftProcessor = new pulse.fftReal(_this.winSize);
                _this._ifftProcessor = new pulse.fftComplex(_this.winSize);

                _this.STFT = function (inputFrame, windowFrame, wantedSize, out) {
                    var winSize = windowFrame.length;
                    var _inputFrame = new Array(winSize);
                    var fftFrame = new Array(2 * winSize);

                    for (var i = 0; i < winSize; i++) {
                        _inputFrame[i] = inputFrame[i] * windowFrame[i];
                    }

                    fftFrame = _this._fftProcessor.forward(_inputFrame);

                    for (var p = 0; p < winSize && p < wantedSize; p++) {
                        var real = out.real;var imag = out.imag;
                        var phase = out.phase;var magnitude = out.magnitude;
                        real[p] = fftFrame[2 * p];
                        imag[p] = fftFrame[2 * p + 1];
                        magnitude[p] = Math.sqrt(imag[p] * imag[p] + real[p] * real[p]);
                        phase[p] = Math.atan2(imag[p], real[p]);
                    }

                    return;
                };

                _this.STFTv2 = function (inputFrame, windowFrame, wantedSize, out) {
                    var winSize = windowFrame.length;
                    var _inputFrame = new Array(winSize);
                    var fftFrame = new Array(2 * winSize);

                    for (var i = 0; i < winSize; i++) {
                        _inputFrame[i] = inputFrame[i] * windowFrame[i];
                    }

                    fftFrame = _this._fftProcessor.forward(_inputFrame);

                    for (var p = 0; p < winSize && p < wantedSize; p++) {
                        var real = out.real;var imag = out.imag;
                        real[p] = fftFrame[2 * p];
                        imag[p] = fftFrame[2 * p + 1];
                    }

                    return;
                };

                _this.ISTFT = function (real, imaginary, windowFrame, restoreEnergy, output2) {
                    var input = new Array(2 * real.length);
                    var output1 = new Array(2 * real.length);

                    for (var i = 0; i < real.length; i++) {
                        input[2 * i] = real[i];
                        input[2 * i + 1] = imaginary[i];
                    }

                    output1 = _this._ifftProcessor.inverse(input);

                    if (restoreEnergy) {
                        var energy1 = 0;
                        var energy2 = 0;
                        var eps = 2.2204e-16;
                        for (var i = 0; i < windowFrame.length; i++) {
                            energy1 += Math.abs(output1[2 * i]);
                            output2[i] = output1[2 * i] / windowFrame.length;
                            output2[i] *= windowFrame[i];
                            energy2 += Math.abs(output1[2 * i]);
                            output2[i] *= energy1 / (energy2 + eps);
                        }
                    } else if (windowFrame) {
                        for (var i = 0; i < windowFrame.length; i++) {
                            output2[i] = output1[2 * i] / windowFrame.length;
                            output2[i] *= windowFrame[i];
                        }
                    } else {
                        for (var i = 0; i < real.length; i++) {
                            output2[i] = output1[2 * i] / real.length;
                        }
                    }

                    return;
                };

                return _this;
            });
        }
    }]);
    return PulseFFTTransforms;
}();

exports.default = PulseFFTTransforms;

},{"babel-runtime/core-js/promise":30,"babel-runtime/helpers/classCallCheck":35,"babel-runtime/helpers/createClass":36}],23:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":41}],24:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":42}],25:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-properties"), __esModule: true };
},{"core-js/library/fn/object/define-properties":43}],26:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":44}],27:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
},{"core-js/library/fn/object/get-own-property-descriptor":45}],28:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/get-prototype-of":46}],29:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":47}],30:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":48}],31:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":49}],32:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":50}],33:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":51}],34:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/weak-map"), __esModule: true };
},{"core-js/library/fn/weak-map":52}],35:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],36:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
},{"../core-js/object/define-property":26}],37:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _getPrototypeOf = require("../core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _getOwnPropertyDescriptor = require("../core-js/object/get-own-property-descriptor");

var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;
  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);

  if (desc === undefined) {
    var parent = (0, _getPrototypeOf2.default)(object);

    if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;

    if (getter === undefined) {
      return undefined;
    }

    return getter.call(receiver);
  }
};
},{"../core-js/object/get-own-property-descriptor":27,"../core-js/object/get-prototype-of":28}],38:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _setPrototypeOf = require("../core-js/object/set-prototype-of");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = require("../core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
},{"../core-js/object/create":24,"../core-js/object/set-prototype-of":29,"../helpers/typeof":40}],39:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};
},{"../helpers/typeof":40}],40:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":32,"../core-js/symbol/iterator":33}],41:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');

},{"../modules/core.get-iterator":138,"../modules/es6.string.iterator":149,"../modules/web.dom.iterable":161}],42:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};

},{"../../modules/_core":68,"../../modules/es6.object.create":140}],43:[function(require,module,exports){
require('../../modules/es6.object.define-properties');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperties(T, D) {
  return $Object.defineProperties(T, D);
};

},{"../../modules/_core":68,"../../modules/es6.object.define-properties":141}],44:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

},{"../../modules/_core":68,"../../modules/es6.object.define-property":142}],45:[function(require,module,exports){
require('../../modules/es6.object.get-own-property-descriptor');
var $Object = require('../../modules/_core').Object;
module.exports = function getOwnPropertyDescriptor(it, key) {
  return $Object.getOwnPropertyDescriptor(it, key);
};

},{"../../modules/_core":68,"../../modules/es6.object.get-own-property-descriptor":143}],46:[function(require,module,exports){
require('../../modules/es6.object.get-prototype-of');
module.exports = require('../../modules/_core').Object.getPrototypeOf;

},{"../../modules/_core":68,"../../modules/es6.object.get-prototype-of":144}],47:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/_core').Object.setPrototypeOf;

},{"../../modules/_core":68,"../../modules/es6.object.set-prototype-of":145}],48:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
require('../modules/es7.promise.finally');
require('../modules/es7.promise.try');
module.exports = require('../modules/_core').Promise;

},{"../modules/_core":68,"../modules/es6.object.to-string":146,"../modules/es6.promise":147,"../modules/es6.string.iterator":149,"../modules/es7.promise.finally":152,"../modules/es7.promise.try":153,"../modules/web.dom.iterable":161}],49:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
require('../modules/es7.set.of');
require('../modules/es7.set.from');
module.exports = require('../modules/_core').Set;

},{"../modules/_core":68,"../modules/es6.object.to-string":146,"../modules/es6.set":148,"../modules/es6.string.iterator":149,"../modules/es7.set.from":154,"../modules/es7.set.of":155,"../modules/es7.set.to-json":156,"../modules/web.dom.iterable":161}],50:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":68,"../../modules/es6.object.to-string":146,"../../modules/es6.symbol":150,"../../modules/es7.symbol.async-iterator":157,"../../modules/es7.symbol.observable":158}],51:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":135,"../../modules/es6.string.iterator":149,"../../modules/web.dom.iterable":161}],52:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/web.dom.iterable');
require('../modules/es6.weak-map');
require('../modules/es7.weak-map.of');
require('../modules/es7.weak-map.from');
module.exports = require('../modules/_core').WeakMap;

},{"../modules/_core":68,"../modules/es6.object.to-string":146,"../modules/es6.weak-map":151,"../modules/es7.weak-map.from":159,"../modules/es7.weak-map.of":160,"../modules/web.dom.iterable":161}],53:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],54:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],55:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],56:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":87}],57:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":77}],58:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":126,"./_to-iobject":128,"./_to-length":129}],59:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":61,"./_ctx":69,"./_iobject":84,"./_to-length":129,"./_to-object":130}],60:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":86,"./_is-object":87,"./_wks":136}],61:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":60}],62:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":63,"./_wks":136}],63:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],64:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":55,"./_ctx":69,"./_descriptors":71,"./_for-of":77,"./_iter-define":90,"./_iter-step":92,"./_meta":95,"./_object-create":99,"./_object-dp":100,"./_redefine-all":114,"./_set-species":119,"./_validate-collection":133}],65:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":57,"./_classof":62}],66:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":55,"./_an-object":56,"./_array-methods":59,"./_for-of":77,"./_has":79,"./_is-object":87,"./_meta":95,"./_redefine-all":114,"./_validate-collection":133}],67:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var meta = require('./_meta');
var fails = require('./_fails');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var setToStringTag = require('./_set-to-string-tag');
var dP = require('./_object-dp').f;
var each = require('./_array-methods')(0);
var DESCRIPTORS = require('./_descriptors');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":55,"./_array-methods":59,"./_descriptors":71,"./_export":75,"./_fails":76,"./_for-of":77,"./_global":78,"./_hide":80,"./_is-object":87,"./_meta":95,"./_object-dp":100,"./_redefine-all":114,"./_set-to-string-tag":120}],68:[function(require,module,exports){
var core = module.exports = { version: '2.5.4' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],69:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":53}],70:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],71:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":76}],72:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":78,"./_is-object":87}],73:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],74:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":105,"./_object-keys":108,"./_object-pie":109}],75:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var has = require('./_has');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":68,"./_ctx":69,"./_global":78,"./_has":79,"./_hide":80}],76:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],77:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":56,"./_ctx":69,"./_is-array-iter":85,"./_iter-call":88,"./_to-length":129,"./core.get-iterator-method":137}],78:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],79:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],80:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":71,"./_object-dp":100,"./_property-desc":113}],81:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":78}],82:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":71,"./_dom-create":72,"./_fails":76}],83:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],84:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":63}],85:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":93,"./_wks":136}],86:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":63}],87:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],88:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":56}],89:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":80,"./_object-create":99,"./_property-desc":113,"./_set-to-string-tag":120,"./_wks":136}],90:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":75,"./_hide":80,"./_iter-create":89,"./_iterators":93,"./_library":94,"./_object-gpo":106,"./_redefine":115,"./_set-to-string-tag":120,"./_wks":136}],91:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":136}],92:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],93:[function(require,module,exports){
module.exports = {};

},{}],94:[function(require,module,exports){
module.exports = true;

},{}],95:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":76,"./_has":79,"./_is-object":87,"./_object-dp":100,"./_uid":132}],96:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":63,"./_global":78,"./_task":125}],97:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":53}],98:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":76,"./_iobject":84,"./_object-gops":105,"./_object-keys":108,"./_object-pie":109,"./_to-object":130}],99:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":56,"./_dom-create":72,"./_enum-bug-keys":73,"./_html":81,"./_object-dps":101,"./_shared-key":121}],100:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":56,"./_descriptors":71,"./_ie8-dom-define":82,"./_to-primitive":131}],101:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":56,"./_descriptors":71,"./_object-dp":100,"./_object-keys":108}],102:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":71,"./_has":79,"./_ie8-dom-define":82,"./_object-pie":109,"./_property-desc":113,"./_to-iobject":128,"./_to-primitive":131}],103:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":104,"./_to-iobject":128}],104:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":73,"./_object-keys-internal":107}],105:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],106:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":79,"./_shared-key":121,"./_to-object":130}],107:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":58,"./_has":79,"./_shared-key":121,"./_to-iobject":128}],108:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":73,"./_object-keys-internal":107}],109:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],110:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":68,"./_export":75,"./_fails":76}],111:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],112:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":56,"./_is-object":87,"./_new-promise-capability":97}],113:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],114:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};

},{"./_hide":80}],115:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":80}],116:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":53,"./_ctx":69,"./_export":75,"./_for-of":77}],117:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":75}],118:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":56,"./_ctx":69,"./_is-object":87,"./_object-gopd":102}],119:[function(require,module,exports){
'use strict';
var global = require('./_global');
var core = require('./_core');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_core":68,"./_descriptors":71,"./_global":78,"./_object-dp":100,"./_wks":136}],120:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":79,"./_object-dp":100,"./_wks":136}],121:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":122,"./_uid":132}],122:[function(require,module,exports){
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":78}],123:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":53,"./_an-object":56,"./_wks":136}],124:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":70,"./_to-integer":127}],125:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":63,"./_ctx":69,"./_dom-create":72,"./_global":78,"./_html":81,"./_invoke":83}],126:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":127}],127:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],128:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":70,"./_iobject":84}],129:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":127}],130:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":70}],131:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":87}],132:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],133:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":87}],134:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":68,"./_global":78,"./_library":94,"./_object-dp":100,"./_wks-ext":135}],135:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":136}],136:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":78,"./_shared":122,"./_uid":132}],137:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":62,"./_core":68,"./_iterators":93,"./_wks":136}],138:[function(require,module,exports){
var anObject = require('./_an-object');
var get = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

},{"./_an-object":56,"./_core":68,"./core.get-iterator-method":137}],139:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":54,"./_iter-define":90,"./_iter-step":92,"./_iterators":93,"./_to-iobject":128}],140:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":75,"./_object-create":99}],141:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":71,"./_export":75,"./_object-dps":101}],142:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":71,"./_export":75,"./_object-dp":100}],143:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":102,"./_object-sap":110,"./_to-iobject":128}],144:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":106,"./_object-sap":110,"./_to-object":130}],145:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":75,"./_set-proto":118}],146:[function(require,module,exports){

},{}],147:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":53,"./_an-instance":55,"./_classof":62,"./_core":68,"./_ctx":69,"./_export":75,"./_for-of":77,"./_global":78,"./_is-object":87,"./_iter-detect":91,"./_library":94,"./_microtask":96,"./_new-promise-capability":97,"./_perform":111,"./_promise-resolve":112,"./_redefine-all":114,"./_set-species":119,"./_set-to-string-tag":120,"./_species-constructor":123,"./_task":125,"./_wks":136}],148:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":67,"./_collection-strong":64,"./_validate-collection":133}],149:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":90,"./_string-at":124}],150:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":56,"./_descriptors":71,"./_enum-keys":74,"./_export":75,"./_fails":76,"./_global":78,"./_has":79,"./_hide":80,"./_is-array":86,"./_is-object":87,"./_library":94,"./_meta":95,"./_object-create":99,"./_object-dp":100,"./_object-gopd":102,"./_object-gopn":104,"./_object-gopn-ext":103,"./_object-gops":105,"./_object-keys":108,"./_object-pie":109,"./_property-desc":113,"./_redefine":115,"./_set-to-string-tag":120,"./_shared":122,"./_to-iobject":128,"./_to-primitive":131,"./_uid":132,"./_wks":136,"./_wks-define":134,"./_wks-ext":135}],151:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":59,"./_collection":67,"./_collection-weak":66,"./_fails":76,"./_is-object":87,"./_meta":95,"./_object-assign":98,"./_redefine":115,"./_validate-collection":133}],152:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":68,"./_export":75,"./_global":78,"./_promise-resolve":112,"./_species-constructor":123}],153:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":75,"./_new-promise-capability":97,"./_perform":111}],154:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":116}],155:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":117}],156:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":65,"./_export":75}],157:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":134}],158:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":134}],159:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":116}],160:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":117}],161:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":78,"./_hide":80,"./_iterators":93,"./_wks":136,"./es6.array.iterator":139}],162:[function(require,module,exports){
(function (process){
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
    return true;
  }

  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
    // double check webkit in userAgent just in case we are in a worker
    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return;

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit')

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
  try {
    return window.localStorage;
  } catch (e) {}
}

}).call(this,require('_process'))

},{"./debug":163,"_process":165}],163:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
 */

exports.formatters = {};

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 * @param {String} namespace
 * @return {Number}
 * @api private
 */

function selectColor(namespace) {
  var hash = 0, i;

  for (i in namespace) {
    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
    hash |= 0; // Convert to 32bit integer
  }

  return exports.colors[Math.abs(hash) % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function createDebug(namespace) {

  function debug() {
    // disabled?
    if (!debug.enabled) return;

    var self = debug;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // turn the `arguments` into a proper Array
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %O
      args.unshift('%O');
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting (colors, etc.)
    exports.formatArgs.call(self, args);

    var logFn = debug.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }

  debug.namespace = namespace;
  debug.enabled = exports.enabled(namespace);
  debug.useColors = exports.useColors();
  debug.color = selectColor(namespace);

  // env-specific initialization logic for debug instances
  if ('function' === typeof exports.init) {
    exports.init(debug);
  }

  return debug;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  exports.names = [];
  exports.skips = [];

  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":164}],164:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return;
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name;
  }
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],165:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}]},{},[12])(12)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2NvcmUvYXVkaW8tY29udGV4dC5qcyIsImRpc3QvY29yZS9hdWRpby10aW1lLWVuZ2luZS5qcyIsImRpc3QvY29yZS9wcmlvcml0eS1xdWV1ZS5qcyIsImRpc3QvY29yZS9zY2hlZHVsaW5nLXF1ZXVlLmpzIiwiZGlzdC9jb3JlL3RpbWUtZW5naW5lLmpzIiwiZGlzdC9lbmdpbmVzL2dyYW51bGFyLWVuZ2luZS5qcyIsImRpc3QvZW5naW5lcy9tZXRyb25vbWUuanMiLCJkaXN0L2VuZ2luZXMvcGhhc2V2b2NvZGVyLWVuZ2luZS5qcyIsImRpc3QvZW5naW5lcy9wbGF5ZXItZW5naW5lLmpzIiwiZGlzdC9lbmdpbmVzL3NlZ21lbnQtZW5naW5lLmpzIiwiZGlzdC9lbmdpbmVzL3NlcXVlbmNlci1lbmdpbmUuanMiLCJkaXN0L2luZGV4LmpzIiwiZGlzdC9tYXN0ZXJzL2ZhY3Rvcmllcy5qcyIsImRpc3QvbWFzdGVycy9wbGF5LWNvbnRyb2wuanMiLCJkaXN0L21hc3RlcnMvc2NoZWR1bGVyLmpzIiwiZGlzdC9tYXN0ZXJzL3NpbXBsZS1zY2hlZHVsZXIuanMiLCJkaXN0L21hc3RlcnMvdHJhbnNwb3J0LmpzIiwiZGlzdC91dGlscy9QVl9mYXN0XzUuanMiLCJkaXN0L3V0aWxzL2J1ZmZlcmVkLXB2LmpzIiwiZGlzdC91dGlscy9jYnVmZmVyLmpzIiwiZGlzdC91dGlscy9kc3AuanMiLCJkaXN0L3V0aWxzL3B1bHNlLXRyYW5zZm9ybXMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0aWVzLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3NldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3dlYWstbWFwLmpzIiwibm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldC5qcyIsIm5vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMuanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vcHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vc2V0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vd2Vhay1tYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FkZC10by11bnNjb3BhYmxlcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYW4taW5zdGFuY2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktZnJvbS1pdGVyYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LW1ldGhvZHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24tc3Ryb25nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2xsZWN0aW9uLXRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvbGxlY3Rpb24td2Vhay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZW51bS1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19mb3Itb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19oaWRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNhbGwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZXRlY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItc3RlcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19saWJyYXJ5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19taWNyb3Rhc2suanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX25ldy1wcm9taXNlLWNhcGFiaWxpdHkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BuLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3BlcmZvcm0uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb21pc2UtcmVzb2x2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fcmVkZWZpbmUtYWxsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tZnJvbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LWNvbGxlY3Rpb24tb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC1wcm90by5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXNwZWNpZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdGFzay5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tYWJzb2x1dGUtaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdG8tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fdmFsaWRhdGUtY29sbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWV4dC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5wcm9taXNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zZXQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3ltYm9sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi53ZWFrLW1hcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcucHJvbWlzZS5maW5hbGx5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5wcm9taXNlLnRyeS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0LmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnNldC5vZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc2V0LnRvLWpzb24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LndlYWstbWFwLmZyb20uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LndlYWstbWFwLm9mLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZGVidWcvc3JjL2RlYnVnLmpzIiwibm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FDQUEsSUFBTSxlQUFlLE9BQU8sWUFBUCxJQUF1QixPQUFPLGtCQUFuRDs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUEsSUFBSSxlQUFlLElBQW5COztBQUVBLElBQUksWUFBSixFQUFrQjtBQUNoQixpQkFBZSxJQUFJLFlBQUosRUFBZjs7QUFFQSxNQUFJLGlCQUFpQixJQUFqQixDQUFzQixVQUFVLFNBQWhDLEtBQThDLGFBQWEsVUFBYixHQUEwQixLQUE1RSxFQUFtRjtBQUNqRixRQUFNLFNBQVMsYUFBYSxZQUFiLENBQTBCLENBQTFCLEVBQTZCLENBQTdCLEVBQWdDLEtBQWhDLENBQWY7QUFDQSxRQUFNLFFBQVEsYUFBYSxrQkFBYixFQUFkO0FBQ0EsVUFBTSxNQUFOLEdBQWUsTUFBZjtBQUNBLFVBQU0s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Ozs7OztrQkExTGdCLGtCOzs7QUNKckI7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9cmV0dXJuIGV9KSgpIiwiY29uc3QgQXVkaW9Db250ZXh0ID0gd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xyXG5cclxuLyoqXHJcbiAqIEV4cG9zZSBhIHVuaXF1ZSBhdWRpbyBjb250ZXh0IHNpbmdsZXRvbiBhcyB0aGUgZGVmYXVsdCBhdWRpb1xyXG4gKiBjb250ZXh0IHVzZWQgYnkgdGhlIGNvbXBvbmVudHMgb2YgdGhlIFdhdmVzIEF1ZGlvIGxpYnJhcnkgYW5kXHJcbiAqIGFwcGxpY2F0aW9ucyB1c2luZyB0aGUgbGlicmFyeS5cclxuICpcclxuICogQHR5cGUgQXVkaW9Db250ZXh0XHJcbiAqIEBuYW1lIGF1ZGlvQ29udGV4dFxyXG4gKiBAY29uc3RhbnRcclxuICogQGdsb2JhbFxyXG4gKiBAaW5zdGFuY2VcclxuICpcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0ICogYXMgYXVkaW8gZnJvbSAnd2F2ZXMtYXVkaW8nO1xyXG4gKiBjb25zdCBhdWRpb0NvbnRleHQgPSBhdWRpby5hdWRpb0NvbnRleHQ7XHJcbiAqL1xyXG5sZXQgYXVkaW9Db250ZXh0ID0gbnVsbDtcclxuXHJcbmlmIChBdWRpb0NvbnRleHQpIHtcclxuICBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XHJcblxyXG4gIGlmICgvKGlQaG9uZXxpUGFkKS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUgPCA0NDEwMCkge1xyXG4gICAgY29uc3QgYnVmZmVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCA0NDEwMCk7XHJcbiAgICBjb25zdCBkdW1teSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgIGR1bW15LmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgIGR1bW15LmNvbm5lY3QoYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcclxuICAgIGR1bW15LnN0YXJ0KDApO1xyXG4gICAgZHVtbXkuZGlzY29ubmVjdCgpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXVkaW9Db250ZXh0O1xyXG4iLCJpbXBvcnQgVGltZUVuZ2luZSBmcm9tICcuL3RpbWUtZW5naW5lJztcclxuaW1wb3J0IGRlZmF1bHRBdWRpb0NvbnRleHQgZnJvbSAnLi9hdWRpby1jb250ZXh0JztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgYXVkaW8gcmVsYXRlZCB0aW1lIGVuZ2luZSBjb21wb25lbnRzLiBJdCBpc1xyXG4gKiB1c2VkIHRvIGhhbmRsZSBhdWRpbyByZWxhdGVkIGV2ZW50cyBzdWNoIGFzIHRoZSBwbGF5YmFjayBvZiBhIG1lZGlhIHN0cmVhbS5cclxuICogSXQgZXh0ZW5kcyB0aGUgVGltZUVuZ2luZSBjbGFzcyBieSB0aGUgc3RhbmRhcmQgd2ViIGF1ZGlvIG5vZGUgbWV0aG9kc1xyXG4gKiBjb25uZWN0IGFuZCBkaXNjb25uZWN0LlxyXG4gKlxyXG4gKiBbZXhhbXBsZV17QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL2F1ZGlvLXRpbWUtZW5naW5lLmh0bWx9XHJcbiAqXHJcbiAqIEBleHRlbmRzIFRpbWVFbmdpbmVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0IGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICpcclxuICogY2xhc3MgTXlFbmdpbmUgZXh0ZW5kcyBhdWRpby5BdWRpb1RpbWVFbmdpbmUge1xyXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xyXG4gKiAgICAgc3VwZXIoKTtcclxuICogICAgIC8vIC4uLlxyXG4gKiAgIH1cclxuICogfVxyXG4gKi9cclxuY2xhc3MgQXVkaW9UaW1lRW5naW5lIGV4dGVuZHMgVGltZUVuZ2luZSB7XHJcbiAgY29uc3RydWN0b3IoYXVkaW9Db250ZXh0ID0gZGVmYXVsdEF1ZGlvQ29udGV4dCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1ZGlvIGNvbnRleHQgdXNlZCBieSB0aGUgVGltZUVuZ2luZSwgZGVmYXVsdCB0byB0aGUgZ2xvYmFsIGF1ZGlvQ29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBuYW1lIGF1ZGlvQ29udGV4dFxyXG4gICAgICogQHR5cGUgQXVkaW9Db250ZXh0XHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UaW1lRW5naW5lXHJcbiAgICAgKiBAc2VlIGF1ZGlvQ29udGV4dFxyXG4gICAgICovXHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE91dHB1dCBhdWRpbyBub2RlLiBCeSBkZWZhdWx0IHRoZSBjb25uZWN0IG1ldGhvZCBjb25uZWN0cyBhIGdpdmVuIG5vZGVcclxuICAgICAqIHRvIHRoaXMgb3V0cHV0IG5vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgb3V0cHV0Tm9kZVxyXG4gICAgICogQHR5cGUgQXVkaW9Ob2RlXHJcbiAgICAgKiBAbWVtYmVyb2YgQXVkaW9UaW1lRW5naW5lXHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKi9cclxuICAgIHRoaXMub3V0cHV0Tm9kZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25uZWN0IHRvIGFuIGF1ZGlvIG5vZGUgKGUuZy4gYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBdWRpb05vZGV9IHRhcmdldCAtIFRhcmdldCBhdWRpbyBub2RlXHJcbiAgICovXHJcbiAgY29ubmVjdCh0YXJnZXQpIHtcclxuICAgIHRoaXMub3V0cHV0Tm9kZS5jb25uZWN0KHRhcmdldCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc2Nvbm5lY3QgZnJvbSBhbiBhdWRpbyBub2RlIChlLmcuIGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbikuIElmIHVuZGVmaW5lZFxyXG4gICAqIGRpc2Nvbm5lY3QgZnJvbSBhbGwgdGFyZ2V0IG5vZGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBdWRpb05vZGV9IHRhcmdldCAtIFRhcmdldCBhdWRpbyBub2RlLlxyXG4gICAqL1xyXG4gIGRpc2Nvbm5lY3QoY29ubmVjdGlvbikge1xyXG4gICAgdGhpcy5vdXRwdXROb2RlLmRpc2Nvbm5lY3QoY29ubmVjdGlvbik7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEF1ZGlvVGltZUVuZ2luZTtcclxuIiwiLy8gd29ya3MgYnkgcmVmZXJlbmNlXHJcbmZ1bmN0aW9uIHN3YXAoYXJyLCBpMSwgaTIpIHtcclxuICBjb25zdCB0bXAgPSBhcnJbaTFdO1xyXG4gIGFycltpMV0gPSBhcnJbaTJdO1xyXG4gIGFycltpMl0gPSB0bXA7XHJcbn1cclxuXHJcbi8vIGh0dHBzOi8vanNwZXJmLmNvbS9qcy1mb3ItbG9vcC12cy1hcnJheS1pbmRleG9mLzM0NlxyXG5mdW5jdGlvbiBpbmRleE9mKGFyciwgZWwpIHtcclxuICBjb25zdCBsID0gYXJyLmxlbmd0aDtcclxuICAvLyBpZ25vcmUgZmlyc3QgZWxlbWVudCBhcyBpdCBjYW4ndCBiZSBhIGVudHJ5XHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBsOyBpKyspIHtcclxuICAgIGlmIChhcnJbaV0gPT09IGVsKSB7XHJcbiAgICAgIHJldHVybiBpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIC0xO1xyXG59XHJcblxyXG4vKipcclxuICogRGVmaW5lIGlmIGB0aW1lMWAgc2hvdWxkIGJlIGxvd2VyIGluIHRoZSB0b3BvZ3JhcGh5IHRoYW4gYHRpbWUyYC5cclxuICogSXMgZHluYW1pY2FsbHkgYWZmZWN0ZWQgdG8gdGhlIHByaW9yaXR5IHF1ZXVlIGFjY29yZGluZyB0byBoYW5kbGUgYG1pbmAgYW5kIGBtYXhgIGhlYXAuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lMVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZTJcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICovXHJcbmNvbnN0IF9pc0xvd2VyTWF4SGVhcCA9IGZ1bmN0aW9uKHRpbWUxLCB0aW1lMikge1xyXG4gIHJldHVybiB0aW1lMSA8IHRpbWUyO1xyXG59O1xyXG5cclxuY29uc3QgX2lzTG93ZXJNaW5IZWFwID0gZnVuY3Rpb24odGltZTEsIHRpbWUyKSB7XHJcbiAgcmV0dXJuIHRpbWUxID4gdGltZTI7XHJcbn07XHJcblxyXG4vKipcclxuICogRGVmaW5lIGlmIGB0aW1lMWAgc2hvdWxkIGJlIGhpZ2hlciBpbiB0aGUgdG9wb2dyYXBoeSB0aGFuIGB0aW1lMmAuXHJcbiAqIElzIGR5bmFtaWNhbGx5IGFmZmVjdGVkIHRvIHRoZSBwcmlvcml0eSBxdWV1ZSBhY2NvcmRpbmcgdG8gaGFuZGxlIGBtaW5gIGFuZCBgbWF4YCBoZWFwLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZTFcclxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUyXHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqL1xyXG5jb25zdCBfaXNIaWdoZXJNYXhIZWFwID0gZnVuY3Rpb24odGltZTEsIHRpbWUyKSB7XHJcbiAgcmV0dXJuIHRpbWUxID4gdGltZTI7XHJcbn07XHJcblxyXG5jb25zdCBfaXNIaWdoZXJNaW5IZWFwID0gZnVuY3Rpb24odGltZTEsIHRpbWUyKSB7XHJcbiAgcmV0dXJuIHRpbWUxIDwgdGltZTI7XHJcbn07XHJcblxyXG5jb25zdCBQT1NJVElWRV9JTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHJcbi8qKlxyXG4gKiBQcmlvcml0eSBxdWV1ZSBpbXBsZW1lbnRpbmcgYSBiaW5hcnkgaGVhcC5cclxuICogQWN0cyBhcyBhIG1pbiBoZWFwIGJ5IGRlZmF1bHQsIGNhbiBiZSBkeW5hbWljYWxseSBjaGFuZ2VkIHRvIGEgbWF4IGhlYXBcclxuICogYnkgc2V0dGluZyBgcmV2ZXJzZWAgdG8gdHJ1ZS5cclxuICpcclxuICogX25vdGVfOiB0aGUgcXVldWUgY3JlYXRlcyBhbmQgbWFpbnRhaW5zIGEgbmV3IHByb3BlcnR5IChpLmUuIGBxdWV1ZVRpbWVgKVxyXG4gKiB0byBlYWNoIG9iamVjdCBhZGRlZC5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtoZWFwTGVuZ3RoPTEwMF0gLSBEZWZhdWx0IHNpemUgb2YgdGhlIGFycmF5IHVzZWQgdG8gY3JlYXRlIHRoZSBoZWFwLlxyXG4gKi9cclxuY2xhc3MgUHJpb3JpdHlRdWV1ZSB7XHJcbiAgY29uc3RydWN0b3IoaGVhcExlbmd0aCA9IDEwMCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb2ludGVyIHRvIHRoZSBmaXJzdCBlbXB0eSBpbmRleCBvZiB0aGUgaGVhcC5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgUHJpb3JpdHlRdWV1ZVxyXG4gICAgICogQG5hbWUgX2N1cnJlbnRMZW5ndGhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX2N1cnJlbnRMZW5ndGggPSAxO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2YgdGhlIHNvcnRlZCBpbmRleGVzIG9mIHRoZSBlbnRyaWVzLCB0aGUgYWN0dWFsIGhlYXAuIElnbm9yZSB0aGUgaW5kZXggMC5cclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqIEBtZW1iZXJvZiBQcmlvcml0eVF1ZXVlXHJcbiAgICAgKiBAbmFtZSBfaGVhcFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGhpcy5faGVhcCA9IG5ldyBBcnJheShoZWFwTGVuZ3RoICsgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUeXBlIG9mIHRoZSBxdWV1ZTogYG1pbmAgaGVhcCBpZiBgZmFsc2VgLCBgbWF4YCBoZWFwIGlmIGB0cnVlYFxyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAbWVtYmVyb2YgUHJpb3JpdHlRdWV1ZVxyXG4gICAgICogQG5hbWUgX3JldmVyc2VcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX3JldmVyc2UgPSBudWxsO1xyXG5cclxuICAgIC8vIGluaXRpYWxpemUgY29tcGFyZSBmdW5jdGlvbnNcclxuICAgIHRoaXMucmV2ZXJzZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGltZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgYmluYXJ5IGhlYXAuXHJcbiAgICogQHJldHVybnMge051bWJlcn1cclxuICAgKi9cclxuICBnZXQgdGltZSgpIHtcclxuICAgIGlmICh0aGlzLl9jdXJyZW50TGVuZ3RoID4gMSlcclxuICAgICAgcmV0dXJuIHRoaXMuX2hlYXBbMV0ucXVldWVUaW1lO1xyXG5cclxuICAgIHJldHVybiBJbmZpbml0eTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpcnN0IGVsZW1lbnQgaW4gdGhlIGJpbmFyeSBoZWFwLlxyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGhlYWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faGVhcFsxXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIHF1ZXVlIChtYXggaGVhcCBpZiB0cnVlLCBtaW4gaGVhcCBpZiBmYWxzZSksXHJcbiAgICogcmVidWlsZCB0aGUgaGVhcCB3aXRoIHRoZSBleGlzdGluZyBlbnRyaWVzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgc2V0IHJldmVyc2UodmFsdWUpIHtcclxuICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcmV2ZXJzZSkge1xyXG4gICAgICB0aGlzLl9yZXZlcnNlID0gdmFsdWU7XHJcblxyXG4gICAgICBpZiAodGhpcy5fcmV2ZXJzZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMuX2lzTG93ZXIgPSBfaXNMb3dlck1heEhlYXA7XHJcbiAgICAgICAgdGhpcy5faXNIaWdoZXIgPSBfaXNIaWdoZXJNYXhIZWFwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX2lzTG93ZXIgPSBfaXNMb3dlck1pbkhlYXA7XHJcbiAgICAgICAgdGhpcy5faXNIaWdoZXIgPSBfaXNIaWdoZXJNaW5IZWFwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmJ1aWxkSGVhcCgpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZ2V0IHJldmVyc2UoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmV2ZXJzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpeCB0aGUgaGVhcCBieSBtb3ZpbmcgYW4gZW50cnkgdG8gYSBuZXcgdXBwZXIgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBlbnRyeSB0byBtb3ZlLlxyXG4gICAqL1xyXG4gIF9idWJibGVVcChzdGFydEluZGV4KSB7XHJcbiAgICBsZXQgZW50cnkgPSB0aGlzLl9oZWFwW3N0YXJ0SW5kZXhdO1xyXG5cclxuICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXg7XHJcbiAgICBsZXQgcGFyZW50SW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gMik7XHJcbiAgICBsZXQgcGFyZW50ID0gdGhpcy5faGVhcFtwYXJlbnRJbmRleF07XHJcblxyXG4gICAgd2hpbGUgKHBhcmVudCAmJiB0aGlzLl9pc0hpZ2hlcihlbnRyeS5xdWV1ZVRpbWUsIHBhcmVudC5xdWV1ZVRpbWUpKSB7XHJcbiAgICAgIHN3YXAodGhpcy5faGVhcCwgaW5kZXgsIHBhcmVudEluZGV4KTtcclxuXHJcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XHJcbiAgICAgIHBhcmVudEluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIDIpO1xyXG4gICAgICBwYXJlbnQgPSB0aGlzLl9oZWFwW3BhcmVudEluZGV4XTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpeCB0aGUgaGVhcCBieSBtb3ZpbmcgYW4gZW50cnkgdG8gYSBuZXcgbG93ZXIgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBlbnRyeSB0byBtb3ZlLlxyXG4gICAqL1xyXG4gIF9idWJibGVEb3duKHN0YXJ0SW5kZXgpIHtcclxuICAgIGxldCBlbnRyeSA9IHRoaXMuX2hlYXBbc3RhcnRJbmRleF07XHJcblxyXG4gICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleDtcclxuICAgIGxldCBjMWluZGV4ID0gaW5kZXggKiAyO1xyXG4gICAgbGV0IGMyaW5kZXggPSBjMWluZGV4ICsgMTtcclxuICAgIGxldCBjaGlsZDEgPSB0aGlzLl9oZWFwW2MxaW5kZXhdO1xyXG4gICAgbGV0IGNoaWxkMiA9IHRoaXMuX2hlYXBbYzJpbmRleF07XHJcblxyXG4gICAgd2hpbGUgKChjaGlsZDEgJiYgdGhpcy5faXNMb3dlcihlbnRyeS5xdWV1ZVRpbWUsIGNoaWxkMS5xdWV1ZVRpbWUpKcKgfHxcclxuICAgICAgICAgICAoY2hpbGQyICYmIHRoaXMuX2lzTG93ZXIoZW50cnkucXVldWVUaW1lLCBjaGlsZDIucXVldWVUaW1lKSkpXHJcbiAgICB7XHJcbiAgICAgIC8vIHN3YXAgd2l0aCB0aGUgbWluaW11bSBjaGlsZFxyXG4gICAgICBsZXQgdGFyZ2V0SW5kZXg7XHJcblxyXG4gICAgICBpZiAoY2hpbGQyKVxyXG4gICAgICAgIHRhcmdldEluZGV4ID0gdGhpcy5faXNIaWdoZXIoY2hpbGQxLnF1ZXVlVGltZSwgY2hpbGQyLnF1ZXVlVGltZSkgPyBjMWluZGV4IDogYzJpbmRleDtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIHRhcmdldEluZGV4ID0gYzFpbmRleDtcclxuXHJcbiAgICAgIHN3YXAodGhpcy5faGVhcCwgaW5kZXgsIHRhcmdldEluZGV4KTtcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSB0byBmaW5kIG5leHQgY2hpbGRyZW5cclxuICAgICAgaW5kZXggPSB0YXJnZXRJbmRleDtcclxuICAgICAgYzFpbmRleCA9IGluZGV4ICogMjtcclxuICAgICAgYzJpbmRleCA9IGMxaW5kZXggKyAxO1xyXG4gICAgICBjaGlsZDEgPSB0aGlzLl9oZWFwW2MxaW5kZXhdO1xyXG4gICAgICBjaGlsZDIgPSB0aGlzLl9oZWFwW2MyaW5kZXhdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQnVpbGQgdGhlIGhlYXAgKGZyb20gYm90dG9tIHVwKS5cclxuICAgKi9cclxuICBidWlsZEhlYXAoKSB7XHJcbiAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBpbnRlcm5hbCBub2RlXHJcbiAgICAvLyBAdG9kbyAtIG1ha2Ugc3VyZSB0aGF0J3MgdGhlIHJpZ2h0IHdheSB0byBkby5cclxuICAgIGxldCBtYXhJbmRleCA9IE1hdGguZmxvb3IoKHRoaXMuX2N1cnJlbnRMZW5ndGggLSAxKSAvIDIpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBtYXhJbmRleDsgaSA+IDA7IGktLSlcclxuICAgICAgdGhpcy5fYnViYmxlRG93bihpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIG5ldyBvYmplY3QgaW4gdGhlIGJpbmFyeSBoZWFwIGFuZCBzb3J0IGl0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudHJ5IC0gRW50cnkgdG8gaW5zZXJ0LlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gVGltZSBhdCB3aGljaCB0aGUgZW50cnkgc2hvdWxkIGJlIG9yZGVyZXIuXHJcbiAgICogQHJldHVybnMge051bWJlcn0gLSBUaW1lIG9mIHRoZSBmaXJzdCBlbnRyeSBpbiB0aGUgaGVhcC5cclxuICAgKi9cclxuICBpbnNlcnQoZW50cnksIHRpbWUpIHtcclxuICAgIGlmIChNYXRoLmFicyh0aW1lKSAhPT0gUE9TSVRJVkVfSU5GSU5JVFkpIHtcclxuICAgICAgZW50cnkucXVldWVUaW1lID0gdGltZTtcclxuICAgICAgLy8gYWRkIHRoZSBuZXcgZW50cnkgYXQgdGhlIGVuZCBvZiB0aGUgaGVhcFxyXG4gICAgICB0aGlzLl9oZWFwW3RoaXMuX2N1cnJlbnRMZW5ndGhdID0gZW50cnk7XHJcbiAgICAgIC8vIGJ1YmJsZSBpdCB1cFxyXG4gICAgICB0aGlzLl9idWJibGVVcCh0aGlzLl9jdXJyZW50TGVuZ3RoKTtcclxuICAgICAgdGhpcy5fY3VycmVudExlbmd0aCArPSAxO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMudGltZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRyeS5xdWV1ZVRpbWUgPSB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoZW50cnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW92ZSBhIGdpdmVuIGVudHJ5IHRvIGEgbmV3IHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudHJ5IC0gRW50cnkgdG8gbW92ZS5cclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIFRpbWUgYXQgd2hpY2ggdGhlIGVudHJ5IHNob3VsZCBiZSBvcmRlcmVyLlxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gLSBUaW1lIG9mIGZpcnN0IGVudHJ5IGluIHRoZSBoZWFwLlxyXG4gICAqL1xyXG4gIG1vdmUoZW50cnksIHRpbWUpIHtcclxuICAgIGlmIChNYXRoLmFicyh0aW1lKSAhPT0gUE9TSVRJVkVfSU5GSU5JVFkpIHtcclxuICAgICAgY29uc3QgaW5kZXggPSBpbmRleE9mKHRoaXMuX2hlYXAsIGVudHJ5KTtcclxuXHJcbiAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICBlbnRyeS5xdWV1ZVRpbWUgPSB0aW1lO1xyXG4gICAgICAgIC8vIGRlZmluZSBpZiB0aGUgZW50cnkgc2hvdWxkIGJlIGJ1YmJsZWQgdXAgb3IgZG93blxyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2hlYXBbTWF0aC5mbG9vcihpbmRleCAvIDIpXTtcclxuXHJcbiAgICAgICAgaWYgKHBhcmVudCAmJiB0aGlzLl9pc0hpZ2hlcih0aW1lLCBwYXJlbnQucXVldWVUaW1lKSlcclxuICAgICAgICAgIHRoaXMuX2J1YmJsZVVwKGluZGV4KTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICB0aGlzLl9idWJibGVEb3duKGluZGV4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMudGltZTtcclxuICAgIH1cclxuXHJcbiAgICBlbnRyeS5xdWV1ZVRpbWUgPSB1bmRlZmluZWQ7XHJcbiAgICByZXR1cm4gdGhpcy5yZW1vdmUoZW50cnkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFuIGVudHJ5IGZyb20gdGhlIGhlYXAgYW5kIGZpeCB0aGUgaGVhcC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSAtIEVudHJ5IHRvIHJlbW92ZS5cclxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gVGltZSBvZiBmaXJzdCBlbnRyeSBpbiB0aGUgaGVhcC5cclxuICAgKi9cclxuICByZW1vdmUoZW50cnkpIHtcclxuICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBlbnRyeVxyXG4gICAgY29uc3QgaW5kZXggPSBpbmRleE9mKHRoaXMuX2hlYXAsIGVudHJ5KTtcclxuXHJcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHRoaXMuX2N1cnJlbnRMZW5ndGggLSAxO1xyXG5cclxuICAgICAgLy8gaWYgdGhlIGVudHJ5IGlzIHRoZSBsYXN0IG9uZVxyXG4gICAgICBpZiAoaW5kZXggPT09IGxhc3RJbmRleCkge1xyXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZWxlbWVudCBmcm9tIGhlYXBcclxuICAgICAgICB0aGlzLl9oZWFwW2xhc3RJbmRleF0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgLy8gdXBkYXRlIGN1cnJlbnQgbGVuZ3RoXHJcbiAgICAgICAgdGhpcy5fY3VycmVudExlbmd0aCA9IGxhc3RJbmRleDtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGltZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBzd2FwIHdpdGggdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgaGVhcFxyXG4gICAgICAgIHN3YXAodGhpcy5faGVhcCwgaW5kZXgsIGxhc3RJbmRleCk7XHJcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBlbGVtZW50IGZyb20gaGVhcFxyXG4gICAgICAgIHRoaXMuX2hlYXBbbGFzdEluZGV4XSA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgaWYgKGluZGV4ID09PSAxKSB7XHJcbiAgICAgICAgICB0aGlzLl9idWJibGVEb3duKDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBidWJibGUgdGhlIChleCBsYXN0KSBlbGVtZW50IHVwIG9yIGRvd24gYWNjb3JkaW5nIHRvIGl0cyBuZXcgY29udGV4dFxyXG4gICAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLl9oZWFwW2luZGV4XTtcclxuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2hlYXBbTWF0aC5mbG9vcihpbmRleCAvIDIpXTtcclxuXHJcbiAgICAgICAgICBpZiAocGFyZW50ICYmIHRoaXMuX2lzSGlnaGVyKGVudHJ5LnF1ZXVlVGltZSwgcGFyZW50LnF1ZXVlVGltZSkpXHJcbiAgICAgICAgICAgIHRoaXMuX2J1YmJsZVVwKGluZGV4KTtcclxuICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGhpcy5fYnViYmxlRG93bihpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB1cGRhdGUgY3VycmVudCBsZW5ndGhcclxuICAgICAgdGhpcy5fY3VycmVudExlbmd0aCA9IGxhc3RJbmRleDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy50aW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXIgdGhlIHF1ZXVlLlxyXG4gICAqL1xyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5fY3VycmVudExlbmd0aCA9IDE7XHJcbiAgICB0aGlzLl9oZWFwID0gbmV3IEFycmF5KHRoaXMuX2hlYXAubGVuZ3RoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlZmluZXMgaWYgdGhlIHF1ZXVlIGNvbnRhaW5zIHRoZSBnaXZlbiBgZW50cnlgLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGVudHJ5IC0gRW50cnkgdG8gYmUgY2hlY2tlZFxyXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAgICovXHJcbiAgaGFzKGVudHJ5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5faGVhcC5pbmRleE9mKGVudHJ5KSAhPT0gLTE7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcmlvcml0eVF1ZXVlO1xyXG4iLCIvKipcclxuICogU2NoZWR1bGluZ1F1ZXVlIGJhc2UgY2xhc3NcclxuICogaHR0cDovL3dhdmVzanMuZ2l0aHViLmlvL2F1ZGlvLyNhdWRpby1zY2hlZHVsaW5nLXF1ZXVlXHJcbiAqXHJcbiAqIE5vcmJlcnQuU2NobmVsbEBpcmNhbS5mclxyXG4gKiBDb3B5cmlnaHQgMjAxNCwgMjAxNSBJUkNBTSDigJPCoENlbnRyZSBQb21waWRvdVxyXG4gKi9cclxuXHJcbmltcG9ydCBQcmlvcml0eVF1ZXVlIGZyb20gJy4vcHJpb3JpdHktcXVldWUnO1xyXG5pbXBvcnQgVGltZUVuZ2luZSBmcm9tICcuL3RpbWUtZW5naW5lJztcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgU2NoZWR1bGluZ1F1ZXVlXHJcbiAqIEBleHRlbmRzIFRpbWVFbmdpbmVcclxuICovXHJcbmNsYXNzIFNjaGVkdWxpbmdRdWV1ZSBleHRlbmRzIFRpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9fcXVldWUgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xyXG4gICAgdGhpcy5fX2VuZ2luZXMgPSBuZXcgU2V0KCk7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lICdzY2hlZHVsZWQnIGludGVyZmFjZVxyXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcclxuICAgIGNvbnN0IGVuZ2luZSA9IHRoaXMuX19xdWV1ZS5oZWFkO1xyXG4gICAgY29uc3QgbmV4dEVuZ2luZVRpbWUgPSBlbmdpbmUuYWR2YW5jZVRpbWUodGltZSk7XHJcblxyXG4gICAgaWYgKCFuZXh0RW5naW5lVGltZSkge1xyXG4gICAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcclxuICAgICAgdGhpcy5fX2VuZ2luZXMuZGVsZXRlKGVuZ2luZSk7XHJcbiAgICAgIHRoaXMuX19xdWV1ZS5yZW1vdmUoZW5naW5lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX19xdWV1ZS5tb3ZlKGVuZ2luZSwgbmV4dEVuZ2luZVRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9fcXVldWUudGltZTtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWFzdGVyIG1ldGhvZCB0byBiZSBpbXBsZW1lbnRlZCBieSBkZXJpdmVkIGNsYXNzXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICAvLyBjYWxsIGEgZnVuY3Rpb24gYXQgYSBnaXZlbiB0aW1lXHJcbiAgZGVmZXIoZnVuLCB0aW1lID0gdGhpcy5jdXJyZW50VGltZSkge1xyXG4gICAgaWYgKCEoZnVuIGluc3RhbmNlb2YgRnVuY3Rpb24pKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgY2Fubm90IGJlIGRlZmVyZWQgYnkgc2NoZWR1bGVyXCIpO1xyXG5cclxuICAgIHRoaXMuYWRkKHtcclxuICAgICAgYWR2YW5jZVRpbWU6IGZ1bmN0aW9uKHRpbWUpIHsgZnVuKHRpbWUpOyB9LCAvLyBtYWtlIHN1ciB0aGF0IHRoZSBhZHZhbmNlVGltZSBtZXRob2QgZG9lcyBub3QgcmV0dXJtIGFueXRoaW5nXHJcbiAgICB9LCB0aW1lKTtcclxuICB9XHJcblxyXG4gIC8vIGFkZCBhIHRpbWUgZW5naW5lIHRvIHRoZSBzY2hlZHVsZXJcclxuICBhZGQoZW5naW5lLCB0aW1lID0gdGhpcy5jdXJyZW50VGltZSkge1xyXG4gICAgaWYgKCFUaW1lRW5naW5lLmltcGxlbWVudHNTY2hlZHVsZWQoZW5naW5lKSlcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGNhbm5vdCBiZSBhZGRlZCB0byBzY2hlZHVsZXJcIik7XHJcblxyXG4gICAgaWYgKGVuZ2luZS5tYXN0ZXIpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIGEgbWFzdGVyXCIpO1xyXG5cclxuICAgIGVuZ2luZS5tYXN0ZXIgPSB0aGlzO1xyXG5cclxuICAgIC8vIGFkZCB0byBlbmdpbmVzIGFuZCBxdWV1ZVxyXG4gICAgdGhpcy5fX2VuZ2luZXMuYWRkKGVuZ2luZSk7XHJcbiAgICBjb25zdCBuZXh0VGltZSA9IHRoaXMuX19xdWV1ZS5pbnNlcnQoZW5naW5lLCB0aW1lKTtcclxuXHJcbiAgICAvLyByZXNjaGVkdWxlIHF1ZXVlXHJcbiAgICB0aGlzLnJlc2V0VGltZShuZXh0VGltZSk7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgYSB0aW1lIGVuZ2luZSBmcm9tIHRoZSBxdWV1ZVxyXG4gIHJlbW92ZShlbmdpbmUpIHtcclxuICAgIGlmIChlbmdpbmUubWFzdGVyICE9PSB0aGlzKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoaXMgc2NoZWR1bGVyXCIpO1xyXG5cclxuICAgIGVuZ2luZS5tYXN0ZXIgPSBudWxsO1xyXG5cclxuICAgIC8vIHJlbW92ZSBmcm9tIGFycmF5IGFuZCBxdWV1ZVxyXG4gICAgdGhpcy5fX2VuZ2luZXMuZGVsZXRlKGVuZ2luZSk7XHJcbiAgICBjb25zdCBuZXh0VGltZSA9IHRoaXMuX19xdWV1ZS5yZW1vdmUoZW5naW5lKTtcclxuXHJcbiAgICAvLyByZXNjaGVkdWxlIHF1ZXVlXHJcbiAgICB0aGlzLnJlc2V0VGltZShuZXh0VGltZSk7XHJcbiAgfVxyXG5cclxuICAvLyByZXNldCBuZXh0IGVuZ2luZSB0aW1lXHJcbiAgcmVzZXRFbmdpbmVUaW1lKGVuZ2luZSwgdGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcclxuICAgIGlmIChlbmdpbmUubWFzdGVyICE9PSB0aGlzKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoaXMgc2NoZWR1bGVyXCIpO1xyXG5cclxuICAgIGxldCBuZXh0VGltZTtcclxuXHJcbiAgICBpZiAodGhpcy5fX3F1ZXVlLmhhcyhlbmdpbmUpKVxyXG4gICAgICBuZXh0VGltZSA9IHRoaXMuX19xdWV1ZS5tb3ZlKGVuZ2luZSwgdGltZSk7XHJcbiAgICBlbHNlXHJcbiAgICAgIG5leHRUaW1lID0gdGhpcy5fX3F1ZXVlLmluc2VydChlbmdpbmUsIHRpbWUpO1xyXG5cclxuICAgIHRoaXMucmVzZXRUaW1lKG5leHRUaW1lKTtcclxuICB9XHJcblxyXG4gIC8vIGNoZWNrIHdoZXRoZXIgYSBnaXZlbiBlbmdpbmUgaXMgc2NoZWR1bGVkXHJcbiAgaGFzKGVuZ2luZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19lbmdpbmVzLmhhcyhlbmdpbmUpO1xyXG4gIH1cclxuXHJcbiAgLy8gY2xlYXIgcXVldWVcclxuICBjbGVhcigpIHtcclxuICAgIGZvcihsZXQgZW5naW5lIG9mIHRoaXMuX19lbmdpbmVzKVxyXG4gICAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9fcXVldWUuY2xlYXIoKTtcclxuICAgIHRoaXMuX19lbmdpbmVzLmNsZWFyKCk7XHJcbiAgICB0aGlzLnJlc2V0VGltZShJbmZpbml0eSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTY2hlZHVsaW5nUXVldWVcclxuIiwiLyoqXHJcbiAqIEJhc2UgY2xhc3MgZm9yIHRpbWUgZW5naW5lc1xyXG4gKlxyXG4gKiBBIHRpbWUgZW5naW5lIGdlbmVyYXRlcyBtb3JlIG9yIGxlc3MgcmVndWxhciBldmVudHMgYW5kL29yIHBsYXlzIGJhY2sgYVxyXG4gKiBtZWRpYSBzdHJlYW0uIEl0IGltcGxlbWVudHMgb25lIG9yIG11bHRpcGxlIGludGVyZmFjZXMgdG8gYmUgZHJpdmVuIGJ5IGFcclxuICogbWFzdGVyIChpLmUuIGEgU2NoZWR1bGVyLCBhIFRyYW5zcG9ydCBvciBhIFBsYXlDb250cm9sKSBpbiBzeW5jaHJvbml6YXRpb25cclxuICogd2l0aCBvdGhlciBlbmdpbmVzLiBUaGUgcHJvdmlkZWQgaW50ZXJmYWNlcyBhcmUgc2NoZWR1bGVkLCB0cmFuc3BvcnRlZCxcclxuICogYW5kIHBsYXktY29udHJvbGxlZC5cclxuICpcclxuICpcclxuICogIyMjIyBUaGUgYHNjaGVkdWxlZGAgaW50ZXJmYWNlXHJcbiAqXHJcbiAqIFRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlIGFsbG93cyBmb3Igc3luY2hyb25pemluZyBhbiBlbmdpbmUgdG8gYSBtb25vdG9ub3VzIHRpbWVcclxuICogYXMgaXQgaXMgcHJvdmlkZWQgYnkgdGhlIFNjaGVkdWxlciBtYXN0ZXIuXHJcbiAqXHJcbiAqICMjIyMjIyBgYWR2YW5jZVRpbWUodGltZSA6TnVtYmVyKSAtPiB7TnVtYmVyfWBcclxuICpcclxuICogVGhlIGBhZHZhbmNlVGltZWAgbWV0aG9kIGhhcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhbiBgVGltZUVuZ2luZWAgYXMgcGFydCBvZiB0aGVcclxuICogc2NoZWR1bGVkIGludGVyZmFjZS4gVGhlIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIG1hc3RlciAoZS5nLiB0aGUgc2NoZWR1bGVyKS5cclxuICogSXQgZ2VuZXJhdGVzIGFuIGV2ZW50IGFuZCB0byByZXR1cm5zIHRoZSB0aW1lIG9mIHRoZSBuZXh0IGV2ZW50IChpLmUuIHRoZSBuZXh0XHJcbiAqIGNhbGwgb2YgYWR2YW5jZVRpbWUpLiBUaGUgcmV0dXJuZWQgdGltZSBoYXMgdG8gYmUgZ3JlYXRlciB0aGFuIHRoZSB0aW1lXHJcbiAqIHJlY2VpdmVkIGFzIGFyZ3VtZW50IG9mIHRoZSBtZXRob2QuIEluIGNhc2UgdGhhdCBhIFRpbWVFbmdpbmUgaGFzIHRvIGdlbmVyYXRlXHJcbiAqIG11bHRpcGxlIGV2ZW50cyBhdCB0aGUgc2FtZSB0aW1lLCB0aGUgZW5naW5lIGhhcyB0byBpbXBsZW1lbnQgaXRzIG93biBsb29wXHJcbiAqIHdoaWxlKGV2ZW50LnRpbWUgPD0gdGltZSkgYW5kIHJldHVybiB0aGUgdGltZSBvZiB0aGUgbmV4dCBldmVudCAoaWYgYW55KS5cclxuICpcclxuICogIyMjIyMjIGByZXNldFRpbWUodGltZT11bmRlZmluZWQgOk51bWJlcilgXHJcbiAqXHJcbiAqIFRoZSBgcmVzZXRUaW1lYCBtZXRob2QgaXMgcHJvdmlkZWQgYnkgdGhlIGBUaW1lRW5naW5lYCBiYXNlIGNsYXNzLiBBbiBlbmdpbmUgbWF5XHJcbiAqIGNhbGwgdGhpcyBtZXRob2QgdG8gcmVzZXQgaXRzIG5leHQgZXZlbnQgdGltZSAoZS5nLiB3aGVuIGEgcGFyYW1ldGVyIGlzXHJcbiAqIGNoYW5nZWQgdGhhdCBpbmZsdWVuY2VzIHRoZSBlbmdpbmUncyB0ZW1wb3JhbCBiZWhhdmlvcikuIFdoZW4gbm8gYXJndW1lbnRcclxuICogaXMgZ2l2ZW4sIHRoZSB0aW1lIGlzIHJlc2V0IHRvIHRoZSBjdXJyZW50IG1hc3RlciB0aW1lLiBXaGVuIGNhbGxpbmcgdGhlXHJcbiAqIG1ldGhvZCB3aXRoIEluZmluaXR5IHRoZSBlbmdpbmUgaXMgc3VzcGVuZGVkIHdpdGhvdXQgYmVpbmcgcmVtb3ZlZCBmcm9tIHRoZVxyXG4gKiBtYXN0ZXIuXHJcbiAqXHJcbiAqXHJcbiAqICMjIyMgVGhlIGB0cmFuc3BvcnRlZGAgaW50ZXJmYWNlXHJcbiAqXHJcbiAqIFRoZSB0cmFuc3BvcnRlZCBpbnRlcmZhY2UgYWxsb3dzIGZvciBzeW5jaHJvbml6aW5nIGFuIGVuZ2luZSB0byBhIHBvc2l0aW9uXHJcbiAqIChpLmUuIG1lZGlhIHBsYXliYWNrIHRpbWUpIHRoYXQgY2FuIHJ1biBmb3J3YXJkIGFuZCBiYWNrd2FyZCBhbmQganVtcCBhcyBpdFxyXG4gKiBpcyBwcm92aWRlZCBieSB0aGUgVHJhbnNwb3J0IG1hc3Rlci5cclxuICpcclxuICogIyMjIyMjIGBzeW5jUG9zaXRpb24odGltZSA6TnVtYmVyLCBwb3NpdGlvbiA6TnVtYmVyLCBzcGVlZCA6TnVtYmVyKSAtPiB7TnVtYmVyfWBcclxuICpcclxuICogVGhlIGBzeW5jUG9zaXRvbmAgbWV0aG9kIGhhcyB0byBiZSBpbXBsZW1lbnRlZCBieSBhIGBUaW1lRW5naW5lYCBhcyBwYXJ0IG9mIHRoZVxyXG4gKiB0cmFuc3BvcnRlZCBpbnRlcmZhY2UuIFRoZSBtZXRob2Qgc3luY1Bvc2l0b24gaXMgY2FsbGVkIHdoZW5ldmVyIHRoZSBtYXN0ZXJcclxuICogb2YgYSB0cmFuc3BvcnRlZCBlbmdpbmUgaGFzIHRvIChyZS0pc3luY2hyb25pemUgdGhlIGVuZ2luZSdzIHBvc2l0aW9uLiBUaGlzXHJcbiAqIGlzIGZvciBleGFtcGxlIHJlcXVpcmVkIHdoZW4gdGhlIG1hc3RlciAocmUtKXN0YXJ0cyBwbGF5YmFjaywganVtcHMgdG8gYW5cclxuICogYXJiaXRyYXJ5IHBvc2l0aW9uLCBhbmQgd2hlbiByZXZlcnNpbmcgcGxheWJhY2sgZGlyZWN0aW9uLiBUaGUgbWV0aG9kIHJldHVybnNcclxuICogdGhlIG5leHQgcG9zaXRpb24gb2YgdGhlIGVuZ2luZSBpbiB0aGUgZ2l2ZW4gcGxheWJhY2sgZGlyZWN0aW9uXHJcbiAqIChpLmUuIGBzcGVlZCA8IDBgIG9yIGBzcGVlZCA+IDBgKS5cclxuICpcclxuICogIyMjIyMjIGBhZHZhbmNlUG9zaXRpb24odGltZSA6TnVtYmVyLCBwb3NpdGlvbiA6TnVtYmVyLCBzcGVlZCA6TnVtYmVyKSAtPiB7TnVtYmVyfWBcclxuICpcclxuICogVGhlIGBhZHZhbmNlUG9zaXRpb25gIG1ldGhvZCBoYXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYSBgVGltZUVuZ2luZWAgYXMgcGFydFxyXG4gKiBvZiB0aGUgdHJhbnNwb3J0ZWQgaW50ZXJmYWNlLiBUaGUgbWFzdGVyIGNhbGxzIHRoZSBhZHZhbmNlUG9zaXRvbiBtZXRob2Qgd2hlblxyXG4gKiB0aGUgZW5naW5lJ3MgZXZlbnQgcG9zaXRpb24gaXMgcmVhY2hlZC4gVGhlIG1ldGhvZCBnZW5lcmF0ZXMgYW4gZXZlbnQgYW5kXHJcbiAqIHJldHVybnMgdGhlIG5leHQgcG9zaXRpb24gaW4gdGhlIGdpdmVuIHBsYXliYWNrIGRpcmVjdGlvbiAoaS5lLiBzcGVlZCA8IDAgb3JcclxuICogc3BlZWQgPiAwKS4gVGhlIHJldHVybmVkIHBvc2l0aW9uIGhhcyB0byBiZSBncmVhdGVyIChpLmUuIHdoZW4gc3BlZWQgPiAwKVxyXG4gKiBvciBsZXNzIChpLmUuIHdoZW4gc3BlZWQgPCAwKSB0aGFuIHRoZSBwb3NpdGlvbiByZWNlaXZlZCBhcyBhcmd1bWVudCBvZiB0aGVcclxuICogbWV0aG9kLlxyXG4gKlxyXG4gKiAjIyMjIyMgYHJlc2V0UG9zaXRpb24ocG9zaXRpb249dW5kZWZpbmVkIDpOdW1iZXIpYFxyXG4gKlxyXG4gKiBUaGUgcmVzZXRQb3NpdGlvbiBtZXRob2QgaXMgcHJvdmlkZWQgYnkgdGhlIFRpbWVFbmdpbmUgYmFzZSBjbGFzcy4gQW4gZW5naW5lXHJcbiAqIG1heSBjYWxsIHRoaXMgbWV0aG9kIHRvIHJlc2V0IGl0cyBuZXh0IGV2ZW50IHBvc2l0aW9uLiBXaGVuIG5vIGFyZ3VtZW50XHJcbiAqIGlzIGdpdmVuLCB0aGUgdGltZSBpcyByZXNldCB0byB0aGUgY3VycmVudCBtYXN0ZXIgdGltZS4gV2hlbiBjYWxsaW5nIHRoZVxyXG4gKiBtZXRob2Qgd2l0aCBJbmZpbml0eSB0aGUgZW5naW5lIGlzIHN1c3BlbmRlZCB3aXRob3V0IGJlaW5nIHJlbW92ZWQgZnJvbVxyXG4gKiB0aGUgbWFzdGVyLlxyXG4gKlxyXG4gKlxyXG4gKiAjIyMjIFRoZSBzcGVlZC1jb250cm9sbGVkIGludGVyZmFjZVxyXG4gKlxyXG4gKiBUaGUgXCJzcGVlZC1jb250cm9sbGVkXCIgaW50ZXJmYWNlIGFsbG93cyBmb3Igc3luY3Jvbml6aW5nIGFuIGVuZ2luZSB0aGF0IGlzXHJcbiAqIG5laXRoZXIgZHJpdmVuIHRocm91Z2ggdGhlIHNjaGVkdWxlZCBub3IgdGhlIHRyYW5zcG9ydGVkIGludGVyZmFjZS4gVGhlXHJcbiAqIGludGVyZmFjZSBhbGxvd3MgaW4gcGFydGljdWxhciB0byBzeW5jaHJvbml6ZSBlbmdpbmVzIHRoYXQgYXNzdXJlIHRoZWlyIG93blxyXG4gKiBzY2hlZHVsaW5nIChpLmUuIGF1ZGlvIHBsYXllciBvciBhbiBvc2NpbGxhdG9yKSB0byB0aGUgZXZlbnQtYmFzZWQgc2NoZWR1bGVkXHJcbiAqIGFuZCB0cmFuc3BvcnRlZCBlbmdpbmVzLlxyXG4gKlxyXG4gKiAjIyMjIyMgYHN5bmNTcGVlZCh0aW1lIDpOdW1iZXIsIHBvc2l0aW9uIDpOdW1iZXIsIHNwZWVkIDpOdW1iZXIsIHNlZWs9ZmFsc2UgOkJvb2xlYW4pYFxyXG4gKlxyXG4gKiBUaGUgc3luY1NwZWVkIG1ldGhvZCBoYXMgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYSBUaW1lRW5naW5lIGFzIHBhcnQgb2YgdGhlXHJcbiAqIHNwZWVkLWNvbnRyb2xsZWQgaW50ZXJmYWNlLiBUaGUgbWV0aG9kIGlzIGNhbGxlZCBieSB0aGUgbWFzdGVyIHdoZW5ldmVyIHRoZVxyXG4gKiBwbGF5YmFjayBzcGVlZCBjaGFuZ2VzIG9yIHRoZSBwb3NpdGlvbiBqdW1wcyBhcmJpdGFyaWx5IChpLmUuIG9uIGEgc2VlaykuXHJcbiAqXHJcbiAqXHJcbiAqIDxociAvPlxyXG4gKlxyXG4gKiBFeGFtcGxlIHRoYXQgc2hvd3MgYSBgVGltZUVuZ2luZWAgcnVubmluZyBpbiBhIGBTY2hlZHVsZXJgIHRoYXQgY291bnRzIHVwXHJcbiAqIGF0IGEgZ2l2ZW4gZnJlcXVlbmN5OlxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3RpbWUtZW5naW5lLmh0bWx9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICpcclxuICogY2xhc3MgTXlFbmdpbmUgZXh0ZW5kcyBhdWRpby5UaW1lRW5naW5lIHtcclxuICogICBjb25zdHJ1Y3RvcigpIHtcclxuICogICAgIHN1cGVyKCk7XHJcbiAqICAgICAvLyAuLi5cclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICovXHJcbmNsYXNzIFRpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZW5naW5lJ3MgbWFzdGVyLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtNaXhlZH1cclxuICAgICAqIEBuYW1lIG1hc3RlclxyXG4gICAgICogQG1lbWJlcm9mIFRpbWVFbmdpbmVcclxuICAgICAqL1xyXG4gICAgdGhpcy5tYXN0ZXIgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHRpbWUgZW5naW5lJ3MgY3VycmVudCAobWFzdGVyKSB0aW1lLlxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbWVtYmVyb2YgVGltZUVuZ2luZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50VGltZSgpIHtcclxuICAgIGlmICh0aGlzLm1hc3RlcilcclxuICAgICAgcmV0dXJuIHRoaXMubWFzdGVyLmN1cnJlbnRUaW1lO1xyXG5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgdGltZSBlbmdpbmUncyBjdXJyZW50IChtYXN0ZXIpIHBvc2l0aW9uLlxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbWVtYmVyb2YgVGltZUVuZ2luZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICB2YXIgbWFzdGVyID0gdGhpcy5tYXN0ZXI7XHJcblxyXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uO1xyXG5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY2hlZHVsZWQgaW50ZXJmYWNlXHJcbiAgICogICAtIGFkdmFuY2VUaW1lKHRpbWUpLCBjYWxsZWQgdG8gZ2VuZXJhdGUgbmV4dCBldmVudCBhdCBnaXZlbiB0aW1lLCByZXR1cm5zIG5leHQgdGltZVxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXHJcbiAgICovXHJcbiAgc3RhdGljIGltcGxlbWVudHNTY2hlZHVsZWQoZW5naW5lKSB7XHJcbiAgICByZXR1cm4gKGVuZ2luZS5hZHZhbmNlVGltZSAmJiBlbmdpbmUuYWR2YW5jZVRpbWUgaW5zdGFuY2VvZiBGdW5jdGlvbik7XHJcbiAgfVxyXG5cclxuICByZXNldFRpbWUodGltZSA9IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHRoaXMubWFzdGVyKVxyXG4gICAgICB0aGlzLm1hc3Rlci5yZXNldEVuZ2luZVRpbWUodGhpcywgdGltZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc3BvcnRlZCBpbnRlcmZhY2VcclxuICAgKiAgIC0gc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCksIGNhbGxlZCB0byByZXBvc2l0aW9uIFRpbWVFbmdpbmUsIHJldHVybnMgbmV4dCBwb3NpdGlvblxyXG4gICAqICAgLSBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSwgY2FsbGVkIHRvIGdlbmVyYXRlIG5leHQgZXZlbnQgYXQgZ2l2ZW4gdGltZSBhbmQgcG9zaXRpb24sIHJldHVybnMgbmV4dCBwb3NpdGlvblxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXHJcbiAgICovXHJcbiAgc3RhdGljIGltcGxlbWVudHNUcmFuc3BvcnRlZChlbmdpbmUpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIGVuZ2luZS5zeW5jUG9zaXRpb24gJiYgZW5naW5lLnN5bmNQb3NpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmXHJcbiAgICAgIGVuZ2luZS5hZHZhbmNlUG9zaXRpb24gJiYgZW5naW5lLmFkdmFuY2VQb3NpdGlvbiBpbnN0YW5jZW9mIEZ1bmN0aW9uXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbiA9IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHRoaXMubWFzdGVyKVxyXG4gICAgICB0aGlzLm1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNwZWVkLWNvbnRyb2xsZWQgaW50ZXJmYWNlXHJcbiAgICogICAtIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsICksIGNhbGxlZCB0b1xyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBtZW1iZXJvZiBUaW1lRW5naW5lXHJcbiAgICovXHJcbiAgc3RhdGljIGltcGxlbWVudHNTcGVlZENvbnRyb2xsZWQoZW5naW5lKSB7XHJcbiAgICByZXR1cm4gKGVuZ2luZS5zeW5jU3BlZWQgJiYgZW5naW5lLnN5bmNTcGVlZCBpbnN0YW5jZW9mIEZ1bmN0aW9uKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRpbWVFbmdpbmU7XHJcbiIsImltcG9ydCBBdWRpb1RpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS9hdWRpby10aW1lLWVuZ2luZSc7XHJcblxyXG5mdW5jdGlvbiBvcHRPckRlZihvcHQsIGRlZikge1xyXG4gIGlmIChvcHQgIT09IHVuZGVmaW5lZClcclxuICAgIHJldHVybiBvcHQ7XHJcblxyXG4gIHJldHVybiBkZWY7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR3JhbnVsYXIgc3ludGhlc2lzIFRpbWVFbmdpbmUgaW1wbGVtZW50aW5nIHRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlLlxyXG4gKiBUaGUgZ3JhaW4gcG9zaXRpb24gKGdyYWluIG9uc2V0IG9yIGNlbnRlciB0aW1lIGluIHRoZSBhdWRpbyBidWZmZXIpIGlzXHJcbiAqIG9wdGlvbmFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgZW5naW5lJ3MgY3VycmVudFBvc2l0aW9uIGF0dHJpYnV0ZS5cclxuICpcclxuICogRXhhbXBsZSB0aGF0IHNob3dzIGEgYEdyYW51bGFyRW5naW5lYCAod2l0aCBhIGZldyBwYXJhbWV0ZXIgY29udHJvbHMpIGRyaXZlblxyXG4gKiBieSBhIGBTY2hlZHVsZXJgIGFuZCBhIGBQbGF5Q29udHJvbGA6XHJcbiAqIHtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvZ3JhbnVsYXItZW5naW5lLmh0bWx9XHJcbiAqXHJcbiAqIEBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XHJcbiAqIGNvbnN0IHNjaGVkdWxlciA9IGF1ZGlvLmdldFNjaGVkdWxlcigpO1xyXG4gKiBjb25zdCBncmFudWxhckVuZ2luZSA9IG5ldyBhdWRpby5HcmFudWxhckVuZ2luZSgpO1xyXG4gKlxyXG4gKiBzY2hlZHVsZXIuYWRkKGdyYW51bGFyRW5naW5lKTtcclxuICpcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnM9e30gLSBQYXJhbWV0ZXJzXHJcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IFtvcHRpb25zLmJ1ZmZlcj1udWxsXSAtIEF1ZGlvIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kQWJzPTAuMDFdIC0gQWJzb2x1dGUgZ3JhaW4gcGVyaW9kIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kUmVsPTBdIC0gR3JhaW4gcGVyaW9kIHJlbGF0aXZlIHRvIGFic29sdXRlXHJcbiAqICBkdXJhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kVmFyPTBdIC0gQW1vdXQgb2YgcmFuZG9tIGdyYWluIHBlcmlvZFxyXG4gKiAgdmFyaWF0aW9uIHJlbGF0aXZlIHRvIGdyYWluIHBlcmlvZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kTWluPTAuMDAxXSAtIE1pbmltdW0gZ3JhaW4gcGVyaW9kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wb3NpdGlvbj0wXSAtIEdyYWluIHBvc2l0aW9uIChvbnNldCB0aW1lIGluIGF1ZGlvXHJcbiAqICBidWZmZXIpIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zaXRpb25WYXI9MC4wMDNdIC0gQW1vdXQgb2YgcmFuZG9tIGdyYWluIHBvc2l0aW9uXHJcbiAqICB2YXJpYXRpb24gaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbkFicz0wLjFdIC0gQWJzb2x1dGUgZ3JhaW4gZHVyYXRpb24gaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvblJlbD0wXSAtIEdyYWluIGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdyYWluXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvblZhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBkdXJhdGlvblxyXG4gKiAgcGVyaW9kIChvdmVybGFwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYXR0YWNrQWJzPTBdIC0gQWJzb2x1dGUgYXR0YWNrIHRpbWUgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5hdHRhY2tSZWw9MC41XSAtIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIGdyYWluIGR1cmF0aW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5hdHRhY2tTaGFwZT0nbGluJ10gLSBTaGFwZSBvZiBhdHRhY2tcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VBYnM9MF0gLSBBYnNvbHV0ZSByZWxlYXNlIHRpbWUgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZWxlYXNlUmVsPTAuNV0gLSBSZWxlYXNlIHRpbWUgcmVsYXRpdmUgdG8gZ3JhaW4gZHVyYXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VTaGFwZT0nbGluJ10gLSBTaGFwZSBvZiByZWxlYXNlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5leHBSYW1wT2Zmc2V0PTAuMDAwMV0gLSBPZmZzZXQgKHN0YXJ0L2VuZCB2YWx1ZSlcclxuICogIGZvciBleHBvbmVudGlhbCBhdHRhY2svcmVsZWFzZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzYW1wbGluZz0wXSAtIEdyYWluIHJlc2FtcGxpbmcgaW4gY2VudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVzYW1wbGluZ1Zhcj0wXSAtIEFtb3V0IG9mIHJhbmRvbSByZXNhbXBsaW5nIHZhcmlhdGlvbiBpbiBjZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5nYWluPTFdIC0gTGluZWFyIGdhaW4gZmFjdG9yXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2VudGVyZWQ9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBncmFpbiBwb3NpdGlvbiByZWZlcnNcclxuICogIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGdyYWluIChvciB0aGUgYmVnaW5uaW5nKVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmN5Y2xpYz1mYWxzZV0gLSBXaGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgYW5kIGdyYWluXHJcbiAqICBwb3NpdGlvbiBhcmUgY29uc2lkZXJlZCBhcyBjeWNsaWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb249MF0gLSBQb3J0aW9uIGF0IHRoZSBlbmQgb2YgdGhlXHJcbiAqICBhdWRpbyBidWZmZXIgdGhhdCBoYXMgYmVlbiBjb3BpZWQgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIGFzc3VyZSBjeWNsaWMgYmVoYXZpb3JcclxuICovXHJcbmNsYXNzIEdyYW51bGFyRW5naW5lIGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG9wdGlvbnMuYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1ZGlvIGJ1ZmZlclxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtBdWRpb0J1ZmZlcn1cclxuICAgICAqIEBuYW1lIGJ1ZmZlclxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5idWZmZXIgPSBvcHRPckRlZihvcHRpb25zLmJ1ZmZlciwgbnVsbCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBncmFpbiBwZXJpb2QgaW4gc2VjXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHBlcmlvZEFic1xyXG4gICAgICogQGRlZmF1bHQgMC4wMVxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RBYnMgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZEFicywgMC4wMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmFpbiBwZXJpb2QgcmVsYXRpdmUgdG8gYWJzb2x1dGUgZHVyYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcGVyaW9kUmVsXHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZFJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kUmVsLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBwZXJpb2QgdmFyaWF0aW9uIHJlbGF0aXZlIHRvIGdyYWluIHBlcmlvZFxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBwZXJpb2RWYXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGVyaW9kVmFyID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RWYXIsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWluaW11bSBncmFpbiBwZXJpb2RcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcGVyaW9kTWluXHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwMVxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RNaW4gPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZE1pbiwgMC4wMDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR3JhaW4gcG9zaXRpb24gKG9uc2V0IHRpbWUgaW4gYXVkaW8gYnVmZmVyKSBpbiBzZWNcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcG9zaXRpb25cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zaXRpb24gPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBwb3NpdGlvbiB2YXJpYXRpb24gaW4gc2VjXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHBvc2l0aW9uVmFyXHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwM1xyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3NpdGlvblZhciA9IG9wdE9yRGVmKG9wdGlvbnMucG9zaXRpb25WYXIsIDAuMDAzKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIGdyYWluIGR1cmF0aW9uIGluIHNlY1xyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBkdXJhdGlvbkFic1xyXG4gICAgICogQGRlZmF1bHQgMC4xXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmR1cmF0aW9uQWJzID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvbkFicywgMC4xKTsgLy8gYWJzb2x1dGUgZ3JhaW4gZHVyYXRpb25cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdyYWluIGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdyYWluIHBlcmlvZCAob3ZlcmxhcClcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgZHVyYXRpb25SZWxcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHVyYXRpb25SZWwgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uUmVsLCAwKTtcclxuICAgIFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFtb3V0IG9mIHJhbmRvbSBncmFpbiBkdXJhdGlvbiB2YXJpYXRpb24gaW4gc2VjXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBuYW1lIGR1cmF0aW9uVmFyXHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZHVyYXRpb25WYXIgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIGF0dGFjayB0aW1lIGluIHNlY1xyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBhdHRhY2tBYnNcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXR0YWNrQWJzID0gb3B0T3JEZWYob3B0aW9ucy5hdHRhY2tBYnMsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXR0YWNrIHRpbWUgcmVsYXRpdmUgdG8gZ3JhaW4gZHVyYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgYXR0YWNrUmVsXHJcbiAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXR0YWNrUmVsID0gb3B0T3JEZWYob3B0aW9ucy5hdHRhY2tSZWwsIDAuNSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaGFwZSBvZiBhdHRhY2sgKCdsaW4nIGZvciBsaW5lYXIgcmFtcCwgJ2V4cCcgZm9yIGV4cG9uZW50aWFsIHJhbXApXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBuYW1lIGF0dGFja1NoYXBlXHJcbiAgICAgKiBAZGVmYXVsdCAnbGluJ1xyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdHRhY2tTaGFwZSA9IG9wdE9yRGVmKG9wdGlvbnMuYXR0YWNrU2hhcGUsICdsaW4nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIHJlbGVhc2UgdGltZSBpbiBzZWNcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcmVsZWFzZUFic1xyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWxlYXNlQWJzID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlQWJzLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBncmFpbiBkdXJhdGlvblxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSByZWxlYXNlUmVsXHJcbiAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZVJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucmVsZWFzZVJlbCwgMC41KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNoYXBlIG9mIHJlbGVhc2UgKCdsaW4nIGZvciBsaW5lYXIgcmFtcCwgJ2V4cCcgZm9yIGV4cG9uZW50aWFsIHJhbXApXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBuYW1lIHJlbGVhc2VTaGFwZVxyXG4gICAgICogQGRlZmF1bHQgJ2xpbidcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZVNoYXBlID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlU2hhcGUsICdsaW4nKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9mZnNldCAoc3RhcnQvZW5kIHZhbHVlKSBmb3IgZXhwb25lbnRpYWwgYXR0YWNrL3JlbGVhc2VcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgZXhwUmFtcE9mZnNldFxyXG4gICAgICogQGRlZmF1bHQgMC4wMDAxXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmV4cFJhbXBPZmZzZXQgPSBvcHRPckRlZihvcHRpb25zLmV4cFJhbXBPZmZzZXQsIDAuMDAwMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmFpbiByZXNhbXBsaW5nIGluIGNlbnRcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcmVzYW1wbGluZ1xyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNhbXBsaW5nID0gb3B0T3JEZWYob3B0aW9ucy5yZXNhbXBsaW5nLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSByZXNhbXBsaW5nIHZhcmlhdGlvbiBpbiBjZW50XHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHJlc2FtcGxpbmdWYXJcclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzYW1wbGluZ1ZhciA9IG9wdE9yRGVmKG9wdGlvbnMucmVzYW1wbGluZ1ZhciwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lYXIgZ2FpbiBmYWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgZ2FpblxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5nYWluID0gb3B0T3JEZWYob3B0aW9ucy5nYWluLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGdyYWluIHBvc2l0aW9uIHJlZmVycyB0byB0aGUgY2VudGVyIG9mIHRoZSBncmFpbiAob3IgdGhlIGJlZ2lubmluZylcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBuYW1lIGNlbnRlcmVkXHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAbWVtYmVyb2YgR3JhbnVsYXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNlbnRlcmVkID0gb3B0T3JEZWYob3B0aW9ucy5jZW50ZXJlZCwgdHJ1ZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgYW5kIGdyYWluIHBvc2l0aW9uIGFyZSBjb25zaWRlcmVkIGFzIGN5Y2xpY1xyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQG5hbWUgY3ljbGljXHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5jeWNsaWMgPSBvcHRPckRlZihvcHRpb25zLmN5Y2xpYywgZmFsc2UpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUG9ydGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBhdWRpbyBidWZmZXIgdGhhdCBoYXMgYmVlbiBjb3BpZWQgZnJvbSB0aGVcclxuICAgICAqIGJlZ2lubmluZyB0byBhc3N1cmUgY3ljbGljIGJlaGF2aW9yXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIHdyYXBBcm91bmRFeHRlbnNpb25cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbiA9IG9wdE9yRGVmKG9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiwgMCk7XHJcblxyXG4gICAgdGhpcy5vdXRwdXROb2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IGJ1ZmZlciBkdXJhdGlvbiAoZXhjbHVkaW5nIHdyYXBBcm91bmRFeHRlbnNpb24pXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGJ1ZmZlckR1cmF0aW9uXHJcbiAgICogQG1lbWJlcm9mIEdyYW51bGFyRW5naW5lXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGJ1ZmZlckR1cmF0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XHJcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xyXG5cclxuICAgICAgaWYgKHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbilcclxuICAgICAgICBidWZmZXJEdXJhdGlvbiAtPSB0aGlzLndyYXBBcm91bmRFeHRlbnNpb247XHJcblxyXG4gICAgICByZXR1cm4gYnVmZmVyRHVyYXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDdXJyZW50IHBvc2l0aW9uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGN1cnJlbnRQb3NpdGlvblxyXG4gICAqIEBtZW1iZXJvZiBHcmFudWxhckVuZ2luZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICB2YXIgbWFzdGVyID0gdGhpcy5tYXN0ZXI7XHJcblxyXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgYWR2YW5jZVRpbWUodGltZSkge1xyXG4gICAgdGltZSA9IE1hdGgubWF4KHRpbWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKTtcclxuICAgIHJldHVybiB0aW1lICsgdGhpcy50cmlnZ2VyKHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJpZ2dlciBhIGdyYWluLiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgYXQgYW55IHRpbWUgKHdoZXRoZXIgdGhlXHJcbiAgICogZW5naW5lIGlzIHNjaGVkdWxlZCBvciBub3QpIHRvIGdlbmVyYXRlIGEgc2luZ2xlIGdyYWluIGFjY29yZGluZyB0byB0aGVcclxuICAgKiBjdXJyZW50IGdyYWluIHBhcmFtZXRlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIGdyYWluIHN5bnRoZXNpcyBhdWRpbyB0aW1lXHJcbiAgICogQHJldHVybiB7TnVtYmVyfSAtIHBlcmlvZCB0byBuZXh0IGdyYWluXHJcbiAgICovXHJcbiAgdHJpZ2dlcih0aW1lKSB7XHJcbiAgICB2YXIgYXVkaW9Db250ZXh0ID0gdGhpcy5hdWRpb0NvbnRleHQ7XHJcbiAgICB2YXIgZ3JhaW5UaW1lID0gdGltZSB8fCBhdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XHJcbiAgICB2YXIgZ3JhaW5QZXJpb2QgPSB0aGlzLnBlcmlvZEFicztcclxuICAgIHZhciBncmFpblBvc2l0aW9uID0gdGhpcy5jdXJyZW50UG9zaXRpb247XHJcbiAgICB2YXIgZ3JhaW5EdXJhdGlvbiA9IHRoaXMuZHVyYXRpb25BYnM7XHJcblxyXG4gICAgaWYgKHRoaXMuYnVmZmVyKSB7XHJcbiAgICAgIHZhciByZXNhbXBsaW5nUmF0ZSA9IDEuMDtcclxuXHJcbiAgICAgIC8vIGNhbGN1bGF0ZSByZXNhbXBsaW5nXHJcbiAgICAgIGlmICh0aGlzLnJlc2FtcGxpbmcgIT09IDAgfHwgdGhpcy5yZXNhbXBsaW5nVmFyID4gMCkge1xyXG4gICAgICAgIHZhciByYW5kb21SZXNhbXBsaW5nID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMi4wICogdGhpcy5yZXNhbXBsaW5nVmFyO1xyXG4gICAgICAgIHJlc2FtcGxpbmdSYXRlID0gTWF0aC5wb3coMi4wLCAodGhpcy5yZXNhbXBsaW5nICsgcmFuZG9tUmVzYW1wbGluZykgLyAxMjAwLjApO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyByYW5kb21pemUgZ3JhaW4gZHVyYXRpb25cclxuICAgICAgaWYgKHRoaXMuZHVyYXRpb25WYXIgPiAwKSBncmFpbkR1cmF0aW9uICs9ICgyLjAgKiBNYXRoLnJhbmRvbSgpIC0gMSkgKiB0aGlzLmR1cmF0aW9uVmFyO1xyXG5cclxuICAgICAgZ3JhaW5QZXJpb2QgKz0gdGhpcy5wZXJpb2RSZWwgKiBncmFpbkR1cmF0aW9uO1xyXG4gICAgICBncmFpbkR1cmF0aW9uICs9IHRoaXMuZHVyYXRpb25SZWwgKiBncmFpblBlcmlvZDtcclxuXHJcbiAgICAgIC8vIGdyYWluIHBlcmlvZCByYW5kb24gdmFyaWF0aW9uXHJcbiAgICAgIGlmICh0aGlzLnBlcmlvZFZhciA+IDAuMClcclxuICAgICAgICBncmFpblBlcmlvZCArPSAyLjAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLnBlcmlvZFZhciAqIGdyYWluUGVyaW9kO1xyXG5cclxuICAgICAgLy8gY2VudGVyIGdyYWluXHJcbiAgICAgIGlmICh0aGlzLmNlbnRlcmVkKVxyXG4gICAgICAgIGdyYWluUG9zaXRpb24gLT0gMC41ICogZ3JhaW5EdXJhdGlvbjtcclxuXHJcbiAgICAgIC8vIHJhbmRvbWl6ZSBncmFpbiBwb3NpdGlvblxyXG4gICAgICBpZiAodGhpcy5wb3NpdGlvblZhciA+IDApXHJcbiAgICAgICAgZ3JhaW5Qb3NpdGlvbiArPSAoMi4wICogTWF0aC5yYW5kb20oKSAtIDEpICogdGhpcy5wb3NpdGlvblZhcjtcclxuXHJcbiAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAvLyB3cmFwIG9yIGNsaXAgZ3JhaW4gcG9zaXRpb24gYW5kIGR1cmF0aW9uIGludG8gYnVmZmVyIGR1cmF0aW9uXHJcbiAgICAgIGlmIChncmFpblBvc2l0aW9uIDwgMCB8fCBncmFpblBvc2l0aW9uID49IGJ1ZmZlckR1cmF0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3ljbGljKSB7XHJcbiAgICAgICAgICB2YXIgY3ljbGVzID0gZ3JhaW5Qb3NpdGlvbiAvIGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICAgICAgZ3JhaW5Qb3NpdGlvbiA9IChjeWNsZXMgLSBNYXRoLmZsb29yKGN5Y2xlcykpICogYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAgICAgaWYgKGdyYWluUG9zaXRpb24gKyBncmFpbkR1cmF0aW9uID4gdGhpcy5idWZmZXIuZHVyYXRpb24pXHJcbiAgICAgICAgICAgIGdyYWluRHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIGdyYWluUG9zaXRpb247XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChncmFpblBvc2l0aW9uIDwgMCkge1xyXG4gICAgICAgICAgICBncmFpblRpbWUgLT0gZ3JhaW5Qb3NpdGlvbjtcclxuICAgICAgICAgICAgZ3JhaW5EdXJhdGlvbiArPSBncmFpblBvc2l0aW9uO1xyXG4gICAgICAgICAgICBncmFpblBvc2l0aW9uID0gMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoZ3JhaW5Qb3NpdGlvbiArIGdyYWluRHVyYXRpb24gPiBidWZmZXJEdXJhdGlvbilcclxuICAgICAgICAgICAgZ3JhaW5EdXJhdGlvbiA9IGJ1ZmZlckR1cmF0aW9uIC0gZ3JhaW5Qb3NpdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIG1ha2UgZ3JhaW5cclxuICAgICAgaWYgKHRoaXMuZ2FpbiA+IDAgJiYgZ3JhaW5EdXJhdGlvbiA+PSAwLjAwMSkge1xyXG4gICAgICAgIC8vIG1ha2UgZ3JhaW4gZW52ZWxvcGVcclxuICAgICAgICB2YXIgZW52ZWxvcGUgPSBhdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgICAgIHZhciBhdHRhY2sgPSB0aGlzLmF0dGFja0FicyArIHRoaXMuYXR0YWNrUmVsICogZ3JhaW5EdXJhdGlvbjtcclxuICAgICAgICB2YXIgcmVsZWFzZSA9IHRoaXMucmVsZWFzZUFicyArIHRoaXMucmVsZWFzZVJlbCAqIGdyYWluRHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmIChhdHRhY2sgKyByZWxlYXNlID4gZ3JhaW5EdXJhdGlvbikge1xyXG4gICAgICAgICAgdmFyIGZhY3RvciA9IGdyYWluRHVyYXRpb24gLyAoYXR0YWNrICsgcmVsZWFzZSk7XHJcbiAgICAgICAgICBhdHRhY2sgKj0gZmFjdG9yO1xyXG4gICAgICAgICAgcmVsZWFzZSAqPSBmYWN0b3I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgYXR0YWNrRW5kVGltZSA9IGdyYWluVGltZSArIGF0dGFjaztcclxuICAgICAgICB2YXIgZ3JhaW5FbmRUaW1lID0gZ3JhaW5UaW1lICsgZ3JhaW5EdXJhdGlvbiAvIHJlc2FtcGxpbmdSYXRlO1xyXG4gICAgICAgIHZhciByZWxlYXNlU3RhcnRUaW1lID0gZ3JhaW5FbmRUaW1lIC0gcmVsZWFzZTtcclxuXHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi52YWx1ZSA9IDA7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmF0dGFja1NoYXBlID09PSAnbGluJykge1xyXG4gICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLjAsIGdyYWluVGltZSk7XHJcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5leHBSYW1wT2Zmc2V0LCBncmFpblRpbWUpO1xyXG4gICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5leHBvbmVudGlhbFJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmVsZWFzZVN0YXJ0VGltZSA+IGF0dGFja0VuZFRpbWUpXHJcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgcmVsZWFzZVN0YXJ0VGltZSk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnJlbGVhc2VTaGFwZSA9PT0gJ2xpbicpIHtcclxuICAgICAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMC4wLCBncmFpbkVuZFRpbWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBlbnZlbG9wZS5nYWluLmV4cG9uZW50aWFsUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5leHBSYW1wT2Zmc2V0LCBncmFpbkVuZFRpbWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZW52ZWxvcGUuY29ubmVjdCh0aGlzLm91dHB1dE5vZGUpO1xyXG5cclxuICAgICAgICAvLyBtYWtlIHNvdXJjZVxyXG4gICAgICAgIHZhciBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcblxyXG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICBzb3VyY2UucGxheWJhY2tSYXRlLnZhbHVlID0gcmVzYW1wbGluZ1JhdGU7XHJcbiAgICAgICAgc291cmNlLmNvbm5lY3QoZW52ZWxvcGUpO1xyXG5cclxuICAgICAgICBzb3VyY2Uuc3RhcnQoZ3JhaW5UaW1lLCBncmFpblBvc2l0aW9uKTtcclxuICAgICAgICBzb3VyY2Uuc3RvcChncmFpbkVuZFRpbWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucGVyaW9kTWluLCBncmFpblBlcmlvZCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBHcmFudWxhckVuZ2luZTtcclxuIiwiaW1wb3J0IEF1ZGlvVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcclxuXHJcbmZ1bmN0aW9uIG9wdE9yRGVmKG9wdCwgZGVmKSB7XHJcbiAgaWYob3B0ICE9PSB1bmRlZmluZWQpXHJcbiAgICByZXR1cm4gb3B0O1xyXG5cclxuICByZXR1cm4gZGVmO1xyXG59XHJcblxyXG4vKipcclxuICogTWV0cm9ub21lIGF1ZGlvIGVuZ2luZS4gSXQgZXh0ZW5kcyBUaW1lIEVuZ2luZSBhcyBhIHRyYW5zcG9ydGVkIGludGVyZmFjZS5cclxuICogW2V4YW1wbGVde0BsaW5rIGh0dHBzOi8vcmF3Z2l0LmNvbS93YXZlc2pzL3dhdmVzLWF1ZGlvL21hc3Rlci9leGFtcGxlcy9tZXRyb25vbWUuaHRtbH1cclxuICpcclxuICogQGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XHJcbiAqIGNvbnN0IG1ldHJvbm9tZSA9IG5ldyBhdWRpby5NZXRyb25vbWUoe3BlcmlvZDogMC4zMzN9KTtcclxuICpcclxuICogc2NoZWR1bGVyLmFkZChtZXRyb25vbWUpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gRGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2Q9MV0gLSBNZXRyb25vbWUgcGVyaW9kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jbGlja0ZyZXE9NjAwXSAtIE1ldHJvbm9tZSBjbGljayBmcmVxdWVuY3lcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNsaWNrQXR0YWNrPTAuMDAyXSAtIE1ldHJvbm9tZSBjbGljayBhdHRhY2sgdGltZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY2xpY2tSZWxlYXNlPTAuMDk4XSAtIE1ldHJvbm9tZSBjbGljayByZWxlYXNlIHRpbWVcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmdhaW49MV0gLSBHYWluXHJcbiAqL1xyXG5jbGFzcyBNZXRyb25vbWUgZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIob3B0aW9ucy5hdWRpb0NvbnRleHQpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0cm9ub21lIHBlcmlvZFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuX19wZXJpb2QgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZCwgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRyb25vbWUgY2xpY2sgZnJlcXVlbmN5XHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBtZW1iZXJvZiBNZXRyb25vbWVcclxuICAgICAqIEBuYW1lIGNsaWNrRnJlcVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY2xpY2tGcmVxID0gb3B0T3JEZWYob3B0aW9ucy5jbGlja0ZyZXEsIDYwMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRyb25vbWUgY2xpY2sgYXR0YWNrIHRpbWVcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxyXG4gICAgICogQG5hbWUgY2xpY2tBdHRhY2tcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaWNrQXR0YWNrID0gb3B0T3JEZWYob3B0aW9ucy5jbGlja0F0dGFjaywgMC4wMDIpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWV0cm9ub21lIGNsaWNrIHJlbGVhc2UgdGltZVxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbWVtYmVyb2YgTWV0cm9ub21lXHJcbiAgICAgKiBAbmFtZSBjbGlja1JlbGVhc2VcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmNsaWNrUmVsZWFzZSA9IG9wdE9yRGVmKG9wdGlvbnMuY2xpY2tSZWxlYXNlLCAwLjA5OCk7XHJcblxyXG4gICAgdGhpcy5fX2xhc3RUaW1lID0gMDtcclxuICAgIHRoaXMuX19waGFzZSA9IDA7XHJcblxyXG4gICAgdGhpcy5fX2dhaW5Ob2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG4gICAgdGhpcy5fX2dhaW5Ob2RlLmdhaW4udmFsdWUgPSBvcHRPckRlZihvcHRpb25zLmdhaW4sIDEpO1xyXG5cclxuICAgIHRoaXMub3V0cHV0Tm9kZSA9IHRoaXMuX19nYWluTm9kZTtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kIChzY2hlZHVsZWQgaW50ZXJmYWNlKVxyXG4gIGFkdmFuY2VUaW1lKHRpbWUpIHtcclxuICAgIHRoaXMudHJpZ2dlcih0aW1lKTtcclxuICAgIHRoaXMuX19sYXN0VGltZSA9IHRpbWU7XHJcbiAgICByZXR1cm4gdGltZSArIHRoaXMuX19wZXJpb2Q7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAodHJhbnNwb3J0ZWQgaW50ZXJmYWNlKVxyXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGlmICh0aGlzLl9fcGVyaW9kID4gMCkge1xyXG4gICAgICB2YXIgbmV4dFBvc2l0aW9uID0gKE1hdGguZmxvb3IocG9zaXRpb24gLyB0aGlzLl9fcGVyaW9kKSArIHRoaXMuX19waGFzZSkgKiB0aGlzLl9fcGVyaW9kO1xyXG5cclxuICAgICAgaWYgKHNwZWVkID4gMCAmJiBuZXh0UG9zaXRpb24gPCBwb3NpdGlvbilcclxuICAgICAgICBuZXh0UG9zaXRpb24gKz0gdGhpcy5fX3BlcmlvZDtcclxuICAgICAgZWxzZSBpZiAoc3BlZWQgPCAwICYmIG5leHRQb3NpdGlvbiA+IHBvc2l0aW9uKVxyXG4gICAgICAgIG5leHRQb3NpdGlvbiAtPSB0aGlzLl9fcGVyaW9kO1xyXG5cclxuICAgICAgcmV0dXJuIG5leHRQb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gSW5maW5pdHkgKiBzcGVlZDtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXHJcbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdGhpcy50cmlnZ2VyKHRpbWUpO1xyXG5cclxuICAgIGlmIChzcGVlZCA8IDApXHJcbiAgICAgIHJldHVybiBwb3NpdGlvbiAtIHRoaXMuX19wZXJpb2Q7XHJcblxyXG4gICAgcmV0dXJuIHBvc2l0aW9uICsgdGhpcy5fX3BlcmlvZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXIgbWV0cm9ub21lIGNsaWNrXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgbWV0cm9ub21lIGNsaWNrIHN5bnRoZXNpcyBhdWRpbyB0aW1lXHJcbiAgICovXHJcbiAgdHJpZ2dlcih0aW1lKSB7XHJcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcclxuICAgIGNvbnN0IGNsaWNrQXR0YWNrID0gdGhpcy5jbGlja0F0dGFjaztcclxuICAgIGNvbnN0IGNsaWNrUmVsZWFzZSA9IHRoaXMuY2xpY2tSZWxlYXNlO1xyXG5cclxuICAgIGNvbnN0IGVudiA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICBlbnYuZ2Fpbi52YWx1ZSA9IDAuMDtcclxuICAgIGVudi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRpbWUpO1xyXG4gICAgZW52LmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMS4wLCB0aW1lICsgY2xpY2tBdHRhY2spO1xyXG4gICAgZW52LmdhaW4uZXhwb25lbnRpYWxSYW1wVG9WYWx1ZUF0VGltZSgwLjAwMDAwMDEsIHRpbWUgKyBjbGlja0F0dGFjayArIGNsaWNrUmVsZWFzZSk7XHJcbiAgICBlbnYuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcclxuICAgIGVudi5jb25uZWN0KHRoaXMub3V0cHV0Tm9kZSk7XHJcblxyXG4gICAgY29uc3Qgb3NjID0gYXVkaW9Db250ZXh0LmNyZWF0ZU9zY2lsbGF0b3IoKTtcclxuICAgIG9zYy5mcmVxdWVuY3kudmFsdWUgPSB0aGlzLmNsaWNrRnJlcTtcclxuICAgIG9zYy5zdGFydCh0aW1lKTtcclxuICAgIG9zYy5zdG9wKHRpbWUgKyBjbGlja0F0dGFjayArIGNsaWNrUmVsZWFzZSk7XHJcbiAgICBvc2MuY29ubmVjdChlbnYpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogbGluZWFyIGdhaW4gZmFjdG9yXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIGdhaW5cclxuICAgKiBAbWVtYmVyb2YgTWV0cm9ub21lXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcbiAgc2V0IGdhaW4odmFsdWUpIHtcclxuICAgIHRoaXMuX19nYWluTm9kZS5nYWluLnZhbHVlID0gdmFsdWU7XHJcbiAgfVxyXG5cclxuICBnZXQgZ2FpbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fZ2Fpbk5vZGUuZ2Fpbi52YWx1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIG1ldHJvbm9tZSBwZXJpb2RcclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG5hbWUgcGVyaW9kXHJcbiAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBwZXJpb2QocGVyaW9kKSB7XHJcbiAgICB0aGlzLl9fcGVyaW9kID0gcGVyaW9kO1xyXG5cclxuICAgIGNvbnN0IG1hc3RlciA9IHRoaXMubWFzdGVyO1xyXG5cclxuICAgIGlmIChtYXN0ZXIpIHtcclxuICAgICAgaWYgKG1hc3Rlci5yZXNldEVuZ2luZVRpbWUpXHJcbiAgICAgICAgbWFzdGVyLnJlc2V0RW5naW5lVGltZSh0aGlzLCB0aGlzLl9fbGFzdFRpbWUgKyBwZXJpb2QpO1xyXG4gICAgICBlbHNlIGlmIChtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbilcclxuICAgICAgICBtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbih0aGlzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBwZXJpb2QoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3BlcmlvZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBwaGFzZSBwYXJhbWV0ZXIgKGF2YWlsYWJsZSBvbmx5IHdoZW4gJ3RyYW5zcG9ydGVkJyksIHNob3VsZCBiZVxyXG4gICAqIGJldHdlZW4gWzAsIDFbXHJcbiAgICpcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBuYW1lIHBoYXNlXHJcbiAgICogQG1lbWJlcm9mIE1ldHJvbm9tZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBwaGFzZShwaGFzZSkge1xyXG4gICAgdGhpcy5fX3BoYXNlID0gcGhhc2UgLSBNYXRoLmZsb29yKHBoYXNlKTtcclxuXHJcbiAgICBjb25zdCBtYXN0ZXIgPSB0aGlzLm1hc3RlcjtcclxuXHJcbiAgICBpZiAobWFzdGVyICYmIG1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIG1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHBoYXNlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19waGFzZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1ldHJvbm9tZTtcclxuIiwiaW1wb3J0IEF1ZGlvVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcclxuaW1wb3J0IFBWIGZyb20gJy4uL3V0aWxzL2J1ZmZlcmVkLXB2JztcclxuLy9pbXBvcnQgUFYgZnJvbSAnLi4vdXRpbHMvc2ltcGxlLXB2JztcclxuXHJcblxyXG5mdW5jdGlvbiBvcHRPckRlZihvcHQsIGRlZikge1xyXG4gIGlmIChvcHQgIT09IHVuZGVmaW5lZClcclxuICAgIHJldHVybiBvcHQ7XHJcblxyXG4gIHJldHVybiBkZWY7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEN1cnJlbnRPclByZXZpb3VzSW5kZXgoc29ydGVkQXJyYXksIHZhbHVlLCBpbmRleCA9IC0xKSB7XHJcbiAgdmFyIHNpemUgPSBzb3J0ZWRBcnJheS5sZW5ndGg7XHJcblxyXG4gIGlmIChzaXplID4gMCkge1xyXG4gICAgdmFyIGZpcnN0VmFsID0gc29ydGVkQXJyYXlbMF07XHJcbiAgICB2YXIgbGFzdFZhbCA9IHNvcnRlZEFycmF5W3NpemUgLSAxXTtcclxuXHJcbiAgICBpZiAodmFsdWUgPCBmaXJzdFZhbClcclxuICAgICAgaW5kZXggPSAtMTtcclxuICAgIGVsc2UgaWYgKHZhbHVlID49IGxhc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gc2l6ZSAtIDE7XHJcbiAgICBlbHNlIHtcclxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKVxyXG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoc2l6ZSAtIDEpICogKHZhbHVlIC0gZmlyc3RWYWwpIC8gKGxhc3RWYWwgLSBmaXJzdFZhbCkpO1xyXG5cclxuICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4XSA+IHZhbHVlKVxyXG4gICAgICAgIGluZGV4LS07XHJcblxyXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXggKyAxXSA8PSB2YWx1ZSlcclxuICAgICAgICBpbmRleCsrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGluZGV4O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDdXJyZW50T3JOZXh0SW5kZXgoc29ydGVkQXJyYXksIHZhbHVlLCBpbmRleCA9IC0xKSB7XHJcbiAgdmFyIHNpemUgPSBzb3J0ZWRBcnJheS5sZW5ndGg7XHJcblxyXG4gIGlmIChzaXplID4gMCkge1xyXG4gICAgdmFyIGZpcnN0VmFsID0gc29ydGVkQXJyYXlbMF07XHJcbiAgICB2YXIgbGFzdFZhbCA9IHNvcnRlZEFycmF5W3NpemUgLSAxXTtcclxuXHJcbiAgICBpZiAodmFsdWUgPD0gZmlyc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gMDtcclxuICAgIGVsc2UgaWYgKHZhbHVlID49IGxhc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gc2l6ZTtcclxuICAgIGVsc2Uge1xyXG4gICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNpemUpXHJcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChzaXplIC0gMSkgKiAodmFsdWUgLSBmaXJzdFZhbCkgLyAobGFzdFZhbCAtIGZpcnN0VmFsKSk7XHJcblxyXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXhdIDwgdmFsdWUpXHJcbiAgICAgICAgaW5kZXgrKztcclxuXHJcbiAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleCAtIDFdID49IHZhbHVlKVxyXG4gICAgICAgIGluZGV4LS07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaW5kZXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VkIHdpdGggYSBidWZmZXIgdG8gc2VydmUgYXVkaW8gZmlsZXMgdmlhIGdyYW51bGFyIHN5bnRoZXNpcy5cclxuICpcclxuICogVGhlIGVuZ2luZSBpbXBsZW1lbnRzIHRoZSBcInNjaGVkdWxlZFwiIGFuZCBcInRyYW5zcG9ydGVkXCIgaW50ZXJmYWNlcy5cclxuICogV2hlbiBcInNjaGVkdWxlZFwiLCB0aGUgZW5naW5lICBnZW5lcmF0ZXMgc2VnbWVudHMgbW9yZSBvciBsZXNzwqBwZXJpb2RpY2FsbHlcclxuICogKGNvbnRyb2xsZWQgYnkgdGhlIHBlcmlvZEFicywgcGVyaW9kUmVsLCBhbmQgcGVyaW9WYXIgYXR0cmlidXRlcykuXHJcbiAqIFdoZW4gXCJ0cmFuc3BvcnRlZFwiLCB0aGUgZW5naW5lIGdlbmVyYXRlcyBzZWdtZW50cyBhdCB0aGUgcG9zaXRpb24gb2YgdGhlaXIgb25zZXQgdGltZS5cclxuICpcclxuICogRXhhbXBsZSB0aGF0IHNob3dzIGEgYFBoYXNldm9jb2RlckVuZ2luZWAgd2l0aCBhIGZldyBwYXJhbWV0ZXIgY29udHJvbHMgcnVubmluZyBpbiBhIGBTY2hlZHVsZXJgLlxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3BoYXNldm9jb2Rlci1lbmdpbmUuaHRtbH1cclxuICpcclxuICogQGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XHJcbiAqIGNvbnN0IFBoYXNldm9jb2RlckVuZ2luZSA9IG5ldyBhdWRpby5QaGFzZXZvY29kZXJFbmdpbmUoKTtcclxuICpcclxuICogc2NoZWR1bGVyLmFkZChQaGFzZXZvY29kZXJFbmdpbmUpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gRGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IFtvcHRpb25zLmJ1ZmZlcj1udWxsXSAtIEF1ZGlvIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kQWJzPTBdIC0gQWJzb2x1dGUgc2VnbWVudCBwZXJpb2QgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RSZWw9MV0gLSBTZWdtZW50IHBlcmlvZCByZWxhdGl2ZSB0byBpbnRlci1zZWdtZW50IGRpc3RhbmNlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RWYXI9MF0gLSBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwZXJpb2QgdmFyaWF0aW9uIHJlbGF0aXZlXHJcbiAqICB0byBzZWdtZW50IHBlcmlvZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kTWluPTAuMDAxXSAtIE1pbmltdW0gc2VnbWVudCBwZXJpb2RcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvc2l0aW9uQXJyYXk9WzAuMF1dIC0gQXJyYXkgb2Ygc2VnbWVudCBwb3NpdGlvbnMgKG9uc2V0IHRpbWVzXHJcbiAqICBpbiBhdWRpbyBidWZmZXIpIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zaXRpb25WYXI9MF0gLSBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwb3NpdGlvbiB2YXJpYXRpb24gaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbkFycmF5PVswLjBdXSAtIEFycmF5IG9mIHNlZ21lbnQgZHVyYXRpb25zIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25BYnM9MF0gLSBBYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25SZWw9MV0gLSBTZWdtZW50IGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdpdmVuIHNlZ21lbnRcclxuICogIGR1cmF0aW9uIG9yIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMub2Zmc2V0QXJyYXk9WzAuMF1dIC0gQXJyYXkgb2Ygc2VnbWVudCBvZmZzZXRzIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0QWJzPS0wLjAwNV0gLSBBYnNvbHV0ZSBzZWdtZW50IG9mZnNldCBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFJlbD0wXSAtIFNlZ21lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlbGF5PTAuMDA1XSAtIFRpbWUgYnkgd2hpY2ggYWxsIHNlZ21lbnRzIGFyZSBkZWxheWVkIChlc3BlY2lhbGx5XHJcbiAqICB0byByZWFsaXplIHNlZ21lbnQgb2Zmc2V0cylcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF0dGFja0Ficz0wLjAwNV0gLSBBYnNvbHV0ZSBhdHRhY2sgdGltZSBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF0dGFja1JlbD0wXSAtIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VBYnM9MC4wMDVdIC0gQWJzb2x1dGUgcmVsZWFzZSB0aW1lIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVsZWFzZVJlbD0wXSAtIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNhbXBsaW5nPTBdIC0gU2VnbWVudCByZXNhbXBsaW5nIGluIGNlbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc2FtcGxpbmdWYXI9MF0gLSBBbW91dCBvZiByYW5kb20gcmVzYW1wbGluZyB2YXJpYXRpb24gaW4gY2VudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ2Fpbj0xXSAtIExpbmVhciBnYWluIGZhY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYWJvcnRUaW1lPTAuMDA1XSAtIGZhZGUtb3V0IHRpbWUgd2hlbiBhYm9ydGVkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zZWdtZW50SW5kZXg9MF0gLSBJbmRleCBvZiB0aGUgc2VnbWVudCB0byBzeW50aGVzaXplIChpLmUuIG9mXHJcbiAqICB0aGlzLnBvc2l0aW9uQXJyYXkvZHVyYXRpb25BcnJheS9vZmZzZXRBcnJheSlcclxuICogQHBhcmFtIHtCb29sfSBbb3B0aW9ucy5jeWNsaWM9ZmFsc2VdIC0gV2hldGhlciB0aGUgYXVkaW8gYnVmZmVyIGFuZCBzZWdtZW50IGluZGljZXMgYXJlXHJcbiAqICBjb25zaWRlcmVkIGFzIGN5Y2xpY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbj0wXSAtIFBvcnRpb24gYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gYnVmZmVyXHJcbiAqICB0aGF0IGhhcyBiZWVuIGNvcGllZCBmcm9tIHRoZSBiZWdpbm5pbmcgdG8gYXNzdXJlIGN5Y2xpYyBiZWhhdmlvclxyXG4gKi9cclxuY2xhc3MgUGhhc2V2b2NvZGVyRW5naW5lIGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG9wdGlvbnMuYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF1ZGlvIGJ1ZmZlclxyXG4gICAgICogQG5hbWUgYnVmZmVyXHJcbiAgICAgKiBAdHlwZSB7QXVkaW9CdWZmZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5idWZmZXIgPSBvcHRPckRlZihvcHRpb25zLmJ1ZmZlciwgbnVsbCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBzZWdtZW50IHBlcmlvZCBpbiBzZWNcclxuICAgICAqIEBuYW1lIHBlcmlvZEFic1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZEFicyA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kQWJzLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZ21lbnQgcGVyaW9kIHJlbGF0aXZlIHRvIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICAgICAqIEBuYW1lIHBlcmlvZFJlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZFJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kUmVsLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBlcmlvZCB2YXJpYXRpb24gcmVsYXRpdmUgdG8gc2VnbWVudCBwZXJpb2RcclxuICAgICAqIEBuYW1lIHBlcmlvZFZhclxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZFZhciA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1pbmltdW0gc2VnbWVudCBwZXJpb2RcclxuICAgICAqIEBuYW1lIHBlcmlvZE1pblxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDAxXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RNaW4gPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZE1pbiwgMC4wMDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2Ygc2VnbWVudCBwb3NpdGlvbnMgKG9uc2V0IHRpbWVzIGluIGF1ZGlvIGJ1ZmZlcikgaW4gc2VjXHJcbiAgICAgKiBAbmFtZSBwb3NpdGlvbkFycmF5XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgWzAuMF1cclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBvc2l0aW9uQXJyYXkgPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uQXJyYXksIFswLjBdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFtb3V0IG9mIHJhbmRvbSBzZWdtZW50IHBvc2l0aW9uIHZhcmlhdGlvbiBpbiBzZWNcclxuICAgICAqIEBuYW1lIHBvc2l0aW9uVmFyXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucG9zaXRpb25WYXIgPSBvcHRPckRlZihvcHRpb25zLnBvc2l0aW9uVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHNlZ21lbnQgZHVyYXRpb25zIGluIHNlY1xyXG4gICAgICogQG5hbWUgZHVyYXRpb25BcnJheVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IFswLjBdXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kdXJhdGlvbkFycmF5ID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvbkFycmF5LCBbMC4wXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uIGluIHNlY1xyXG4gICAgICogQG5hbWUgZHVyYXRpb25BYnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kdXJhdGlvbkFicyA9IG9wdE9yRGVmKG9wdGlvbnMuZHVyYXRpb25BYnMsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VnbWVudCBkdXJhdGlvbiByZWxhdGl2ZSB0byBnaXZlbiBzZWdtZW50IGR1cmF0aW9uIG9yIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICAgICAqIEBuYW1lIGR1cmF0aW9uUmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHVyYXRpb25SZWwgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uUmVsLCAxKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFycmF5IG9mIHNlZ21lbnQgb2Zmc2V0cyBpbiBzZWNcclxuICAgICAqXHJcbiAgICAgKiBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICogb2Zmc2V0IDwgMDogdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb24gaXMgdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb25cclxuICAgICAqIGFuZCB0aGUgZHVyYXRpb24gaGFzIHRvIGJlIGNvcnJlY3RlZCBieSB0aGUgb2Zmc2V0XHJcbiAgICAgKlxyXG4gICAgICogQG5hbWUgb2Zmc2V0QXJyYXlcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqIEBkZWZhdWx0IFswLjBdXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5vZmZzZXRBcnJheSA9IG9wdE9yRGVmKG9wdGlvbnMub2Zmc2V0QXJyYXksIFswLjBdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIHNlZ21lbnQgb2Zmc2V0IGluIHNlY1xyXG4gICAgICogQG5hbWUgb2Zmc2V0QWJzXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgLTAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5vZmZzZXRBYnMgPSBvcHRPckRlZihvcHRpb25zLm9mZnNldEFicywgMC4wMDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VnbWVudCBvZmZzZXQgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICogQG5hbWUgb2Zmc2V0UmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMub2Zmc2V0UmVsID0gb3B0T3JEZWYob3B0aW9ucy5vZmZzZXRSZWwsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGltZSBieSB3aGljaCBhbGwgc2VnbWVudHMgYXJlIGRlbGF5ZWQgKGVzcGVjaWFsbHkgdG8gcmVhbGl6ZSBzZWdtZW50IG9mZnNldHMpXHJcbiAgICAgKiBAbmFtZSBkZWxheVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kZWxheSA9IG9wdE9yRGVmKG9wdGlvbnMuZGVsYXksIDAuMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBhdHRhY2sgdGltZSBpbiBzZWNcclxuICAgICAqIEBuYW1lIGF0dGFja0Fic1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdHRhY2tBYnMgPSBvcHRPckRlZihvcHRpb25zLmF0dGFja0FicywgMC4wKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAqIEBuYW1lIGF0dGFja1JlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmF0dGFja1JlbCA9IG9wdE9yRGVmKG9wdGlvbnMuYXR0YWNrUmVsLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIHJlbGVhc2UgdGltZSBpbiBzZWNcclxuICAgICAqIEBuYW1lIHJlbGVhc2VBYnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZUFicyA9IG9wdE9yRGVmKG9wdGlvbnMucmVsZWFzZUFicywgMC4wKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXHJcbiAgICAgKiBAbmFtZSByZWxlYXNlUmVsXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVsZWFzZVJlbCA9IG9wdE9yRGVmKG9wdGlvbnMucmVsZWFzZVJlbCwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWdtZW50IHJlc2FtcGxpbmcgaW4gY2VudFxyXG4gICAgICogQG5hbWUgcmVzYW1wbGluZ1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc2FtcGxpbmcgPSBvcHRPckRlZihvcHRpb25zLnJlc2FtcGxpbmcsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW1vdXQgb2YgcmFuZG9tIHJlc2FtcGxpbmcgdmFyaWF0aW9uIGluIGNlbnRcclxuICAgICAqIEBuYW1lIHJlc2FtcGxpbmdWYXJcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZXNhbXBsaW5nVmFyID0gb3B0T3JEZWYob3B0aW9ucy5yZXNhbXBsaW5nVmFyLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpbmVhciBnYWluIGZhY3RvclxyXG4gICAgICogQG5hbWUgZ2FpblxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmdhaW4gPSBvcHRPckRlZihvcHRpb25zLmdhaW4sIDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSW5kZXggb2YgdGhlIHNlZ21lbnQgdG8gc3ludGhlc2l6ZSAoaS5lLiBvZiB0aGlzLnBvc2l0aW9uQXJyYXkvZHVyYXRpb25BcnJheS9vZmZzZXRBcnJheSlcclxuICAgICAqIEBuYW1lIHNlZ21lbnRJbmRleFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IG9wdE9yRGVmKG9wdGlvbnMuc2VnbWVudEluZGV4LCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGF1ZGlvIGJ1ZmZlciBhbmQgc2VnbWVudCBpbmRpY2VzIGFyZSBjb25zaWRlcmVkIGFzIGN5Y2xpY1xyXG4gICAgICogQG5hbWUgY3ljbGljXHJcbiAgICAgKiBAdHlwZSB7Qm9vbH1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5jeWNsaWMgPSBvcHRPckRlZihvcHRpb25zLmN5Y2xpYywgZmFsc2UpO1xyXG4gICAgdGhpcy5fX2N5Y2xpY09mZnNldCA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBsYXN0IHNlZ21lbnQgaXMgYWJvcnRlZCB3aGVuIHRyaWdnZXJpbmcgdGhlIG5leHRcclxuICAgICAqIEBuYW1lIG1vbm9waG9uaWNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubW9ub3Bob25pYyA9IG9wdE9yRGVmKG9wdGlvbnMubW9ub3Bob25pYywgZmFsc2UpO1xyXG4gICAgdGhpcy5fX2N1cnJlbnRTcmMgPSBudWxsO1xyXG4gICAgdGhpcy5fX2N1cnJlbnRFbnYgPSBudWxsO1xyXG4gICAgdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUgPSAwO1xyXG4gICAgdGhpcy5fX2N1cnJlbnRHYWluID0gMDtcclxuICAgIHRoaXMuX19jdXJyZW50RW5kVGltZSA9IDA7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGYWRlLW91dCB0aW1lICh3aGVuIGFib3J0ZWQpXHJcbiAgICAgKiBAbmFtZSBhYm9ydFRpbWVcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwLjAwNVxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWJvcnRUaW1lID0gb3B0T3JEZWYob3B0aW9ucy5hYm9ydFRpbWUsIDAuMDA1KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvcnRpb24gYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gYnVmZmVyIHRoYXQgaGFzIGJlZW4gY29waWVkIGZyb20gdGhlIGJlZ2lubmluZyB0byBhc3N1cmUgY3ljbGljIGJlaGF2aW9yXHJcbiAgICAgKiBAbmFtZSB3cmFwQXJvdW5kRXh0ZW5zaW9uXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbiA9IG9wdE9yRGVmKG9wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbiwgMCk7XHJcblxyXG4gICAgdGhpcy5vdXRwdXROb2RlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xyXG5cclxuICAgLyoqXHJcbiAgICogT3B0aW9uYWxseSBzZXQgZnVuY3Rpb24gdG8gdXNlIGZvciBGRlQgdHJhbnNmb3JtXHJcbiAgICogQG5hbWUgc2V0U1RGVFxyXG4gICAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gICAgdGhpcy5zZXRTVEZUID0gZnVuY3Rpb24gKF9TVEZUKSB7IHRoaXMuX3B2LlNURlQgPSBfU1RGVCB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBPcHRpb25hbGx5IHNldCBmdW5jdGlvbiB0byB1c2UgZm9yIGludmVyc2UgRkZUIHRyYW5zZm9ybVxyXG4gICAgKiBAbmFtZSBzZXRTVEZUXHJcbiAgICAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgKiBAbWVtYmVyb2YgUGhhc2V2b2NvZGVyRW5naW5lXHJcbiAgICAqIEBpbnN0YW5jZVxyXG4gICAgKi9cclxuICAgIHRoaXMuc2V0SVNURlQgPSBmdW5jdGlvbihfSVNURlQpIHt0aGlzLl9wdi5JU1RGVCA9IF9JU1RGVH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaXplIG9mIHBoYXNldm9jb2RlciBhbmFseXNpcyBmcmFtZVxyXG4gICAgICogQG5hbWUgZnJhbWVTaXplXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgNDA5NlxyXG4gICAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZnJhbWVTaXplID0gb3B0T3JEZWYob3B0aW9ucy5mcmFtZVNpemUsIDIwNDgpO1xyXG5cclxuXHJcbiAgICAvLyBTZXR1cCB2b2NvZGVyXHJcbiAgICB0aGlzLl9wdiA9IG5ldyBQVih0aGlzLmZyYW1lU2l6ZSk7IC8vIG5ldyBCdWZmZXJlZFBWKHRoaXMuZnJhbWVTaXplKTtcclxuICAgIHRoaXMuX3B2LnNldF9hdWRpb19idWZmZXIodGhpcy5idWZmZXIpO1xyXG4gICAgdGhpcy5fcHYuYWxwaGEgPSAyO1xyXG5cclxuICAgIC8vIEZJWE1FOiBCVUZGRVJfU0laRSBub3QgaW4gdXNlIHlldC4uLlxyXG4gICAgLy8gVGhpbmtpbmcgdGhhdCBpZiB1c2VyIGRvbnQgcHJvdmlkZSBzZWdtZW50cyAoaWUgbWFya2VyYnVmZmVyKSwgXHJcbiAgICAvLyB0aGVuIHRoZSBlbmdpbmUganVzdCBjaG9wcyB0aGUgYnVmZmVyIGludG8gY2h1bmtzIHdoaXRoIHRoaXMgc2l6ZS5cclxuICAgIHRoaXMuQlVGRkVSX1NJWkUgPSA0MDk2O1xyXG4gICAgICAgIFxyXG4gICAvKipcclxuICAgKiBUaGUgYW1vdW50IHRvIHN0cmV0Y2ggdGhlIGF1ZGlvIHNlZ21lbnRzIHdpdGhcclxuICAgKiBAbmFtZSBzdHJldGNoRmFjdG9yXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAZGVmYXVsdCAxXHJcbiAgICogQG1lbWJlcm9mIFBoYXNldm9jb2RlckVuZ2luZVxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gICAgdGhpcy5zdHJldGNoRmFjdG9yID0gb3B0T3JEZWYob3B0aW9ucy5zdHJldGNoRmFjdG9yLCAxKTtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYnVmZmVyIGR1cmF0aW9uIChleGNsdWRpbmcgd3JhcEFyb3VuZEV4dGVuc2lvbilcclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQGRlZmF1bHQgMFxyXG4gICAqIEBtZW1iZXJvZiBQaGFzZXZvY29kZXJFbmdpbmVcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKi9cclxuICBnZXQgYnVmZmVyRHVyYXRpb24oKSB7XHJcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcclxuICAgICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXIuZHVyYXRpb247XHJcblxyXG4gICAgICBpZiAodGhpcy53cmFwQXJvdW5kRXh0ZW5zaW9uKVxyXG4gICAgICAgIGJ1ZmZlckR1cmF0aW9uIC09IHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbjtcclxuXHJcbiAgICAgIHJldHVybiBidWZmZXJEdXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXHJcbiAgYWR2YW5jZVRpbWUodGltZSkge1xyXG4gICAgdGltZSA9IE1hdGgubWF4KHRpbWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKTtcclxuICAgIHJldHVybiB0aW1lICsgdGhpcy50cmlnZ2VyKHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHRyYW5zcG9ydGVkIGludGVyZmFjZSlcclxuICBzeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLnNlZ21lbnRJbmRleDtcclxuICAgIHZhciBjeWNsaWNPZmZzZXQgPSAwO1xyXG4gICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICBpZiAodGhpcy5jeWNsaWMpIHtcclxuICAgICAgdmFyIGN5Y2xlcyA9IHBvc2l0aW9uIC8gYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICBjeWNsaWNPZmZzZXQgPSBNYXRoLmZsb29yKGN5Y2xlcykgKiBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgcG9zaXRpb24gLT0gY3ljbGljT2Zmc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzcGVlZCA+IDApIHtcclxuICAgICAgaW5kZXggPSBnZXRDdXJyZW50T3JOZXh0SW5kZXgodGhpcy5wb3NpdGlvbkFycmF5LCBwb3NpdGlvbik7XHJcblxyXG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICBjeWNsaWNPZmZzZXQgKz0gYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jeWNsaWMpXHJcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoc3BlZWQgPCAwKSB7XHJcbiAgICAgIGluZGV4ID0gZ2V0Q3VycmVudE9yUHJldmlvdXNJbmRleCh0aGlzLnBvc2l0aW9uQXJyYXksIHBvc2l0aW9uKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICBpbmRleCA9IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxO1xyXG4gICAgICAgIGN5Y2xpY09mZnNldCAtPSBidWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcclxuICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IGluZGV4O1xyXG4gICAgdGhpcy5fX2N5Y2xpY09mZnNldCA9IGN5Y2xpY09mZnNldDtcclxuXHJcbiAgICByZXR1cm4gY3ljbGljT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbkFycmF5W2luZGV4XTtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXHJcbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5zZWdtZW50SW5kZXg7XHJcbiAgICB2YXIgY3ljbGljT2Zmc2V0ID0gdGhpcy5fX2N5Y2xpY09mZnNldDtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGltZSk7XHJcblxyXG4gICAgaWYgKHNwZWVkID4gMCkge1xyXG4gICAgICBpbmRleCsrO1xyXG5cclxuICAgICAgaWYgKGluZGV4ID49IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGgpIHtcclxuICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgY3ljbGljT2Zmc2V0ICs9IHRoaXMuYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jeWNsaWMpXHJcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGluZGV4LS07XHJcblxyXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgaW5kZXggPSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoIC0gMTtcclxuICAgICAgICBjeWNsaWNPZmZzZXQgLT0gdGhpcy5idWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcclxuICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IGluZGV4O1xyXG4gICAgdGhpcy5fX2N5Y2xpY09mZnNldCA9IGN5Y2xpY09mZnNldDtcclxuXHJcbiAgICByZXR1cm4gY3ljbGljT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbkFycmF5W2luZGV4XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXIgYSBzZWdtZW50LlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCBhdCBhbnkgdGltZSAod2hldGhlciB0aGUgZW5naW5lIGlzIHNjaGVkdWxlZC90cmFuc3BvcnRlZCBvciBub3QpXHJcbiAgICogdG8gZ2VuZXJhdGUgYSBzaW5nbGUgc2VnbWVudCBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc2VnbWVudCBwYXJhbWV0ZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgc2VnbWVudCBzeW50aGVzaXMgYXVkaW8gdGltZVxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gcGVyaW9kIHRvIG5leHQgc2VnbWVudFxyXG4gICAqL1xyXG4gIHRyaWdnZXIodGltZSkge1xyXG4gICAgdmFyIGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xyXG4gICAgdmFyIHNlZ21lbnRUaW1lID0gKHRpbWUgfHwgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKSArIHRoaXMuZGVsYXk7XHJcbiAgICB2YXIgc2VnbWVudFBlcmlvZCA9IHRoaXMucGVyaW9kQWJzO1xyXG4gICAgdmFyIHNlZ21lbnRJbmRleCA9IHRoaXMuc2VnbWVudEluZGV4O1xyXG5cclxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xyXG4gICAgICB2YXIgc2VnbWVudFBvc2l0aW9uID0gMC4wO1xyXG4gICAgICB2YXIgc2VnbWVudER1cmF0aW9uID0gMC4wO1xyXG4gICAgICB2YXIgc2VnbWVudE9mZnNldCA9IDAuMDtcclxuICAgICAgdmFyIHJlc2FtcGxpbmdSYXRlID0gMS4wO1xyXG4gICAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgICAgaWYgKHRoaXMuY3ljbGljKVxyXG4gICAgICAgIHNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleCAlIHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGg7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBzZWdtZW50SW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWdtZW50SW5kZXgsIHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxKSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5wb3NpdGlvbkFycmF5KVxyXG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XHJcblxyXG4gICAgICBpZiAodGhpcy5kdXJhdGlvbkFycmF5KVxyXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiA9IHRoaXMuZHVyYXRpb25BcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XHJcblxyXG4gICAgICBpZiAodGhpcy5vZmZzZXRBcnJheSlcclxuICAgICAgICBzZWdtZW50T2Zmc2V0ID0gdGhpcy5vZmZzZXRBcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XHJcblxyXG4gICAgICAvLyBjYWxjdWxhdGUgcmVzYW1wbGluZ1xyXG4gICAgICBpZiAodGhpcy5yZXNhbXBsaW5nICE9PSAwIHx8IHRoaXMucmVzYW1wbGluZ1ZhciA+IDApIHtcclxuICAgICAgICB2YXIgcmFuZG9tUmVzYW1wbGluZyA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIuMCAqIHRoaXMucmVzYW1wbGluZ1ZhcjtcclxuICAgICAgICByZXNhbXBsaW5nUmF0ZSA9IE1hdGgucG93KDIuMCwgKHRoaXMucmVzYW1wbGluZyArIHJhbmRvbVJlc2FtcGxpbmcpIC8gMTIwMC4wKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY2FsY3VsYXRlIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICAgICAgaWYgKHNlZ21lbnREdXJhdGlvbiA9PT0gMCB8fCB0aGlzLnBlcmlvZFJlbCA+IDApIHtcclxuICAgICAgICB2YXIgbmV4dFNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleCArIDE7XHJcbiAgICAgICAgdmFyIG5leHRQb3NpdGlvbiwgbmV4dE9mZnNldDtcclxuXHJcbiAgICAgICAgaWYgKG5leHRTZWdtZW50SW5kZXggPT09IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgIGlmICh0aGlzLmN5Y2xpYykge1xyXG4gICAgICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uQXJyYXlbMF0gKyBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgICAgICAgbmV4dE9mZnNldCA9IHRoaXMub2Zmc2V0QXJyYXlbMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgICAgICAgbmV4dE9mZnNldCA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVtuZXh0U2VnbWVudEluZGV4XTtcclxuICAgICAgICAgIG5leHRPZmZzZXQgPSB0aGlzLm9mZnNldEFycmF5W25leHRTZWdtZW50SW5kZXhdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGludGVyU2VnbWVudERpc3RhbmNlID0gbmV4dFBvc2l0aW9uIC0gc2VnbWVudFBvc2l0aW9uO1xyXG5cclxuICAgICAgICAvLyBjb3JyZWN0IGludGVyLXNlZ21lbnQgZGlzdGFuY2UgYnkgb2Zmc2V0c1xyXG4gICAgICAgIC8vICAgb2Zmc2V0ID4gMDogdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gaXMgYWZ0ZXIgdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb25cclxuICAgICAgICBpZiAoc2VnbWVudE9mZnNldCA+IDApXHJcbiAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSAtPSBzZWdtZW50T2Zmc2V0O1xyXG5cclxuICAgICAgICBpZiAobmV4dE9mZnNldCA+IDApXHJcbiAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSArPSBuZXh0T2Zmc2V0O1xyXG5cclxuICAgICAgICBpZiAoaW50ZXJTZWdtZW50RGlzdGFuY2UgPCAwKVxyXG4gICAgICAgICAgaW50ZXJTZWdtZW50RGlzdGFuY2UgPSAwO1xyXG5cclxuICAgICAgICAvLyB1c2UgaW50ZXItc2VnbWVudCBkaXN0YW5jZSBpbnN0ZWFkIG9mIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAgICBpZiAoc2VnbWVudER1cmF0aW9uID09PSAwKVxyXG4gICAgICAgICAgc2VnbWVudER1cmF0aW9uID0gaW50ZXJTZWdtZW50RGlzdGFuY2U7XHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBwZXJpb2QgcmVsYXRpdmUgdG8gaW50ZXIgbWFya2VyIGRpc3RhbmNlXHJcbiAgICAgICAgc2VnbWVudFBlcmlvZCArPSB0aGlzLnBlcmlvZFJlbCAqIGludGVyU2VnbWVudERpc3RhbmNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhZGQgcmVsYXRpdmUgYW5kIGFic29sdXRlIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAgc2VnbWVudER1cmF0aW9uICo9IHRoaXMuZHVyYXRpb25SZWw7XHJcbiAgICAgIHNlZ21lbnREdXJhdGlvbiArPSB0aGlzLmR1cmF0aW9uQWJzO1xyXG5cclxuICAgICAgLy8gYWRkIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBzZWdtZW50IG9mZnNldFxyXG4gICAgICBzZWdtZW50T2Zmc2V0ICo9IHRoaXMub2Zmc2V0UmVsO1xyXG4gICAgICBzZWdtZW50T2Zmc2V0ICs9IHRoaXMub2Zmc2V0QWJzO1xyXG5cclxuICAgICAgLy8gYXBwbHkgc2VnbWVudCBvZmZzZXRcclxuICAgICAgLy8gICBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICAvLyAgIG9mZnNldCA8IDA6IHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uIGlzIHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGFuZCB0aGUgZHVyYXRpb24gaGFzIHRvIGJlIGNvcnJlY3RlZCBieSB0aGUgb2Zmc2V0XHJcbiAgICAgIGlmIChzZWdtZW50T2Zmc2V0IDwgMCkge1xyXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiAtPSBzZWdtZW50T2Zmc2V0O1xyXG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiArPSBzZWdtZW50T2Zmc2V0O1xyXG4gICAgICAgIHNlZ21lbnRUaW1lICs9IChzZWdtZW50T2Zmc2V0IC8gcmVzYW1wbGluZ1JhdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlZ21lbnRUaW1lIC09IChzZWdtZW50T2Zmc2V0IC8gcmVzYW1wbGluZ1JhdGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByYW5kb21pemUgc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICBpZiAodGhpcy5wb3NpdGlvblZhciA+IDApXHJcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uICs9IDIuMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRoaXMucG9zaXRpb25WYXI7XHJcblxyXG4gICAgICAvLyBzaG9ydGVuIGR1cmF0aW9uIG9mIHNlZ21lbnRzIG92ZXIgdGhlIGVkZ2VzIG9mIHRoZSBidWZmZXJcclxuICAgICAgaWYgKHNlZ21lbnRQb3NpdGlvbiA8IDApIHtcclxuICAgICAgICAvL3NlZ21lbnRUaW1lIC09IGdyYWluUG9zaXRpb247IGhtLCBub3Qgc3VyZSBpZiB3ZSB3YW50IHRvIGRvIHRoaXNcclxuICAgICAgICBzZWdtZW50RHVyYXRpb24gKz0gc2VnbWVudFBvc2l0aW9uO1xyXG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZWdtZW50UG9zaXRpb24gKyBzZWdtZW50RHVyYXRpb24gPiB0aGlzLmJ1ZmZlci5kdXJhdGlvbilcclxuICAgICAgICBzZWdtZW50RHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIHNlZ21lbnRQb3NpdGlvbjtcclxuXHJcbiAgICAgIHNlZ21lbnREdXJhdGlvbiAvPSByZXNhbXBsaW5nUmF0ZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1vbm9waG9uaWMpXHJcbiAgICAgICAgdGhpcy5hYm9ydChzZWdtZW50VGltZSk7XHJcblxyXG4gICAgICAvLyBtYWtlIHNlZ21lbnRcclxuICAgICAgaWYgKHRoaXMuZ2FpbiA+IDAgJiYgc2VnbWVudER1cmF0aW9uID4gMCkge1xyXG4gICAgICAgIC8vIG1ha2Ugc2VnbWVudCBlbnZlbG9wZVxyXG4gICAgICAgIHZhciBlbnZlbG9wZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdmFyIGF0dGFjayA9IHRoaXMuYXR0YWNrQWJzICsgdGhpcy5hdHRhY2tSZWwgKiBzZWdtZW50RHVyYXRpb247XHJcbiAgICAgICAgdmFyIHJlbGVhc2UgPSB0aGlzLnJlbGVhc2VBYnMgKyB0aGlzLnJlbGVhc2VSZWwgKiBzZWdtZW50RHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmIChhdHRhY2sgKyByZWxlYXNlID4gc2VnbWVudER1cmF0aW9uKSB7XHJcbiAgICAgICAgICB2YXIgZmFjdG9yID0gc2VnbWVudER1cmF0aW9uIC8gKGF0dGFjayArIHJlbGVhc2UpO1xyXG4gICAgICAgICAgYXR0YWNrICo9IGZhY3RvcjtcclxuICAgICAgICAgIHJlbGVhc2UgKj0gZmFjdG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGF0dGFja0VuZFRpbWUgPSBzZWdtZW50VGltZSArIGF0dGFjaztcclxuICAgICAgICB2YXIgc2VnbWVudEVuZFRpbWUgPSBzZWdtZW50VGltZSArIHNlZ21lbnREdXJhdGlvbjtcclxuICAgICAgICB2YXIgcmVsZWFzZVN0YXJ0VGltZSA9IHNlZ21lbnRFbmRUaW1lIC0gcmVsZWFzZTtcclxuXHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi52YWx1ZSA9IDA7XHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLjAsIHNlZ21lbnRUaW1lKTtcclxuICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XHJcblxyXG4gICAgICAgIGlmIChyZWxlYXNlU3RhcnRUaW1lID4gYXR0YWNrRW5kVGltZSlcclxuICAgICAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5nYWluLCByZWxlYXNlU3RhcnRUaW1lKTtcclxuXHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLjAsIHNlZ21lbnRFbmRUaW1lKTtcclxuICAgICAgICBlbnZlbG9wZS5jb25uZWN0KHRoaXMub3V0cHV0Tm9kZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX19jdXJyZW50RW52ID0gZW52ZWxvcGU7XHJcblxyXG4gICAgICAgIC8vIG1ha2Ugc291cmNlXHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuXHJcbiAgICAgICAgLy8gQnVmZmVyIHRvIHNhdmUgdGhlIHN0cmV0Y2ggYXVkaW8gaW50b1xyXG5cclxuICAgICAgICB2YXIgc3RyZXRjaGVkQnVmZmVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigyLCBzZWdtZW50RHVyYXRpb24gKiBhdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSwgYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIHBoYXNldm9jb2RlcidzIHBvc2l0aW9uIGluIHNvdXJjZSBidWZmZXIgKGllIHRoaXMuYnVmZmVyKS5cclxuICAgICAgICB0aGlzLl9wdi5wb3NpdGlvbiA9IHNlZ21lbnRQb3NpdGlvbiAqIGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlOyAgICAgICBcclxuICAgICAgICB0aGlzLl9wdi5wcm9jZXNzKHN0cmV0Y2hlZEJ1ZmZlcik7XHJcbiAgICAgICAgLy8gRklYTUU6IElmIHBoYXNlIGlzIG5vdCByZXNldCwgdGhlIGF1ZGlvIGlzIHNpbGVuY2VkIHdoZW4gbG9vcGVkLi4uIGRvbnQga25vdyB3aHkuLi5cclxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbkFycmF5KSB7XHJcbiAgICAgICAgICBpZiAoc2VnbWVudEluZGV4ID09IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3B2LnJlc2V0UGhhc2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNvdXJjZS5idWZmZXIgPSBzdHJldGNoZWRCdWZmZXI7XHJcbiAgICAgICAgc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHJlc2FtcGxpbmdSYXRlO1xyXG4gICAgICAgIC8vc291cmNlLmNvbm5lY3QoZW52ZWxvcGUpOyAvL0ZJWE1FOiBVc2luZyBlbnZlbG9wZSBjYXVzZXMgXCJ0cmVtb2xvXCIgZXZlbiBpZiBhbGwgcmFtcGluZyBpcyAwLlxyXG4gICAgICAgIHNvdXJjZS5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7IFxyXG5cclxuICAgICAgICBzb3VyY2Uuc3RhcnQoc2VnbWVudFRpbWUpO1xyXG4gICAgICAgIHNvdXJjZS5zdG9wKHNlZ21lbnRUaW1lICsgc2VnbWVudER1cmF0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRTcmMgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUgPSByZWxlYXNlU3RhcnRUaW1lO1xyXG4gICAgICAgIHRoaXMuX19jdXJyZW50R2FpbiA9IHRoaXMuZ2FpbjtcclxuICAgICAgICB0aGlzLl9fY3VycmVudEVuZFRpbWUgPSBzZWdtZW50RW5kVGltZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBncmFpbiBwZXJpb2QgcmFuZG9uIHZhcmlhdGlvblxyXG4gICAgaWYgKHRoaXMucGVyaW9kVmFyID4gMC4wKVxyXG4gICAgICBzZWdtZW50UGVyaW9kICs9IDIuMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRoaXMucGVyaW9kVmFyICogZ3JhaW5QZXJpb2Q7XHJcblxyXG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucGVyaW9kTWluLCBzZWdtZW50UGVyaW9kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFib3J0IHRoZSBjdXJyZW50IHNlZ21lbnQgYXQgZ2l2ZW4gdGltZSwgZmFkZSBvdXQgZHVyYXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gYWJvcnQgdGltZVxyXG4gICAqL1xyXG4gIGFib3J0KHRpbWUpIHtcclxuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xyXG4gICAgY29uc3QgZW5kVGltZSA9IHRoaXMuX19jdXJyZW50RW5kVGltZTtcclxuICAgIGNvbnN0IGFib3J0VGltZSA9IHRpbWUgfHwgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xyXG5cclxuICAgIGlmIChhYm9ydFRpbWUgPCBlbmRUaW1lKSB7XHJcbiAgICAgIGNvbnN0IHNlZ21lbnRFbmRUaW1lID0gTWF0aC5taW4oYWJvcnRUaW1lICsgdGhpcy5hYm9ydFRpbWUsIGVuZFRpbWUpO1xyXG4gICAgICBjb25zdCBlbnZlbG9wZSA9IHRoaXMuX19jdXJyZW50RW52O1xyXG4gICAgICBsZXQgY3VycmVudEdhaW5WYWx1ZSA9IHRoaXMuX19jdXJyZW50R2FpbjtcclxuXHJcbiAgICAgIGlmIChhYm9ydFRpbWUgPiB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZSkge1xyXG4gICAgICAgIGNvbnN0IHJlbGVhc2VTdGFydCA9IHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lO1xyXG4gICAgICAgIGN1cnJlbnRHYWluVmFsdWUgKj0gKGFib3J0VGltZSAtIHJlbGVhc2VTdGFydCkgLyAoZW5kVGltZSAtIHJlbGVhc2VTdGFydCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVudmVsb3BlLmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGFib3J0VGltZSk7XHJcbiAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUoY3VycmVudEdhaW5WYWx1ZSwgYWJvcnRUaW1lKTtcclxuICAgICAgZW52ZWxvcGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCBzZWdtZW50RW5kVGltZSk7XHJcblxyXG4gICAgICB0aGlzLl9fY3VycmVudFNyYyA9IG51bGw7XHJcbiAgICAgIHRoaXMuX19jdXJyZW50RW52ID0gbnVsbDtcclxuICAgICAgdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUgPSAwO1xyXG4gICAgICB0aGlzLl9fY3VycmVudEdhaW4gPSAwO1xyXG4gICAgICB0aGlzLl9fY3VycmVudEVuZFRpbWUgPSAwO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2V0IHN0cmV0Y2hGYWN0b3IgKG5ld0FscGhhKSB7XHJcbiAgICAgIGlmKHRoaXMuX3B2KVxyXG4gICAgICAgIHRoaXMuX3B2LmFscGhhID0gbmV3QWxwaGE7XHJcbiAgfVxyXG5cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGhhc2V2b2NvZGVyRW5naW5lO1xyXG4iLCJpbXBvcnQgQXVkaW9UaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvYXVkaW8tdGltZS1lbmdpbmUnO1xyXG5cclxuZnVuY3Rpb24gb3B0T3JEZWYob3B0LCBkZWYpIHtcclxuICBpZihvcHQgIT09IHVuZGVmaW5lZClcclxuICAgIHJldHVybiBvcHQ7XHJcblxyXG4gIHJldHVybiBkZWY7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VkIHdpdGggYSBidWZmZXIgdG8gc2VydmUgYXVkaW8gZmlsZXMuXHJcbiAqXHJcbiAqIFtleGFtcGxlXXtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvcGxheWVyLWVuZ2luZS5odG1sfVxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBdWRpb1RpbWVFbmdpbmVcclxuICogQGV4YW1wbGVcclxuICogaW1wb3J0ICogYXMgYXVkaW8gZnJvbSAnd2F2ZXMtYXVkaW8nO1xyXG4gKiBjb25zdCBwbGF5ZXJFbmdpbmUgPSBhdWRpby5QbGF5ZXJFbmdpbmUoKTtcclxuICogY29uc3QgcGxheUNvbnRyb2wgPSBuZXcgYXVkaW8uUGxheUNvbnRyb2wocGxheWVyRW5naW5lKTtcclxuICpcclxuICogcGxheUNvbnRyb2wuc3RhcnQoKTtcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIERlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYnVmZmVyPTFdIC0gQXVkaW8gYnVmZmVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mYWRlVGltZT02MDBdIC0gRmFkZSB0aW1lIGZvciBjaGFpbmluZyBzZWdtZW50c1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY3ljbGljPWZhbHNlXSAtIExvb3AgbW9kZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ2Fpbj0xXSAtIEdhaW5cclxuICovXHJcbmNsYXNzIFBsYXllckVuZ2luZSBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZSB7XHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihvcHRpb25zLmF1ZGlvQ29udGV4dCk7XHJcblxyXG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsOyAvLyBzZXQgd2hlbiBhZGRlZCB0byB0cmFuc3BvcnRlclxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXVkaW8gYnVmZmVyXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge0F1ZGlvQnVmZmVyfVxyXG4gICAgICogQG5hbWUgYnVmZmVyXHJcbiAgICAgKiBAbWVtYmVyb2YgUGxheWVyRW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqL1xyXG4gICAgdGhpcy5idWZmZXIgPSBvcHRPckRlZihvcHRpb25zLmJ1ZmZlciwgbnVsbCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGYWRlIHRpbWUgZm9yIGNoYWluaW5nIHNlZ21lbnRzIChlLmcuIGluIHN0YXJ0LCBzdG9wLCBhbmQgc2VlaylcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgZmFkZVRpbWVcclxuICAgICAqIEBtZW1iZXJvZiBQbGF5ZXJFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQGRlZmF1bHQgMC4wMDVcclxuICAgICAqL1xyXG4gICAgdGhpcy5mYWRlVGltZSA9IG9wdE9yRGVmKG9wdGlvbnMuZmFkZVRpbWUsIDAuMDA1KTtcclxuXHJcbiAgICB0aGlzLl9fdGltZSA9IDA7XHJcbiAgICB0aGlzLl9fcG9zaXRpb24gPSAwO1xyXG4gICAgdGhpcy5fX3NwZWVkID0gMDtcclxuXHJcbiAgICB0aGlzLl9fYnVmZmVyU291cmNlID0gbnVsbDtcclxuICAgIHRoaXMuX19lbnZOb2RlID0gbnVsbDtcclxuXHJcbiAgICB0aGlzLl9fZ2Fpbk5vZGUgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICB0aGlzLl9fZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSA9IG9wdE9yRGVmKG9wdGlvbnMuZ2FpbiwgMSk7XHJcblxyXG4gICAgdGhpcy5fX2N5Y2xpYyA9IG9wdE9yRGVmKG9wdGlvbnMuY3ljbGljLCBmYWxzZSk7XHJcblxyXG4gICAgdGhpcy5vdXRwdXROb2RlID0gdGhpcy5fX2dhaW5Ob2RlO1xyXG4gIH1cclxuXHJcbiAgX19zdGFydCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIHZhciBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcclxuXHJcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcclxuICAgICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXIuZHVyYXRpb247XHJcblxyXG4gICAgICBpZiAodGhpcy5fX2N5Y2xpYyAmJiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IGJ1ZmZlckR1cmF0aW9uKSkge1xyXG4gICAgICAgIHZhciBwaGFzZSA9IHBvc2l0aW9uIC8gYnVmZmVyRHVyYXRpb247XHJcbiAgICAgICAgcG9zaXRpb24gPSAocGhhc2UgLSBNYXRoLmZsb29yKHBoYXNlKSkgKiBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBvc2l0aW9uID49IDAgJiYgcG9zaXRpb24gPCBidWZmZXJEdXJhdGlvbiAmJiBzcGVlZCA+IDApIHtcclxuICAgICAgICB0aGlzLl9fZW52Tm9kZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdGhpcy5fX2Vudk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLCB0aW1lKTtcclxuICAgICAgICB0aGlzLl9fZW52Tm9kZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDEsIHRpbWUgKyB0aGlzLmZhZGVUaW1lKTtcclxuICAgICAgICB0aGlzLl9fZW52Tm9kZS5jb25uZWN0KHRoaXMuX19nYWluTm9kZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX19idWZmZXJTb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcclxuICAgICAgICB0aGlzLl9fYnVmZmVyU291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHNwZWVkO1xyXG4gICAgICAgIHRoaXMuX19idWZmZXJTb3VyY2UubG9vcCA9IHRoaXMuX19jeWNsaWM7XHJcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5sb29wU3RhcnQgPSAwO1xyXG4gICAgICAgIHRoaXMuX19idWZmZXJTb3VyY2UubG9vcEVuZCA9IGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX19idWZmZXJTb3VyY2Uuc3RhcnQodGltZSwgcG9zaXRpb24pO1xyXG4gICAgICAgIHRoaXMuX19idWZmZXJTb3VyY2UuY29ubmVjdCh0aGlzLl9fZW52Tm9kZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9faGFsdCh0aW1lKSB7XHJcbiAgICBpZiAodGhpcy5fX2J1ZmZlclNvdXJjZSkge1xyXG4gICAgICB0aGlzLl9fZW52Tm9kZS5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aW1lKTtcclxuICAgICAgdGhpcy5fX2Vudk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh0aGlzLl9fZW52Tm9kZS5nYWluLnZhbHVlLCB0aW1lKTtcclxuICAgICAgdGhpcy5fX2Vudk5vZGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCB0aW1lICsgdGhpcy5mYWRlVGltZSk7XHJcbiAgICAgIHRoaXMuX19idWZmZXJTb3VyY2Uuc3RvcCh0aW1lICsgdGhpcy5mYWRlVGltZSk7XHJcblxyXG4gICAgICB0aGlzLl9fYnVmZmVyU291cmNlID0gbnVsbDtcclxuICAgICAgdGhpcy5fX2Vudk5vZGUgPSBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHNwZWVkLWNvbnRyb2xsZWQgaW50ZXJmYWNlKVxyXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsIHNlZWsgPSBmYWxzZSkge1xyXG4gICAgdmFyIGxhc3RTcGVlZCA9IHRoaXMuX19zcGVlZDtcclxuXHJcbiAgICBpZiAoc3BlZWQgIT09IGxhc3RTcGVlZCB8fCBzZWVrKSB7XHJcbiAgICAgIGlmIChzZWVrIHx8IGxhc3RTcGVlZCAqIHNwZWVkIDwgMCkge1xyXG4gICAgICAgIHRoaXMuX19oYWx0KHRpbWUpO1xyXG4gICAgICAgIHRoaXMuX19zdGFydCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKGxhc3RTcGVlZCA9PT0gMCB8fCBzZWVrKSB7XHJcbiAgICAgICAgdGhpcy5fX3N0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3BlZWQgPT09IDApIHtcclxuICAgICAgICB0aGlzLl9faGFsdCh0aW1lKTtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9fYnVmZmVyU291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5fX2J1ZmZlclNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUoc3BlZWQsIHRpbWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9fc3BlZWQgPSBzcGVlZDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB3aGV0aGVyIHRoZSBhdWRpbyBidWZmZXIgaXMgY29uc2lkZXJlZCBhcyBjeWNsaWNcclxuICAgKiBAdHlwZSB7Qm9vbH1cclxuICAgKiBAbmFtZSBjeWNsaWNcclxuICAgKiBAbWVtYmVyb2YgUGxheWVyRW5naW5lXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcbiAgc2V0IGN5Y2xpYyhjeWNsaWMpIHtcclxuICAgIGlmIChjeWNsaWMgIT09IHRoaXMuX19jeWNsaWMpIHtcclxuICAgICAgdmFyIHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xyXG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmN1cnJlbnRvc2l0aW9uO1xyXG5cclxuICAgICAgdGhpcy5fX2hhbHQodGltZSk7XHJcbiAgICAgIHRoaXMuX19jeWNsaWMgPSBjeWNsaWM7XHJcblxyXG4gICAgICBpZiAodGhpcy5fX3NwZWVkICE9PSAwKVxyXG4gICAgICAgIHRoaXMuX19zdGFydCh0aW1lLCBwb3NpdGlvbiwgdGhpcy5fX3NwZWVkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBjeWNsaWMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2N5Y2xpYztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpbmVhciBnYWluIGZhY3RvclxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG5hbWUgZ2FpblxyXG4gICAqIEBtZW1iZXJvZiBQbGF5ZXJFbmdpbmVcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKi9cclxuICBzZXQgZ2Fpbih2YWx1ZSkge1xyXG4gICAgdmFyIHRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lO1xyXG4gICAgdGhpcy5fX2dhaW5Ob2RlLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyh0aW1lKTtcclxuICAgIHRoaXMuX19nYWluTm9kZS5zZXRWYWx1ZUF0VGltZSh0aGlzLl9fZ2Fpbk5vZGUuZ2Fpbi52YWx1ZSwgdGltZSk7XHJcbiAgICB0aGlzLl9fZ2Fpbk5vZGUubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgdGltZSArIHRoaXMuZmFkZVRpbWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGdhaW4oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2dhaW5Ob2RlLmdhaW4udmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYnVmZmVyIGR1cmF0aW9uXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbmFtZSBidWZmZXJEdXJhdGlvblxyXG4gICAqIEBtZW1iZXJvZiBQbGF5ZXJFbmdpbmVcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgYnVmZmVyRHVyYXRpb24oKSB7XHJcbiAgICBpZih0aGlzLmJ1ZmZlcilcclxuICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmR1cmF0aW9uO1xyXG5cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGxheWVyRW5naW5lO1xyXG4iLCJpbXBvcnQgQXVkaW9UaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvYXVkaW8tdGltZS1lbmdpbmUnO1xyXG5cclxuZnVuY3Rpb24gb3B0T3JEZWYob3B0LCBkZWYpIHtcclxuICBpZiAob3B0ICE9PSB1bmRlZmluZWQpXHJcbiAgICByZXR1cm4gb3B0O1xyXG5cclxuICByZXR1cm4gZGVmO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDdXJyZW50T3JQcmV2aW91c0luZGV4KHNvcnRlZEFycmF5LCB2YWx1ZSwgaW5kZXggPSAtMSkge1xyXG4gIHZhciBzaXplID0gc29ydGVkQXJyYXkubGVuZ3RoO1xyXG5cclxuICBpZiAoc2l6ZSA+IDApIHtcclxuICAgIHZhciBmaXJzdFZhbCA9IHNvcnRlZEFycmF5WzBdO1xyXG4gICAgdmFyIGxhc3RWYWwgPSBzb3J0ZWRBcnJheVtzaXplIC0gMV07XHJcblxyXG4gICAgaWYgKHZhbHVlIDwgZmlyc3RWYWwpXHJcbiAgICAgIGluZGV4ID0gLTE7XHJcbiAgICBlbHNlIGlmICh2YWx1ZSA+PSBsYXN0VmFsKVxyXG4gICAgICBpbmRleCA9IHNpemUgLSAxO1xyXG4gICAgZWxzZSB7XHJcbiAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gc2l6ZSlcclxuICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoKHNpemUgLSAxKSAqICh2YWx1ZSAtIGZpcnN0VmFsKSAvIChsYXN0VmFsIC0gZmlyc3RWYWwpKTtcclxuXHJcbiAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleF0gPiB2YWx1ZSlcclxuICAgICAgICBpbmRleC0tO1xyXG5cclxuICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4ICsgMV0gPD0gdmFsdWUpXHJcbiAgICAgICAgaW5kZXgrKztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBpbmRleDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q3VycmVudE9yTmV4dEluZGV4KHNvcnRlZEFycmF5LCB2YWx1ZSwgaW5kZXggPSAtMSkge1xyXG4gIHZhciBzaXplID0gc29ydGVkQXJyYXkubGVuZ3RoO1xyXG5cclxuICBpZiAoc2l6ZSA+IDApIHtcclxuICAgIHZhciBmaXJzdFZhbCA9IHNvcnRlZEFycmF5WzBdO1xyXG4gICAgdmFyIGxhc3RWYWwgPSBzb3J0ZWRBcnJheVtzaXplIC0gMV07XHJcblxyXG4gICAgaWYgKHZhbHVlIDw9IGZpcnN0VmFsKVxyXG4gICAgICBpbmRleCA9IDA7XHJcbiAgICBlbHNlIGlmICh2YWx1ZSA+PSBsYXN0VmFsKVxyXG4gICAgICBpbmRleCA9IHNpemU7XHJcbiAgICBlbHNlIHtcclxuICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKVxyXG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcigoc2l6ZSAtIDEpICogKHZhbHVlIC0gZmlyc3RWYWwpIC8gKGxhc3RWYWwgLSBmaXJzdFZhbCkpO1xyXG5cclxuICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4XSA8IHZhbHVlKVxyXG4gICAgICAgIGluZGV4Kys7XHJcblxyXG4gICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXggLSAxXSA+PSB2YWx1ZSlcclxuICAgICAgICBpbmRleC0tO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGluZGV4O1xyXG59XHJcblxyXG4vKipcclxuICogVXNlZCB3aXRoIGEgYnVmZmVyIHRvIHNlcnZlIGF1ZGlvIGZpbGVzIHZpYSBncmFudWxhciBzeW50aGVzaXMuXHJcbiAqXHJcbiAqIFRoZSBlbmdpbmUgaW1wbGVtZW50cyB0aGUgXCJzY2hlZHVsZWRcIiBhbmQgXCJ0cmFuc3BvcnRlZFwiIGludGVyZmFjZXMuXHJcbiAqIFdoZW4gXCJzY2hlZHVsZWRcIiwgdGhlIGVuZ2luZSAgZ2VuZXJhdGVzIHNlZ21lbnRzIG1vcmUgb3IgbGVzc8KgcGVyaW9kaWNhbGx5XHJcbiAqIChjb250cm9sbGVkIGJ5IHRoZSBwZXJpb2RBYnMsIHBlcmlvZFJlbCwgYW5kIHBlcmlvVmFyIGF0dHJpYnV0ZXMpLlxyXG4gKiBXaGVuIFwidHJhbnNwb3J0ZWRcIiwgdGhlIGVuZ2luZSBnZW5lcmF0ZXMgc2VnbWVudHMgYXQgdGhlIHBvc2l0aW9uIG9mIHRoZWlyIG9uc2V0IHRpbWUuXHJcbiAqXHJcbiAqIEV4YW1wbGUgdGhhdCBzaG93cyBhIGBTZWdtZW50RW5naW5lYCB3aXRoIGEgZmV3IHBhcmFtZXRlciBjb250cm9scyBydW5uaW5nIGluIGEgYFNjaGVkdWxlcmAuXHJcbiAqIHtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvc2VnbWVudC1lbmdpbmUuaHRtbH1cclxuICpcclxuICogQGV4dGVuZHMgQXVkaW9UaW1lRW5naW5lXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XHJcbiAqIGNvbnN0IHNlZ21lbnRFbmdpbmUgPSBuZXcgYXVkaW8uU2VnbWVudEVuZ2luZSgpO1xyXG4gKlxyXG4gKiBzY2hlZHVsZXIuYWRkKHNlZ21lbnRFbmdpbmUpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gRGVmYXVsdCBvcHRpb25zXHJcbiAqIEBwYXJhbSB7QXVkaW9CdWZmZXJ9IFtvcHRpb25zLmJ1ZmZlcj1udWxsXSAtIEF1ZGlvIGJ1ZmZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kQWJzPTBdIC0gQWJzb2x1dGUgc2VnbWVudCBwZXJpb2QgaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RSZWw9MV0gLSBTZWdtZW50IHBlcmlvZCByZWxhdGl2ZSB0byBpbnRlci1zZWdtZW50IGRpc3RhbmNlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wZXJpb2RWYXI9MF0gLSBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwZXJpb2QgdmFyaWF0aW9uIHJlbGF0aXZlXHJcbiAqICB0byBzZWdtZW50IHBlcmlvZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kTWluPTAuMDAxXSAtIE1pbmltdW0gc2VnbWVudCBwZXJpb2RcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvc2l0aW9uQXJyYXk9WzAuMF1dIC0gQXJyYXkgb2Ygc2VnbWVudCBwb3NpdGlvbnMgKG9uc2V0IHRpbWVzXHJcbiAqICBpbiBhdWRpbyBidWZmZXIpIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucG9zaXRpb25WYXI9MF0gLSBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwb3NpdGlvbiB2YXJpYXRpb24gaW4gc2VjXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5kdXJhdGlvbkFycmF5PVswLjBdXSAtIEFycmF5IG9mIHNlZ21lbnQgZHVyYXRpb25zIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25BYnM9MF0gLSBBYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZHVyYXRpb25SZWw9MV0gLSBTZWdtZW50IGR1cmF0aW9uIHJlbGF0aXZlIHRvIGdpdmVuIHNlZ21lbnRcclxuICogIGR1cmF0aW9uIG9yIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICogQHBhcmFtIHtBcnJheX0gW29wdGlvbnMub2Zmc2V0QXJyYXk9WzAuMF1dIC0gQXJyYXkgb2Ygc2VnbWVudCBvZmZzZXRzIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0QWJzPS0wLjAwNV0gLSBBYnNvbHV0ZSBzZWdtZW50IG9mZnNldCBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm9mZnNldFJlbD0wXSAtIFNlZ21lbnQgb2Zmc2V0IHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmRlbGF5PTAuMDA1XSAtIFRpbWUgYnkgd2hpY2ggYWxsIHNlZ21lbnRzIGFyZSBkZWxheWVkIChlc3BlY2lhbGx5XHJcbiAqICB0byByZWFsaXplIHNlZ21lbnQgb2Zmc2V0cylcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF0dGFja0Ficz0wLjAwNV0gLSBBYnNvbHV0ZSBhdHRhY2sgdGltZSBpbiBzZWNcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmF0dGFja1JlbD0wXSAtIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlbGVhc2VBYnM9MC4wMDVdIC0gQWJzb2x1dGUgcmVsZWFzZSB0aW1lIGluIHNlY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucmVsZWFzZVJlbD0wXSAtIFJlbGVhc2UgdGltZSByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXNhbXBsaW5nPTBdIC0gU2VnbWVudCByZXNhbXBsaW5nIGluIGNlbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc2FtcGxpbmdWYXI9MF0gLSBBbW91dCBvZiByYW5kb20gcmVzYW1wbGluZyB2YXJpYXRpb24gaW4gY2VudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZ2Fpbj0xXSAtIExpbmVhciBnYWluIGZhY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYWJvcnRUaW1lPTAuMDA1XSAtIGZhZGUtb3V0IHRpbWUgd2hlbiBhYm9ydGVkXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zZWdtZW50SW5kZXg9MF0gLSBJbmRleCBvZiB0aGUgc2VnbWVudCB0byBzeW50aGVzaXplIChpLmUuIG9mXHJcbiAqICB0aGlzLnBvc2l0aW9uQXJyYXkvZHVyYXRpb25BcnJheS9vZmZzZXRBcnJheSlcclxuICogQHBhcmFtIHtCb29sfSBbb3B0aW9ucy5jeWNsaWM9ZmFsc2VdIC0gV2hldGhlciB0aGUgYXVkaW8gYnVmZmVyIGFuZCBzZWdtZW50IGluZGljZXMgYXJlXHJcbiAqICBjb25zaWRlcmVkIGFzIGN5Y2xpY1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMud3JhcEFyb3VuZEV4dGVuc2lvbj0wXSAtIFBvcnRpb24gYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gYnVmZmVyXHJcbiAqICB0aGF0IGhhcyBiZWVuIGNvcGllZCBmcm9tIHRoZSBiZWdpbm5pbmcgdG8gYXNzdXJlIGN5Y2xpYyBiZWhhdmlvclxyXG4gKi9cclxuY2xhc3MgU2VnbWVudEVuZ2luZSBleHRlbmRzIEF1ZGlvVGltZUVuZ2luZSB7XHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICBzdXBlcihvcHRpb25zLmF1ZGlvQ29udGV4dCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdWRpbyBidWZmZXJcclxuICAgICAqIEBuYW1lIGJ1ZmZlclxyXG4gICAgICogQHR5cGUge0F1ZGlvQnVmZmVyfVxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLmJ1ZmZlciA9IG9wdE9yRGVmKG9wdGlvbnMuYnVmZmVyLCBudWxsKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIHNlZ21lbnQgcGVyaW9kIGluIHNlY1xyXG4gICAgICogQG5hbWUgcGVyaW9kQWJzXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZEFicyA9IG9wdE9yRGVmKG9wdGlvbnMucGVyaW9kQWJzLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZ21lbnQgcGVyaW9kIHJlbGF0aXZlIHRvIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICAgICAqIEBuYW1lIHBlcmlvZFJlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RSZWwgPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZFJlbCwgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwZXJpb2QgdmFyaWF0aW9uIHJlbGF0aXZlIHRvIHNlZ21lbnQgcGVyaW9kXHJcbiAgICAgKiBAbmFtZSBwZXJpb2RWYXJcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucGVyaW9kVmFyID0gb3B0T3JEZWYob3B0aW9ucy5wZXJpb2RWYXIsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWluaW11bSBzZWdtZW50IHBlcmlvZFxyXG4gICAgICogQG5hbWUgcGVyaW9kTWluXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMC4wMDFcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2RNaW4gPSBvcHRPckRlZihvcHRpb25zLnBlcmlvZE1pbiwgMC4wMDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2Ygc2VnbWVudCBwb3NpdGlvbnMgKG9uc2V0IHRpbWVzIGluIGF1ZGlvIGJ1ZmZlcikgaW4gc2VjXHJcbiAgICAgKiBAbmFtZSBwb3NpdGlvbkFycmF5XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgWzAuMF1cclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3NpdGlvbkFycmF5ID0gb3B0T3JEZWYob3B0aW9ucy5wb3NpdGlvbkFycmF5LCBbMC4wXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbW91dCBvZiByYW5kb20gc2VnbWVudCBwb3NpdGlvbiB2YXJpYXRpb24gaW4gc2VjXHJcbiAgICAgKiBAbmFtZSBwb3NpdGlvblZhclxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wb3NpdGlvblZhciA9IG9wdE9yRGVmKG9wdGlvbnMucG9zaXRpb25WYXIsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2Ygc2VnbWVudCBkdXJhdGlvbnMgaW4gc2VjXHJcbiAgICAgKiBAbmFtZSBkdXJhdGlvbkFycmF5XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgWzAuMF1cclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kdXJhdGlvbkFycmF5ID0gb3B0T3JEZWYob3B0aW9ucy5kdXJhdGlvbkFycmF5LCBbMC4wXSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBzZWdtZW50IGR1cmF0aW9uIGluIHNlY1xyXG4gICAgICogQG5hbWUgZHVyYXRpb25BYnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZHVyYXRpb25BYnMgPSBvcHRPckRlZihvcHRpb25zLmR1cmF0aW9uQWJzLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZ21lbnQgZHVyYXRpb24gcmVsYXRpdmUgdG8gZ2l2ZW4gc2VnbWVudCBkdXJhdGlvbiBvciBpbnRlci1zZWdtZW50IGRpc3RhbmNlXHJcbiAgICAgKiBAbmFtZSBkdXJhdGlvblJlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5kdXJhdGlvblJlbCA9IG9wdE9yRGVmKG9wdGlvbnMuZHVyYXRpb25SZWwsIDEpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXJyYXkgb2Ygc2VnbWVudCBvZmZzZXRzIGluIHNlY1xyXG4gICAgICpcclxuICAgICAqIG9mZnNldCA+IDA6IHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGlzIGFmdGVyIHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uXHJcbiAgICAgKiBvZmZzZXQgPCAwOiB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvbiBpcyB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvblxyXG4gICAgICogYW5kIHRoZSBkdXJhdGlvbiBoYXMgdG8gYmUgY29ycmVjdGVkIGJ5IHRoZSBvZmZzZXRcclxuICAgICAqXHJcbiAgICAgKiBAbmFtZSBvZmZzZXRBcnJheVxyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQGRlZmF1bHQgWzAuMF1cclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5vZmZzZXRBcnJheSA9IG9wdE9yRGVmKG9wdGlvbnMub2Zmc2V0QXJyYXksIFswLjBdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFic29sdXRlIHNlZ21lbnQgb2Zmc2V0IGluIHNlY1xyXG4gICAgICogQG5hbWUgb2Zmc2V0QWJzXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgLTAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMub2Zmc2V0QWJzID0gb3B0T3JEZWYob3B0aW9ucy5vZmZzZXRBYnMsIC0wLjAwNSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWdtZW50IG9mZnNldCByZWxhdGl2ZSB0byBzZWdtZW50IGR1cmF0aW9uXHJcbiAgICAgKiBAbmFtZSBvZmZzZXRSZWxcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMub2Zmc2V0UmVsID0gb3B0T3JEZWYob3B0aW9ucy5vZmZzZXRSZWwsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGltZSBieSB3aGljaCBhbGwgc2VnbWVudHMgYXJlIGRlbGF5ZWQgKGVzcGVjaWFsbHkgdG8gcmVhbGl6ZSBzZWdtZW50IG9mZnNldHMpXHJcbiAgICAgKiBAbmFtZSBkZWxheVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGVsYXkgPSBvcHRPckRlZihvcHRpb25zLmRlbGF5LCAwLjAwNSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSBhdHRhY2sgdGltZSBpbiBzZWNcclxuICAgICAqIEBuYW1lIGF0dGFja0Fic1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYXR0YWNrQWJzID0gb3B0T3JEZWYob3B0aW9ucy5hdHRhY2tBYnMsIDAuMDA1KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEF0dGFjayB0aW1lIHJlbGF0aXZlIHRvIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAqIEBuYW1lIGF0dGFja1JlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5hdHRhY2tSZWwgPSBvcHRPckRlZihvcHRpb25zLmF0dGFja1JlbCwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBYnNvbHV0ZSByZWxlYXNlIHRpbWUgaW4gc2VjXHJcbiAgICAgKiBAbmFtZSByZWxlYXNlQWJzXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMC4wMDVcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWxlYXNlQWJzID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlQWJzLCAwLjAwNSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWxlYXNlIHRpbWUgcmVsYXRpdmUgdG8gc2VnbWVudCBkdXJhdGlvblxyXG4gICAgICogQG5hbWUgcmVsZWFzZVJlbFxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5yZWxlYXNlUmVsID0gb3B0T3JEZWYob3B0aW9ucy5yZWxlYXNlUmVsLCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlZ21lbnQgcmVzYW1wbGluZyBpbiBjZW50XHJcbiAgICAgKiBAbmFtZSByZXNhbXBsaW5nXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnJlc2FtcGxpbmcgPSBvcHRPckRlZihvcHRpb25zLnJlc2FtcGxpbmcsIDApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQW1vdXQgb2YgcmFuZG9tIHJlc2FtcGxpbmcgdmFyaWF0aW9uIGluIGNlbnRcclxuICAgICAqIEBuYW1lIHJlc2FtcGxpbmdWYXJcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMucmVzYW1wbGluZ1ZhciA9IG9wdE9yRGVmKG9wdGlvbnMucmVzYW1wbGluZ1ZhciwgMCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaW5lYXIgZ2FpbiBmYWN0b3JcclxuICAgICAqIEBuYW1lIGdhaW5cclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZ2FpbiA9IG9wdE9yRGVmKG9wdGlvbnMuZ2FpbiwgMSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRleCBvZiB0aGUgc2VnbWVudCB0byBzeW50aGVzaXplIChpLmUuIG9mIHRoaXMucG9zaXRpb25BcnJheS9kdXJhdGlvbkFycmF5L29mZnNldEFycmF5KVxyXG4gICAgICogQG5hbWUgc2VnbWVudEluZGV4XHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IG9wdE9yRGVmKG9wdGlvbnMuc2VnbWVudEluZGV4LCAwKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIGF1ZGlvIGJ1ZmZlciBhbmQgc2VnbWVudCBpbmRpY2VzIGFyZSBjb25zaWRlcmVkIGFzIGN5Y2xpY1xyXG4gICAgICogQG5hbWUgY3ljbGljXHJcbiAgICAgKiBAdHlwZSB7Qm9vbH1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuY3ljbGljID0gb3B0T3JEZWYob3B0aW9ucy5jeWNsaWMsIGZhbHNlKTtcclxuICAgIHRoaXMuX19jeWNsaWNPZmZzZXQgPSAwO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgbGFzdCBzZWdtZW50IGlzIGFib3J0ZWQgd2hlbiB0cmlnZ2VyaW5nIHRoZSBuZXh0XHJcbiAgICAgKiBAbmFtZSBtb25vcGhvbmljXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBtZW1iZXJvZiBTZWdtZW50RW5naW5lXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5tb25vcGhvbmljID0gb3B0T3JEZWYob3B0aW9ucy5tb25vcGhvbmljLCBmYWxzZSk7XHJcbiAgICB0aGlzLl9fY3VycmVudFNyYyA9IG51bGw7XHJcbiAgICB0aGlzLl9fY3VycmVudEVudiA9IG51bGw7XHJcbiAgICB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZSA9IDA7XHJcbiAgICB0aGlzLl9fY3VycmVudEdhaW4gPSAwO1xyXG4gICAgdGhpcy5fX2N1cnJlbnRFbmRUaW1lID0gMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZhZGUtb3V0IHRpbWUgKHdoZW4gYWJvcnRlZClcclxuICAgICAqIEBuYW1lIGFib3J0VGltZVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDAuMDA1XHJcbiAgICAgKiBAbWVtYmVyb2YgU2VnbWVudEVuZ2luZVxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYWJvcnRUaW1lID0gb3B0T3JEZWYob3B0aW9ucy5hYm9ydFRpbWUsIDAuMDA1KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBvcnRpb24gYXQgdGhlIGVuZCBvZiB0aGUgYXVkaW8gYnVmZmVyIHRoYXQgaGFzIGJlZW4gY29waWVkIGZyb20gdGhlIGJlZ2lubmluZyB0byBhc3N1cmUgY3ljbGljIGJlaGF2aW9yXHJcbiAgICAgKiBAbmFtZSB3cmFwQXJvdW5kRXh0ZW5zaW9uXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLndyYXBBcm91bmRFeHRlbnNpb24gPSBvcHRPckRlZihvcHRpb25zLndyYXBBcm91bmRFeHRlbnNpb24sIDApO1xyXG5cclxuICAgIHRoaXMub3V0cHV0Tm9kZSA9IHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBidWZmZXIgZHVyYXRpb24gKGV4Y2x1ZGluZyB3cmFwQXJvdW5kRXh0ZW5zaW9uKVxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAZGVmYXVsdCAwXHJcbiAgICogQG1lbWJlcm9mIFNlZ21lbnRFbmdpbmVcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKi9cclxuICBnZXQgYnVmZmVyRHVyYXRpb24oKSB7XHJcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcclxuICAgICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXIuZHVyYXRpb247XHJcblxyXG4gICAgICBpZiAodGhpcy53cmFwQXJvdW5kRXh0ZW5zaW9uKVxyXG4gICAgICAgIGJ1ZmZlckR1cmF0aW9uIC09IHRoaXMud3JhcEFyb3VuZEV4dGVuc2lvbjtcclxuXHJcbiAgICAgIHJldHVybiBidWZmZXJEdXJhdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXHJcbiAgYWR2YW5jZVRpbWUodGltZSkge1xyXG4gICAgdGltZSA9IE1hdGgubWF4KHRpbWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKTtcclxuICAgIHJldHVybiB0aW1lICsgdGhpcy50cmlnZ2VyKHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gVGltZUVuZ2luZSBtZXRob2QgKHRyYW5zcG9ydGVkIGludGVyZmFjZSlcclxuICBzeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLnNlZ21lbnRJbmRleDtcclxuICAgIHZhciBjeWNsaWNPZmZzZXQgPSAwO1xyXG4gICAgdmFyIGJ1ZmZlckR1cmF0aW9uID0gdGhpcy5idWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICBpZiAodGhpcy5jeWNsaWMpIHtcclxuICAgICAgdmFyIGN5Y2xlcyA9IHBvc2l0aW9uIC8gYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICBjeWNsaWNPZmZzZXQgPSBNYXRoLmZsb29yKGN5Y2xlcykgKiBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgcG9zaXRpb24gLT0gY3ljbGljT2Zmc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzcGVlZCA+IDApIHtcclxuICAgICAgaW5kZXggPSBnZXRDdXJyZW50T3JOZXh0SW5kZXgodGhpcy5wb3NpdGlvbkFycmF5LCBwb3NpdGlvbik7XHJcblxyXG4gICAgICBpZiAoaW5kZXggPj0gdGhpcy5wb3NpdGlvbkFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICBjeWNsaWNPZmZzZXQgKz0gYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jeWNsaWMpXHJcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoc3BlZWQgPCAwKSB7XHJcbiAgICAgIGluZGV4ID0gZ2V0Q3VycmVudE9yUHJldmlvdXNJbmRleCh0aGlzLnBvc2l0aW9uQXJyYXksIHBvc2l0aW9uKTtcclxuXHJcbiAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICBpbmRleCA9IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxO1xyXG4gICAgICAgIGN5Y2xpY09mZnNldCAtPSBidWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcclxuICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBJbmZpbml0eTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IGluZGV4O1xyXG4gICAgdGhpcy5fX2N5Y2xpY09mZnNldCA9IGN5Y2xpY09mZnNldDtcclxuXHJcbiAgICByZXR1cm4gY3ljbGljT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbkFycmF5W2luZGV4XTtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kICh0cmFuc3BvcnRlZCBpbnRlcmZhY2UpXHJcbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5zZWdtZW50SW5kZXg7XHJcbiAgICB2YXIgY3ljbGljT2Zmc2V0ID0gdGhpcy5fX2N5Y2xpY09mZnNldDtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIodGltZSk7XHJcblxyXG4gICAgaWYgKHNwZWVkID4gMCkge1xyXG4gICAgICBpbmRleCsrO1xyXG5cclxuICAgICAgaWYgKGluZGV4ID49IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGgpIHtcclxuICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgY3ljbGljT2Zmc2V0ICs9IHRoaXMuYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5jeWNsaWMpXHJcbiAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGluZGV4LS07XHJcblxyXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgaW5kZXggPSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoIC0gMTtcclxuICAgICAgICBjeWNsaWNPZmZzZXQgLT0gdGhpcy5idWZmZXJEdXJhdGlvbjtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmN5Y2xpYylcclxuICAgICAgICAgIHJldHVybiAtSW5maW5pdHk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNlZ21lbnRJbmRleCA9IGluZGV4O1xyXG4gICAgdGhpcy5fX2N5Y2xpY09mZnNldCA9IGN5Y2xpY09mZnNldDtcclxuXHJcbiAgICByZXR1cm4gY3ljbGljT2Zmc2V0ICsgdGhpcy5wb3NpdGlvbkFycmF5W2luZGV4XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWdnZXIgYSBzZWdtZW50LlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCBhdCBhbnkgdGltZSAod2hldGhlciB0aGUgZW5naW5lIGlzIHNjaGVkdWxlZC90cmFuc3BvcnRlZCBvciBub3QpXHJcbiAgICogdG8gZ2VuZXJhdGUgYSBzaW5nbGUgc2VnbWVudCBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgc2VnbWVudCBwYXJhbWV0ZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgc2VnbWVudCBzeW50aGVzaXMgYXVkaW8gdGltZVxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gcGVyaW9kIHRvIG5leHQgc2VnbWVudFxyXG4gICAqL1xyXG4gIHRyaWdnZXIodGltZSkge1xyXG4gICAgdmFyIGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xyXG4gICAgdmFyIHNlZ21lbnRUaW1lID0gKHRpbWUgfHwgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKSArIHRoaXMuZGVsYXk7XHJcbiAgICB2YXIgc2VnbWVudFBlcmlvZCA9IHRoaXMucGVyaW9kQWJzO1xyXG4gICAgdmFyIHNlZ21lbnRJbmRleCA9IHRoaXMuc2VnbWVudEluZGV4O1xyXG5cclxuICAgIGlmICh0aGlzLmJ1ZmZlcikge1xyXG4gICAgICB2YXIgc2VnbWVudFBvc2l0aW9uID0gMC4wO1xyXG4gICAgICB2YXIgc2VnbWVudER1cmF0aW9uID0gMC4wO1xyXG4gICAgICB2YXIgc2VnbWVudE9mZnNldCA9IDAuMDtcclxuICAgICAgdmFyIHJlc2FtcGxpbmdSYXRlID0gMS4wO1xyXG4gICAgICB2YXIgYnVmZmVyRHVyYXRpb24gPSB0aGlzLmJ1ZmZlckR1cmF0aW9uO1xyXG5cclxuICAgICAgaWYgKHRoaXMuY3ljbGljKVxyXG4gICAgICAgIHNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleCAlIHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGg7XHJcbiAgICAgIGVsc2VcclxuICAgICAgICBzZWdtZW50SW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWdtZW50SW5kZXgsIHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxKSk7XHJcblxyXG4gICAgICBpZiAodGhpcy5wb3NpdGlvbkFycmF5KVxyXG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XHJcblxyXG4gICAgICBpZiAodGhpcy5kdXJhdGlvbkFycmF5KVxyXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiA9IHRoaXMuZHVyYXRpb25BcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XHJcblxyXG4gICAgICBpZiAodGhpcy5vZmZzZXRBcnJheSlcclxuICAgICAgICBzZWdtZW50T2Zmc2V0ID0gdGhpcy5vZmZzZXRBcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XHJcblxyXG4gICAgICAvLyBjYWxjdWxhdGUgcmVzYW1wbGluZ1xyXG4gICAgICBpZiAodGhpcy5yZXNhbXBsaW5nICE9PSAwIHx8IHRoaXMucmVzYW1wbGluZ1ZhciA+IDApIHtcclxuICAgICAgICB2YXIgcmFuZG9tUmVzYW1wbGluZyA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIuMCAqIHRoaXMucmVzYW1wbGluZ1ZhcjtcclxuICAgICAgICByZXNhbXBsaW5nUmF0ZSA9IE1hdGgucG93KDIuMCwgKHRoaXMucmVzYW1wbGluZyArIHJhbmRvbVJlc2FtcGxpbmcpIC8gMTIwMC4wKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY2FsY3VsYXRlIGludGVyLXNlZ21lbnQgZGlzdGFuY2VcclxuICAgICAgaWYgKHNlZ21lbnREdXJhdGlvbiA9PT0gMCB8fCB0aGlzLnBlcmlvZFJlbCA+IDApIHtcclxuICAgICAgICB2YXIgbmV4dFNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleCArIDE7XHJcbiAgICAgICAgdmFyIG5leHRQb3NpdGlvbiwgbmV4dE9mZnNldDtcclxuXHJcbiAgICAgICAgaWYgKG5leHRTZWdtZW50SW5kZXggPT09IHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgIGlmICh0aGlzLmN5Y2xpYykge1xyXG4gICAgICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uQXJyYXlbMF0gKyBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgICAgICAgbmV4dE9mZnNldCA9IHRoaXMub2Zmc2V0QXJyYXlbMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgICAgICAgbmV4dE9mZnNldCA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVtuZXh0U2VnbWVudEluZGV4XTtcclxuICAgICAgICAgIG5leHRPZmZzZXQgPSB0aGlzLm9mZnNldEFycmF5W25leHRTZWdtZW50SW5kZXhdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGludGVyU2VnbWVudERpc3RhbmNlID0gbmV4dFBvc2l0aW9uIC0gc2VnbWVudFBvc2l0aW9uO1xyXG5cclxuICAgICAgICAvLyBjb3JyZWN0IGludGVyLXNlZ21lbnQgZGlzdGFuY2UgYnkgb2Zmc2V0c1xyXG4gICAgICAgIC8vICAgb2Zmc2V0ID4gMDogdGhlIHNlZ21lbnQncyByZWZlcmVuY2UgcG9zaXRpb24gaXMgYWZ0ZXIgdGhlIGdpdmVuIHNlZ21lbnQgcG9zaXRpb25cclxuICAgICAgICBpZiAoc2VnbWVudE9mZnNldCA+IDApXHJcbiAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSAtPSBzZWdtZW50T2Zmc2V0O1xyXG5cclxuICAgICAgICBpZiAobmV4dE9mZnNldCA+IDApXHJcbiAgICAgICAgICBpbnRlclNlZ21lbnREaXN0YW5jZSArPSBuZXh0T2Zmc2V0O1xyXG5cclxuICAgICAgICBpZiAoaW50ZXJTZWdtZW50RGlzdGFuY2UgPCAwKVxyXG4gICAgICAgICAgaW50ZXJTZWdtZW50RGlzdGFuY2UgPSAwO1xyXG5cclxuICAgICAgICAvLyB1c2UgaW50ZXItc2VnbWVudCBkaXN0YW5jZSBpbnN0ZWFkIG9mIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAgICBpZiAoc2VnbWVudER1cmF0aW9uID09PSAwKVxyXG4gICAgICAgICAgc2VnbWVudER1cmF0aW9uID0gaW50ZXJTZWdtZW50RGlzdGFuY2U7XHJcblxyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBwZXJpb2QgcmVsYXRpdmUgdG8gaW50ZXIgbWFya2VyIGRpc3RhbmNlXHJcbiAgICAgICAgc2VnbWVudFBlcmlvZCArPSB0aGlzLnBlcmlvZFJlbCAqIGludGVyU2VnbWVudERpc3RhbmNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhZGQgcmVsYXRpdmUgYW5kIGFic29sdXRlIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAgc2VnbWVudER1cmF0aW9uICo9IHRoaXMuZHVyYXRpb25SZWw7XHJcbiAgICAgIHNlZ21lbnREdXJhdGlvbiArPSB0aGlzLmR1cmF0aW9uQWJzO1xyXG5cclxuICAgICAgLy8gYWRkIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBzZWdtZW50IG9mZnNldFxyXG4gICAgICBzZWdtZW50T2Zmc2V0ICo9IHRoaXMub2Zmc2V0UmVsO1xyXG4gICAgICBzZWdtZW50T2Zmc2V0ICs9IHRoaXMub2Zmc2V0QWJzO1xyXG5cclxuICAgICAgLy8gYXBwbHkgc2VnbWVudCBvZmZzZXRcclxuICAgICAgLy8gICBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICAvLyAgIG9mZnNldCA8IDA6IHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uIGlzIHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGFuZCB0aGUgZHVyYXRpb24gaGFzIHRvIGJlIGNvcnJlY3RlZCBieSB0aGUgb2Zmc2V0XHJcbiAgICAgIGlmIChzZWdtZW50T2Zmc2V0IDwgMCkge1xyXG4gICAgICAgIHNlZ21lbnREdXJhdGlvbiAtPSBzZWdtZW50T2Zmc2V0O1xyXG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiArPSBzZWdtZW50T2Zmc2V0O1xyXG4gICAgICAgIHNlZ21lbnRUaW1lICs9IChzZWdtZW50T2Zmc2V0IC8gcmVzYW1wbGluZ1JhdGUpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlZ21lbnRUaW1lIC09IChzZWdtZW50T2Zmc2V0IC8gcmVzYW1wbGluZ1JhdGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyByYW5kb21pemUgc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICBpZiAodGhpcy5wb3NpdGlvblZhciA+IDApXHJcbiAgICAgICAgc2VnbWVudFBvc2l0aW9uICs9IDIuMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRoaXMucG9zaXRpb25WYXI7XHJcblxyXG4gICAgICAvLyBzaG9ydGVuIGR1cmF0aW9uIG9mIHNlZ21lbnRzIG92ZXIgdGhlIGVkZ2VzIG9mIHRoZSBidWZmZXJcclxuICAgICAgaWYgKHNlZ21lbnRQb3NpdGlvbiA8IDApIHtcclxuICAgICAgICAvL3NlZ21lbnRUaW1lIC09IGdyYWluUG9zaXRpb247IGhtLCBub3Qgc3VyZSBpZiB3ZSB3YW50IHRvIGRvIHRoaXNcclxuICAgICAgICBzZWdtZW50RHVyYXRpb24gKz0gc2VnbWVudFBvc2l0aW9uO1xyXG4gICAgICAgIHNlZ21lbnRQb3NpdGlvbiA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZWdtZW50UG9zaXRpb24gKyBzZWdtZW50RHVyYXRpb24gPiB0aGlzLmJ1ZmZlci5kdXJhdGlvbilcclxuICAgICAgICBzZWdtZW50RHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIHNlZ21lbnRQb3NpdGlvbjtcclxuXHJcbiAgICAgIHNlZ21lbnREdXJhdGlvbiAvPSByZXNhbXBsaW5nUmF0ZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm1vbm9waG9uaWMpXHJcbiAgICAgICAgdGhpcy5hYm9ydChzZWdtZW50VGltZSk7XHJcblxyXG4gICAgICAvLyBtYWtlIHNlZ21lbnRcclxuICAgICAgaWYgKHRoaXMuZ2FpbiA+IDAgJiYgc2VnbWVudER1cmF0aW9uID4gMCkge1xyXG4gICAgICAgIC8vIG1ha2Ugc2VnbWVudCBlbnZlbG9wZVxyXG4gICAgICAgIHZhciBlbnZlbG9wZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgdmFyIGF0dGFjayA9IHRoaXMuYXR0YWNrQWJzICsgdGhpcy5hdHRhY2tSZWwgKiBzZWdtZW50RHVyYXRpb247XHJcbiAgICAgICAgdmFyIHJlbGVhc2UgPSB0aGlzLnJlbGVhc2VBYnMgKyB0aGlzLnJlbGVhc2VSZWwgKiBzZWdtZW50RHVyYXRpb247XHJcblxyXG4gICAgICAgIGlmIChhdHRhY2sgKyByZWxlYXNlID4gc2VnbWVudER1cmF0aW9uKSB7XHJcbiAgICAgICAgICB2YXIgZmFjdG9yID0gc2VnbWVudER1cmF0aW9uIC8gKGF0dGFjayArIHJlbGVhc2UpO1xyXG4gICAgICAgICAgYXR0YWNrICo9IGZhY3RvcjtcclxuICAgICAgICAgIHJlbGVhc2UgKj0gZmFjdG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGF0dGFja0VuZFRpbWUgPSBzZWdtZW50VGltZSArIGF0dGFjaztcclxuICAgICAgICB2YXIgc2VnbWVudEVuZFRpbWUgPSBzZWdtZW50VGltZSArIHNlZ21lbnREdXJhdGlvbjtcclxuICAgICAgICB2YXIgcmVsZWFzZVN0YXJ0VGltZSA9IHNlZ21lbnRFbmRUaW1lIC0gcmVsZWFzZTtcclxuXHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi52YWx1ZSA9IDA7XHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSgwLjAsIHNlZ21lbnRUaW1lKTtcclxuICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKHRoaXMuZ2FpbiwgYXR0YWNrRW5kVGltZSk7XHJcblxyXG4gICAgICAgIGlmIChyZWxlYXNlU3RhcnRUaW1lID4gYXR0YWNrRW5kVGltZSlcclxuICAgICAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUodGhpcy5nYWluLCByZWxlYXNlU3RhcnRUaW1lKTtcclxuXHJcbiAgICAgICAgZW52ZWxvcGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLjAsIHNlZ21lbnRFbmRUaW1lKTtcclxuICAgICAgICBlbnZlbG9wZS5jb25uZWN0KHRoaXMub3V0cHV0Tm9kZSk7XHJcblxyXG4gICAgICAgIHRoaXMuX19jdXJyZW50RW52ID0gZW52ZWxvcGU7XHJcblxyXG4gICAgICAgIC8vIG1ha2Ugc291cmNlXHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuXHJcbiAgICAgICAgc291cmNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xyXG4gICAgICAgIHNvdXJjZS5wbGF5YmFja1JhdGUudmFsdWUgPSByZXNhbXBsaW5nUmF0ZTtcclxuICAgICAgICBzb3VyY2UuY29ubmVjdChlbnZlbG9wZSk7XHJcblxyXG4gICAgICAgIHNvdXJjZS5zdGFydChzZWdtZW50VGltZSwgc2VnbWVudFBvc2l0aW9uKTtcclxuICAgICAgICBzb3VyY2Uuc3RvcChzZWdtZW50VGltZSArIHNlZ21lbnREdXJhdGlvbik7XHJcblxyXG4gICAgICAgIHRoaXMuX19jdXJyZW50U3JjID0gc291cmNlO1xyXG4gICAgICAgIHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lID0gcmVsZWFzZVN0YXJ0VGltZTtcclxuICAgICAgICB0aGlzLl9fY3VycmVudEdhaW4gPSB0aGlzLmdhaW47XHJcbiAgICAgICAgdGhpcy5fX2N1cnJlbnRFbmRUaW1lID0gc2VnbWVudEVuZFRpbWU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBncmFpbiBwZXJpb2QgcmFuZG9uIHZhcmlhdGlvblxyXG4gICAgaWYgKHRoaXMucGVyaW9kVmFyID4gMC4wKVxyXG4gICAgICBzZWdtZW50UGVyaW9kICs9IDIuMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRoaXMucGVyaW9kVmFyICogZ3JhaW5QZXJpb2Q7XHJcblxyXG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMucGVyaW9kTWluLCBzZWdtZW50UGVyaW9kKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFib3J0IHRoZSBjdXJyZW50IHNlZ21lbnQgYXQgZ2l2ZW4gdGltZSwgZmFkZSBvdXQgZHVyYXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIC0gYWJvcnQgdGltZVxyXG4gICAqL1xyXG4gIGFib3J0KHRpbWUpIHtcclxuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xyXG4gICAgY29uc3QgZW5kVGltZSA9IHRoaXMuX19jdXJyZW50RW5kVGltZTtcclxuICAgIGNvbnN0IGFib3J0VGltZSA9IHRpbWUgfHwgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lO1xyXG5cclxuICAgIGlmIChhYm9ydFRpbWUgPCBlbmRUaW1lKSB7XHJcbiAgICAgIGNvbnN0IHNlZ21lbnRFbmRUaW1lID0gTWF0aC5taW4oYWJvcnRUaW1lICsgdGhpcy5hYm9ydFRpbWUsIGVuZFRpbWUpO1xyXG4gICAgICBjb25zdCBlbnZlbG9wZSA9IHRoaXMuX19jdXJyZW50RW52O1xyXG4gICAgICBsZXQgY3VycmVudEdhaW5WYWx1ZSA9IHRoaXMuX19jdXJyZW50R2FpbjtcclxuXHJcbiAgICAgIGlmIChhYm9ydFRpbWUgPiB0aGlzLl9fcmVsZWFzZVN0YXJ0VGltZSkge1xyXG4gICAgICAgIGNvbnN0IHJlbGVhc2VTdGFydCA9IHRoaXMuX19yZWxlYXNlU3RhcnRUaW1lO1xyXG4gICAgICAgIGN1cnJlbnRHYWluVmFsdWUgKj0gKGFib3J0VGltZSAtIHJlbGVhc2VTdGFydCkgLyAoZW5kVGltZSAtIHJlbGVhc2VTdGFydCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVudmVsb3BlLmdhaW4uY2FuY2VsU2NoZWR1bGVkVmFsdWVzKGFib3J0VGltZSk7XHJcbiAgICAgIGVudmVsb3BlLmdhaW4uc2V0VmFsdWVBdFRpbWUoY3VycmVudEdhaW5WYWx1ZSwgYWJvcnRUaW1lKTtcclxuICAgICAgZW52ZWxvcGUuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCBzZWdtZW50RW5kVGltZSk7XHJcblxyXG4gICAgICB0aGlzLl9fY3VycmVudFNyYyA9IG51bGw7XHJcbiAgICAgIHRoaXMuX19jdXJyZW50RW52ID0gbnVsbDtcclxuICAgICAgdGhpcy5fX3JlbGVhc2VTdGFydFRpbWUgPSAwO1xyXG4gICAgICB0aGlzLl9fY3VycmVudEdhaW4gPSAwO1xyXG4gICAgICB0aGlzLl9fY3VycmVudEVuZFRpbWUgPSAwO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2VnbWVudEVuZ2luZTtcclxuIiwiaW1wb3J0IEF1ZGlvVGltZUVuZ2luZSBmcm9tICcuLi9jb3JlL2F1ZGlvLXRpbWUtZW5naW5lJztcclxuaW1wb3J0IFNlZ21lbnRFbmdpbmUgZnJvbSAnLi9zZWdtZW50LWVuZ2luZSc7XHJcblxyXG5mdW5jdGlvbiBvcHRPckRlZihvcHQsIGRlZikge1xyXG4gICAgaWYgKG9wdCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHJldHVybiBvcHQ7XHJcblxyXG4gICAgcmV0dXJuIGRlZjtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q3VycmVudE9yUHJldmlvdXNJbmRleChzb3J0ZWRBcnJheSwgdmFsdWUsIGluZGV4ID0gLTEpIHtcclxuICAgIHZhciBzaXplID0gc29ydGVkQXJyYXkubGVuZ3RoO1xyXG5cclxuICAgIGlmIChzaXplID4gMCkge1xyXG4gICAgICAgIHZhciBmaXJzdFZhbCA9IHNvcnRlZEFycmF5WzBdO1xyXG4gICAgICAgIHZhciBsYXN0VmFsID0gc29ydGVkQXJyYXlbc2l6ZSAtIDFdO1xyXG5cclxuICAgICAgICBpZiAodmFsdWUgPCBmaXJzdFZhbClcclxuICAgICAgICAgICAgaW5kZXggPSAtMTtcclxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA+PSBsYXN0VmFsKVxyXG4gICAgICAgICAgICBpbmRleCA9IHNpemUgLSAxO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHNpemUpXHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoKHNpemUgLSAxKSAqICh2YWx1ZSAtIGZpcnN0VmFsKSAvIChsYXN0VmFsIC0gZmlyc3RWYWwpKTtcclxuXHJcbiAgICAgICAgICAgIHdoaWxlIChzb3J0ZWRBcnJheVtpbmRleF0gPiB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIGluZGV4LS07XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXggKyAxXSA8PSB2YWx1ZSlcclxuICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBpbmRleDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0Q3VycmVudE9yTmV4dEluZGV4KHNvcnRlZEFycmF5LCB2YWx1ZSwgaW5kZXggPSAtMSkge1xyXG4gICAgdmFyIHNpemUgPSBzb3J0ZWRBcnJheS5sZW5ndGg7XHJcblxyXG4gICAgaWYgKHNpemUgPiAwKSB7XHJcbiAgICAgICAgdmFyIGZpcnN0VmFsID0gc29ydGVkQXJyYXlbMF07XHJcbiAgICAgICAgdmFyIGxhc3RWYWwgPSBzb3J0ZWRBcnJheVtzaXplIC0gMV07XHJcblxyXG4gICAgICAgIGlmICh2YWx1ZSA8PSBmaXJzdFZhbClcclxuICAgICAgICAgICAgaW5kZXggPSAwO1xyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID49IGxhc3RWYWwpXHJcbiAgICAgICAgICAgIGluZGV4ID0gc2l6ZTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBzaXplKVxyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChzaXplIC0gMSkgKiAodmFsdWUgLSBmaXJzdFZhbCkgLyAobGFzdFZhbCAtIGZpcnN0VmFsKSk7XHJcblxyXG4gICAgICAgICAgICB3aGlsZSAoc29ydGVkQXJyYXlbaW5kZXhdIDwgdmFsdWUpXHJcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xyXG5cclxuICAgICAgICAgICAgd2hpbGUgKHNvcnRlZEFycmF5W2luZGV4IC0gMV0gPj0gdmFsdWUpXHJcbiAgICAgICAgICAgICAgICBpbmRleC0tO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gaW5kZXg7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgU2VxdWVuY2VyRW5naW5lXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZXF1ZW5jZXJFbmdpbmUgZXh0ZW5kcyBTZWdtZW50RW5naW5lIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0ge0F1ZGlvQnVmZmVyfSBidWZmZXIgaW5pdGlhbCBhdWRpbyBidWZmZXIgZm9yIGdyYW51bGFyIHN5bnRoZXNpc1xyXG4gICAgICpcclxuICAgICAqIFRoZSBlbmdpbmUgaW1wbGVtZW50cyB0aGUgXCJzY2hlZHVsZWRcIiBhbmQgXCJ0cmFuc3BvcnRlZFwiIGludGVyZmFjZXMuXHJcbiAgICAgKiBXaGVuIFwic2NoZWR1bGVkXCIsIHRoZSBlbmdpbmUgIGdlbmVyYXRlcyBzZWdtZW50cyBtb3JlIG9yIGxlc3PCoHBlcmlvZGljYWxseVxyXG4gICAgICogKGNvbnRyb2xsZWQgYnkgdGhlIHBlcmlvZEFicywgcGVyaW9kUmVsLCBhbmQgcGVyaW9WYXIgYXR0cmlidXRlcykuXHJcbiAgICAgKiBXaGVuIFwidHJhbnNwb3J0ZWRcIiwgdGhlIGVuZ2luZSBnZW5lcmF0ZXMgc2VnbWVudHMgYXQgdGhlIHBvc2l0aW9uIG9mIHRoZWlyIG9uc2V0IHRpbWUuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZnVuY3Rpb24gY2FsbGJhY2sgdGhhdCBnZXRzIGNhbGxlZCBmcm9tIHRyaWdnZXIoKS5cclxuICAgICAgICAgKiBUaGlzIGxldHMgeW91IHNldCB1cCBldmVudHMgdG8gYmUgdHJpZ2dlcmVkIGJ5IHRoZSBzZXF1ZW5jZXIuXHJcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRPckRlZihvcHRpb25zLmNhbGxiYWNrLCBudWxsKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyIGEgc2VnbWVudFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgc2VnbWVudCBzeW50aGVzaXMgYXVkaW8gdGltZVxyXG4gICAgICogQHJldHVybiB7TnVtYmVyfSBwZXJpb2QgdG8gbmV4dCBzZWdtZW50XHJcbiAgICAgKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIGF0IGFueSB0aW1lICh3aGV0aGVyIHRoZSBlbmdpbmUgaXMgc2NoZWR1bGVkL3RyYW5zcG9ydGVkIG9yIG5vdClcclxuICAgICAqIHRvIGdlbmVyYXRlIGEgc2luZ2xlIHNlZ21lbnQgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHNlZ21lbnQgcGFyYW1ldGVycy5cclxuICAgICAqL1xyXG4gICAgdHJpZ2dlcih0aW1lKSB7XHJcbiAgICAgICAgdmFyIGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xyXG4gICAgICAgIHZhciBzZWdtZW50VGltZSA9ICh0aW1lIHx8IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSkgKyB0aGlzLmRlbGF5O1xyXG4gICAgICAgIHZhciBzZWdtZW50UGVyaW9kID0gdGhpcy5wZXJpb2RBYnM7XHJcbiAgICAgICAgdmFyIHNlZ21lbnRJbmRleCA9IHRoaXMuc2VnbWVudEluZGV4O1xyXG5cclxuICAgICAgICAvLyBJZ25vcmUgYnVmZmVyIGZvciBub3csIHRoaXMgaXMgYSBzZXF1bmNlci4uLiBubyBhdWRpbyBwcm9kdWNlZC5cclxuICAgICAgICBpZiAoIC8qdGhpcy5idWZmZXIqLyB0cnVlKSB7XHJcbiAgICAgICAgICAgIHZhciBzZWdtZW50UG9zaXRpb24gPSAwLjA7XHJcbiAgICAgICAgICAgIHZhciBzZWdtZW50RHVyYXRpb24gPSAwLjA7XHJcbiAgICAgICAgICAgIHZhciBzZWdtZW50T2Zmc2V0ID0gMC4wO1xyXG4gICAgICAgICAgICB2YXIgcmVzYW1wbGluZ1JhdGUgPSAxLjA7XHJcbiAgICAgICAgICAgIHZhciBidWZmZXJEdXJhdGlvbiA9IHRoaXMuYnVmZmVyRHVyYXRpb247XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jeWNsaWMpXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXggJSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50SW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZWdtZW50SW5kZXgsIHRoaXMucG9zaXRpb25BcnJheS5sZW5ndGggLSAxKSk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbkFycmF5KVxyXG4gICAgICAgICAgICAgICAgc2VnbWVudFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkFycmF5W3NlZ21lbnRJbmRleF0gfHwgMDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmR1cmF0aW9uQXJyYXkpXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50RHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uQXJyYXlbc2VnbWVudEluZGV4XSB8fCAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMub2Zmc2V0QXJyYXkpXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50T2Zmc2V0ID0gdGhpcy5vZmZzZXRBcnJheVtzZWdtZW50SW5kZXhdIHx8IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVzYW1wbGluZ1xyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXNhbXBsaW5nICE9PSAwIHx8IHRoaXMucmVzYW1wbGluZ1ZhciA+IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciByYW5kb21SZXNhbXBsaW5nID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMi4wICogdGhpcy5yZXNhbXBsaW5nVmFyO1xyXG4gICAgICAgICAgICAgICAgcmVzYW1wbGluZ1JhdGUgPSBNYXRoLnBvdygyLjAsICh0aGlzLnJlc2FtcGxpbmcgKyByYW5kb21SZXNhbXBsaW5nKSAvIDEyMDAuMCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBpbnRlci1zZWdtZW50IGRpc3RhbmNlXHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50RHVyYXRpb24gPT09IDAgfHwgdGhpcy5wZXJpb2RSZWwgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleCArIDE7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFBvc2l0aW9uLCBuZXh0T2Zmc2V0O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChuZXh0U2VnbWVudEluZGV4ID09PSB0aGlzLnBvc2l0aW9uQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3ljbGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb25BcnJheVswXSArIGJ1ZmZlckR1cmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0T2Zmc2V0ID0gdGhpcy5vZmZzZXRBcnJheVswXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24gPSBidWZmZXJEdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dE9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uQXJyYXlbbmV4dFNlZ21lbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dE9mZnNldCA9IHRoaXMub2Zmc2V0QXJyYXlbbmV4dFNlZ21lbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGludGVyU2VnbWVudERpc3RhbmNlID0gbmV4dFBvc2l0aW9uIC0gc2VnbWVudFBvc2l0aW9uO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgaW50ZXItc2VnbWVudCBkaXN0YW5jZSBieSBvZmZzZXRzXHJcbiAgICAgICAgICAgICAgICAvLyAgIG9mZnNldCA+IDA6IHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGlzIGFmdGVyIHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnbWVudE9mZnNldCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJTZWdtZW50RGlzdGFuY2UgLT0gc2VnbWVudE9mZnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dE9mZnNldCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJTZWdtZW50RGlzdGFuY2UgKz0gbmV4dE9mZnNldDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJTZWdtZW50RGlzdGFuY2UgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGludGVyU2VnbWVudERpc3RhbmNlID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB1c2UgaW50ZXItc2VnbWVudCBkaXN0YW5jZSBpbnN0ZWFkIG9mIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAgICAgICAgICAgIGlmIChzZWdtZW50RHVyYXRpb24gPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudER1cmF0aW9uID0gaW50ZXJTZWdtZW50RGlzdGFuY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHBlcmlvZCByZWxhdGl2ZSB0byBpbnRlciBtYXJrZXIgZGlzdGFuY2VcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRQZXJpb2QgKz0gdGhpcy5wZXJpb2RSZWwgKiBpbnRlclNlZ21lbnREaXN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAvLyBhZGQgcmVsYXRpdmUgYW5kIGFic29sdXRlIHNlZ21lbnQgZHVyYXRpb25cclxuICAgICAgICAgICAgc2VnbWVudER1cmF0aW9uICo9IHRoaXMuZHVyYXRpb25SZWw7XHJcbiAgICAgICAgICAgIHNlZ21lbnREdXJhdGlvbiArPSB0aGlzLmR1cmF0aW9uQWJzO1xyXG5cclxuICAgICAgICAgICAgLy8gYWRkIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBzZWdtZW50IG9mZnNldFxyXG4gICAgICAgICAgICBzZWdtZW50T2Zmc2V0ICo9IHRoaXMub2Zmc2V0UmVsO1xyXG4gICAgICAgICAgICBzZWdtZW50T2Zmc2V0ICs9IHRoaXMub2Zmc2V0QWJzO1xyXG5cclxuICAgICAgICAgICAgLy8gYXBwbHkgc2VnbWVudCBvZmZzZXRcclxuICAgICAgICAgICAgLy8gICBvZmZzZXQgPiAwOiB0aGUgc2VnbWVudCdzIHJlZmVyZW5jZSBwb3NpdGlvbiBpcyBhZnRlciB0aGUgZ2l2ZW4gc2VnbWVudCBwb3NpdGlvblxyXG4gICAgICAgICAgICAvLyAgIG9mZnNldCA8IDA6IHRoZSBnaXZlbiBzZWdtZW50IHBvc2l0aW9uIGlzIHRoZSBzZWdtZW50J3MgcmVmZXJlbmNlIHBvc2l0aW9uIGFuZCB0aGUgZHVyYXRpb24gaGFzIHRvIGJlIGNvcnJlY3RlZCBieSB0aGUgb2Zmc2V0XHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50T2Zmc2V0IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudER1cmF0aW9uIC09IHNlZ21lbnRPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50UG9zaXRpb24gKz0gc2VnbWVudE9mZnNldDtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRUaW1lICs9IChzZWdtZW50T2Zmc2V0IC8gcmVzYW1wbGluZ1JhdGUpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudFRpbWUgLT0gKHNlZ21lbnRPZmZzZXQgLyByZXNhbXBsaW5nUmF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHJhbmRvbWl6ZSBzZWdtZW50IHBvc2l0aW9uXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uVmFyID4gMClcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRQb3NpdGlvbiArPSAyLjAgKiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiB0aGlzLnBvc2l0aW9uVmFyO1xyXG5cclxuICAgICAgICAgICAgLy8gc2hvcnRlbiBkdXJhdGlvbiBvZiBzZWdtZW50cyBvdmVyIHRoZSBlZGdlcyBvZiB0aGUgYnVmZmVyXHJcbiAgICAgICAgICAgIGlmIChzZWdtZW50UG9zaXRpb24gPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvL3NlZ21lbnRUaW1lIC09IGdyYWluUG9zaXRpb247IGhtLCBub3Qgc3VyZSBpZiB3ZSB3YW50IHRvIGRvIHRoaXNcclxuICAgICAgICAgICAgICAgIHNlZ21lbnREdXJhdGlvbiArPSBzZWdtZW50UG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50UG9zaXRpb24gPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2VnbWVudFBvc2l0aW9uICsgc2VnbWVudER1cmF0aW9uID4gdGhpcy5idWZmZXIuZHVyYXRpb24pXHJcbiAgICAgICAgICAgICAgICBzZWdtZW50RHVyYXRpb24gPSB0aGlzLmJ1ZmZlci5kdXJhdGlvbiAtIHNlZ21lbnRQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgIHNlZ21lbnREdXJhdGlvbiAvPSByZXNhbXBsaW5nUmF0ZTtcclxuXHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc2VnbWVudFxyXG4gICAgICAgICAgICBpZiAodGhpcy5nYWluID4gMCAmJiBzZWdtZW50RHVyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgICAgICAgLy8gbWFrZSBzZWdtZW50IGVudmVsb3BlXHJcbiAgICAgICAgICAgICAgdmFyIGVudmVsb3BlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICAgICAgICB2YXIgYXR0YWNrID0gdGhpcy5hdHRhY2tBYnMgKyB0aGlzLmF0dGFja1JlbCAqIHNlZ21lbnREdXJhdGlvbjtcclxuICAgICAgICAgICAgICB2YXIgcmVsZWFzZSA9IHRoaXMucmVsZWFzZUFicyArIHRoaXMucmVsZWFzZVJlbCAqIHNlZ21lbnREdXJhdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGF0dGFjayArIHJlbGVhc2UgPiBzZWdtZW50RHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBzZWdtZW50RHVyYXRpb24gLyAoYXR0YWNrICsgcmVsZWFzZSk7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2sgKj0gZmFjdG9yO1xyXG4gICAgICAgICAgICAgICAgcmVsZWFzZSAqPSBmYWN0b3I7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICB2YXIgYXR0YWNrRW5kVGltZSA9IHNlZ21lbnRUaW1lICsgYXR0YWNrO1xyXG4gICAgICAgICAgICAgIHZhciBzZWdtZW50RW5kVGltZSA9IHNlZ21lbnRUaW1lICsgc2VnbWVudER1cmF0aW9uO1xyXG4gICAgICAgICAgICAgIHZhciByZWxlYXNlU3RhcnRUaW1lID0gc2VnbWVudEVuZFRpbWUgLSByZWxlYXNlO1xyXG5cclxuICAgICAgICAgICAgICBlbnZlbG9wZS5nYWluLnZhbHVlID0gMDtcclxuICAgICAgICAgICAgICBlbnZlbG9wZS5nYWluLnNldFZhbHVlQXRUaW1lKDAuMCwgc2VnbWVudFRpbWUpO1xyXG4gICAgICAgICAgICAgIGVudmVsb3BlLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUodGhpcy5nYWluLCBhdHRhY2tFbmRUaW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHJlbGVhc2VTdGFydFRpbWUgPiBhdHRhY2tFbmRUaW1lKVxyXG4gICAgICAgICAgICAgICAgZW52ZWxvcGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh0aGlzLmdhaW4sIHJlbGVhc2VTdGFydFRpbWUpO1xyXG5cclxuICAgICAgICAgICAgICBlbnZlbG9wZS5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKDAuMCwgc2VnbWVudEVuZFRpbWUpO1xyXG4gICAgICAgICAgICAgIGVudmVsb3BlLmNvbm5lY3QodGhpcy5vdXRwdXROb2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbWFrZSBzb3VyY2VcclxuICAgICAgICAgICAgICB2YXIgc291cmNlID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xyXG5cclxuICAgICAgICAgICAgICBzb3VyY2UuYnVmZmVyID0gdGhpcy5idWZmZXI7XHJcbiAgICAgICAgICAgICAgc291cmNlLnBsYXliYWNrUmF0ZS52YWx1ZSA9IHJlc2FtcGxpbmdSYXRlO1xyXG4gICAgICAgICAgICAgIHNvdXJjZS5jb25uZWN0KGVudmVsb3BlKTtcclxuXHJcbiAgICAgICAgICAgICAgc291cmNlLnN0YXJ0KHNlZ21lbnRUaW1lLCBzZWdtZW50UG9zaXRpb24pO1xyXG4gICAgICAgICAgICAgIHNvdXJjZS5zdG9wKHNlZ21lbnRUaW1lICsgc2VnbWVudER1cmF0aW9uKTtcclxuICAgICAgICAgICAgfSovXHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2sgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuY2FsbGJhY2spID09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2FsbGJhY2soc2VnbWVudEluZGV4KTtcclxuICAgICAgICAgICAgLy9pZiAocmVzdWx0KVxyXG4gICAgICAgICAgICAvLyAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNlcXVlbmNlci5UcmlnZ2VyOiBcIiArIHNlZ21lbnRJbmRleCArIFwiIFBvc2l0aW9uOiBcIiArIHNlZ21lbnRQb3NpdGlvbik7XHJcblxyXG4gICAgICAgIC8vIGdyYWluIHBlcmlvZCByYW5kb24gdmFyaWF0aW9uXHJcbiAgICAgICAgaWYgKHRoaXMucGVyaW9kVmFyID4gMC4wKVxyXG4gICAgICAgICAgICBzZWdtZW50UGVyaW9kICs9IDIuMCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIHRoaXMucGVyaW9kVmFyICogZ3JhaW5QZXJpb2Q7XHJcblxyXG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnBlcmlvZE1pbiwgc2VnbWVudFBlcmlvZCk7XHJcbiAgICB9XHJcbn0iLCIvLyBjb3JlXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXVkaW9Db250ZXh0IH0gZnJvbSAnLi9jb3JlL2F1ZGlvLWNvbnRleHQnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFRpbWVFbmdpbmUgfSBmcm9tICcuL2NvcmUvdGltZS1lbmdpbmUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEF1ZGlvVGltZUVuZ2luZSB9IGZyb20gJy4vY29yZS9hdWRpby10aW1lLWVuZ2luZSc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHJpb3JpdHlRdWV1ZSB9IGZyb20gJy4vY29yZS9wcmlvcml0eS1xdWV1ZSc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2NoZWR1bGluZ1F1ZXVlIH0gZnJvbSAnLi9jb3JlL3NjaGVkdWxpbmctcXVldWUnO1xyXG5cclxuLy8gZW5naW5lc1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIEdyYW51bGFyRW5naW5lIH0gZnJvbSAnLi9lbmdpbmVzL2dyYW51bGFyLWVuZ2luZSc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWV0cm9ub21lIH0gZnJvbSAnLi9lbmdpbmVzL21ldHJvbm9tZSc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGxheWVyRW5naW5lIH0gZnJvbSAnLi9lbmdpbmVzL3BsYXllci1lbmdpbmUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlZ21lbnRFbmdpbmUgfSBmcm9tICcuL2VuZ2luZXMvc2VnbWVudC1lbmdpbmUnO1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFNlcXVlbmNlckVuZ2luZSB9IGZyb20gJy4vZW5naW5lcy9zZXF1ZW5jZXItZW5naW5lJztcclxuZXhwb3J0IHsgZGVmYXVsdCBhcyBQaGFzZXZvY29kZXJFbmdpbmUgfSBmcm9tICcuL2VuZ2luZXMvcGhhc2V2b2NvZGVyLWVuZ2luZSc7XHJcbmV4cG9ydCB7ZGVmYXVsdCBhcyBQdWxzZUZGVFRyYW5zZm9ybXMgfSBmcm9tICcuL3V0aWxzL3B1bHNlLXRyYW5zZm9ybXMnO1xyXG5cclxuLy8gbWFzdGVyc1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIFBsYXlDb250cm9sIH0gZnJvbSAnLi9tYXN0ZXJzL3BsYXktY29udHJvbCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVHJhbnNwb3J0IH0gZnJvbSAnLi9tYXN0ZXJzL3RyYW5zcG9ydCc7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2NoZWR1bGVyIH0gZnJvbSAnLi9tYXN0ZXJzL3NjaGVkdWxlcic7XHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2ltcGxlU2NoZWR1bGVyIH0gZnJvbSAnLi9tYXN0ZXJzL3NpbXBsZS1zY2hlZHVsZXInO1xyXG5cclxuLy8gZmFjdG9yaWVzXHJcbmV4cG9ydCB7IGdldFNjaGVkdWxlciB9IGZyb20gJy4vbWFzdGVycy9mYWN0b3JpZXMnO1xyXG5leHBvcnQgeyBnZXRTaW1wbGVTY2hlZHVsZXIgfSBmcm9tICcuL21hc3RlcnMvZmFjdG9yaWVzJztcclxuIiwiLy8gc2NoZWR1bGVycyBzaG91bGQgYmUgc2luZ2xldG9uc1xyXG5pbXBvcnQgZGVmYXVsdEF1ZGlvQ29udGV4dCBmcm9tICcuLi9jb3JlL2F1ZGlvLWNvbnRleHQnO1xyXG5pbXBvcnQgU2NoZWR1bGVyIGZyb20gJy4vc2NoZWR1bGVyJztcclxuaW1wb3J0IFNpbXBsZVNjaGVkdWxlciBmcm9tICcuL3NpbXBsZS1zY2hlZHVsZXInO1xyXG5cclxuY29uc3Qgc2NoZWR1bGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuY29uc3Qgc2ltcGxlU2NoZWR1bGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgdW5pcXVlIGluc3RhbmNlIG9mIGBTY2hlZHVsZXJgXHJcbiAqXHJcbiAqIEBnbG9iYWxcclxuICogQGZ1bmN0aW9uXHJcbiAqIEByZXR1cm5zIHtTY2hlZHVsZXJ9XHJcbiAqIEBzZWUgU2NoZWR1bGVyXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZ2V0U2NoZWR1bGVyID0gZnVuY3Rpb24oYXVkaW9Db250ZXh0ID0gZGVmYXVsdEF1ZGlvQ29udGV4dCkge1xyXG4gIGxldCBzY2hlZHVsZXIgPSBzY2hlZHVsZXJNYXAuZ2V0KGF1ZGlvQ29udGV4dCk7XHJcblxyXG4gIGlmICghc2NoZWR1bGVyKSB7XHJcbiAgICBzY2hlZHVsZXIgPSBuZXcgU2NoZWR1bGVyKHsgYXVkaW9Db250ZXh0OiBhdWRpb0NvbnRleHQgfSk7XHJcbiAgICBzY2hlZHVsZXJNYXAuc2V0KGF1ZGlvQ29udGV4dCwgc2NoZWR1bGVyKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzY2hlZHVsZXI7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHVuaXF1ZSBpbnN0YW5jZSBvZiBgU2ltcGxlU2NoZWR1bGVyYFxyXG4gKlxyXG4gKiBAZ2xvYmFsXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7U2ltcGxlU2NoZWR1bGVyfVxyXG4gKiBAc2VlIFNpbXBsZVNjaGVkdWxlclxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGdldFNpbXBsZVNjaGVkdWxlciA9IGZ1bmN0aW9uKGF1ZGlvQ29udGV4dCA9IGRlZmF1bHRBdWRpb0NvbnRleHQpIHtcclxuICBsZXQgc2ltcGxlU2NoZWR1bGVyID0gc2ltcGxlU2NoZWR1bGVyTWFwLmdldChhdWRpb0NvbnRleHQpO1xyXG5cclxuICBpZiAoIXNpbXBsZVNjaGVkdWxlcikge1xyXG4gICAgc2ltcGxlU2NoZWR1bGVyID0gbmV3IFNpbXBsZVNjaGVkdWxlcih7IGF1ZGlvQ29udGV4dDogYXVkaW9Db250ZXh0IH0pO1xyXG4gICAgc2ltcGxlU2NoZWR1bGVyTWFwLnNldChhdWRpb0NvbnRleHQsIHNpbXBsZVNjaGVkdWxlcik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc2ltcGxlU2NoZWR1bGVyO1xyXG59O1xyXG4iLCJpbXBvcnQgZGVmYXVsdEF1ZGlvQ29udGV4dCBmcm9tICcuLi9jb3JlL2F1ZGlvLWNvbnRleHQnO1xyXG5pbXBvcnQgU2NoZWR1bGluZ1F1ZXVlIGZyb20gJy4uL2NvcmUvc2NoZWR1bGluZy1xdWV1ZSc7XHJcbmltcG9ydCBUaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvdGltZS1lbmdpbmUnO1xyXG5pbXBvcnQgeyBnZXRTY2hlZHVsZXIgfSBmcm9tICcuL2ZhY3Rvcmllcyc7XHJcblxyXG5jb25zdCBFUFNJTE9OID0gMWUtODtcclxuXHJcbmNsYXNzIExvb3BDb250cm9sIGV4dGVuZHMgVGltZUVuZ2luZSB7XHJcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wpIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5fX3BsYXlDb250cm9sID0gcGxheUNvbnRyb2w7XHJcbiAgICB0aGlzLnNwZWVkID0gMTtcclxuICAgIHRoaXMubG93ZXIgPSAtSW5maW5pdHk7XHJcbiAgICB0aGlzLnVwcGVyID0gSW5maW5pdHk7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAoc2NoZWR1bGVkIGludGVyZmFjZSlcclxuICBhZHZhbmNlVGltZSh0aW1lKSB7XHJcbiAgICBjb25zdCBwbGF5Q29udHJvbCA9IHRoaXMuX19wbGF5Q29udHJvbDtcclxuICAgIGNvbnN0IHNwZWVkID0gdGhpcy5zcGVlZDtcclxuICAgIGNvbnN0IGxvd2VyID0gdGhpcy5sb3dlcjtcclxuICAgIGNvbnN0IHVwcGVyID0gdGhpcy51cHBlcjtcclxuXHJcbiAgICBpZiAoc3BlZWQgPiAwKVxyXG4gICAgICB0aW1lICs9IEVQU0lMT047XHJcbiAgICBlbHNlXHJcbiAgICAgIHRpbWUgLT0gRVBTSUxPTjtcclxuXHJcbiAgICBpZiAoc3BlZWQgPiAwKSB7XHJcbiAgICAgIHBsYXlDb250cm9sLnN5bmNTcGVlZCh0aW1lLCBsb3dlciwgc3BlZWQsIHRydWUpO1xyXG4gICAgICByZXR1cm4gcGxheUNvbnRyb2wuX19nZXRUaW1lQXRQb3NpdGlvbih1cHBlcikgLSBFUFNJTE9OO1xyXG4gICAgfSBlbHNlIGlmIChzcGVlZCA8IDApIHtcclxuICAgICAgcGxheUNvbnRyb2wuc3luY1NwZWVkKHRpbWUsIHVwcGVyLCBzcGVlZCwgdHJ1ZSk7XHJcbiAgICAgIHJldHVybiBwbGF5Q29udHJvbC5fX2dldFRpbWVBdFBvc2l0aW9uKGxvd2VyKSArIEVQU0lMT047XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEluZmluaXR5O1xyXG4gIH1cclxuXHJcbiAgcmVzY2hlZHVsZShzcGVlZCkge1xyXG4gICAgY29uc3QgcGxheUNvbnRyb2wgPSB0aGlzLl9fcGxheUNvbnRyb2w7XHJcbiAgICBjb25zdCBsb3dlciA9IE1hdGgubWluKHBsYXlDb250cm9sLl9fbG9vcFN0YXJ0LCBwbGF5Q29udHJvbC5fX2xvb3BFbmQpO1xyXG4gICAgY29uc3QgdXBwZXIgPSBNYXRoLm1heChwbGF5Q29udHJvbC5fX2xvb3BTdGFydCwgcGxheUNvbnRyb2wuX19sb29wRW5kKTtcclxuXHJcbiAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XHJcbiAgICB0aGlzLmxvd2VyID0gbG93ZXI7XHJcbiAgICB0aGlzLnVwcGVyID0gdXBwZXI7XHJcblxyXG4gICAgaWYgKGxvd2VyID09PSB1cHBlcilcclxuICAgICAgc3BlZWQgPSAwO1xyXG5cclxuICAgIGlmIChzcGVlZCA+IDApXHJcbiAgICAgIHRoaXMucmVzZXRUaW1lKHBsYXlDb250cm9sLl9fZ2V0VGltZUF0UG9zaXRpb24odXBwZXIpIC0gRVBTSUxPTik7XHJcbiAgICBlbHNlIGlmIChzcGVlZCA8IDApXHJcbiAgICAgIHRoaXMucmVzZXRUaW1lKHBsYXlDb250cm9sLl9fZ2V0VGltZUF0UG9zaXRpb24obG93ZXIpICsgRVBTSUxPTik7XHJcbiAgICBlbHNlXHJcbiAgICAgIHRoaXMucmVzZXRUaW1lKEluZmluaXR5KTtcclxuICB9XHJcblxyXG4gIGFwcGx5TG9vcEJvdW5kYXJpZXMocG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICBjb25zdCBsb3dlciA9IHRoaXMubG93ZXI7XHJcbiAgICBjb25zdCB1cHBlciA9IHRoaXMudXBwZXI7XHJcblxyXG4gICAgaWYgKHNwZWVkID4gMCAmJiBwb3NpdGlvbiA+PSB1cHBlcilcclxuICAgICAgcmV0dXJuIGxvd2VyICsgKHBvc2l0aW9uIC0gbG93ZXIpICUgKHVwcGVyIC0gbG93ZXIpO1xyXG4gICAgZWxzZSBpZiAoc3BlZWQgPCAwICYmIHBvc2l0aW9uIDwgbG93ZXIpXHJcbiAgICAgIHJldHVybiB1cHBlciAtICh1cHBlciAtIHBvc2l0aW9uKSAlICh1cHBlciAtIGxvd2VyKTtcclxuXHJcbiAgICByZXR1cm4gcG9zaXRpb247XHJcbiAgfVxyXG59XHJcblxyXG4vLyBwbGF5IGNvbnRyb2xsZWQgYmFzZSBjbGFzc1xyXG5jbGFzcyBQbGF5Q29udHJvbGxlZCB7XHJcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xyXG4gICAgdGhpcy5fX3BsYXlDb250cm9sID0gcGxheUNvbnRyb2w7XHJcblxyXG4gICAgZW5naW5lLm1hc3RlciA9IHRoaXM7XHJcbiAgICB0aGlzLl9fZW5naW5lID0gZW5naW5lO1xyXG4gIH1cclxuXHJcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlaywgbGFzdFNwZWVkKSB7XHJcbiAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsIHNlZWspO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19wbGF5Q29udHJvbC5jdXJyZW50VGltZTtcclxuICB9XHJcblxyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3BsYXlDb250cm9sLmN1cnJlbnRQb3NpdGlvbjtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2wgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX19lbmdpbmUubWFzdGVyID0gbnVsbDtcclxuICAgIHRoaXMuX19lbmdpbmUgPSBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLy8gcGxheSBjb250cm9sIGZvciBlbmdpbmVzIGltcGxlbWVudGluZyB0aGUgKnNwZWVkLWNvbnRyb2xsZWQqIGludGVyZmFjZVxyXG5jbGFzcyBQbGF5Q29udHJvbGxlZFNwZWVkQ29udHJvbGxlZCBleHRlbmRzIFBsYXlDb250cm9sbGVkIHtcclxuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCwgZW5naW5lKSB7XHJcbiAgICBzdXBlcihwbGF5Q29udHJvbCwgZW5naW5lKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIHBsYXkgY29udHJvbCBmb3IgZW5naW5lcyBpbXBsbWVudGluZyB0aGUgKnRyYW5zcG9ydGVkKiBpbnRlcmZhY2VcclxuY2xhc3MgUGxheUNvbnRyb2xsZWRUcmFuc3BvcnRlZCBleHRlbmRzIFBsYXlDb250cm9sbGVkIHtcclxuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCwgZW5naW5lKSB7XHJcbiAgICBzdXBlcihwbGF5Q29udHJvbCwgZW5naW5lKTtcclxuXHJcbiAgICB0aGlzLl9fc2NoZWR1bGVySG9vayA9IG5ldyBQbGF5Q29udHJvbGxlZFNjaGVkdWxlckhvb2socGxheUNvbnRyb2wsIGVuZ2luZSk7XHJcbiAgfVxyXG5cclxuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrLCBsYXN0U3BlZWQpIHtcclxuICAgIGlmIChzcGVlZCAhPT0gbGFzdFNwZWVkIHx8IChzZWVrICYmIHNwZWVkICE9PSAwKSkge1xyXG4gICAgICB2YXIgbmV4dFBvc2l0aW9uO1xyXG5cclxuICAgICAgLy8gcmVzeW5jIHRyYW5zcG9ydGVkIGVuZ2luZXNcclxuICAgICAgaWYgKHNlZWsgfHwgc3BlZWQgKiBsYXN0U3BlZWQgPCAwKSB7XHJcbiAgICAgICAgLy8gc2VlayBvciByZXZlcnNlIGRpcmVjdGlvblxyXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX19lbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgIH0gZWxzZSBpZiAobGFzdFNwZWVkID09PSAwKSB7XHJcbiAgICAgICAgLy8gc3RhcnRcclxuICAgICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fZW5naW5lLnN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKHNwZWVkID09PSAwKSB7XHJcbiAgICAgICAgLy8gc3RvcFxyXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IEluZmluaXR5O1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQpXHJcbiAgICAgICAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgMCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQpIHtcclxuICAgICAgICAvLyBjaGFuZ2Ugc3BlZWQgd2l0aG91dCByZXZlcnNpbmcgZGlyZWN0aW9uXHJcbiAgICAgICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5fX3NjaGVkdWxlckhvb2sucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmVzZXRFbmdpbmVQb3NpdGlvbihlbmdpbmUsIHBvc2l0aW9uID0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB2YXIgcGxheUNvbnRyb2wgPSB0aGlzLl9fcGxheUNvbnRyb2w7XHJcbiAgICAgIHZhciB0aW1lID0gcGxheUNvbnRyb2wuX19zeW5jKCk7XHJcblxyXG4gICAgICBwb3NpdGlvbiA9IHRoaXMuX19lbmdpbmUuc3luY1Bvc2l0aW9uKHRpbWUsIHBsYXlDb250cm9sLl9fcG9zaXRpb24sIHBsYXlDb250cm9sLl9fc3BlZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX19zY2hlZHVsZXJIb29rLnJlc2V0UG9zaXRpb24ocG9zaXRpb24pO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX19zY2hlZHVsZXJIb29rLmRlc3Ryb3koKTtcclxuICAgIHRoaXMuX19zY2hlZHVsZXJIb29rID0gbnVsbDtcclxuXHJcbiAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBwbGF5IGNvbnRyb2wgZm9yIHRpbWUgZW5naW5lcyBpbXBsZW1lbnRpbmcgdGhlICpzY2hlZHVsZWQqIGludGVyZmFjZVxyXG5jbGFzcyBQbGF5Q29udHJvbGxlZFNjaGVkdWxlZCBleHRlbmRzIFBsYXlDb250cm9sbGVkIHtcclxuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCwgZW5naW5lKSB7XHJcbiAgICBzdXBlcihwbGF5Q29udHJvbCwgZW5naW5lKTtcclxuXHJcbiAgICAvLyBzY2hlZHVsaW5nIHF1ZXVlIGJlY29tZXMgbWFzdGVyIG9mIGVuZ2luZVxyXG4gICAgZW5naW5lLm1hc3RlciA9IG51bGw7XHJcbiAgICB0aGlzLl9fc2NoZWR1bGluZ1F1ZXVlID0gbmV3IFBsYXlDb250cm9sbGVkU2NoZWR1bGluZ1F1ZXVlKHBsYXlDb250cm9sLCBlbmdpbmUpO1xyXG4gIH1cclxuXHJcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCwgc2VlaywgbGFzdFNwZWVkKSB7XHJcbiAgICBpZiAobGFzdFNwZWVkID09PSAwICYmIHNwZWVkICE9PSAwKSAvLyBzdGFydCBvciBzZWVrXHJcbiAgICAgIHRoaXMuX19lbmdpbmUucmVzZXRUaW1lKCk7XHJcbiAgICBlbHNlIGlmIChsYXN0U3BlZWQgIT09IDAgJiYgc3BlZWQgPT09IDApIC8vIHN0b3BcclxuICAgICAgdGhpcy5fX2VuZ2luZS5yZXNldFRpbWUoSW5maW5pdHkpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX19zY2hlZHVsaW5nUXVldWUuZGVzdHJveSgpO1xyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gdHJhbnNsYXRlcyB0cmFuc3BvcnRlZCBlbmdpbmUgYWR2YW5jZVBvc2l0aW9uIGludG8gZ2xvYmFsIHNjaGVkdWxlciB0aW1lc1xyXG5jbGFzcyBQbGF5Q29udHJvbGxlZFNjaGVkdWxlckhvb2sgZXh0ZW5kcyBUaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihwbGF5Q29udHJvbCwgZW5naW5lKSB7XHJcbiAgICBzdXBlcigpO1xyXG5cclxuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IHBsYXlDb250cm9sO1xyXG4gICAgdGhpcy5fX2VuZ2luZSA9IGVuZ2luZTtcclxuXHJcbiAgICB0aGlzLl9fbmV4dFBvc2l0aW9uID0gSW5maW5pdHk7XHJcbiAgICBwbGF5Q29udHJvbC5fX3NjaGVkdWxlci5hZGQodGhpcywgSW5maW5pdHkpO1xyXG4gIH1cclxuXHJcbiAgYWR2YW5jZVRpbWUodGltZSkge1xyXG4gICAgdmFyIHBsYXlDb250cm9sID0gdGhpcy5fX3BsYXlDb250cm9sO1xyXG4gICAgdmFyIGVuZ2luZSA9IHRoaXMuX19lbmdpbmU7XHJcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9fbmV4dFBvc2l0aW9uO1xyXG4gICAgdmFyIG5leHRQb3NpdGlvbiA9IGVuZ2luZS5hZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHBsYXlDb250cm9sLl9fc3BlZWQpO1xyXG4gICAgdmFyIG5leHRUaW1lID0gcGxheUNvbnRyb2wuX19nZXRUaW1lQXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xyXG5cclxuICAgIHRoaXMuX19uZXh0UG9zaXRpb24gPSBuZXh0UG9zaXRpb247XHJcbiAgICByZXR1cm4gbmV4dFRpbWU7XHJcbiAgfVxyXG5cclxuICBnZXQgY3VycmVudFRpbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3BsYXlDb250cm9sLmN1cnJlbnRUaW1lO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcGxheUNvbnRyb2wuY3VycmVudFBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbiA9IHRoaXMuX19uZXh0UG9zaXRpb24pIHtcclxuICAgIHZhciB0aW1lID0gdGhpcy5fX3BsYXlDb250cm9sLl9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pO1xyXG4gICAgdGhpcy5fX25leHRQb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgdGhpcy5yZXNldFRpbWUodGltZSk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5fX3BsYXlDb250cm9sLl9fc2NoZWR1bGVyLnJlbW92ZSh0aGlzKTtcclxuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IG51bGw7XHJcbiAgICB0aGlzLl9fZW5naW5lID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vIGludGVybmFsIHNjaGVkdWxpbmcgcXVldWUgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IHBvc2l0aW9uIChhbmQgdGltZSkgb2YgdGhlIHBsYXkgY29udHJvbFxyXG5jbGFzcyBQbGF5Q29udHJvbGxlZFNjaGVkdWxpbmdRdWV1ZSBleHRlbmRzIFNjaGVkdWxpbmdRdWV1ZSB7XHJcbiAgY29uc3RydWN0b3IocGxheUNvbnRyb2wsIGVuZ2luZSkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMuX19wbGF5Q29udHJvbCA9IHBsYXlDb250cm9sO1xyXG4gICAgdGhpcy5fX2VuZ2luZSA9IGVuZ2luZTtcclxuXHJcbiAgICB0aGlzLmFkZChlbmdpbmUsIEluZmluaXR5KTtcclxuICAgIHBsYXlDb250cm9sLl9fc2NoZWR1bGVyLmFkZCh0aGlzLCBJbmZpbml0eSk7XHJcbiAgfVxyXG5cclxuICBnZXQgY3VycmVudFRpbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3BsYXlDb250cm9sLmN1cnJlbnRUaW1lO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcGxheUNvbnRyb2wuY3VycmVudFBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX19wbGF5Q29udHJvbC5fX3NjaGVkdWxlci5yZW1vdmUodGhpcyk7XHJcbiAgICB0aGlzLnJlbW92ZSh0aGlzLl9fZW5naW5lKTtcclxuXHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2wgPSBudWxsO1xyXG4gICAgdGhpcy5fX2VuZ2luZSA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEV4dGVuZHMgVGltZSBFbmdpbmUgdG8gcHJvdmlkZSBwbGF5YmFjayBjb250cm9sIG9mIGEgVGltZSBFbmdpbmUgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIFtleGFtcGxlXXtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvcGxheS1jb250cm9sLmh0bWx9XHJcbiAqXHJcbiAqIEBleHRlbmRzIFRpbWVFbmdpbmVcclxuICogQHBhcmFtIHtUaW1lRW5naW5lfSBlbmdpbmUgLSBlbmdpbmUgdG8gY29udHJvbFxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBpbXBvcnQgKiBhcyBhdWRpbyBmcm9tICd3YXZlcy1hdWRpbyc7XHJcbiAqIGNvbnN0IHBsYXllckVuZ2luZSA9IGF1ZGlvLlBsYXllckVuZ2luZSgpO1xyXG4gKiBjb25zdCBwbGF5Q29udHJvbCA9IG5ldyBhdWRpby5QbGF5Q29udHJvbChwbGF5ZXJFbmdpbmUpO1xyXG4gKlxyXG4gKiBwbGF5Q29udHJvbC5zdGFydCgpO1xyXG4gKi9cclxuY2xhc3MgUGxheUNvbnRyb2wgZXh0ZW5kcyBUaW1lRW5naW5lIHtcclxuICBjb25zdHJ1Y3RvcihlbmdpbmUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IG9wdGlvbnMuYXVkaW9Db250ZXh0IHx8IGRlZmF1bHRBdWRpb0NvbnRleHQ7XHJcbiAgICB0aGlzLl9fc2NoZWR1bGVyID0gZ2V0U2NoZWR1bGVyKHRoaXMuYXVkaW9Db250ZXh0KTtcclxuXHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX19sb29wQ29udHJvbCA9IG51bGw7XHJcbiAgICB0aGlzLl9fbG9vcFN0YXJ0ID0gMDtcclxuICAgIHRoaXMuX19sb29wRW5kID0gMTtcclxuXHJcbiAgICAvLyBzeW5jaHJvbml6ZWQgdGllLCBwb3NpdGlvbiwgYW5kIHNwZWVkXHJcbiAgICB0aGlzLl9fdGltZSA9IDA7XHJcbiAgICB0aGlzLl9fcG9zaXRpb24gPSAwO1xyXG4gICAgdGhpcy5fX3NwZWVkID0gMDtcclxuXHJcbiAgICAvLyBub24temVybyBcInVzZXJcIiBzcGVlZFxyXG4gICAgdGhpcy5fX3BsYXlpbmdTcGVlZCA9IDE7XHJcblxyXG4gICAgaWYgKGVuZ2luZSlcclxuICAgICAgdGhpcy5fX3NldEVuZ2luZShlbmdpbmUpO1xyXG4gIH1cclxuXHJcbiAgX19zZXRFbmdpbmUoZW5naW5lKSB7XHJcbiAgICBpZiAoZW5naW5lLm1hc3RlcilcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQgdG8gYSBtYXN0ZXJcIik7XHJcblxyXG4gICAgaWYgKFRpbWVFbmdpbmUuaW1wbGVtZW50c1NwZWVkQ29udHJvbGxlZChlbmdpbmUpKVxyXG4gICAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQgPSBuZXcgUGxheUNvbnRyb2xsZWRTcGVlZENvbnRyb2xsZWQodGhpcywgZW5naW5lKTtcclxuICAgIGVsc2UgaWYgKFRpbWVFbmdpbmUuaW1wbGVtZW50c1RyYW5zcG9ydGVkKGVuZ2luZSkpXHJcbiAgICAgIHRoaXMuX19wbGF5Q29udHJvbGxlZCA9IG5ldyBQbGF5Q29udHJvbGxlZFRyYW5zcG9ydGVkKHRoaXMsIGVuZ2luZSk7XHJcbiAgICBlbHNlIGlmIChUaW1lRW5naW5lLmltcGxlbWVudHNTY2hlZHVsZWQoZW5naW5lKSlcclxuICAgICAgdGhpcy5fX3BsYXlDb250cm9sbGVkID0gbmV3IFBsYXlDb250cm9sbGVkU2NoZWR1bGVkKHRoaXMsIGVuZ2luZSk7XHJcbiAgICBlbHNlXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBjYW5ub3QgYmUgYWRkZWQgdG8gcGxheSBjb250cm9sXCIpO1xyXG4gIH1cclxuXHJcbiAgX19yZXNldEVuZ2luZSgpIHtcclxuICAgIHRoaXMuX19wbGF5Q29udHJvbGxlZC5kZXN0cm95KCk7XHJcbiAgICB0aGlzLl9fcGxheUNvbnRyb2xsZWQgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlL2V4dHJhcG9sYXRlIHBsYXlpbmcgdGltZSBmb3IgZ2l2ZW4gcG9zaXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiBwb3NpdGlvblxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gZXh0cmFwb2xhdGVkIHRpbWVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgIHJldHVybiB0aGlzLl9fdGltZSArIChwb3NpdGlvbiAtIHRoaXMuX19wb3NpdGlvbikgLyB0aGlzLl9fc3BlZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUvZXh0cmFwb2xhdGUgcGxheWluZyBwb3NpdGlvbiBmb3IgZ2l2ZW4gdGltZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgdGltZVxyXG4gICAqIEByZXR1cm4ge051bWJlcn0gZXh0cmFwb2xhdGVkIHBvc2l0aW9uXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfX2dldFBvc2l0aW9uQXRUaW1lKHRpbWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcG9zaXRpb24gKyAodGltZSAtIHRoaXMuX190aW1lKSAqIHRoaXMuX19zcGVlZDtcclxuICB9XHJcblxyXG4gIF9fc3luYygpIHtcclxuICAgIGNvbnN0IG5vdyA9IHRoaXMuY3VycmVudFRpbWU7XHJcbiAgICB0aGlzLl9fcG9zaXRpb24gKz0gKG5vdyAtIHRoaXMuX190aW1lKSAqIHRoaXMuX19zcGVlZDtcclxuICAgIHRoaXMuX190aW1lID0gbm93O1xyXG4gICAgcmV0dXJuIG5vdztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IG1hc3RlciB0aW1lLlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSByZXBsYWNlZCB3aGVuIHRoZSBwbGF5LWNvbnRyb2wgaXMgYWRkZWQgdG8gYSBtYXN0ZXIuXHJcbiAgICpcclxuICAgKiBAbmFtZSBjdXJyZW50VGltZVxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19zY2hlZHVsZXIuY3VycmVudFRpbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY3VycmVudCBtYXN0ZXIgcG9zaXRpb24uXHJcbiAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIHJlcGxhY2VkIHdoZW4gdGhlIHBsYXktY29udHJvbCBpcyBhZGRlZCB0byBhIG1hc3Rlci5cclxuICAgKlxyXG4gICAqIEBuYW1lIGN1cnJlbnRQb3NpdGlvblxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG1lbWJlcm9mIFBsYXlDb250cm9sXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl9fcG9zaXRpb24gKyAodGhpcy5fX3NjaGVkdWxlci5jdXJyZW50VGltZSAtIHRoaXMuX190aW1lKSAqIHRoaXMuX19zcGVlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgaWYgdGhlIHBsYXkgY29udHJvbCBpcyBydW5uaW4gZy5cclxuICAgKlxyXG4gICAqIEBuYW1lIHJ1bm5pbmdcclxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgKiBAbWVtYmVyb2YgUGxheUNvbnRyb2xcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcnVubmluZygpIHtcclxuICAgIHJldHVybiAhKHRoaXMuX19zcGVlZCA9PT0gMCk7XHJcbiAgfVxyXG5cclxuICBzZXQoZW5naW5lID0gbnVsbCkge1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XHJcbiAgICBjb25zdCBzcGVlZCA9IHRoaXMuX19zcGVlZDtcclxuXHJcbiAgICBpZiAodGhpcy5fX3BsYXlDb250cm9sbGVkICE9PSBudWxsICYmIHRoaXMuX19wbGF5Q29udHJvbGxlZC5fX2VuZ2luZSAhPT0gZW5naW5lKSB7XHJcblxyXG4gICAgICB0aGlzLnN5bmNTcGVlZCh0aW1lLCB0aGlzLl9fcG9zaXRpb24sIDApO1xyXG5cclxuICAgICAgaWYgKHRoaXMuX19wbGF5Q29udHJvbGxlZClcclxuICAgICAgICB0aGlzLl9fcmVzZXRFbmdpbmUoKTtcclxuXHJcblxyXG4gICAgICBpZiAodGhpcy5fX3BsYXlDb250cm9sbGVkID09PSBudWxsICYmIGVuZ2luZSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuX19zZXRFbmdpbmUoZW5naW5lKTtcclxuXHJcbiAgICAgICAgaWYgKHNwZWVkICE9PSAwKVxyXG4gICAgICAgICAgdGhpcy5zeW5jU3BlZWQodGltZSwgdGhpcy5fX3Bvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHBsYXkgY29udHJvbCBsb29wIGJlaGF2aW9yLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICogQG5hbWUgbG9vcFxyXG4gICAqIEBtZW1iZXJvZiBQbGF5Q29udHJvbFxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBsb29wKGVuYWJsZSkge1xyXG4gICAgaWYgKGVuYWJsZSAmJiB0aGlzLl9fbG9vcFN0YXJ0ID4gLUluZmluaXR5ICYmIHRoaXMuX19sb29wRW5kIDwgSW5maW5pdHkpIHtcclxuICAgICAgaWYgKCF0aGlzLl9fbG9vcENvbnRyb2wpIHtcclxuICAgICAgICB0aGlzLl9fbG9vcENvbnRyb2wgPSBuZXcgTG9vcENvbnRyb2wodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fX3NjaGVkdWxlci5hZGQodGhpcy5fX2xvb3BDb250cm9sLCBJbmZpbml0eSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aGlzLl9fc3BlZWQgIT09IDApIHtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuY3VycmVudFBvc2l0aW9uO1xyXG4gICAgICAgIGNvbnN0IGxvd2VyID0gTWF0aC5taW4odGhpcy5fX2xvb3BTdGFydCwgdGhpcy5fX2xvb3BFbmQpO1xyXG4gICAgICAgIGNvbnN0IHVwcGVyID0gTWF0aC5tYXgodGhpcy5fX2xvb3BTdGFydCwgdGhpcy5fX2xvb3BFbmQpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fX3NwZWVkID4gMCAmJiBwb3NpdGlvbiA+IHVwcGVyKVxyXG4gICAgICAgICAgdGhpcy5zZWVrKHVwcGVyKTtcclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9fc3BlZWQgPCAwICYmIHBvc2l0aW9uIDwgbG93ZXIpXHJcbiAgICAgICAgICB0aGlzLnNlZWsobG93ZXIpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIHRoaXMuX19sb29wQ29udHJvbC5yZXNjaGVkdWxlKHRoaXMuX19zcGVlZCk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAodGhpcy5fX2xvb3BDb250cm9sKSB7XHJcbiAgICAgIHRoaXMuX19zY2hlZHVsZXIucmVtb3ZlKHRoaXMuX19sb29wQ29udHJvbCk7XHJcbiAgICAgIHRoaXMuX19sb29wQ29udHJvbCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgbG9vcCgpIHtcclxuICAgIHJldHVybiAoISF0aGlzLl9fbG9vcENvbnRyb2wpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBsb29wIHN0YXJ0IGFuZCBlbmQgdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsb29wU3RhcnQgLSBsb29wIHN0YXJ0IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsb29wRW5kIC0gbG9vcCBlbmQgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0TG9vcEJvdW5kYXJpZXMobG9vcFN0YXJ0LCBsb29wRW5kKSB7XHJcbiAgICB0aGlzLl9fbG9vcFN0YXJ0ID0gbG9vcFN0YXJ0O1xyXG4gICAgdGhpcy5fX2xvb3BFbmQgPSBsb29wRW5kO1xyXG5cclxuICAgIHRoaXMubG9vcCA9IHRoaXMubG9vcDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbG9vcCBzdGFydCB2YWx1ZVxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbmFtZSBsb29wU3RhcnRcclxuICAgKiBAbWVtYmVyb2YgUGxheUNvbnRyb2xcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKi9cclxuICBzZXQgbG9vcFN0YXJ0KGxvb3BTdGFydCkge1xyXG4gICAgdGhpcy5zZXRMb29wQm91bmRhcmllcyhsb29wU3RhcnQsIHRoaXMuX19sb29wRW5kKTtcclxuICB9XHJcblxyXG4gIGdldCBsb29wU3RhcnQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX2xvb3BTdGFydDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgbG9vcCBlbmQgdmFsdWVcclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG5hbWUgbG9vcEVuZFxyXG4gICAqIEBtZW1iZXJvZiBQbGF5Q29udHJvbFxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBsb29wRW5kKGxvb3BFbmQpIHtcclxuICAgIHRoaXMuc2V0TG9vcEJvdW5kYXJpZXModGhpcy5fX2xvb3BTdGFydCwgbG9vcEVuZCk7XHJcbiAgfVxyXG5cclxuICBnZXQgbG9vcEVuZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9fbG9vcEVuZDtcclxuICB9XHJcblxyXG4gIC8vIFRpbWVFbmdpbmUgbWV0aG9kIChzcGVlZC1jb250cm9sbGVkIGludGVyZmFjZSlcclxuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGxhc3RTcGVlZCA9IHRoaXMuX19zcGVlZDtcclxuXHJcbiAgICBpZiAoc3BlZWQgIT09IGxhc3RTcGVlZCB8fCBzZWVrKSB7XHJcbiAgICAgIGlmICgoc2VlayB8fCBsYXN0U3BlZWQgPT09IDApICYmIHRoaXMuX19sb29wQ29udHJvbClcclxuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX19sb29wQ29udHJvbC5hcHBseUxvb3BCb3VuZGFyaWVzKHBvc2l0aW9uLCBzcGVlZCk7XHJcblxyXG4gICAgICB0aGlzLl9fdGltZSA9IHRpbWU7XHJcbiAgICAgIHRoaXMuX19wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICB0aGlzLl9fc3BlZWQgPSBzcGVlZDtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9fcGxheUNvbnRyb2xsZWQpXHJcbiAgICAgICAgdGhpcy5fX3BsYXlDb250cm9sbGVkLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQsIHNlZWssIGxhc3RTcGVlZCk7XHJcblxyXG4gICAgICBpZiAodGhpcy5fX2xvb3BDb250cm9sKVxyXG4gICAgICAgIHRoaXMuX19sb29wQ29udHJvbC5yZXNjaGVkdWxlKHNwZWVkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0cyBwbGF5YmFja1xyXG4gICAqL1xyXG4gIHN0YXJ0KCkge1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XHJcbiAgICB0aGlzLnN5bmNTcGVlZCh0aW1lLCB0aGlzLl9fcG9zaXRpb24sIHRoaXMuX19wbGF5aW5nU3BlZWQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2VzIHBsYXliYWNrIGFuZCBzdGF5cyBhdCB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICAgKi9cclxuICBwYXVzZSgpIHtcclxuICAgIGNvbnN0IHRpbWUgPSB0aGlzLl9fc3luYygpO1xyXG4gICAgdGhpcy5zeW5jU3BlZWQodGltZSwgdGhpcy5fX3Bvc2l0aW9uLCAwKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3BzIHBsYXliYWNrIGFuZCBzZWVrcyB0byBpbml0aWFsICgwKSBwb3NpdGlvbi5cclxuICAgKi9cclxuICBzdG9wKCkge1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XHJcbiAgICB0aGlzLnN5bmNTcGVlZCh0aW1lLCAwLCAwLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIElmIHNwZWVkIGlmIHByb3ZpZGVkLCBzZXRzIHRoZSBwbGF5YmFjayBzcGVlZC4gVGhlIHNwZWVkIHZhbHVlIHNob3VsZFxyXG4gICAqIGJlIG5vbi16ZXJvIGJldHdlZW4gLTE2IGFuZCAtMS8xNiBvciBiZXR3ZWVuIDEvMTYgYW5kIDE2LlxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbmFtZSBzcGVlZFxyXG4gICAqIEBtZW1iZXJvZiBQbGF5Q29udHJvbFxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqL1xyXG4gIHNldCBzcGVlZChzcGVlZCkge1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XHJcblxyXG4gICAgaWYgKHNwZWVkID49IDApIHtcclxuICAgICAgaWYgKHNwZWVkIDwgMC4wMSlcclxuICAgICAgICBzcGVlZCA9IDAuMDE7XHJcbiAgICAgIGVsc2UgaWYgKHNwZWVkID4gMTAwKVxyXG4gICAgICAgIHNwZWVkID0gMTAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHNwZWVkIDwgLTEwMClcclxuICAgICAgICBzcGVlZCA9IC0xMDA7XHJcbiAgICAgIGVsc2UgaWYgKHNwZWVkID4gLTAuMDEpXHJcbiAgICAgICAgc3BlZWQgPSAtMC4wMTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9fcGxheWluZ1NwZWVkID0gc3BlZWQ7XHJcblxyXG4gICAgaWYgKCF0aGlzLm1hc3RlciAmJiB0aGlzLl9fc3BlZWQgIT09IDApXHJcbiAgICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIHRoaXMuX19wb3NpdGlvbiwgc3BlZWQpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHNwZWVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19wbGF5aW5nU3BlZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgKGp1bXAgdG8pIHBsYXlpbmcgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gdGFyZ2V0IHBvc2l0aW9uXHJcbiAgICovXHJcbiAgc2Vlayhwb3NpdGlvbikge1xyXG4gICAgY29uc3QgdGltZSA9IHRoaXMuX19zeW5jKCk7XHJcbiAgICB0aGlzLl9fcG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIHRoaXMuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCB0aGlzLl9fc3BlZWQsIHRydWUpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUGxheUNvbnRyb2w7XHJcbiIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XHJcbmltcG9ydCBkZWZhdWx0QXVkaW9Db250ZXh0IGZyb20gJy4uL2NvcmUvYXVkaW8tY29udGV4dCc7XHJcbmltcG9ydCBTY2hlZHVsaW5nUXVldWUgZnJvbSAnLi4vY29yZS9zY2hlZHVsaW5nLXF1ZXVlJztcclxuXHJcbmNvbnN0IGxvZyA9IGRlYnVnKCd3YXZlc2pzOmF1ZGlvJyk7XHJcblxyXG4vKipcclxuICogVGhlIGBTY2hlZHVsZXJgIGNsYXNzIGltcGxlbWVudHMgYSBtYXN0ZXIgZm9yIGBUaW1lRW5naW5lYCBvciBgQXVkaW9UaW1lRW5naW5lYFxyXG4gKiBpbnN0YW5jZXMgdGhhdCBpbXBsZW1lbnQgdGhlICpzY2hlZHVsZWQqIGludGVyZmFjZSBzdWNoIGFzIHRoZSBgTWV0cm9ub21lYFxyXG4gKiBgR3JhbnVsYXJFbmdpbmVgLlxyXG4gKlxyXG4gKiBBIGBTY2hlZHVsZXJgIGNhbiBhbHNvIHNjaGVkdWxlIHNpbXBsZSBjYWxsYmFjayBmdW5jdGlvbnMuXHJcbiAqIFRoZSBjbGFzcyBpcyBiYXNlZCBvbiByZWN1cnNpdmUgY2FsbHMgdG8gYHNldFRpbWVPdXRgIGFuZCB1c2VzIHRoZVxyXG4gKiBgYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lYCBhcyBsb2dpY2FsIHBhc3NlZCB0byB0aGUgYGFkdmFuY2VUaW1lYCBtZXRob2RzXHJcbiAqIG9mIHRoZSBzY2hlZHVsZWQgZW5naW5lcyBvciB0byB0aGUgc2NoZWR1bGVkIGNhbGxiYWNrIGZ1bmN0aW9ucy5cclxuICogSXQgZXh0ZW5kcyB0aGUgYFNjaGVkdWxpbmdRdWV1ZWAgY2xhc3MgdGhhdCBpdHNlbGYgaW5jbHVkZXMgYSBgUHJpb3JpdHlRdWV1ZWBcclxuICogdG8gYXNzdXJlIHRoZSBvcmRlciBvZiB0aGUgc2NoZWR1bGVkIGVuZ2luZXMgKHNlZSBgU2ltcGxlU2NoZWR1bGVyYCBmb3IgYVxyXG4gKiBzaW1wbGlmaWVkIHNjaGVkdWxlciBpbXBsZW1lbnRhdGlvbiB3aXRob3V0IGBQcmlvcml0eVF1ZXVlYCkuXHJcbiAqXHJcbiAqIFRvIGdldCBhIHVuaXF1ZSBpbnN0YW5jZSBvZiBgU2NoZWR1bGVyYCBhcyB0aGUgZ2xvYmFsIHNjaGVkdWxlciBvZiBhblxyXG4gKiBhcHBsaWNhdGlvbiwgdGhlIGBnZXRTY2hlZHVsZXJgIGZhY3RvcnkgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQuIFRoZVxyXG4gKiBmdW5jdGlvbiBhY2NlcHRzIGFuIGF1ZGlvIGNvbnRleHQgYXMgb3B0aW9uYWwgYXJndW1lbnQgYW5kIHVzZXMgdGhlIFdhdmVzXHJcbiAqIGRlZmF1bHQgYXVkaW8gY29udGV4dCAoc2VlIGBhdWRpb0NvbnRleHRgKSBhc1xyXG4gKiBkZWZhdWx0LiBUaGUgZmFjdG9yeSBjcmVhdGVzIGEgc2luZ2xlIHNjaGVkdWxlciBmb3IgZWFjaCBhdWRpbyBjb250ZXh0LlxyXG4gKlxyXG4gKiBFeGFtcGxlIHRoYXQgc2hvd3MgdGhyZWUgTWV0cm9ub21lIGVuZ2luZXMgcnVubmluZyBpbiBhIFNjaGVkdWxlcjpcclxuICoge0BsaW5rIGh0dHBzOi8vcmF3Z2l0LmNvbS93YXZlc2pzL3dhdmVzLWF1ZGlvL21hc3Rlci9leGFtcGxlcy9zY2hlZHVsZXIuaHRtbH1cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kPTAuMDI1XSAtIHBlcmlvZCBvZiB0aGUgc2NoZWR1bGVyLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubG9va2FoZWFkPTAuMV0gLSBsb29rYWhlYWQgb2YgdGhlIHNjaGVkdWxlci5cclxuICpcclxuICogQHNlZSBUaW1lRW5naW5lXHJcbiAqIEBzZWUgQXVkaW9UaW1lRW5naW5lXHJcbiAqIEBzZWUgZ2V0U2NoZWR1bGVyXHJcbiAqIEBzZWUgU2ltcGxlU2NoZWR1bGVyXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2NoZWR1bGVyKCk7XHJcbiAqXHJcbiAqIHNjaGVkdWxlci5hZGQobXlFbmdpbmUpO1xyXG4gKi9cclxuY2xhc3MgU2NoZWR1bGVyIGV4dGVuZHMgU2NoZWR1bGluZ1F1ZXVlIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKCk7XHJcblxyXG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBvcHRpb25zLmF1ZGlvQ29udGV4dCB8fCDCoGRlZmF1bHRBdWRpb0NvbnRleHQ7XHJcblxyXG4gICAgdGhpcy5fX2N1cnJlbnRUaW1lID0gbnVsbDtcclxuICAgIHRoaXMuX19uZXh0VGltZSA9IEluZmluaXR5O1xyXG4gICAgdGhpcy5fX3RpbWVvdXQgPSBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogc2NoZWR1bGVyIChzZXRUaW1lb3V0KSBwZXJpb2RcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAbmFtZSBwZXJpb2RcclxuICAgICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICB0aGlzLnBlcmlvZCA9IG9wdGlvbnMucGVyaW9kIHx8IMKgMC4wMjU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBzY2hlZHVsZXIgbG9va2FoZWFkIHRpbWUgKD4gcGVyaW9kKVxyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBuYW1lIGxvb2thaGVhZFxyXG4gICAgICogQG1lbWJlcm9mIFNjaGVkdWxlclxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHRoaXMubG9va2FoZWFkID0gb3B0aW9ucy5sb29rYWhlYWQgfHwgwqAwLjE7XHJcbiAgfVxyXG5cclxuICAvLyBzZXRUaW1lb3V0IHNjaGVkdWxpbmcgbG9vcFxyXG4gIF9fdGljaygpIHtcclxuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHRoaXMuYXVkaW9Db250ZXh0O1xyXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBhdWRpb0NvbnRleHQuY3VycmVudFRpbWU7XHJcbiAgICBsZXQgdGltZSA9IHRoaXMuX19uZXh0VGltZTtcclxuXHJcbiAgICB0aGlzLl9fdGltZW91dCA9IG51bGw7XHJcblxyXG4gICAgd2hpbGUgKHRpbWUgPD0gY3VycmVudFRpbWUgKyB0aGlzLmxvb2thaGVhZCkge1xyXG4gICAgICB0aGlzLl9fY3VycmVudFRpbWUgPSB0aW1lO1xyXG4gICAgICB0aW1lID0gdGhpcy5hZHZhbmNlVGltZSh0aW1lKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9fY3VycmVudFRpbWUgPSBudWxsO1xyXG4gICAgdGhpcy5yZXNldFRpbWUodGltZSk7XHJcbiAgfVxyXG5cclxuICByZXNldFRpbWUodGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcclxuICAgIGlmICh0aGlzLm1hc3Rlcikge1xyXG4gICAgICB0aGlzLm1hc3Rlci5yZXNldCh0aGlzLCB0aW1lKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmICh0aGlzLl9fdGltZW91dCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9fdGltZW91dCk7XHJcbiAgICAgICAgdGhpcy5fX3RpbWVvdXQgPSBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodGltZSAhPT0gSW5maW5pdHkpIHtcclxuICAgICAgICBpZiAodGhpcy5fX25leHRUaW1lID09PSBJbmZpbml0eSlcclxuICAgICAgICAgIGxvZygnU2NoZWR1bGVyIFN0YXJ0Jyk7XHJcblxyXG4gICAgICAgIGNvbnN0IHRpbWVPdXREZWxheSA9IE1hdGgubWF4KCh0aW1lIC0gdGhpcy5sb29rYWhlYWQgLSB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSksIHRoaXMucGVyaW9kKTtcclxuXHJcbiAgICAgICAgdGhpcy5fX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX190aWNrKCk7XHJcbiAgICAgICAgfSwgTWF0aC5jZWlsKHRpbWVPdXREZWxheSAqIDEwMDApKTtcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9fbmV4dFRpbWUgIT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgbG9nKCdTY2hlZHVsZXIgU3RvcCcpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9fbmV4dFRpbWUgPSB0aW1lO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2NoZWR1bGVyIGN1cnJlbnQgbG9naWNhbCB0aW1lLlxyXG4gICAqXHJcbiAgICogQG5hbWUgY3VycmVudFRpbWVcclxuICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKi9cclxuICBnZXQgY3VycmVudFRpbWUoKSB7XHJcbiAgICBpZiAodGhpcy5tYXN0ZXIpXHJcbiAgICAgIHJldHVybiB0aGlzLm1hc3Rlci5jdXJyZW50VGltZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fX2N1cnJlbnRUaW1lIHx8IHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lICsgdGhpcy5sb29rYWhlYWQ7XHJcbiAgfVxyXG5cclxuICBnZXQgY3VycmVudFBvc2l0aW9uKCkge1xyXG4gICAgY29uc3QgbWFzdGVyID0gdGhpcy5tYXN0ZXI7XHJcblxyXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHJldHVybiBtYXN0ZXIuY3VycmVudFBvc2l0aW9uO1xyXG5cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvLyBpbmhlcml0ZWQgZnJvbSBzY2hlZHVsaW5nIHF1ZXVlXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgVGltZUVuZ2luZSBvciBhIHNpbXBsZSBjYWxsYmFjayBmdW5jdGlvbiB0byB0aGUgc2NoZWR1bGVyIGF0IGFuXHJcbiAgICogb3B0aW9uYWxseSBnaXZlbiB0aW1lLiBXaGV0aGVyIHRoZSBhZGQgbWV0aG9kIGlzIGNhbGxlZCB3aXRoIGEgVGltZUVuZ2luZVxyXG4gICAqIG9yIGEgY2FsbGJhY2sgZnVuY3Rpb24gaXQgcmV0dXJucyBhIFRpbWVFbmdpbmUgdGhhdCBjYW4gYmUgdXNlZCBhcyBhcmd1bWVudFxyXG4gICAqIG9mIHRoZSBtZXRob2RzIHJlbW92ZSBhbmQgcmVzZXRFbmdpbmVUaW1lLiBBIFRpbWVFbmdpbmUgYWRkZWQgdG8gYSBzY2hlZHVsZXJcclxuICAgKiBoYXMgdG8gaW1wbGVtZW50IHRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlLiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gYWRkZWQgdG8gYVxyXG4gICAqIHNjaGVkdWxlciB3aWxsIGJlIGNhbGxlZCBhdCB0aGUgZ2l2ZW4gdGltZSBhbmQgd2l0aCB0aGUgZ2l2ZW4gdGltZSBhc1xyXG4gICAqIGFyZ3VtZW50LiBUaGUgY2FsbGJhY2sgY2FuIHJldHVybiBhIG5ldyBzY2hlZHVsaW5nIHRpbWUgKGkuZS4gdGhlIG5leHRcclxuICAgKiB0aW1lIHdoZW4gaXQgd2lsbCBiZSBjYWxsZWQpIG9yIGl0IGNhbiByZXR1cm4gSW5maW5pdHkgdG8gc3VzcGVuZCBzY2hlZHVsaW5nXHJcbiAgICogd2l0aG91dCByZW1vdmluZyB0aGUgZnVuY3Rpb24gZnJvbSB0aGUgc2NoZWR1bGVyLiBBIGZ1bmN0aW9uIHRoYXQgZG9lc1xyXG4gICAqIG5vdCByZXR1cm4gYSB2YWx1ZSAob3IgcmV0dXJucyBudWxsIG9yIDApIGlzIHJlbW92ZWQgZnJvbSB0aGUgc2NoZWR1bGVyXHJcbiAgICogYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGFyZ3VtZW50IG9mIHRoZSBtZXRob2RzIHJlbW92ZSBhbmQgcmVzZXRFbmdpbmVUaW1lXHJcbiAgICogYW55bW9yZS5cclxuICAgKlxyXG4gICAqIEBuYW1lIGFkZFxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV8RnVuY3Rpb259IGVuZ2luZSAtIEVuZ2luZSB0byBhZGQgdG8gdGhlIHNjaGVkdWxlclxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZT10aGlzLmN1cnJlbnRUaW1lXSAtIFNjaGVkdWxlIHRpbWVcclxuICAgKi9cclxuICAvKipcclxuICAgKiBSZW1vdmUgYSBUaW1lRW5naW5lIGZyb20gdGhlIHNjaGVkdWxlciB0aGF0IGhhcyBiZWVuIGFkZGVkIHRvIHRoZVxyXG4gICAqIHNjaGVkdWxlciB1c2luZyB0aGUgYWRkIG1ldGhvZC5cclxuICAgKlxyXG4gICAqIEBuYW1lIGFkZFxyXG4gICAqIEBmdW5jdGlvblxyXG4gICAqIEBtZW1iZXJvZiBTY2hlZHVsZXJcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV9IGVuZ2luZSAtIEVuZ2luZSB0byByZW1vdmUgZnJvbSB0aGUgc2NoZWR1bGVyXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lPXRoaXMuY3VycmVudFRpbWVdIC0gU2NoZWR1bGUgdGltZVxyXG4gICAqL1xyXG4gIC8qKlxyXG4gICAqIFJlc2NoZWR1bGUgYSBzY2hlZHVsZWQgdGltZSBlbmdpbmUgYXQgYSBnaXZlbiB0aW1lLlxyXG4gICAqXHJcbiAgICogQG5hbWUgcmVzZXRFbmdpbmVUaW1lXHJcbiAgICogQGZ1bmN0aW9uXHJcbiAgICogQG1lbWJlcm9mIFNjaGVkdWxlclxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gRW5naW5lIHRvIHJlc2NoZWR1bGVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gdGltZSAtIFNjaGVkdWxlIHRpbWVcclxuICAgKi9cclxuICAvKipcclxuICAgKiBSZW1vdmUgYWxsIHNjaGVkdWxlZCBjYWxsYmFja3MgYW5kIGVuZ2luZXMgZnJvbSB0aGUgc2NoZWR1bGVyLlxyXG4gICAqXHJcbiAgICogQG5hbWUgY2xlYXJcclxuICAgKiBAZnVuY3Rpb25cclxuICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTY2hlZHVsZXI7XHJcbiIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XHJcbmltcG9ydCBkZWZhdWx0QXVkaW9Db250ZXh0IGZyb20gJy4uL2NvcmUvYXVkaW8tY29udGV4dCc7XHJcbmltcG9ydCBUaW1lRW5naW5lIGZyb20gJy4uL2NvcmUvdGltZS1lbmdpbmUnO1xyXG5cclxuY29uc3QgbG9nID0gZGVidWcoJ3dhdmVzanM6YXVkaW8nKTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKlxyXG4gKlxyXG4gKiBUaGUgU2ltcGxlU2NoZWR1bGVyIGNsYXNzIGltcGxlbWVudHMgYSBzaW1wbGlmaWVkIG1hc3RlciBmb3IgdGltZSBlbmdpbmVzXHJcbiAqIChzZWUgVGltZUVuZ2luZSBvciBBdWRpb1RpbWVFbmdpbmUpIHRoYXQgaW1wbGVtZW50IHRoZSBzY2hlZHVsZWQgaW50ZXJmYWNlXHJcbiAqIHN1Y2ggYXMgdGhlIE1ldHJvbm9tZSBhbmQgdGhlIEdyYW51bGFyRW5naW5lLiBUaGUgQVBJIGFuZCBmdW50aW9uYWxpdGllcyBvZlxyXG4gKiB0aGUgU2ltcGxlU2NoZWR1bGVyIGNsYXNzIGFyZSBpZGVudGljYWwgdG8gdGhlIFNjaGVkdWxlciBjbGFzcy4gQnV0LCBvdGhlclxyXG4gKiB0aGFuIHRoZSBTY2hlZHVsZXIsIHRoZSBTaW1wbGVTY2hlZHVsZXIgY2xhc3MgZG9lcyBub3QgZ3VhcmFudGVlIHRoZSBvcmRlclxyXG4gKiBvZiBldmVudHMgKGkuZS4gY2FsbHMgdG8gdGhlIGFkdmFuY2VUaW1lIG1ldGhvZCBvZiBzY2hlZHVsZWQgdGltZSBlbmdpbmVzXHJcbiAqIGFuZCB0byBzY2hlZHVsZWQgY2FsbGJhY2sgZnVuY3Rpb25zKSB3aXRoaW4gYSBzY2hlZHVsaW5nIHBlcmlvZCAoc2VlIHBlcmlvZFxyXG4gKiBhdHRyaWJ1dGUpLlxyXG4gKlxyXG4gKiBUbyBnZXQgYSB1bmlxdWUgaW5zdGFuY2Ugb2YgU2ltcGxlU2NoZWR1bGVyIGFzIHRoZSBnbG9iYWwgc2NoZWR1bGVyIG9mIGFuXHJcbiAqIGFwcGxpY2F0aW9uLCB0aGUgZ2V0U2ltcGxlU2NoZWR1bGVyIGZhY3RvcnkgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQuIFRoZVxyXG4gKiBmdW5jdGlvbiBhY2NlcHRzIGFuIGF1ZGlvIGNvbnRleHQgYXMgb3B0aW9uYWwgYXJndW1lbnQgYW5kIHVzZXMgdGhlIFdhdmVzXHJcbiAqIGRlZmF1bHQgYXVkaW8gY29udGV4dCAoc2VlIEF1ZGlvIENvbnRleHQpIGFzIGRlZmF1bHQuIFRoZSBmYWN0b3J5IGNyZWF0ZXNcclxuICogYSBzaW5nbGUgKHNpbXBsZSkgc2NoZWR1bGVyIGZvciBlYWNoIGF1ZGlvIGNvbnRleHQuXHJcbiAqXHJcbiAqIEV4YW1wbGUgdGhhdCBzaG93cyB0aHJlZSBNZXRyb25vbWUgZW5naW5lcyBydW5uaW5nIGluIGEgU2ltcGxlU2NoZWR1bGVyOlxyXG4gKiB7QGxpbmsgaHR0cHM6Ly9yYXdnaXQuY29tL3dhdmVzanMvd2F2ZXMtYXVkaW8vbWFzdGVyL2V4YW1wbGVzL3NpbXBsZS1zY2hlZHVsZXIuaHRtbH1cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIGRlZmF1bHQgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucGVyaW9kPTAuMDI1XSAtIHBlcmlvZCBvZiB0aGUgc2NoZWR1bGVyLlxyXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubG9va2FoZWFkPTAuMV0gLSBsb29rYWhlYWQgb2YgdGhlIHNjaGVkdWxlci5cclxuICpcclxuICogQHNlZSBUaW1lRW5naW5lXHJcbiAqIEBzZWUgQXVkaW9UaW1lRW5naW5lXHJcbiAqIEBzZWUgZ2V0U2ltcGxlU2NoZWR1bGVyXHJcbiAqIEBzZWUgU2NoZWR1bGVyXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3Qgc2NoZWR1bGVyID0gYXVkaW8uZ2V0U2ltcGxlU2NoZWR1bGVyKCk7XHJcbiAqXHJcbiAqIHNjaGVkdWxlci5hZGQobXlFbmdpbmUpO1xyXG4gKi9cclxuY2xhc3MgU2ltcGxlU2NoZWR1bGVyIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gb3B0aW9ucy5hdWRpb0NvbnRleHQgfHwgwqBkZWZhdWx0QXVkaW9Db250ZXh0O1xyXG5cclxuICAgIHRoaXMuX19lbmdpbmVzID0gbmV3IFNldCgpO1xyXG5cclxuICAgIHRoaXMuX19zY2hlZEVuZ2luZXMgPSBbXTtcclxuICAgIHRoaXMuX19zY2hlZFRpbWVzID0gW107XHJcblxyXG4gICAgdGhpcy5fX2N1cnJlbnRUaW1lID0gbnVsbDtcclxuICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNjaGVkdWxlciAoc2V0VGltZW91dCkgcGVyaW9kXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgcGVyaW9kXHJcbiAgICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5wZXJpb2QgPSBvcHRpb25zLnBlcmlvZCB8fCAwLjAyNTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHNjaGVkdWxlciBsb29rYWhlYWQgdGltZSAoPiBwZXJpb2QpXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQG5hbWUgbG9va2FoZWFkXHJcbiAgICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgdGhpcy5sb29rYWhlYWQgPSBvcHRpb25zLmxvb2thaGVhZCB8fCAwLjE7XHJcbiAgfVxyXG5cclxuICBfX3NjaGVkdWxlRW5naW5lKGVuZ2luZSwgdGltZSkge1xyXG4gICAgdGhpcy5fX3NjaGVkRW5naW5lcy5wdXNoKGVuZ2luZSk7XHJcbiAgICB0aGlzLl9fc2NoZWRUaW1lcy5wdXNoKHRpbWUpO1xyXG4gIH1cclxuXHJcbiAgX19yZXNjaGVkdWxlRW5naW5lKGVuZ2luZSwgdGltZSkge1xyXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fX3NjaGVkRW5naW5lcy5pbmRleE9mKGVuZ2luZSk7XHJcblxyXG4gICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgaWYgKHRpbWUgIT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgdGhpcy5fX3NjaGVkVGltZXNbaW5kZXhdID0gdGltZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLl9fc2NoZWRFbmdpbmVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgdGhpcy5fX3NjaGVkVGltZXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aW1lIDwgSW5maW5pdHkpIHtcclxuICAgICAgdGhpcy5fX3NjaGVkRW5naW5lcy5wdXNoKGVuZ2luZSk7XHJcbiAgICAgIHRoaXMuX19zY2hlZFRpbWVzLnB1c2godGltZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfX3Vuc2NoZWR1bGVFbmdpbmUoZW5naW5lKSB7XHJcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9fc2NoZWRFbmdpbmVzLmluZGV4T2YoZW5naW5lKTtcclxuXHJcbiAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICB0aGlzLl9fc2NoZWRFbmdpbmVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgIHRoaXMuX19zY2hlZFRpbWVzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfX3Jlc2V0VGljaygpIHtcclxuICAgIGlmICh0aGlzLl9fc2NoZWRFbmdpbmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgaWYgKCF0aGlzLl9fdGltZW91dCkge1xyXG4gICAgICAgIGxvZygnU2ltcGxlU2NoZWR1bGVyIFN0YXJ0Jyk7XHJcbiAgICAgICAgdGhpcy5fX3RpY2soKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9fdGltZW91dCkge1xyXG4gICAgICBsb2coJ1NpbXBsZVNjaGVkdWxlciBTdG9wJyk7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9fdGltZW91dCk7XHJcbiAgICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9fdGljaygpIHtcclxuICAgIHZhciBhdWRpb0NvbnRleHQgPSB0aGlzLmF1ZGlvQ29udGV4dDtcclxuICAgIHZhciBjdXJyZW50VGltZSA9IGF1ZGlvQ29udGV4dC5jdXJyZW50VGltZTtcclxuICAgIHZhciBpID0gMDtcclxuXHJcbiAgICB3aGlsZSAoaSA8IHRoaXMuX19zY2hlZEVuZ2luZXMubGVuZ3RoKSB7XHJcbiAgICAgIHZhciBlbmdpbmUgPSB0aGlzLl9fc2NoZWRFbmdpbmVzW2ldO1xyXG4gICAgICB2YXIgdGltZSA9IHRoaXMuX19zY2hlZFRpbWVzW2ldO1xyXG5cclxuICAgICAgd2hpbGUgKHRpbWUgJiYgdGltZSA8PSBjdXJyZW50VGltZSArIHRoaXMubG9va2FoZWFkKSB7XHJcbiAgICAgICAgdGltZSA9IE1hdGgubWF4KHRpbWUsIGN1cnJlbnRUaW1lKTtcclxuICAgICAgICB0aGlzLl9fY3VycmVudFRpbWUgPSB0aW1lO1xyXG4gICAgICAgIHRpbWUgPSBlbmdpbmUuYWR2YW5jZVRpbWUodGltZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0aW1lICYmIHRpbWUgPCBJbmZpbml0eSkge1xyXG4gICAgICAgIHRoaXMuX19zY2hlZFRpbWVzW2krK10gPSB0aW1lO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX191bnNjaGVkdWxlRW5naW5lKGVuZ2luZSk7XHJcblxyXG4gICAgICAgIC8vIHJlbW92ZSBlbmdpbmUgZnJvbSBzY2hlZHVsZXJcclxuICAgICAgICBpZiAoIXRpbWUpIHtcclxuICAgICAgICAgIGVuZ2luZS5tYXN0ZXIgPSBudWxsO1xyXG4gICAgICAgICAgdGhpcy5fX2VuZ2luZXMuZGVsZXRlKGVuZ2luZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fX2N1cnJlbnRUaW1lID0gbnVsbDtcclxuICAgIHRoaXMuX190aW1lb3V0ID0gbnVsbDtcclxuXHJcbiAgICBpZiAodGhpcy5fX3NjaGVkRW5naW5lcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHRoaXMuX190aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fX3RpY2soKTtcclxuICAgICAgfSwgdGhpcy5wZXJpb2QgKiAxMDAwKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNjaGVkdWxlciBjdXJyZW50IGxvZ2ljYWwgdGltZS5cclxuICAgKlxyXG4gICAqIEBuYW1lIGN1cnJlbnRUaW1lXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbWVtYmVyb2YgU2NoZWR1bGVyXHJcbiAgICogQGluc3RhbmNlXHJcbiAgICovXHJcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19jdXJyZW50VGltZSB8fCB0aGlzLmF1ZGlvQ29udGV4dC5jdXJyZW50VGltZSArIHRoaXMubG9va2FoZWFkO1xyXG4gIH1cclxuXHJcbiAgZ2V0IGN1cnJlbnRQb3NpdGlvbigpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvLyBjYWxsIGEgZnVuY3Rpb24gYXQgYSBnaXZlbiB0aW1lXHJcbiAgLyoqXHJcbiAgICogRGVmZXIgdGhlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uIGF0IGEgZ2l2ZW4gdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1biAtIEZ1bmN0aW9uIHRvIGRlZmVyXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lPXRoaXMuY3VycmVudFRpbWVdIC0gU2NoZWR1bGUgdGltZVxyXG4gICAqL1xyXG4gIGRlZmVyKGZ1biwgdGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcclxuICAgIGlmICghKGZ1biBpbnN0YW5jZW9mIEZ1bmN0aW9uKSlcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGNhbm5vdCBiZSBkZWZlcmVkIGJ5IHNjaGVkdWxlclwiKTtcclxuXHJcbiAgICB0aGlzLmFkZCh7XHJcbiAgICAgIGFkdmFuY2VUaW1lOiBmdW5jdGlvbih0aW1lKSB7IGZ1bih0aW1lKTsgfSwgLy8gbWFrZSBzdXIgdGhhdCB0aGUgYWR2YW5jZVRpbWUgbWV0aG9kIGRvZXMgbm90IHJldHVybSBhbnl0aGluZ1xyXG4gICAgfSwgdGltZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgYSBUaW1lRW5naW5lIGZ1bmN0aW9uIHRvIHRoZSBzY2hlZHVsZXIgYXQgYW4gb3B0aW9uYWxseSBnaXZlbiB0aW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUaW1lRW5naW5lfSBlbmdpbmUgLSBFbmdpbmUgdG8gYWRkIHRvIHRoZSBzY2hlZHVsZXJcclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWU9dGhpcy5jdXJyZW50VGltZV0gLSBTY2hlZHVsZSB0aW1lXHJcbiAgICovXHJcbiAgYWRkKGVuZ2luZSwgdGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcclxuICAgIGlmICghVGltZUVuZ2luZS5pbXBsZW1lbnRzU2NoZWR1bGVkKGVuZ2luZSkpXHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9iamVjdCBjYW5ub3QgYmUgYWRkZWQgdG8gc2NoZWR1bGVyXCIpO1xyXG5cclxuICAgIGlmIChlbmdpbmUubWFzdGVyKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byBhIG1hc3RlclwiKTtcclxuXHJcbiAgICAvLyBzZXQgbWFzdGVyIGFuZCBhZGQgdG8gYXJyYXlcclxuICAgIGVuZ2luZS5tYXN0ZXIgPSB0aGlzO1xyXG4gICAgdGhpcy5fX2VuZ2luZXMuYWRkKGVuZ2luZSk7XHJcblxyXG4gICAgLy8gc2NoZWR1bGUgZW5naW5lXHJcbiAgICB0aGlzLl9fc2NoZWR1bGVFbmdpbmUoZW5naW5lLCB0aW1lKTtcclxuICAgIHRoaXMuX19yZXNldFRpY2soKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhIFRpbWVFbmdpbmUgZnJvbSB0aGUgc2NoZWR1bGVyIHRoYXQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlXHJcbiAgICogc2NoZWR1bGVyIHVzaW5nIHRoZSBhZGQgbWV0aG9kLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUaW1lRW5naW5lfSBlbmdpbmUgLSBFbmdpbmUgdG8gcmVtb3ZlIGZyb20gdGhlIHNjaGVkdWxlclxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZT10aGlzLmN1cnJlbnRUaW1lXSAtIFNjaGVkdWxlIHRpbWVcclxuICAgKi9cclxuICByZW1vdmUoZW5naW5lKSB7XHJcbiAgICBpZiAoIWVuZ2luZS5tYXN0ZXIgfHwgZW5naW5lLm1hc3RlciAhPT0gdGhpcylcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW5naW5lIGhhcyBub3QgYmVlbiBhZGRlZCB0byB0aGlzIHNjaGVkdWxlclwiKTtcclxuXHJcbiAgICAvLyByZXNldCBtYXN0ZXIgYW5kIHJlbW92ZSBmcm9tIGFycmF5XHJcbiAgICBlbmdpbmUubWFzdGVyID0gbnVsbDtcclxuICAgIHRoaXMuX19lbmdpbmVzLmRlbGV0ZShlbmdpbmUpO1xyXG5cclxuICAgIC8vIHVuc2NoZWR1bGUgZW5naW5lXHJcbiAgICB0aGlzLl9fdW5zY2hlZHVsZUVuZ2luZShlbmdpbmUpO1xyXG4gICAgdGhpcy5fX3Jlc2V0VGljaygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzY2hlZHVsZSBhIHNjaGVkdWxlZCB0aW1lIGVuZ2luZSBhdCBhIGdpdmVuIHRpbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RpbWVFbmdpbmV9IGVuZ2luZSAtIEVuZ2luZSB0byByZXNjaGVkdWxlXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgLSBTY2hlZHVsZSB0aW1lXHJcbiAgICovXHJcbiAgcmVzZXRFbmdpbmVUaW1lKGVuZ2luZSwgdGltZSA9IHRoaXMuY3VycmVudFRpbWUpIHtcclxuICAgIHRoaXMuX19yZXNjaGVkdWxlRW5naW5lKGVuZ2luZSwgdGltZSk7XHJcbiAgICB0aGlzLl9fcmVzZXRUaWNrKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayB3aGV0aGVyIGEgZ2l2ZW4gZW5naW5lIGlzIHNjaGVkdWxlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gZW5naW5lIC0gRW5naW5lIHRvIGNoZWNrXHJcbiAgICovXHJcbiAgaGFzKGVuZ2luZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19lbmdpbmVzLmhhcyhlbmdpbmUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFsbCBlbmdpbmVzIGZyb20gdGhlIHNjaGVkdWxlci5cclxuICAgKi9cclxuICBjbGVhcigpIHtcclxuICAgIGlmICh0aGlzLl9fdGltZW91dCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fX3RpbWVvdXQpO1xyXG4gICAgICB0aGlzLl9fdGltZW91dCA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fX3NjaGVkRW5naW5lcy5sZW5ndGggPSAwO1xyXG4gICAgdGhpcy5fX3NjaGVkVGltZXMubGVuZ3RoID0gMDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNpbXBsZVNjaGVkdWxlcjtcclxuIiwiaW1wb3J0IGRlZmF1bHRBdWRpb0NvbnRleHQgZnJvbSAnLi4vY29yZS9hdWRpby1jb250ZXh0JztcclxuaW1wb3J0IFByaW9yaXR5UXVldWUgZnJvbSAnLi4vY29yZS9wcmlvcml0eS1xdWV1ZSc7XHJcbmltcG9ydCBTY2hlZHVsaW5nUXVldWUgZnJvbSAnLi4vY29yZS9zY2hlZHVsaW5nLXF1ZXVlJztcclxuaW1wb3J0IFRpbWVFbmdpbmUgZnJvbSAnLi4vY29yZS90aW1lLWVuZ2luZSc7XHJcbmltcG9ydCB7IGdldFNjaGVkdWxlciB9IGZyb20gJy4vZmFjdG9yaWVzJztcclxuXHJcblxyXG5mdW5jdGlvbiBhZGREdXBsZXQoZmlyc3RBcnJheSwgc2Vjb25kQXJyYXksIGZpcnN0RWxlbWVudCwgc2Vjb25kRWxlbWVudCkge1xyXG4gIGZpcnN0QXJyYXkucHVzaChmaXJzdEVsZW1lbnQpO1xyXG4gIHNlY29uZEFycmF5LnB1c2goc2Vjb25kRWxlbWVudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZUR1cGxldChmaXJzdEFycmF5LCBzZWNvbmRBcnJheSwgZmlyc3RFbGVtZW50KSB7XHJcbiAgY29uc3QgaW5kZXggPSBmaXJzdEFycmF5LmluZGV4T2YoZmlyc3RFbGVtZW50KTtcclxuXHJcbiAgaWYgKGluZGV4ID49IDApIHtcclxuICAgIGNvbnN0IHNlY29uZEVsZW1lbnQgPSBzZWNvbmRBcnJheVtpbmRleF07XHJcblxyXG4gICAgZmlyc3RBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgc2Vjb25kQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICByZXR1cm4gc2Vjb25kRWxlbWVudDtcclxuICB9XHJcblxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcblxyXG4vLyBUaGUgVHJhbnNwb3J0ZWQgY2FsbCBpcyB0aGUgYmFzZSBjbGFzcyBvZiB0aGUgYWRhcHRlcnMgYmV0d2VlblxyXG4vLyBkaWZmZXJlbnQgdHlwZXMgb2YgZW5naW5lcyAoaS5lLiB0cmFuc3BvcnRlZCwgc2NoZWR1bGVkLCBwbGF5LWNvbnRyb2xsZWQpXHJcbi8vIFRoZSBhZGFwdGVycyBhcmUgYXQgdGhlIHNhbWUgdGltZSBtYXN0ZXJzIGZvciB0aGUgZW5naW5lcyBhZGRlZCB0byB0aGUgdHJhbnNwb3J0XHJcbi8vIGFuZCB0cmFuc3BvcnRlZCBUaW1lRW5naW5lcyBpbnNlcnRlZCBpbnRvIHRoZSB0cmFuc3BvcnQncyBwb3NpdGlvbi1iYXNlZCBwcml0b3JpdHkgcXVldWUuXHJcbmNsYXNzIFRyYW5zcG9ydGVkIGV4dGVuZHMgVGltZUVuZ2luZSB7XHJcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBlbmdpbmUsIHN0YXJ0LCBkdXJhdGlvbiwgb2Zmc2V0LCBzdHJldGNoID0gMSkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIHRoaXMubWFzdGVyID0gdHJhbnNwb3J0O1xyXG5cclxuICAgIHRoaXMuX19lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICBlbmdpbmUubWFzdGVyID0gdGhpcztcclxuXHJcbiAgICB0aGlzLl9fc3RhcnRQb3NpdGlvbiA9IHN0YXJ0O1xyXG4gICAgdGhpcy5fX2VuZFBvc2l0aW9uID0gIWlzRmluaXRlKGR1cmF0aW9uKSA/IEluZmluaXR5IDogc3RhcnQgKyBkdXJhdGlvbjtcclxuICAgIHRoaXMuX19vZmZzZXRQb3NpdGlvbiA9IHN0YXJ0ICsgb2Zmc2V0O1xyXG4gICAgdGhpcy5fX3N0cmV0Y2hQb3NpdGlvbiA9IHN0cmV0Y2g7XHJcbiAgICB0aGlzLl9faXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBzZXRCb3VuZGFyaWVzKHN0YXJ0LCBkdXJhdGlvbiwgb2Zmc2V0ID0gMCwgc3RyZXRjaCA9IDEpIHtcclxuICAgIHRoaXMuX19zdGFydFBvc2l0aW9uID0gc3RhcnQ7XHJcbiAgICB0aGlzLl9fZW5kUG9zaXRpb24gPSBzdGFydCArIGR1cmF0aW9uO1xyXG4gICAgdGhpcy5fX29mZnNldFBvc2l0aW9uID0gc3RhcnQgKyBvZmZzZXQ7XHJcbiAgICB0aGlzLl9fc3RyZXRjaFBvc2l0aW9uID0gc3RyZXRjaDtcclxuICAgIHRoaXMucmVzZXRQb3NpdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7fVxyXG4gIHN0b3AodGltZSwgcG9zaXRpb24pIHt9XHJcblxyXG4gIGdldCBjdXJyZW50VGltZSgpIHtcclxuICAgIHJldHVybiB0aGlzLm1hc3Rlci5jdXJyZW50VGltZTtcclxuICB9XHJcblxyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tYXN0ZXIuY3VycmVudFBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgaWYgKHBvc2l0aW9uICE9PSB1bmRlZmluZWQpXHJcbiAgICAgIHBvc2l0aW9uICs9IHRoaXMuX19vZmZzZXRQb3NpdGlvbjtcclxuXHJcbiAgICB0aGlzLm1hc3Rlci5yZXNldEVuZ2luZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGlmIChzcGVlZCA+IDApIHtcclxuICAgICAgaWYgKHBvc2l0aW9uIDwgdGhpcy5fX3N0YXJ0UG9zaXRpb24pIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX19pc1J1bm5pbmcpXHJcbiAgICAgICAgICB0aGlzLnN0b3AodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24pO1xyXG5cclxuICAgICAgICB0aGlzLl9faXNSdW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGFydFBvc2l0aW9uO1xyXG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgdGhpcy5fX2VuZFBvc2l0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydCh0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbiwgc3BlZWQpO1xyXG5cclxuICAgICAgICB0aGlzLl9faXNSdW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2VuZFBvc2l0aW9uO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocG9zaXRpb24gPiB0aGlzLl9fZW5kUG9zaXRpb24pIHtcclxuICAgICAgICBpZiAodGhpcy5fX2lzUnVubmluZykgLy8gaWYgZW5naW5lIGlzIHJ1bm5pbmdcclxuICAgICAgICAgIHRoaXMuc3RvcCh0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbik7XHJcblxyXG4gICAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2VuZFBvc2l0aW9uO1xyXG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID4gdGhpcy5fX3N0YXJ0UG9zaXRpb24pIHtcclxuICAgICAgICB0aGlzLnN0YXJ0KHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uLCBzcGVlZCk7XHJcblxyXG4gICAgICAgIHRoaXMuX19pc1J1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhcnRQb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9faXNSdW5uaW5nKSAvLyBpZiBlbmdpbmUgaXMgcnVubmluZ1xyXG4gICAgICB0aGlzLnN0b3AodGltZSwgcG9zaXRpb24pO1xyXG5cclxuICAgIHRoaXMuX19pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgIHJldHVybiBJbmZpbml0eSAqIHNwZWVkO1xyXG4gIH1cclxuXHJcbiAgYWR2YW5jZVBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgaWYgKCF0aGlzLl9faXNSdW5uaW5nKSB7XHJcbiAgICAgIHRoaXMuc3RhcnQodGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcclxuICAgICAgdGhpcy5fX2lzUnVubmluZyA9IHRydWU7XHJcblxyXG4gICAgICBpZiAoc3BlZWQgPiAwKVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9fZW5kUG9zaXRpb247XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5fX3N0YXJ0UG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3RvcCBlbmdpbmVcclxuICAgIHRoaXMuc3RvcCh0aW1lLCBwb3NpdGlvbiAtIHRoaXMuX19vZmZzZXRQb3NpdGlvbik7XHJcblxyXG4gICAgdGhpcy5fX2lzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgcmV0dXJuIEluZmluaXR5ICogc3BlZWQ7XHJcbiAgfVxyXG5cclxuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICBpZiAoc3BlZWQgPT09IDApIC8vIHN0b3BcclxuICAgICAgdGhpcy5zdG9wKHRpbWUsIHBvc2l0aW9uIC0gdGhpcy5fX29mZnNldFBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLm1hc3RlciA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fX2VuZ2luZS5tYXN0ZXIgPSBudWxsO1xyXG4gICAgdGhpcy5fX2VuZ2luZSA9IG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBUcmFuc3BvcnRlZFRyYW5zcG9ydGVkXHJcbi8vIGhhcyB0byBzd2l0Y2ggb24gYW5kIG9mZiB0aGUgc2NoZWR1bGVkIGVuZ2luZXMgd2hlbiB0aGUgdHJhbnNwb3J0IGhpdHMgdGhlIGVuZ2luZSdzIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25cclxuY2xhc3MgVHJhbnNwb3J0ZWRUcmFuc3BvcnRlZCBleHRlbmRzIFRyYW5zcG9ydGVkIHtcclxuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKSB7XHJcbiAgICBzdXBlcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIHN5bmNQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGlmIChzcGVlZCA+IDAgJiYgcG9zaXRpb24gPCB0aGlzLl9fZW5kUG9zaXRpb24pXHJcbiAgICAgIHBvc2l0aW9uID0gTWF0aC5tYXgocG9zaXRpb24sIHRoaXMuX19zdGFydFBvc2l0aW9uKTtcclxuICAgIGVsc2UgaWYgKHNwZWVkIDwgMCAmJiBwb3NpdGlvbiA+PSB0aGlzLl9fc3RhcnRQb3NpdGlvbilcclxuICAgICAgcG9zaXRpb24gPSBNYXRoLm1pbihwb3NpdGlvbiwgdGhpcy5fX2VuZFBvc2l0aW9uKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fX29mZnNldFBvc2l0aW9uICsgdGhpcy5fX2VuZ2luZS5zeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcclxuICB9XHJcblxyXG4gIGFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIHBvc2l0aW9uID0gdGhpcy5fX29mZnNldFBvc2l0aW9uICsgdGhpcy5fX2VuZ2luZS5hZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIHNwZWVkKTtcclxuXHJcbiAgICBpZiAoc3BlZWQgPiAwICYmIHBvc2l0aW9uIDwgdGhpcy5fX2VuZFBvc2l0aW9uIHx8IHNwZWVkIDwgMCAmJiBwb3NpdGlvbiA+PSB0aGlzLl9fc3RhcnRQb3NpdGlvbilcclxuICAgICAgcmV0dXJuIHBvc2l0aW9uO1xyXG5cclxuICAgIHJldHVybiBJbmZpbml0eSAqIHNwZWVkO1xyXG4gIH1cclxuXHJcbiAgc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgaWYgKHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKVxyXG4gICAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRFbmdpbmVQb3NpdGlvbihlbmdpbmUsIHBvc2l0aW9uID0gdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAocG9zaXRpb24gIT09IHVuZGVmaW5lZClcclxuICAgICAgcG9zaXRpb24gKz0gdGhpcy5fX29mZnNldFBvc2l0aW9uO1xyXG5cclxuICAgIHRoaXMucmVzZXRQb3NpdGlvbihwb3NpdGlvbik7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBUcmFuc3BvcnRlZFNwZWVkQ29udHJvbGxlZFxyXG4vLyBoYXMgdG8gc3RhcnQgYW5kIHN0b3AgdGhlIHNwZWVkLWNvbnRyb2xsZWQgZW5naW5lcyB3aGVuIHRoZSB0cmFuc3BvcnQgaGl0cyB0aGUgZW5naW5lJ3Mgc3RhcnQgYW5kIGVuZCBwb3NpdGlvblxyXG5jbGFzcyBUcmFuc3BvcnRlZFNwZWVkQ29udHJvbGxlZCBleHRlbmRzIFRyYW5zcG9ydGVkIHtcclxuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKSB7XHJcbiAgICBzdXBlcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcclxuICB9XHJcblxyXG4gIHN0YXJ0KHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdGhpcy5fX2VuZ2luZS5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCB0cnVlKTtcclxuICB9XHJcblxyXG4gIHN0b3AodGltZSwgcG9zaXRpb24pIHtcclxuICAgIHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKHRpbWUsIHBvc2l0aW9uLCAwKTtcclxuICB9XHJcblxyXG4gIHN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGlmICh0aGlzLl9faXNSdW5uaW5nKVxyXG4gICAgICB0aGlzLl9fZW5naW5lLnN5bmNTcGVlZCh0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuX19lbmdpbmUuc3luY1NwZWVkKHRoaXMubWFzdGVyLmN1cnJlbnRUaW1lLCB0aGlzLm1hc3Rlci5jdXJyZW50UG9zaXRpb24gLSB0aGlzLl9fb2Zmc2V0UG9zaXRpb24sIDApO1xyXG4gICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gIH1cclxufVxyXG5cclxuLy8gVHJhbnNwb3J0ZWRTY2hlZHVsZWRcclxuLy8gaGFzIHRvIHN3aXRjaCBvbiBhbmQgb2ZmIHRoZSBzY2hlZHVsZWQgZW5naW5lcyB3aGVuIHRoZSB0cmFuc3BvcnQgaGl0cyB0aGUgZW5naW5lJ3Mgc3RhcnQgYW5kIGVuZCBwb3NpdGlvblxyXG5jbGFzcyBUcmFuc3BvcnRlZFNjaGVkdWxlZCBleHRlbmRzIFRyYW5zcG9ydGVkIHtcclxuICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKSB7XHJcbiAgICBzdXBlcih0cmFuc3BvcnQsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcclxuXHJcbiAgICAvLyBzY2hlZHVsaW5nIHF1ZXVlIGJlY29tZXMgbWFzdGVyIG9mIGVuZ2luZVxyXG4gICAgZW5naW5lLm1hc3RlciA9IG51bGw7XHJcbiAgICB0cmFuc3BvcnQuX19zY2hlZHVsaW5nUXVldWUuYWRkKGVuZ2luZSwgSW5maW5pdHkpO1xyXG4gIH1cclxuXHJcbiAgc3RhcnQodGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICB0aGlzLm1hc3Rlci5fX3NjaGVkdWxpbmdRdWV1ZS5yZXNldEVuZ2luZVRpbWUodGhpcy5fX2VuZ2luZSwgdGltZSk7XHJcbiAgfVxyXG5cclxuICBzdG9wKHRpbWUsIHBvc2l0aW9uKSB7XHJcbiAgICB0aGlzLm1hc3Rlci5fX3NjaGVkdWxpbmdRdWV1ZS5yZXNldEVuZ2luZVRpbWUodGhpcy5fX2VuZ2luZSwgSW5maW5pdHkpO1xyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMubWFzdGVyLl9fc2NoZWR1bGluZ1F1ZXVlLnJlbW92ZSh0aGlzLl9fZW5naW5lKTtcclxuICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICB9XHJcbn1cclxuXHJcbi8vIHRyYW5zbGF0ZXMgYWR2YW5jZVBvc2l0aW9uIG9mICp0cmFuc3BvcnRlZCogZW5naW5lcyBpbnRvIGdsb2JhbCBzY2hlZHVsZXIgdGltZXNcclxuY2xhc3MgVHJhbnNwb3J0U2NoZWR1bGVySG9vayBleHRlbmRzIFRpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xyXG5cclxuICAgIHRoaXMuX19uZXh0UG9zaXRpb24gPSBJbmZpbml0eTtcclxuICAgIHRoaXMuX19uZXh0VGltZSA9IEluZmluaXR5O1xyXG4gICAgdHJhbnNwb3J0Ll9fc2NoZWR1bGVyLmFkZCh0aGlzLCBJbmZpbml0eSk7XHJcbiAgfVxyXG5cclxuICAvLyBUaW1lRW5naW5lIG1ldGhvZCAoc2NoZWR1bGVkIGludGVyZmFjZSlcclxuICBhZHZhbmNlVGltZSh0aW1lKSB7XHJcbiAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLl9fdHJhbnNwb3J0O1xyXG4gICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9fbmV4dFBvc2l0aW9uO1xyXG4gICAgY29uc3Qgc3BlZWQgPSB0cmFuc3BvcnQuX19zcGVlZDtcclxuICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IHRyYW5zcG9ydC5hZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICAgIGNvbnN0IG5leHRUaW1lID0gdHJhbnNwb3J0Ll9fZ2V0VGltZUF0UG9zaXRpb24obmV4dFBvc2l0aW9uKTtcclxuXHJcbiAgICB0aGlzLl9fbmV4dFBvc2l0aW9uID0gbmV4dFBvc2l0aW9uO1xyXG4gICAgdGhpcy5fX25leHRUaW1lID0gbmV4dFRpbWU7XHJcblxyXG4gICAgcmV0dXJuIG5leHRUaW1lO1xyXG4gIH1cclxuXHJcbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbiA9IHRoaXMuX19uZXh0UG9zaXRpb24pIHtcclxuICAgIGNvbnN0IHRyYW5zcG9ydCA9IHRoaXMuX190cmFuc3BvcnQ7XHJcbiAgICBjb25zdCB0aW1lID0gdHJhbnNwb3J0Ll9fZ2V0VGltZUF0UG9zaXRpb24ocG9zaXRpb24pO1xyXG5cclxuICAgIHRoaXMuX19uZXh0UG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIHRoaXMuX19uZXh0VGltZSA9IHRpbWU7XHJcblxyXG4gICAgdGhpcy5yZXNldFRpbWUodGltZSk7XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5fX3RyYW5zcG9ydC5fX3NjaGVkdWxlci5yZW1vdmUodGhpcyk7XHJcbiAgICB0aGlzLl9fdHJhbnNwb3J0ID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8vIGludGVybmFsIHNjaGVkdWxpbmcgcXVldWUgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IHBvc2l0aW9uIChhbmQgdGltZSkgb2YgdGhlIHBsYXkgY29udHJvbFxyXG5jbGFzcyBUcmFuc3BvcnRTY2hlZHVsaW5nUXVldWUgZXh0ZW5kcyBTY2hlZHVsaW5nUXVldWUge1xyXG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLl9fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xyXG4gICAgdHJhbnNwb3J0Ll9fc2NoZWR1bGVyLmFkZCh0aGlzLCBJbmZpbml0eSk7XHJcbiAgfVxyXG5cclxuICBnZXQgY3VycmVudFRpbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3RyYW5zcG9ydC5jdXJyZW50VGltZTtcclxuICB9XHJcblxyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3RyYW5zcG9ydC5jdXJyZW50UG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBkZXN0cm95KCkge1xyXG4gICAgdGhpcy5fX3RyYW5zcG9ydC5fX3NjaGVkdWxlci5yZW1vdmUodGhpcyk7XHJcbiAgICB0aGlzLl9fdHJhbnNwb3J0ID0gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBzeW5jaHJvbml6ZWQgc2NoZWR1bGluZyBvZiBUaW1lIEVuZ2luZSBpbnN0YW5jZXMuXHJcbiAqXHJcbiAqIFtleGFtcGxlXXtAbGluayBodHRwczovL3Jhd2dpdC5jb20vd2F2ZXNqcy93YXZlcy1hdWRpby9tYXN0ZXIvZXhhbXBsZXMvdHJhbnNwb3J0Lmh0bWx9XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGltcG9ydCAqIGFzIGF1ZGlvIGZyb20gJ3dhdmVzLWF1ZGlvJztcclxuICogY29uc3QgdHJhbnNwb3J0ID0gYXVkaW8uVHJhbnNwb3J0KCk7XHJcbiAqIGNvbnN0IHBsYXlDb250cm9sID0gbmV3IGF1ZGlvLlBsYXlDb250cm9sKHRyYW5zcG9ydCk7XHJcbiAqIGNvbnN0IG15RW5naW5lID0gbmV3IE15RW5naW5lKCk7XHJcbiAqIGNvbnN0IHlvdXJFbmdpbmUgPSBuZXcgeW91ckVuZ2luZSgpO1xyXG4gKlxyXG4gKiB0cmFuc3BvcnQuYWRkKG15RW5naW5lKTtcclxuICogdHJhbnNwb3J0LmFkZCh5b3VyRW5naW5lKTtcclxuICpcclxuICogcGxheUNvbnRyb2wuc3RhcnQoKTtcclxuICovXHJcbmNsYXNzIFRyYW5zcG9ydCBleHRlbmRzIFRpbWVFbmdpbmUge1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIoKTtcclxuXHJcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IG9wdGlvbnMuYXVkaW9Db250ZXh0IHx8IGRlZmF1bHRBdWRpb0NvbnRleHQ7XHJcblxyXG4gICAgdGhpcy5fX2VuZ2luZXMgPSBbXTtcclxuICAgIHRoaXMuX190cmFuc3BvcnRlZCA9IFtdO1xyXG5cclxuICAgIHRoaXMuX19zY2hlZHVsZXIgPSBnZXRTY2hlZHVsZXIodGhpcy5hdWRpb0NvbnRleHQpO1xyXG4gICAgdGhpcy5fX3NjaGVkdWxlckhvb2sgPSBuZXcgVHJhbnNwb3J0U2NoZWR1bGVySG9vayh0aGlzKTtcclxuICAgIHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlID0gbmV3IFByaW9yaXR5UXVldWUoKTtcclxuICAgIHRoaXMuX19zY2hlZHVsaW5nUXVldWUgPSBuZXcgVHJhbnNwb3J0U2NoZWR1bGluZ1F1ZXVlKHRoaXMpO1xyXG5cclxuICAgIC8vIHN5bmNyb25pemVkIHRpbWUsIHBvc2l0aW9uLCBhbmQgc3BlZWRcclxuICAgIHRoaXMuX190aW1lID0gMDtcclxuICAgIHRoaXMuX19wb3NpdGlvbiA9IDA7XHJcbiAgICB0aGlzLl9fc3BlZWQgPSAwO1xyXG4gIH1cclxuXHJcbiAgX19nZXRUaW1lQXRQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIHRoaXMuX190aW1lICsgKHBvc2l0aW9uIC0gdGhpcy5fX3Bvc2l0aW9uKSAvIHRoaXMuX19zcGVlZDtcclxuICB9XHJcblxyXG4gIF9fZ2V0UG9zaXRpb25BdFRpbWUodGltZSkge1xyXG4gICAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiArICh0aW1lIC0gdGhpcy5fX3RpbWUpICogdGhpcy5fX3NwZWVkO1xyXG4gIH1cclxuXHJcbiAgX19zeW5jVHJhbnNwb3J0ZWRQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpIHtcclxuICAgIGNvbnN0IG51bVRyYW5zcG9ydGVkRW5naW5lcyA9IHRoaXMuX190cmFuc3BvcnRlZC5sZW5ndGg7XHJcbiAgICBsZXQgbmV4dFBvc2l0aW9uID0gSW5maW5pdHkgKiBzcGVlZDtcclxuXHJcbiAgICBpZiAobnVtVHJhbnNwb3J0ZWRFbmdpbmVzID4gMCkge1xyXG4gICAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5jbGVhcigpO1xyXG4gICAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5yZXZlcnNlID0gKHNwZWVkIDwgMCk7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRyYW5zcG9ydGVkRW5naW5lczsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZW5naW5lID0gdGhpcy5fX3RyYW5zcG9ydGVkW2ldO1xyXG4gICAgICAgIGNvbnN0IG5leHRFbmdpbmVQb3NpdGlvbiA9IGVuZ2luZS5zeW5jUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICAgICAgICB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5pbnNlcnQoZW5naW5lLCBuZXh0RW5naW5lUG9zaXRpb24pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuZXh0UG9zaXRpb24gPSB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS50aW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuZXh0UG9zaXRpb247XHJcbiAgfVxyXG5cclxuICBfX3N5bmNUcmFuc3BvcnRlZFNwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgZm9yIChsZXQgdHJhbnNwb3J0ZWQgb2YgdGhpcy5fX3RyYW5zcG9ydGVkKVxyXG4gICAgICB0cmFuc3BvcnRlZC5zeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IG1hc3RlciB0aW1lLiBUaGlzIGdldHRlciB3aWxsIGJlIHJlcGxhY2VkIHdoZW4gdGhlIHRyYW5zcG9ydFxyXG4gICAqIGlzIGFkZGVkIHRvIGEgbWFzdGVyIChpLmUuIHRyYW5zcG9ydCBvciBwbGF5LWNvbnRyb2wpLlxyXG4gICAqXHJcbiAgICogQHR5cGUge051bWJlcn1cclxuICAgKiBAbmFtZSBjdXJyZW50VGltZVxyXG4gICAqIEBtZW1iZXJvZiBUcmFuc3BvcnRcclxuICAgKiBAaW5zdGFuY2VcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgY3VycmVudFRpbWUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX3NjaGVkdWxlci5jdXJyZW50VGltZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjdXJyZW50IG1hc3RlciBwb3NpdGlvbi4gVGhpcyBnZXR0ZXIgd2lsbCBiZSByZXBsYWNlZCB3aGVuIHRoZSB0cmFuc3BvcnRcclxuICAgKiBpcyBhZGRlZCB0byBhIG1hc3RlciAoaS5lLiB0cmFuc3BvcnQgb3IgcGxheS1jb250cm9sKS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICogQG5hbWUgY3VycmVudFBvc2l0aW9uXHJcbiAgICogQG1lbWJlcm9mIFRyYW5zcG9ydFxyXG4gICAqIEBpbnN0YW5jZVxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50UG9zaXRpb24oKSB7XHJcbiAgICBjb25zdCBtYXN0ZXIgPSB0aGlzLm1hc3RlcjtcclxuXHJcbiAgICBpZiAobWFzdGVyICYmIG1hc3Rlci5jdXJyZW50UG9zaXRpb24gIT09IHVuZGVmaW5lZClcclxuICAgICAgcmV0dXJuIG1hc3Rlci5jdXJyZW50UG9zaXRpb247XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX19wb3NpdGlvbiArICh0aGlzLl9fc2NoZWR1bGVyLmN1cnJlbnRUaW1lIC0gdGhpcy5fX3RpbWUpICogdGhpcy5fX3NwZWVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgbmV4dCB0cmFuc3BvcnQgcG9zaXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuZXh0IC0gdHJhbnNwb3J0IHBvc2l0aW9uXHJcbiAgICovXHJcbiAgcmVzZXRQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgY29uc3QgbWFzdGVyID0gdGhpcy5tYXN0ZXI7XHJcblxyXG4gICAgaWYgKG1hc3RlciAmJiBtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbiAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICBtYXN0ZXIucmVzZXRFbmdpbmVQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XHJcbiAgICBlbHNlXHJcbiAgICAgIHRoaXMuX19zY2hlZHVsZXJIb29rLnJlc2V0UG9zaXRpb24ocG9zaXRpb24pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIHRyYW5zcG9ydGVkIHRpbWUgZW5naW5lIGludGVyZmFjZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWVkXHJcbiAgICovXHJcbiAgc3luY1Bvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCkge1xyXG4gICAgdGhpcy5fX3RpbWUgPSB0aW1lO1xyXG4gICAgdGhpcy5fX3Bvc2l0aW9uID0gcG9zaXRpb247XHJcbiAgICB0aGlzLl9fc3BlZWQgPSBzcGVlZDtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgdHJhbnNwb3J0ZWQgdGltZSBlbmdpbmUgaW50ZXJmYWNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVcclxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb25cclxuICAgKiBAcGFyYW0ge051bWJlcn0gc3BlZWRcclxuICAgKi9cclxuICBhZHZhbmNlUG9zaXRpb24odGltZSwgcG9zaXRpb24sIHNwZWVkKSB7XHJcbiAgICBjb25zdCBlbmdpbmUgPSB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5oZWFkO1xyXG4gICAgY29uc3QgbmV4dEVuZ2luZVBvc2l0aW9uID0gZW5naW5lLmFkdmFuY2VQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgcmV0dXJuIHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLm1vdmUoZW5naW5lLCBuZXh0RW5naW5lUG9zaXRpb24pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIHRyYW5zcG9ydGVkIHRpbWUgZW5naW5lIGludGVyZmFjZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNwZWVkXHJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbc2Vlaz1mYWxzZV1cclxuICAgKi9cclxuICBzeW5jU3BlZWQodGltZSwgcG9zaXRpb24sIHNwZWVkLCBzZWVrID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IGxhc3RTcGVlZCA9IHRoaXMuX19zcGVlZDtcclxuXHJcbiAgICB0aGlzLl9fdGltZSA9IHRpbWU7XHJcbiAgICB0aGlzLl9fcG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgIHRoaXMuX19zcGVlZCA9IHNwZWVkO1xyXG5cclxuICAgIGlmIChzcGVlZCAhPT0gbGFzdFNwZWVkIHx8IChzZWVrICYmIHNwZWVkICE9PSAwKSkge1xyXG4gICAgICBsZXQgbmV4dFBvc2l0aW9uO1xyXG5cclxuICAgICAgLy8gcmVzeW5jIHRyYW5zcG9ydGVkIGVuZ2luZXNcclxuICAgICAgaWYgKHNlZWsgfHwgc3BlZWQgKiBsYXN0U3BlZWQgPCAwKSB7XHJcbiAgICAgICAgLy8gc2VlayBvciByZXZlcnNlIGRpcmVjdGlvblxyXG4gICAgICAgIG5leHRQb3NpdGlvbiA9IHRoaXMuX19zeW5jVHJhbnNwb3J0ZWRQb3NpdGlvbih0aW1lLCBwb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgICB9IGVsc2UgaWYgKGxhc3RTcGVlZCA9PT0gMCkge1xyXG4gICAgICAgIC8vIHN0YXJ0XHJcbiAgICAgICAgbmV4dFBvc2l0aW9uID0gdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFBvc2l0aW9uKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc3BlZWQgPT09IDApIHtcclxuICAgICAgICAvLyBzdG9wXHJcbiAgICAgICAgbmV4dFBvc2l0aW9uID0gSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFNwZWVkKHRpbWUsIHBvc2l0aW9uLCAwKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBjaGFuZ2Ugc3BlZWQgd2l0aG91dCByZXZlcnNpbmcgZGlyZWN0aW9uXHJcbiAgICAgICAgdGhpcy5fX3N5bmNUcmFuc3BvcnRlZFNwZWVkKHRpbWUsIHBvc2l0aW9uLCBzcGVlZCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgdGltZSBlbmdpbmUgdG8gdGhlIHRyYW5zcG9ydC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbmdpbmUgLSBlbmdpbmUgdG8gYmUgYWRkZWQgdG8gdGhlIHRyYW5zcG9ydFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIHN0YXJ0IHBvc2l0aW9uXHJcbiAgICovXHJcbiAgYWRkKGVuZ2luZSwgc3RhcnRQb3NpdGlvbiA9IDAsIGVuZFBvc2l0aW9uID0gSW5maW5pdHksIG9mZnNldFBvc2l0aW9uID0gMCkge1xyXG4gICAgbGV0IHRyYW5zcG9ydGVkID0gbnVsbDtcclxuXHJcbiAgICBpZiAob2Zmc2V0UG9zaXRpb24gPT09IC1JbmZpbml0eSlcclxuICAgICAgb2Zmc2V0UG9zaXRpb24gPSAwO1xyXG5cclxuICAgIGlmIChlbmdpbmUubWFzdGVyKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byBhIG1hc3RlclwiKTtcclxuXHJcbiAgICBpZiAoVGltZUVuZ2luZS5pbXBsZW1lbnRzVHJhbnNwb3J0ZWQoZW5naW5lKSlcclxuICAgICAgdHJhbnNwb3J0ZWQgPSBuZXcgVHJhbnNwb3J0ZWRUcmFuc3BvcnRlZCh0aGlzLCBlbmdpbmUsIHN0YXJ0UG9zaXRpb24sIGVuZFBvc2l0aW9uLCBvZmZzZXRQb3NpdGlvbik7XHJcbiAgICBlbHNlIGlmIChUaW1lRW5naW5lLmltcGxlbWVudHNTcGVlZENvbnRyb2xsZWQoZW5naW5lKSlcclxuICAgICAgdHJhbnNwb3J0ZWQgPSBuZXcgVHJhbnNwb3J0ZWRTcGVlZENvbnRyb2xsZWQodGhpcywgZW5naW5lLCBzdGFydFBvc2l0aW9uLCBlbmRQb3NpdGlvbiwgb2Zmc2V0UG9zaXRpb24pO1xyXG4gICAgZWxzZSBpZiAoVGltZUVuZ2luZS5pbXBsZW1lbnRzU2NoZWR1bGVkKGVuZ2luZSkpXHJcbiAgICAgIHRyYW5zcG9ydGVkID0gbmV3IFRyYW5zcG9ydGVkU2NoZWR1bGVkKHRoaXMsIGVuZ2luZSwgc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24sIG9mZnNldFBvc2l0aW9uKTtcclxuICAgIGVsc2VcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2JqZWN0IGNhbm5vdCBiZSBhZGRlZCB0byBhIHRyYW5zcG9ydFwiKTtcclxuXHJcbiAgICBpZiAodHJhbnNwb3J0ZWQpIHtcclxuICAgICAgY29uc3Qgc3BlZWQgPSB0aGlzLl9fc3BlZWQ7XHJcblxyXG4gICAgICBhZGREdXBsZXQodGhpcy5fX2VuZ2luZXMsIHRoaXMuX190cmFuc3BvcnRlZCwgZW5naW5lLCB0cmFuc3BvcnRlZCk7XHJcblxyXG4gICAgICBpZiAoc3BlZWQgIT09IDApIHtcclxuICAgICAgICAvLyBzeW5jIGFuZCBzdGFydFxyXG4gICAgICAgIGNvbnN0IG5leHRFbmdpbmVQb3NpdGlvbiA9IHRyYW5zcG9ydGVkLnN5bmNQb3NpdGlvbih0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmN1cnJlbnRQb3NpdGlvbiwgc3BlZWQpO1xyXG4gICAgICAgIGNvbnN0IG5leHRQb3NpdGlvbiA9IHRoaXMuX190cmFuc3BvcnRlZFF1ZXVlLmluc2VydCh0cmFuc3BvcnRlZCwgbmV4dEVuZ2luZVBvc2l0aW9uKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZXNldFBvc2l0aW9uKG5leHRQb3NpdGlvbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJhbnNwb3J0ZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgYSB0aW1lIGVuZ2luZSBmcm9tIHRoZSB0cmFuc3BvcnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge29iamVjdH0gZW5naW5lT3JUcmFuc3BvcnRlZCAtIGVuZ2luZSBvciB0cmFuc3BvcnRlZCB0byBiZSByZW1vdmVkIGZyb20gdGhlIHRyYW5zcG9ydFxyXG4gICAqL1xyXG4gIHJlbW92ZShlbmdpbmVPclRyYW5zcG9ydGVkKSB7XHJcbiAgICBsZXQgZW5naW5lID0gZW5naW5lT3JUcmFuc3BvcnRlZDtcclxuICAgIGxldCB0cmFuc3BvcnRlZCA9IHJlbW92ZUR1cGxldCh0aGlzLl9fZW5naW5lcywgdGhpcy5fX3RyYW5zcG9ydGVkLCBlbmdpbmVPclRyYW5zcG9ydGVkKTtcclxuXHJcbiAgICBpZiAoIXRyYW5zcG9ydGVkKSB7XHJcbiAgICAgIGVuZ2luZSA9IHJlbW92ZUR1cGxldCh0aGlzLl9fdHJhbnNwb3J0ZWQsIHRoaXMuX19lbmdpbmVzLCBlbmdpbmVPclRyYW5zcG9ydGVkKTtcclxuICAgICAgdHJhbnNwb3J0ZWQgPSBlbmdpbmVPclRyYW5zcG9ydGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChlbmdpbmUgJiYgdHJhbnNwb3J0ZWQpIHtcclxuICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0gdGhpcy5fX3RyYW5zcG9ydGVkUXVldWUucmVtb3ZlKHRyYW5zcG9ydGVkKTtcclxuXHJcbiAgICAgIHRyYW5zcG9ydGVkLmRlc3Ryb3koKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLl9fc3BlZWQgIT09IDApXHJcbiAgICAgICAgdGhpcy5yZXNldFBvc2l0aW9uKG5leHRQb3NpdGlvbik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvYmplY3QgaGFzIG5vdCBiZWVuIGFkZGVkIHRvIHRoaXMgdHJhbnNwb3J0XCIpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGVuZ2luZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VGltZUVuZ2luZX0gdHJhbnNwb3J0ZWQgLSBFbmdpbmUgdG8gcmVzZXRcclxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBOZXcgcG9zaXRpb25cclxuICAgKi9cclxuICByZXNldEVuZ2luZVBvc2l0aW9uKHRyYW5zcG9ydGVkLCBwb3NpdGlvbiA9IHVuZGVmaW5lZCkge1xyXG4gICAgY29uc3Qgc3BlZWQgPSB0aGlzLl9fc3BlZWQ7XHJcblxyXG4gICAgaWYgKHNwZWVkICE9PSAwKSB7XHJcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgIHBvc2l0aW9uID0gdHJhbnNwb3J0ZWQuc3luY1Bvc2l0aW9uKHRoaXMuY3VycmVudFRpbWUsIHRoaXMuY3VycmVudFBvc2l0aW9uLCBzcGVlZCk7XHJcblxyXG4gICAgICBjb25zdCBuZXh0UG9zaXRpb24gPSB0aGlzLl9fdHJhbnNwb3J0ZWRRdWV1ZS5tb3ZlKHRyYW5zcG9ydGVkLCBwb3NpdGlvbik7XHJcbiAgICAgIHRoaXMucmVzZXRQb3NpdGlvbihuZXh0UG9zaXRpb24pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGFsbCB0aW1lIGVuZ2luZXMgZnJvbSB0aGUgdHJhbnNwb3J0LlxyXG4gICAqL1xyXG4gIGNsZWFyKCkge1xyXG4gICAgdGhpcy5zeW5jU3BlZWQodGhpcy5jdXJyZW50VGltZSwgdGhpcy5jdXJyZW50UG9zaXRpb24sIDApO1xyXG5cclxuICAgIGZvciAobGV0IHRyYW5zcG9ydGVkIG9mIHRoaXMuX190cmFuc3BvcnRlZClcclxuICAgICAgdHJhbnNwb3J0ZWQuZGVzdHJveSgpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVHJhbnNwb3J0O1xyXG4iLCIvKiAgRnJvbSBQaGFzZVZvY29kZXIuanMgKGMpIDIwMTUgYnkgRWNobzY2XG4gICAgaHR0cHM6Ly9naXRodWIuY29tL2VjaG82Ni9QaGFzZVZvY29kZXJKU1xuXG4gICAgVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuXHRhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cblxuaW1wb3J0IENCdWZmZXIgZnJvbSAnLi9jYnVmZmVyJztcbmltcG9ydCB7RkZUfSBmcm9tICcuL2RzcC5qcyc7XG5pbXBvcnQgRFNQIGZyb20gJy4vZHNwJztcblxuZnVuY3Rpb24gUGhhc2VWb2NvZGVyKHdpblNpemUsIHNhbXBsZVJhdGUpIHtcblxuXHR2YXIgX3NhbXBsZVJhdGUgPSBzYW1wbGVSYXRlOyB2YXIgX0hzID0gMDsgdmFyIF9IYSA9IDA7IHZhciBfb21lZ2E7XG5cblx0dmFyIF9wcmV2aW91c0lucHV0UGhhc2U7IHZhciBfcHJldmlvdXNPdXRwdXRQaGFzZTsgdmFyIF9mcmFtaW5nV2luZG93O1xuXHRcblx0dmFyIF9zcXVhcmVkRnJhbWluZ1dpbmRvdzsgdmFyIF93aW5TaXplID0gd2luU2l6ZTtcblxuXHR2YXIgX292ZXJsYXBCdWZmZXJzOyB2YXIgX293T3ZlcmxhcEJ1ZmZlcnM7XG5cblx0dmFyIF9maXJzdCA9IHRydWU7XG5cblx0dmFyIF9vdmVybGFwRmFjdG9yID0gMTY7XG5cblx0dmFyIF9sYXN0SW5wdXRBbHBoYSA9IDE7XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKiBkc3AuanMgRkZUICoqKioqKioqKioqKioqKioqKioqKiovXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXHR2YXIgZmZ0ID0gbmV3IEZGVChfd2luU2l6ZSwgc2FtcGxlUmF0ZSk7XG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuXHR2YXIgc3FydCA9IE1hdGguc3FydDsgdmFyIGNvcyA9IE1hdGguY29zO1xuXHR2YXIgc2luID0gTWF0aC5zaW47IHZhciBhdGFuMiA9IE1hdGguYXRhbjI7XG5cdHZhciByb3VuZCA9IE1hdGgucm91bmQ7IHZhciBtYXggPSBNYXRoLm1heDtcblx0dmFyIGNlaWwgPSBNYXRoLmNlaWw7IHZhciBwb3cgPSBNYXRoLnBvdztcblx0dmFyIFBJID0gTWF0aC5QSTtcblxuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKlBSRS1BTExPQ0FURSBNRU1PUlkqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Ly9maW5kX3BlYWtzXG5cdHZhciBfaGxmU2l6ZSA9IHJvdW5kKF93aW5TaXplLzIpKzE7XG5cblx0Ly8gLy8gcHJvY2Vzc1xuXHR2YXIgX3Byb2Nlc3MgPSB7XG5cdFx0ZmZ0T2JqIDoge1xuXHRcdFx0cmVhbDogbmV3IEZsb2F0MzJBcnJheShfaGxmU2l6ZSksIFxuXHRcdFx0aW1hZzogbmV3IEZsb2F0MzJBcnJheShfaGxmU2l6ZSksIFxuXHRcdFx0bWFnbml0dWRlOiBuZXcgRmxvYXQzMkFycmF5KF9obGZTaXplKSwgXG5cdFx0XHRwaGFzZTogbmV3IEZsb2F0MzJBcnJheShfaGxmU2l6ZSlcblx0XHR9LCBcblx0XHRwdk91dCA6IHtcblx0XHRcdHJlYWw6IGNyZWF0ZV9jb25zdGFudF9hcnJheShfd2luU2l6ZSwgMCwgRmxvYXQzMkFycmF5KSwgXG5cdFx0XHRpbWFnOiBjcmVhdGVfY29uc3RhbnRfYXJyYXkoX3dpblNpemUsIDAsIEZsb2F0MzJBcnJheSksIFxuXHRcdFx0bWFnbml0dWRlOiBjcmVhdGVfY29uc3RhbnRfYXJyYXkoX3dpblNpemUsIDAsIEZsb2F0MzJBcnJheSksIFxuXHRcdFx0cGhhc2U6IGNyZWF0ZV9jb25zdGFudF9hcnJheShfd2luU2l6ZSwgMCwgRmxvYXQzMkFycmF5KVxuXHRcdH0sXG5cdFx0cHJvY2Vzc2VkRnJhbWUgOiBuZXcgRmxvYXQzMkFycmF5KF93aW5TaXplKVxuXHR9O1xuXG5cdHZhciBfcHZfc3RlcCA9IHtcblx0XHRpbnN0UGhhc2VBZHYgOiBuZXcgRmxvYXQzMkFycmF5KF9obGZTaXplKSwgXG5cdFx0cGhUaCA6IG5ldyBGbG9hdDMyQXJyYXkoX2hsZlNpemUpXG5cdH07XG5cblx0dmFyIF9TVEZUID0ge1xuXHRcdF9pbnB1dEZyYW1lIDogbmV3IEZsb2F0MzJBcnJheShfd2luU2l6ZSksXG5cdFx0X3plcm9zOiBuZXcgRmxvYXQzMkFycmF5KF93aW5TaXplKVxuXHR9XG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblx0dmFyIHBoVGhfaWR4ID0gMDtcblx0dmFyIHR3b1BJID0gMiAqIFBJO1xuXHR2YXIgZXhwZWN0ZWRQaGFzZUFkdiwgYXV4SGV0ZXJvZHluZWRQaGFzZUluY3IsIGhldGVyb2R5bmVkUGhhc2VJbmNyLCBcblx0XHRpbnN0UGhhc2VBZHZQZXJTYW1wbGVIb3AsIGluc3RQaGFzZUFkdl8sIHByZXZJbnN0UGhhc2VBZHZfO1xuXHRcblx0ZnVuY3Rpb24gb3ZlcmxhcF9hbmRfc2xpZGUoSHMsIGluRiwgc3F1YXJlZFdpbkYsIG9CdWYsIG93T0J1Ziwgd2luZG93U2l6ZSwgb3V0Rikge1xuXG5cdFx0dmFyIG93U2FtcGxlLCBvU2FtcGxlID0gMDtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBIczsgaSsrKSB7XG5cdCAgICAgIG93U2FtcGxlID0gb3dPQnVmLnNoaWZ0KCkgfHwgMDtcblx0ICAgICAgb1NhbXBsZSAgPSBvQnVmLnNoaWZ0KCkgfHwgMDtcblx0ICAgICAgb3V0Ri5wdXNoKG9TYW1wbGUgLyAoKG93U2FtcGxlPDEwZS0zKT8gMSA6IG93U2FtcGxlKSk7XG5cdCAgICAgIG9CdWYucHVzaCgwKTtcblx0ICAgICAgb3dPQnVmLnB1c2goMCk7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG5cdCAgICAgIG9TYW1wbGUgPSBvQnVmLnNoaWZ0KCk7XG5cdCAgICAgIG9CdWYucHVzaChpbkZbaV0gKyBvU2FtcGxlKTtcblx0ICAgICAgb3dTYW1wbGUgPSBvd09CdWYuc2hpZnQoKTtcblx0ICAgICAgb3dPQnVmLnB1c2goc3F1YXJlZFdpbkZbaV0gKyBvd1NhbXBsZSk7XG5cdCAgICB9XG5cdH1cblxuXG5cdGZ1bmN0aW9uIHB2X3N0ZXAoZmZ0T2JqLCBwcmV2SW5QaCwgcHJldk91dFBoLCBvbWVnYSwgSGEsIEhzLCBvdXQpIHtcblxuXHRcdHZhciBjdXJySW5QaCA9IGZmdE9iai5waGFzZTtcblx0XHR2YXIgbWFnID0gZmZ0T2JqLm1hZ25pdHVkZTtcblx0XHR2YXIgaW5zdFBoYXNlQWR2ID0gX3B2X3N0ZXAuaW5zdFBoYXNlQWR2O1xuXHRcdHZhciBwaFRoID0gX3B2X3N0ZXAucGhUaDtcblxuXHRcdHZhciBwZWFrLCBwcmV2UGVhaywgcmVnLCByZWdTdGFydCwgcHJldlJlZ0VuZCwgcHJldlJlZ1N0YXJ0LCBkLCBpO1xuXHRcdHBoVGhfaWR4ID0gMDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBvbWVnYS5sZW5ndGg7IGkrKykge1xuXHRcdFx0ZXhwZWN0ZWRQaGFzZUFkdiA9IG9tZWdhW2ldICogSGE7XG5cblx0XHRcdGF1eEhldGVyb2R5bmVkUGhhc2VJbmNyID0gKGN1cnJJblBoW2ldIC0gcHJldkluUGhbaV0pIC0gZXhwZWN0ZWRQaGFzZUFkdjtcblx0XHRcdGhldGVyb2R5bmVkUGhhc2VJbmNyID0gYXV4SGV0ZXJvZHluZWRQaGFzZUluY3IgLSB0d29QSSAqIHJvdW5kKGF1eEhldGVyb2R5bmVkUGhhc2VJbmNyL3R3b1BJKTtcblxuXHRcdFx0aW5zdFBoYXNlQWR2UGVyU2FtcGxlSG9wID0gb21lZ2FbaV0gKyBoZXRlcm9keW5lZFBoYXNlSW5jciAvIEhhO1xuXG5cdFx0XHRpbnN0UGhhc2VBZHZfID0gaW5zdFBoYXNlQWR2UGVyU2FtcGxlSG9wICogSHM7XG5cblx0XHRcdGlmIChtYWdbaV0gPiBtYXgoKG1hZ1tpLTJdfDApLCAobWFnW2ktMV18MCksIChtYWdbaSsxXXwwKSwgKG1hZ1tpKzJdfDApKSkge1xuXHRcdFx0Ly8gaWYgKG1hZ1tpXSA+IChtYWdbaS0yXXwwKSAmJiBtYWdbaV0gPiAobWFnW2ktMV18MCkgJiYgbWFnW2ldID4gKG1hZ1tpKzFdfDApICYmIG1hZ1tpXSA+IChtYWdbaSsyXXwwKSkge1xuXHRcdFx0XHRwZWFrID0gaTtcblx0XHRcdFx0cmVnU3RhcnQgPSBjZWlsKChwcmV2UGVhayArIHBlYWspLzIpIHwgMDsgXG5cdFx0XHRcdHByZXZSZWdFbmQgPSByZWdTdGFydC0xO1xuXHRcdFx0XHRyZWcgPSBtYXgoMCwgcHJldlJlZ0VuZCAtIHByZXZSZWdTdGFydCArIDEpO1xuXHRcdFx0XHRwcmV2UmVnU3RhcnQgPSByZWdTdGFydDtcblx0XHRcdFx0Zm9yIChkID0gMDsgZCA8IHJlZzsgZCsrLCBwaFRoX2lkeCsrKSB7XG5cdFx0XHRcdFx0cGhUaFtwaFRoX2lkeF0gPSBwcmV2T3V0UGhbcHJldlBlYWtdICsgcHJldkluc3RQaGFzZUFkdl8gLSBjdXJySW5QaFtwcmV2UGVha107XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJldlBlYWsgPSBwZWFrO1xuXHRcdFx0XHRwcmV2SW5zdFBoYXNlQWR2XyA9IGluc3RQaGFzZUFkdl87XG5cdFx0XHR9XG5cdFx0fVxuXHRcdFxuXHRcdGZvciAodmFyIGk9MDsgaTxwaFRoLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgdGhldGEgPSBwaFRoW2ldO1xuXG5cdFx0XHR2YXIgcGhUaFJlID0gY29zKHBoVGhbaV0pO1xuXHRcdFx0dmFyIHBoVGhJbSA9IHNpbihwaFRoW2ldKTtcblx0XHRcdFxuXHRcdFx0b3V0LnJlYWxbaV0gPSBwaFRoUmUgKiBmZnRPYmoucmVhbFtpXSAtIHBoVGhJbSAqIGZmdE9iai5pbWFnW2ldO1xuXHRcdFx0b3V0LmltYWdbaV0gPSBwaFRoUmUgKiBmZnRPYmouaW1hZ1tpXSArIHBoVGhJbSAqIGZmdE9iai5yZWFsW2ldO1xuXHRcdFx0b3V0LnBoYXNlW2ldID0gYXRhbjIob3V0LmltYWdbaV0sIG91dC5yZWFsW2ldKTtcblx0XHR9XG5cdFx0XG5cdFx0cmV0dXJuO1xuXHR9XG5cblxuXHR0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihpbnB1dEFycmF5LCBvdXRwdXRBcnJheSkge1xuXG5cdFx0dmFyIF8gPSB0aGlzO1xuXG5cdFx0dmFyIF9fSHMgPSBfSHM7XG5cdFx0dmFyIF9fSGEgPSBfSGE7XG5cblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0Ly8gLS0tLS0tLS0tLUFOQUxZU0lTIFNURVAtLS0tLS0tLS0tLVxuXHRcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0XHRcblx0XHR2YXIgcHJvY2Vzc2VkRnJhbWUgPSBfcHJvY2Vzcy5wcm9jZXNzZWRGcmFtZTs7XG5cdFx0dmFyIGZmdE9iaiA9IF9wcm9jZXNzLmZmdE9iajtcblx0XHQvLyBGT1IgU09NRSBSRUFTT04sIElGIEkgRE9OJ1QgQ1JFQVRFIEEgTkVXIFwicGhhc2VcIiBBUkhhWSwgSSBHRVQgQVJUSUZBQ1RTLlxuXHRcdC8vIGZmdE9iai5waGFzZSA9IG5ldyBGbG9hdDMyQXJyYXkoX2hsZlNpemUpOyBcblx0XHR2YXIgcHZPdXQgPSBfcHJvY2Vzcy5wdk91dDtcblx0XHRfLlNURlQoaW5wdXRBcnJheSwgX2ZyYW1pbmdXaW5kb3csIF9obGZTaXplLCBmZnRPYmopO1xuXHRcdHB2X3N0ZXAoZmZ0T2JqLCBfcHJldmlvdXNJbnB1dFBoYXNlLCBfcHJldmlvdXNPdXRwdXRQaGFzZSwgX29tZWdhLCBfX0hhLCBfX0hzLCBwdk91dCk7XG5cdFx0X3ByZXZpb3VzT3V0cHV0UGhhc2UgPSBwdk91dC5waGFzZTtcblx0XHQvLyBUaGUgXCJwaGFzZVwiIGlzc3VlIG1lbnRpb25lZCBhYm92ZSBpcyByZWxhdGVkIHRvIHRoaXMgbGluZS4gXG5cdFx0Ly8gSWYgSSBjcmVhdGUgYSBuZXcgRmxvYXQgYXJyYXkgdXNpbmcgdGhlIHBoYXNlIGFycmF5LCBJIGdldCBubyBpc3N1ZXMuXG5cdFx0X3ByZXZpb3VzSW5wdXRQaGFzZSA9IG5ldyBGbG9hdDMyQXJyYXkoZmZ0T2JqLnBoYXNlKTsgXG5cdFx0Xy5JU1RGVChwdk91dC5yZWFsLCBwdk91dC5pbWFnLCBfZnJhbWluZ1dpbmRvdywgZmFsc2UsIHByb2Nlc3NlZEZyYW1lKTtcblxuXG5cdFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRcdC8vIC0tLS0tLU9WRVJMQVAgQU5EIFNMSURFIFNURVAtLS0tLS1cblx0XHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdFx0Ly8gdmFyIG91dHB1dEZyYW1lID0gbmV3IEFycmF5KF9fSHMpO1xuXG5cdFx0b3ZlcmxhcF9hbmRfc2xpZGUoX19IcywgcHJvY2Vzc2VkRnJhbWUsIF9zcXVhcmVkRnJhbWluZ1dpbmRvdywgX292ZXJsYXBCdWZmZXJzLCBfb3dPdmVybGFwQnVmZmVycywgX3dpblNpemUsIG91dHB1dEFycmF5KTtcblxuXHRcdHJldHVybiBfX0hzO1xuXG5cdH1cblxuXHRcblx0dGhpcy5TVEZUID0gZnVuY3Rpb24oaW5wdXRGcmFtZSwgd2luZG93RnJhbWUsIHdhbnRlZFNpemUsIG91dCkge1xuXHRcdHRoaXMuU1RGVF9kcm9tKGlucHV0RnJhbWUsIHdpbmRvd0ZyYW1lLCB3YW50ZWRTaXplLCBvdXQpO1xuXHR9XG5cblx0dGhpcy5TVEZUX2Ryb20gPSBmdW5jdGlvbihpbnB1dEZyYW1lLCB3aW5kb3dGcmFtZSwgd2FudGVkU2l6ZSwgb3V0KSB7XG5cdFx0dmFyIHdpblNpemUgPSB3aW5kb3dGcmFtZS5sZW5ndGg7XG5cdFx0dmFyIF9pbnB1dEZyYW1lID0gX1NURlQuX2lucHV0RnJhbWU7XG5cblx0XHRmb3IgKHZhciBpPTA7IGk8d2luU2l6ZTsgaSsrKSB7XG5cdFx0XHRfaW5wdXRGcmFtZVtpXSA9IGlucHV0RnJhbWVbaV0gKiB3aW5kb3dGcmFtZVtpXTtcblx0XHR9XG5cdFx0XG5cdFx0ZmZ0LmZvcndhcmQoX2lucHV0RnJhbWUpO1xuXHRcdG91dC5yZWFsID0gZmZ0LnJlYWw7XG5cdFx0b3V0LmltYWcgPSBmZnQuaW1hZztcblx0XHRcblx0XHR2YXIgUiA9IG91dC5yZWFsOyB2YXIgSSA9IG91dC5pbWFnO1xuXHRcdHZhciBQID0gb3V0LnBoYXNlOyB2YXIgTSA9IG91dC5tYWduaXR1ZGU7XG5cblx0XHRmb3IgKHZhciBwPTA7IHA8d2luU2l6ZSAmJiBwPHdhbnRlZFNpemU7IHArKykge1x0XG5cdFx0XHRNW3BdID0gc3FydChJW3BdKklbcF0gKyBSW3BdKlJbcF0pICogMTAwMDtcblx0XHRcdFBbcF0gPSBhdGFuMihJW3BdLCBSW3BdKTtcblx0XHR9XG5cblx0XHRyZXR1cm47XG5cdH1cblxuXG5cblx0dGhpcy5JU1RGVCA9IGZ1bmN0aW9uKHJlYWwsIGltYWcsIHdpbmRvd0ZyYW1lLCByZXN0b3JlRW5lcmd5LCB0aW1lRnJhbWUpIHtcblx0XHR0aGlzLklTVEZUX2Ryb20ocmVhbCwgaW1hZywgd2luZG93RnJhbWUsIHJlc3RvcmVFbmVyZ3ksIHRpbWVGcmFtZSk7XG5cdH1cblxuXHR0aGlzLklTVEZUX2Ryb20gPSBmdW5jdGlvbihyZWFsLCBpbWFnLCB3aW5kb3dGcmFtZSwgcmVzdG9yZUVuZXJneSwgdGltZUZyYW1lKSB7XG5cblx0XHRmZnQuaW52ZXJzZShyZWFsLCBpbWFnLCB0aW1lRnJhbWUpO1xuXG5cdFx0cmV0dXJuO1xuXG5cdH1cblxuXG5cblx0dGhpcy5pbml0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHRfb21lZ2EgPSBjcmVhdGVfb21lZ2FfYXJyYXkod2luU2l6ZSk7XG5cblx0XHR0aGlzLnJlc2V0X3BoYXNlc19hbmRfb3ZlcmxhcF9idWZmZXJzKCk7XG5cblx0XHRfZnJhbWluZ1dpbmRvdyA9IGNyZWF0ZV9zaW5fYmV0YV93aW5kb3dfYXJyYXkod2luU2l6ZSwgMSk7XG5cblx0XHRfc3F1YXJlZEZyYW1pbmdXaW5kb3cgPSBfZnJhbWluZ1dpbmRvdy5tYXAoZnVuY3Rpb24oeCxpKXsgcmV0dXJuIHgqeDsgfSk7XG5cblx0XHR0aGlzLnNldF9hbHBoYSgxKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZV9vbWVnYV9hcnJheShzaXplKSB7XG5cdFx0cmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIEFycmF5KHNpemUvMiArIDEpKS5tYXAoZnVuY3Rpb24gKHgsIGkpIHsgXG5cdFx0XHRyZXR1cm4gdHdvUEkgKiBpIC8gc2l6ZTtcblx0XHR9KTtcblx0fVxuXHRcblx0ZnVuY3Rpb24gY3JlYXRlX3Npbl9iZXRhX3dpbmRvd19hcnJheShzaXplLCBiZXRhKSB7XG5cdFx0cmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIEFycmF5KHNpemUpKS5tYXAoZnVuY3Rpb24oeCxpKXtcblx0XHRcdHJldHVybiBwb3coc2luKFBJICogaSAvIHNpemUpLCBiZXRhKTtcblx0XHR9KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZV9jb25zdGFudF9hcnJheShzaXplLCBjb25zdGFudCwgQXJyYXlUeXBlKSB7XG5cdFx0dmFyIGFyciA9IG5ldyAoKEFycmF5VHlwZSk/QXJyYXlUeXBlOkFycmF5KShzaXplKTtcblx0XHRmb3IgKHZhciBpPTA7IGk8c2l6ZTsgaSsrKSBcblx0XHRcdGFycltpXSA9IGNvbnN0YW50O1xuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHR0aGlzLnJlc2V0X3BoYXNlc19hbmRfb3ZlcmxhcF9idWZmZXJzID0gZnVuY3Rpb24oKSB7XG5cblx0XHRfcHJldmlvdXNJbnB1dFBoYXNlID0gY3JlYXRlX2NvbnN0YW50X2FycmF5KHdpblNpemUvMiwgMCk7XG5cdFx0X3ByZXZpb3VzT3V0cHV0UGhhc2UgPSBjcmVhdGVfY29uc3RhbnRfYXJyYXkod2luU2l6ZS8yLCAwKTtcblxuXHRcdF9vdmVybGFwQnVmZmVycyA9IG5ldyBDQnVmZmVyKHdpblNpemUpO1xuXHRcdF9vd092ZXJsYXBCdWZmZXJzID0gbmV3IENCdWZmZXIod2luU2l6ZSk7XG5cdFx0Zm9yICh2YXIgaT0wOyBpIDwgd2luU2l6ZTsgaSsrKSB7XG5cdFx0XHRfb3ZlcmxhcEJ1ZmZlcnMucHVzaCgwKTtcblx0XHRcdF9vd092ZXJsYXBCdWZmZXJzLnB1c2goMCk7XG5cdFx0fVxuXG5cdFx0X2ZpcnN0ID0gdHJ1ZTtcblx0fVxuXG5cdHRoaXMucmVzZXRfcGhhc2VzID0gZnVuY3Rpb24oKSB7XG5cblx0XHRfcHJldmlvdXNJbnB1dFBoYXNlID0gY3JlYXRlX2NvbnN0YW50X2FycmF5KHdpblNpemUvMiwgMCk7XG5cdFx0X3ByZXZpb3VzT3V0cHV0UGhhc2UgPSBjcmVhdGVfY29uc3RhbnRfYXJyYXkod2luU2l6ZS8yLCAwKTtcblxuXHRcdF9maXJzdCA9IHRydWU7XG5cdH1cblxuXG5cdHRoaXMuZ2V0X3ByZXZpb3VzX2lucHV0X3BoYXNlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF9wcmV2aW91c0lucHV0UGhhc2U7XG5cdH1cblxuXHR0aGlzLmdldF9wcmV2aW91c19vdXRwdXRfcGhhc2UgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX3ByZXZpb3VzT3V0cHV0UGhhc2U7XG5cdH1cblxuXHR0aGlzLmdldF9hbmFseXNpc19ob3AgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX0hhO1xuXHR9XG5cblx0dGhpcy5nZXRfc3ludGhlc2lzX2hvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfSHM7XG5cdH1cblxuXHR0aGlzLmdldF9hbHBoYSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfSHMgLyBfSGE7XG5cdH1cblxuXHR0aGlzLmdldF9mcmFtaW5nX3dpbmRvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBfZnJhbWluZ1dpbmRvdztcblx0fVxuXG5cdHRoaXMuZ2V0X3NxdWFyZWRfZnJhbWluZ193aW5kb3cgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX3NxdWFyZWRGcmFtaW5nV2luZG93O1xuXHR9XG5cblx0dGhpcy5zZXRfYWxwaGEyID0gZnVuY3Rpb24obmV3QWxwaGEpIHtcblx0XHRfbGFzdElucHV0QWxwaGEgPSBuZXdBbHBoYTtcblx0XHRpZiAobmV3QWxwaGEgPD0gMC44KVxuXHRcdFx0X292ZXJsYXBGYWN0b3IgPSAyO1xuXHRcdGVsc2UgaWYgKG5ld0FscGhhIDw9IDEpXG5cdFx0XHRfb3ZlcmxhcEZhY3RvciA9IDQ7XG5cdFx0ZWxzZVxuXHRcdFx0X292ZXJsYXBGYWN0b3IgPSA1O1xuXG5cdFx0LyogXCJGaXhlZFwiIHN5bnRoZXNpcyBob3Agc2l6ZS4gKi9cblx0XHRfSGEgPSByb3VuZChfd2luU2l6ZS9fb3ZlcmxhcEZhY3Rvcik7XG5cdFx0X0hzID0gcm91bmQobmV3QWxwaGEgKiBfSGEpO1xuXHRcdFxuXHRcdC8vIF9IcyA9IF9IYTtcblxuXHRcdC8vIF9IcyA9IHJvdW5kKF93aW5TaXplLzIpO1xuXHRcdC8vIF9IYSA9IHJvdW5kKF9IcyAvIG5ld0FscGhhKTtcblx0fVxuXHR0aGlzLnNldF9hbHBoYSA9IGZ1bmN0aW9uIChuZXdBbHBoYSkge1xuXHRcdF9sYXN0SW5wdXRBbHBoYSA9IG5ld0FscGhhO1xuXHRcdF9vdmVybGFwRmFjdG9yID0gTWF0aC5taW4oTWF0aC5mbG9vcigoTWF0aC5wb3coNCwgKG5ld0FscGhhKSAvIDQpICogMikgLyAxKSAqIDIsIDEyOCk7XG5cblx0XHRfSGEgPSBNYXRoLnJvdW5kKF93aW5TaXplIC8gX292ZXJsYXBGYWN0b3IpO1xuXHRcdF9IcyA9IE1hdGgucm91bmQobmV3QWxwaGEgKiBfSGEpO1xuXHRcdC8vIF9SUyA9IE1hdGgucm91bmQoX3dpblNpemUvMik7XG5cdFx0Ly8gX1JBID0gTWF0aC5yb3VuZChfUlMgLyBuZXdBbHBoYSk7XG5cdH1cblxuXHR0aGlzLmdldF9hbHBoYV9zdGVwID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIDEvX0hhO1xuXHR9XG5cblx0dGhpcy5zZXRfaG9wcyA9IGZ1bmN0aW9uKEhhLCBIcykge1xuXHRcdF9IYSA9IEhhO1xuXHRcdF9IcyA9IEhzO1xuXHR9XG5cblx0dGhpcy5nZXRfc3BlY2lmaWVkX2FscGhhID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIF9sYXN0SW5wdXRBbHBoYTtcblx0fVxuXG5cdHRoaXMuc2V0X292ZXJsYXBfZmFjdG9yID0gZnVuY3Rpb24ob3ZlcmxhcEZhY3Rvcikge1xuXHRcdF9vdmVybGFwRmFjdG9yID0gb3ZlcmxhcEZhY3Rvcjtcblx0XHR0aGlzLnNldF9hbHBoYShfbGFzdElucHV0QWxwaGEpO1xuXHR9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFBoYXNlVm9jb2RlcjsiLCIvKiAgRnJvbSBQaGFzZVZvY29kZXIuanMgKGMpIDIwMTUgYnkgRWNobzY2XG4gICAgaHR0cHM6Ly9naXRodWIuY29tL2VjaG82Ni9QaGFzZVZvY29kZXJKU1xuXG5cdFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcblx0YWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgQ0J1ZmZlciBmcm9tICcuL2NidWZmZXInO1xuaW1wb3J0IFBoYXNlVm9jb2RlciBmcm9tICcuL1BWX2Zhc3RfNSc7XG4vL2ltcG9ydCBQaGFzZVZvY29kZXIgZnJvbSAnLi4vdXRpbHMvUFZfZmFzdF9wdWxzZWZmdCc7XG5pbXBvcnQgYXVkaW9Db250ZXh0IGZyb20gJy4uL2NvcmUvYXVkaW8tY29udGV4dCc7XG5cbmZ1bmN0aW9uIFBWKGZyYW1lU2l6ZSkge1xuXG5cdHZhciBfZnJhbWVTaXplID0gZnJhbWVTaXplIHx8IDQwOTY7XG5cdFxuXHRsZXQgX3B2TCA9ICBuZXcgUGhhc2VWb2NvZGVyKF9mcmFtZVNpemUsIGF1ZGlvQ29udGV4dC5zYW1wbGVSYXRlKTsgX3B2TC5pbml0KCk7XG5cdGxldCBfcHZSID0gIG5ldyBQaGFzZVZvY29kZXIoX2ZyYW1lU2l6ZSwgYXVkaW9Db250ZXh0LnNhbXBsZVJhdGUpOyBfcHZSLmluaXQoKTtcblxuXHR2YXIgX2J1ZmZlcjtcblx0dmFyIF9wb3NpdGlvbiA9IDA7XG5cdHZhciBfbmV3QWxwaGEgPSAxO1xuXG5cdHZhciBfbWlkQnVmTCA9IG5ldyBDQnVmZmVyKE1hdGgucm91bmQoX2ZyYW1lU2l6ZSAqIDIpKTtcblx0dmFyIF9taWRCdWZSID0gbmV3IENCdWZmZXIoTWF0aC5yb3VuZChfZnJhbWVTaXplICogMikpO1xuXG5cdHRoaXMucHJvY2Vzc01vbm8gPSBmdW5jdGlvbihvdXRwdXRBdWRpb0J1ZmZlcikge1xuXG5cdFx0aWYgKCFfYnVmZmVyKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKFwiTm8gaW5wdXQgYnVmZmVyXCIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBzYW1wbGVDb3VudGVyID0gMDtcblxuICAgICAgICB2YXIgaWwgPSBfYnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICB2YXIgaXIgPSBfYnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICB2YXIgb2wgPSBvdXRwdXRBdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgICAgdmFyIG9yID0gb3V0cHV0QXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMSk7XG5cblxuICAgICAgICB3aGlsZSAoX21pZEJ1ZlIuc2l6ZSA+IDAgJiYgc2FtcGxlQ291bnRlciA8IG91dHB1dEF1ZGlvQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBpID0gc2FtcGxlQ291bnRlcisrO1xuICAgICAgICAgIG9sW2ldID0gX21pZEJ1Zkwuc2hpZnQoKTtcbiAgICAgICAgICBvcltpXSA9IF9taWRCdWZSLnNoaWZ0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2FtcGxlQ291bnRlciA9PSBvdXRwdXRBdWRpb0J1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGRvIHtcblxuICAgICAgICAgIHZhciBidWZMID0gaWwuc3ViYXJyYXkoX3Bvc2l0aW9uLCBfcG9zaXRpb24gKyBfZnJhbWVTaXplKTtcbiAgICAgICAgICB2YXIgYnVmUiA9IGlyLnN1YmFycmF5KF9wb3NpdGlvbiwgX3Bvc2l0aW9uICsgX2ZyYW1lU2l6ZSk7XG5cbiAgICAgICAgICBpZiAoX25ld0FscGhhICE9IHVuZGVmaW5lZCAmJiBfbmV3QWxwaGEgIT0gX3B2TC5nZXRfYWxwaGEoKSkge1xuICAgICAgICAgICAgX3B2TC5zZXRfYWxwaGEoX25ld0FscGhhKTtcbiAgICAgICAgICAgIF9wdlIuc2V0X2FscGhhKF9uZXdBbHBoYSk7XG4gICAgICAgICAgICBfbmV3QWxwaGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgICAvKiBMRUZUICovXG4gICAgICAgICAgX3B2TC5wcm9jZXNzKGJ1ZkwsIF9taWRCdWZMKTtcbiAgICAgICAgICBfcHZSLnByb2Nlc3MoYnVmUiwgX21pZEJ1ZlIpO1xuICAgICAgICAgIGZvciAodmFyIGk9c2FtcGxlQ291bnRlcjsgX21pZEJ1Zkwuc2l6ZSA+IDAgJiYgaSA8IG91dHB1dEF1ZGlvQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvbFtpXSA9IF9taWRCdWZMLnNoaWZ0KCk7XG4gICAgICAgICAgICBvcltpXSA9IF9taWRCdWZSLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2FtcGxlQ291bnRlciArPSBfcHZMLmdldF9zeW50aGVzaXNfaG9wKCk7XG5cbiAgICAgICAgICBfcG9zaXRpb25cbiAgICAgICAgICAgKz0gX3B2TC5nZXRfYW5hbHlzaXNfaG9wKCk7XG5cbiAgICAgICAgfSB3aGlsZSAoc2FtcGxlQ291bnRlciA8IG91dHB1dEF1ZGlvQnVmZmVyLmxlbmd0aCk7XG5cdH1cblxuXHR0aGlzLnByb2Nlc3NTdGVyZW8gPSBmdW5jdGlvbiAob3V0cHV0QXVkaW9CdWZmZXIpIHtcblxuXHRcdGlmICghX2J1ZmZlciB8fCBfYnVmZmVyLm51bWJlck9mQ2hhbm5lbHMgIT0gMikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihcIk5vIGlucHV0IGJ1ZmZlciBvciB3cm9uZyBudW1iZXIgb2YgY2hhbm5lbHNcIilcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc2FtcGxlQ291bnRlciA9IDA7XG5cblx0XHR2YXIgaWwgPSBfYnVmZmVyLmdldENoYW5uZWxEYXRhKDApO1xuXHRcdHZhciBpciA9IF9idWZmZXIuZ2V0Q2hhbm5lbERhdGEoMSk7XG5cdFx0dmFyIG9sID0gb3V0cHV0QXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMCk7XG5cdFx0dmFyIG9yID0gb3V0cHV0QXVkaW9CdWZmZXIuZ2V0Q2hhbm5lbERhdGEoMSk7XG5cblxuXHRcdHdoaWxlIChfbWlkQnVmUi5zaXplID4gMCAmJiBzYW1wbGVDb3VudGVyIDwgb3V0cHV0QXVkaW9CdWZmZXIubGVuZ3RoKSB7XG5cdFx0XHR2YXIgaSA9IHNhbXBsZUNvdW50ZXIrKztcblx0XHRcdG9sW2ldID0gX21pZEJ1Zkwuc2hpZnQoKTtcblx0XHRcdG9yW2ldID0gX21pZEJ1ZlIuc2hpZnQoKTtcblx0XHR9XG5cblx0XHRpZiAoc2FtcGxlQ291bnRlciA9PSBvdXRwdXRBdWRpb0J1ZmZlci5sZW5ndGgpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRkbyB7XG5cblx0XHRcdHZhciBidWZMID0gaWwuc3ViYXJyYXkoX3Bvc2l0aW9uLCBfcG9zaXRpb24gKyBfZnJhbWVTaXplKTtcblx0XHRcdHZhciBidWZSID0gaXIuc3ViYXJyYXkoX3Bvc2l0aW9uLCBfcG9zaXRpb24gKyBfZnJhbWVTaXplKTtcblxuXHRcdFx0aWYgKF9uZXdBbHBoYSAhPSB1bmRlZmluZWQgJiYgX25ld0FscGhhICE9IF9wdkwuZ2V0X2FscGhhKCkpIHtcblx0XHRcdFx0X3B2TC5zZXRfYWxwaGEoX25ld0FscGhhKTtcblx0XHRcdFx0X3B2Ui5zZXRfYWxwaGEoX25ld0FscGhhKTtcblx0XHRcdFx0X25ld0FscGhhID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXG5cblx0XHRcdC8qIExFRlQgKi9cblx0XHRcdF9wdkwucHJvY2VzcyhidWZMLCBfbWlkQnVmTCk7XG5cdFx0XHRfcHZSLnByb2Nlc3MoYnVmUiwgX21pZEJ1ZlIpO1xuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciBpID0gc2FtcGxlQ291bnRlcjsgX21pZEJ1Zkwuc2l6ZSA+IDAgJiYgaSA8IG91dHB1dEF1ZGlvQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdG9sW2ldID0gX21pZEJ1Zkwuc2hpZnQoKTtcblx0XHRcdFx0b3JbaV0gPSBfbWlkQnVmUi5zaGlmdCgpO1xuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0c2FtcGxlQ291bnRlciArPSBfcHZMLmdldF9zeW50aGVzaXNfaG9wKCk7XG5cblx0XHRcdF9wb3NpdGlvblxuXHRcdFx0XHQrPSBfcHZMLmdldF9hbmFseXNpc19ob3AoKTtcblxuXHRcdH0gd2hpbGUgKHNhbXBsZUNvdW50ZXIgPCBvdXRwdXRBdWRpb0J1ZmZlci5sZW5ndGgpO1xuXHR9XG5cblx0dGhpcy5wcm9jZXNzID0gdGhpcy5wcm9jZXNzTW9ubztcblxuXHR0aGlzLnNldF9hdWRpb19idWZmZXIgPSBmdW5jdGlvbihuZXdCdWZmZXIpIHtcblx0XHRfYnVmZmVyID0gbmV3QnVmZmVyO1xuXHRcdGlmIChfYnVmZmVyLm51bWJlck9mQ2hhbm5lbHMgPT0gMilcblx0XHRcdHRoaXMucHJvY2VzcyA9IHRoaXMucHJvY2Vzc1N0ZXJlbztcblx0XHRlbHNlXG5cdFx0XHR0aGlzLnByb2Nlc3MgPSB0aGlzLnByb2Nlc3NNb25vO1x0XHRcblx0XHRfcG9zaXRpb24gPSAwO1xuXHRcdF9uZXdBbHBoYSA9IDE7XG5cdH1cblxuXHR0aGlzLnJlc2V0UGhhc2UgPSBmdW5jdGlvbigpIHtcblx0XHRfcHZMLnJlc2V0X3BoYXNlcygpO1xuXHRcdF9wdlIucmVzZXRfcGhhc2VzKCk7XG5cdH1cblx0XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcblx0XHQncG9zaXRpb24nIDoge1xuXHRcdFx0Z2V0IDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBfcG9zaXRpb247XG5cdFx0XHR9LCBcblx0XHRcdHNldCA6IGZ1bmN0aW9uKG5ld1Bvc2l0aW9uKSB7XG5cdFx0XHRcdF9wb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuXHRcdFx0fVxuXHRcdH0sIFxuXHRcdCdhbHBoYScgOiB7XG5cdFx0XHRnZXQgOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIF9wdkwuZ2V0X2FscGhhKCk7XG5cdFx0XHR9LCBcblx0XHRcdHNldCA6IGZ1bmN0aW9uKG5ld0FscGhhKSB7XG5cdFx0XHRcdF9uZXdBbHBoYSA9IG5ld0FscGhhO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0J1NURlQnOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIF9wdkwuU1RGVDtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uIChuZXdTVEZUKSB7XG5cdFx0XHRcdF9wdkwuU1RGVCA9IG5ld1NURlQ7XG5cdFx0XHRcdF9wdlIuU1RGVCA9IG5ld1NURlQ7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQnSVNURlQnOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0cmV0dXJuIF9wdkwuSVNURlQ7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiBmdW5jdGlvbiAobmV3SVNURlQpIHtcblx0XHRcdFx0X3B2TC5JU1RGVCA9IG5ld0lTVEZUO1xuXHRcdFx0XHRfcHZSLklTVEZUID0gbmV3SVNURlQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUFY7IiwiLypcblx0VGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cdENvcHlyaWdodCAoYykgMjAxMyBUcmV2b3IgTm9ycmlzIDx0cmV2Lm5vcnJpc0BnbWFpbC5jb20+XG5cblx0UGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxuXHR0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluXG5cdHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG9cblx0dXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2Zcblx0dGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuXHRzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuXHRUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcblx0Y29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5cdElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTXG5cdEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUlxuXHRDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVJcblx0SU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cblx0Q09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbmZ1bmN0aW9uIENCdWZmZXIoKSB7XG5cdC8vIGhhbmRsZSBjYXNlcyB3aGVyZSBcIm5ld1wiIGtleXdvcmQgd2Fzbid0IHVzZWRcblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIENCdWZmZXIpKSB7XG5cdFx0Ly8gbXVsdGlwbGUgY29uZGl0aW9ucyBuZWVkIHRvIGJlIGNoZWNrZWQgdG8gcHJvcGVybHkgZW11bGF0ZSBBcnJheVxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSB8fCB0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnbnVtYmVyJykge1xuXHRcdFx0cmV0dXJuIENCdWZmZXIuYXBwbHkobmV3IENCdWZmZXIoYXJndW1lbnRzLmxlbmd0aCksIGFyZ3VtZW50cyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBuZXcgQ0J1ZmZlcihhcmd1bWVudHNbMF0pO1xuXHRcdH1cblx0fVxuXHQvLyBpZiBubyBhcmd1bWVudHMsIHRoZW4gbm90aGluZyBuZWVkcyB0byBiZSBzZXRcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG5cdHRocm93IG5ldyBFcnJvcignTWlzc2luZyBBcmd1bWVudDogWW91IG11c3QgcGFzcyBhIHZhbGlkIGJ1ZmZlciBsZW5ndGgnKTtcblx0Ly8gdGhpcyBpcyB0aGUgc2FtZSBpbiBlaXRoZXIgc2NlbmFyaW9cblx0dGhpcy5zaXplID0gdGhpcy5zdGFydCA9IDA7XG5cdC8vIHNldCB0byBjYWxsYmFjayBmbiBpZiBkYXRhIGlzIGFib3V0IHRvIGJlIG92ZXJ3cml0dGVuXG5cdHRoaXMub3ZlcmZsb3cgPSBudWxsO1xuXHQvLyBlbXVsYXRlIEFycmF5IGJhc2VkIG9uIHBhc3NlZCBhcmd1bWVudHNcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxIHx8IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdudW1iZXInKSB7XG5cdFx0dGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblx0XHR0aGlzLmVuZCA9ICh0aGlzLmxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgpIC0gMTtcblx0XHR0aGlzLnB1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSBlbHNlIHtcblx0XHR0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGFyZ3VtZW50c1swXSk7XG5cdFx0dGhpcy5lbmQgPSAodGhpcy5sZW5ndGggPSBhcmd1bWVudHNbMF0pIC0gMTtcblx0fVxuXHQvLyBuZWVkIHRvIGByZXR1cm4gdGhpc2Agc28gYHJldHVybiBDQnVmZmVyLmFwcGx5YCB3b3Jrc1xuXHRyZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcml0b3IoYSwgYikge1xuXHRyZXR1cm4gYSA9PSBiID8gMCA6IGEgPiBiID8gMSA6IC0xO1xufVxuXG5DQnVmZmVyLnByb3RvdHlwZSA9IHtcblx0Ly8gcHJvcGVybHkgc2V0IGNvbnN0cnVjdG9yXG5cdGNvbnN0cnVjdG9yIDogQ0J1ZmZlcixcblxuXHQvKiBtdXRhdG9yIG1ldGhvZHMgKi9cblx0Ly8gcG9wIGxhc3QgaXRlbVxuXHRwb3AgOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGl0ZW07XG5cdFx0aWYgKHRoaXMuc2l6ZSA9PT0gMCkgcmV0dXJuO1xuXHRcdGl0ZW0gPSB0aGlzLmRhdGFbdGhpcy5lbmRdO1xuXHRcdC8vIHJlbW92ZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBvYmplY3Qgc28gaXQgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkXG5cdFx0ZGVsZXRlIHRoaXMuZGF0YVt0aGlzLmVuZF07XG5cdFx0dGhpcy5lbmQgPSAodGhpcy5lbmQgLSAxICsgdGhpcy5sZW5ndGgpICUgdGhpcy5sZW5ndGg7XG5cdFx0dGhpcy5zaXplLS07XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH0sXG5cdC8vIHB1c2ggaXRlbSB0byB0aGUgZW5kXG5cdHB1c2ggOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdC8vIGNoZWNrIGlmIG92ZXJmbG93IGlzIHNldCwgYW5kIGlmIGRhdGEgaXMgYWJvdXQgdG8gYmUgb3ZlcndyaXR0ZW5cblx0XHRpZiAodGhpcy5vdmVyZmxvdyAmJiB0aGlzLnNpemUgKyBhcmd1bWVudHMubGVuZ3RoID4gdGhpcy5sZW5ndGgpIHtcblx0XHRcdC8vIGNhbGwgb3ZlcmZsb3cgZnVuY3Rpb24gYW5kIHNlbmQgZGF0YSB0aGF0J3MgYWJvdXQgdG8gYmUgb3ZlcndyaXR0ZW5cblx0XHRcdGZvciAoOyBpIDwgdGhpcy5zaXplICsgYXJndW1lbnRzLmxlbmd0aCAtIHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5vdmVyZmxvdyh0aGlzLmRhdGFbKHRoaXMuZW5kICsgaSArIDEpICUgdGhpcy5sZW5ndGhdLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gcHVzaCBpdGVtcyB0byB0aGUgZW5kLCB3cmFwcGluZyBhbmQgZXJhc2luZyBleGlzdGluZyBpdGVtc1xuXHRcdC8vIHVzaW5nIGFyZ3VtZW50cyB2YXJpYWJsZSBkaXJlY3RseSB0byByZWR1Y2UgZ2MgZm9vdHByaW50XG5cdFx0Zm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5kYXRhWyh0aGlzLmVuZCArIGkgKyAxKSAlIHRoaXMubGVuZ3RoXSA9IGFyZ3VtZW50c1tpXTtcblx0XHR9XG5cdFx0Ly8gcmVjYWxjdWxhdGUgc2l6ZVxuXHRcdGlmICh0aGlzLnNpemUgPCB0aGlzLmxlbmd0aCkge1xuXHRcdFx0aWYgKHRoaXMuc2l6ZSArIGkgPiB0aGlzLmxlbmd0aCkgdGhpcy5zaXplID0gdGhpcy5sZW5ndGg7XG5cdFx0XHRlbHNlIHRoaXMuc2l6ZSArPSBpO1xuXHRcdH1cblx0XHQvLyByZWNhbGN1bGF0ZSBlbmRcblx0XHR0aGlzLmVuZCA9ICh0aGlzLmVuZCArIGkpICUgdGhpcy5sZW5ndGg7XG5cdFx0Ly8gcmVjYWxjdWxhdGUgc3RhcnRcblx0XHR0aGlzLnN0YXJ0ID0gKHRoaXMubGVuZ3RoICsgdGhpcy5lbmQgLSB0aGlzLnNpemUgKyAxKSAlIHRoaXMubGVuZ3RoO1xuXHRcdC8vIHJldHVybiBudW1iZXIgY3VycmVudCBudW1iZXIgb2YgaXRlbXMgaW4gQ0J1ZmZlclxuXHRcdHJldHVybiB0aGlzLnNpemU7XG5cdH0sXG5cdC8vIHJldmVyc2Ugb3JkZXIgb2YgdGhlIGJ1ZmZlclxuXHRyZXZlcnNlIDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdHRtcDtcblx0XHRmb3IgKDsgaSA8IH5+KHRoaXMuc2l6ZSAvIDIpOyBpKyspIHtcblx0XHRcdHRtcCA9IHRoaXMuZGF0YVsodGhpcy5zdGFydCArIGkpICUgdGhpcy5sZW5ndGhdO1xuXHRcdFx0dGhpcy5kYXRhWyh0aGlzLnN0YXJ0ICsgaSkgJSB0aGlzLmxlbmd0aF0gPSB0aGlzLmRhdGFbKHRoaXMuc3RhcnQgKyAodGhpcy5zaXplIC0gaSAtIDEpKSAlIHRoaXMubGVuZ3RoXTtcblx0XHRcdHRoaXMuZGF0YVsodGhpcy5zdGFydCArICh0aGlzLnNpemUgLSBpIC0gMSkpICUgdGhpcy5sZW5ndGhdID0gdG1wO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblx0Ly8gcm90YXRlIGJ1ZmZlciB0byB0aGUgbGVmdCBieSBjbnRyLCBvciBieSAxXG5cdHJvdGF0ZUxlZnQgOiBmdW5jdGlvbiAoY250cikge1xuXHRcdGlmICh0eXBlb2YgY250ciA9PT0gJ3VuZGVmaW5lZCcpIGNudHIgPSAxO1xuXHRcdGlmICh0eXBlb2YgY250ciAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXJcIik7XG5cdFx0d2hpbGUgKC0tY250ciA+PSAwKSB7XG5cdFx0XHR0aGlzLnB1c2godGhpcy5zaGlmdCgpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cdC8vIHJvdGF0ZSBidWZmZXIgdG8gdGhlIHJpZ2h0IGJ5IGNudHIsIG9yIGJ5IDFcblx0cm90YXRlUmlnaHQgOiBmdW5jdGlvbiAoY250cikge1xuXHRcdGlmICh0eXBlb2YgY250ciA9PT0gJ3VuZGVmaW5lZCcpIGNudHIgPSAxO1xuXHRcdGlmICh0eXBlb2YgY250ciAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXJcIik7XG5cdFx0d2hpbGUgKC0tY250ciA+PSAwKSB7XG5cdFx0XHR0aGlzLnVuc2hpZnQodGhpcy5wb3AoKSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHQvLyByZW1vdmUgYW5kIHJldHVybiBmaXJzdCBpdGVtXG5cdHNoaWZ0IDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBpdGVtO1xuXHRcdC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgaXRlbXMgaW4gQ0J1ZmZcblx0XHRpZiAodGhpcy5zaXplID09PSAwKSByZXR1cm47XG5cdFx0Ly8gc3RvcmUgZmlyc3QgaXRlbSBmb3IgcmV0dXJuXG5cdFx0aXRlbSA9IHRoaXMuZGF0YVt0aGlzLnN0YXJ0XTtcblx0XHQvLyByZWNhbGN1bGF0ZSBzdGFydCBvZiBDQnVmZmVyXG5cdFx0dGhpcy5zdGFydCA9ICh0aGlzLnN0YXJ0ICsgMSkgJSB0aGlzLmxlbmd0aDtcblx0XHQvLyBkZWNyZW1lbnQgc2l6ZVxuXHRcdHRoaXMuc2l6ZS0tO1xuXHRcdHJldHVybiBpdGVtO1xuXHR9LFxuXHQvLyBzb3J0IGl0ZW1zXG5cdHNvcnQgOiBmdW5jdGlvbiAoZm4pIHtcblx0XHQvLyB0aGlzLmRhdGEuc29ydChmbiB8fCBkZWZhdWx0Q29tcGFyaXRvcik7XG5cdFx0Ly8gdGhpcy5zdGFydCA9IDA7XG5cdFx0Ly8gdGhpcy5lbmQgPSB0aGlzLnNpemUgLSAxO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHQvLyBhZGQgaXRlbSB0byBiZWdpbm5pbmcgb2YgYnVmZmVyXG5cdHVuc2hpZnQgOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdC8vIGNoZWNrIGlmIG92ZXJmbG93IGlzIHNldCwgYW5kIGlmIGRhdGEgaXMgYWJvdXQgdG8gYmUgb3ZlcndyaXR0ZW5cblx0XHRpZiAodGhpcy5vdmVyZmxvdyAmJiB0aGlzLnNpemUgKyBhcmd1bWVudHMubGVuZ3RoID4gdGhpcy5sZW5ndGgpIHtcblx0XHRcdC8vIGNhbGwgb3ZlcmZsb3cgZnVuY3Rpb24gYW5kIHNlbmQgZGF0YSB0aGF0J3MgYWJvdXQgdG8gYmUgb3ZlcndyaXR0ZW5cblx0XHRcdGZvciAoOyBpIDwgdGhpcy5zaXplICsgYXJndW1lbnRzLmxlbmd0aCAtIHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dGhpcy5vdmVyZmxvdyh0aGlzLmRhdGFbdGhpcy5lbmQgLSAoaSAlIHRoaXMubGVuZ3RoKV0sIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR0aGlzLmRhdGFbKHRoaXMubGVuZ3RoICsgdGhpcy5zdGFydCAtIChpICUgdGhpcy5sZW5ndGgpIC0gMSkgJSB0aGlzLmxlbmd0aF0gPSBhcmd1bWVudHNbaV07XG5cdFx0fVxuXHRcdGlmICh0aGlzLmxlbmd0aCAtIHRoaXMuc2l6ZSAtIGkgPCAwKSB7XG5cdFx0XHR0aGlzLmVuZCArPSB0aGlzLmxlbmd0aCAtIHRoaXMuc2l6ZSAtIGk7XG5cdFx0XHRpZiAodGhpcy5lbmQgPCAwKSB0aGlzLmVuZCA9IHRoaXMubGVuZ3RoICsgKHRoaXMuZW5kICUgdGhpcy5sZW5ndGgpO1xuXHRcdH1cblx0XHRpZiAodGhpcy5zaXplIDwgdGhpcy5sZW5ndGgpIHtcblx0XHRcdGlmICh0aGlzLnNpemUgKyBpID4gdGhpcy5sZW5ndGgpIHRoaXMuc2l6ZSA9IHRoaXMubGVuZ3RoO1xuXHRcdFx0ZWxzZSB0aGlzLnNpemUgKz0gaTtcblx0XHR9XG5cdFx0dGhpcy5zdGFydCAtPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdGlmICh0aGlzLnN0YXJ0IDwgMCkgdGhpcy5zdGFydCA9IHRoaXMubGVuZ3RoICsgKHRoaXMuc3RhcnQgJSB0aGlzLmxlbmd0aCk7XG5cdFx0cmV0dXJuIHRoaXMuc2l6ZTtcblx0fSxcblxuXHQvKiBhY2Nlc3NvciBtZXRob2RzICovXG5cdC8vIHJldHVybiBpbmRleCBvZiBmaXJzdCBtYXRjaGVkIGVsZW1lbnRcblx0aW5kZXhPZiA6IGZ1bmN0aW9uIChhcmcsIGlkeCkge1xuXHRcdGlmICghaWR4KSBpZHggPSAwO1xuXHRcdGZvciAoOyBpZHggPCB0aGlzLnNpemU7IGlkeCsrKSB7XG5cdFx0XHRpZiAodGhpcy5kYXRhWyh0aGlzLnN0YXJ0ICsgaWR4KSAlIHRoaXMubGVuZ3RoXSA9PT0gYXJnKSByZXR1cm4gaWR4O1xuXHRcdH1cblx0XHRyZXR1cm4gLTE7XG5cdH0sXG5cdC8vIHJldHVybiBsYXN0IGluZGV4IG9mIHRoZSBmaXJzdCBtYXRjaFxuXHRsYXN0SW5kZXhPZiA6IGZ1bmN0aW9uIChhcmcsIGlkeCkge1xuXHRcdGlmICghaWR4KSBpZHggPSB0aGlzLnNpemUgLSAxO1xuXHRcdGZvciAoOyBpZHggPj0gMDsgaWR4LS0pIHtcblx0XHRcdGlmICh0aGlzLmRhdGFbKHRoaXMuc3RhcnQgKyBpZHgpICUgdGhpcy5sZW5ndGhdID09PSBhcmcpIHJldHVybiBpZHg7XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHQvLyByZXR1cm4gdGhlIGluZGV4IGFuIGl0ZW0gd291bGQgYmUgaW5zZXJ0ZWQgdG8gaWYgdGhpc1xuXHQvLyBpcyBhIHNvcnRlZCBjaXJjdWxhciBidWZmZXJcblx0c29ydGVkSW5kZXggOiBmdW5jdGlvbih2YWx1ZSwgY29tcGFyaXRvciwgY29udGV4dCkge1xuXHRcdGNvbXBhcml0b3IgPSBjb21wYXJpdG9yIHx8IGRlZmF1bHRDb21wYXJpdG9yO1xuXHRcdHZhciBsb3cgPSB0aGlzLnN0YXJ0LFxuXHRcdFx0aGlnaCA9IHRoaXMuc2l6ZSAtIDE7XG5cblx0XHQvLyBUcmlja3kgcGFydCBpcyBmaW5kaW5nIGlmIGl0cyBiZWZvcmUgb3IgYWZ0ZXIgdGhlIHBpdm90XG5cdFx0Ly8gd2UgY2FuIGdldCB0aGlzIGluZm8gYnkgY2hlY2tpbmcgaWYgdGhlIHRhcmdldCBpcyBsZXNzIHRoYW5cblx0XHQvLyB0aGUgbGFzdCBpdGVtLiBBZnRlciB0aGF0IGl0J3MganVzdCBhIHR5cGljYWwgYmluYXJ5IHNlYXJjaC5cblx0XHRpZiAobG93ICYmIGNvbXBhcml0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgdGhpcy5kYXRhW2hpZ2hdKSA+IDApIHtcblx0XHRcdGxvdyA9IDAsIGhpZ2ggPSB0aGlzLmVuZDtcblx0XHR9XG5cblx0XHR3aGlsZSAobG93IDwgaGlnaCkge1xuXHRcdCAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcblx0XHQgIGlmIChjb21wYXJpdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIHRoaXMuZGF0YVttaWRdKSA+IDApIGxvdyA9IG1pZCArIDE7XG5cdFx0ICBlbHNlIGhpZ2ggPSBtaWQ7XG5cdFx0fVxuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE4NjE4MjczLzE1MTc5MTlcblx0XHRyZXR1cm4gKCgobG93IC0gdGhpcy5zdGFydCkgJSB0aGlzLnNpemUpICsgdGhpcy5zaXplKSAlIHRoaXMuc2l6ZTtcblx0fSxcblxuXHQvKiBpdGVyYXRpb24gbWV0aG9kcyAqL1xuXHQvLyBjaGVjayBldmVyeSBpdGVtIGluIHRoZSBhcnJheSBhZ2FpbnN0IGEgdGVzdFxuXHRldmVyeSA6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuXHRcdHZhciBpID0gMDtcblx0XHRmb3IgKDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG5cdFx0XHRpZiAoIWNhbGxiYWNrLmNhbGwoY29udGV4dCwgdGhpcy5kYXRhWyh0aGlzLnN0YXJ0ICsgaSkgJSB0aGlzLmxlbmd0aF0sIGksIHRoaXMpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXHQvLyBsb29wIHRocm91Z2ggZWFjaCBpdGVtIGluIGJ1ZmZlclxuXHQvLyBUT0RPOiBmaWd1cmUgb3V0IGhvdyB0byBlbXVsYXRlIEFycmF5IHVzZSBiZXR0ZXJcblx0Zm9yRWFjaCA6IGZ1bmN0aW9uIChjYWxsYmFjaywgY29udGV4dCkge1xuXHRcdHZhciBpID0gMDtcblx0XHRmb3IgKDsgaSA8IHRoaXMuc2l6ZTsgaSsrKSB7XG5cdFx0XHRjYWxsYmFjay5jYWxsKGNvbnRleHQsIHRoaXMuZGF0YVsodGhpcy5zdGFydCArIGkpICUgdGhpcy5sZW5ndGhdLCBpLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cdC8vIGNoZWNrIGl0ZW1zIGFnYWlucyB0ZXN0IHVudGlsIG9uZSByZXR1cm5zIHRydWVcblx0Ly8gVE9ETzogZmlndXJlIG91dCBob3cgdG8gZW11bGRhdGUgQXJyYXkgdXNlIGJldHRlclxuXHRzb21lIDogZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdGZvciAoOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcblx0XHRcdGlmIChjYWxsYmFjay5jYWxsKGNvbnRleHQsIHRoaXMuZGF0YVsodGhpcy5zdGFydCArIGkpICUgdGhpcy5sZW5ndGhdLCBpLCB0aGlzKSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblx0Ly8gY2FsY3VsYXRlIHRoZSBhdmVyYWdlIHZhbHVlIG9mIGEgY2lyY3VsYXIgYnVmZmVyXG5cdGF2ZyA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5zaXplID09IDAgPyAwIDogKHRoaXMuc3VtKCkgLyB0aGlzLnNpemUpO1xuXHR9LFxuXHQvLyBsb29wIHRocm91Z2ggZWFjaCBpdGVtIGluIGJ1ZmZlciBhbmQgY2FsY3VsYXRlIHN1bVxuXHRzdW0gOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5zaXplO1xuXHRcdHZhciBzID0gMDtcblx0XHR3aGlsZSAoaW5kZXgtLSkgcyArPSB0aGlzLmRhdGFbaW5kZXhdO1xuXHRcdHJldHVybiBzO1xuXHR9LFxuXHQvLyBsb29wIHRocm91Z2ggZWFjaCBpdGVtIGluIGJ1ZmZlciBhbmQgY2FsY3VsYXRlIG1lZGlhblxuXHRtZWRpYW4gOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuc2l6ZSA9PT0gMClcblx0XHRcdHJldHVybiAwO1xuXHRcdHZhciB2YWx1ZXMgPSB0aGlzLnNsaWNlKCkuc29ydChkZWZhdWx0Q29tcGFyaXRvcik7XG5cdFx0dmFyIGhhbGYgPSBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKTtcblx0XHRpZih2YWx1ZXMubGVuZ3RoICUgMilcblx0XHRcdHJldHVybiB2YWx1ZXNbaGFsZl07XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuICh2YWx1ZXNbaGFsZi0xXSArIHZhbHVlc1toYWxmXSkgLyAyLjA7XG5cdH0sXG5cdC8qIHV0aWxpdHkgbWV0aG9kcyAqL1xuXHQvLyByZXNldCBwb2ludGVycyB0byBidWZmZXIgd2l0aCB6ZXJvIGl0ZW1zXG5cdC8vIG5vdGU6IHRoaXMgd2lsbCBub3QgcmVtb3ZlIHZhbHVlcyBpbiBjYnVmZmVyLCBzbyBpZiBmb3Igc2VjdXJpdHkgdmFsdWVzXG5cdC8vICAgICAgIG5lZWQgdG8gYmUgb3ZlcndyaXR0ZW4sIHJ1biBgLmZpbGwobnVsbCkuZW1wdHkoKWBcblx0ZW1wdHkgOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGkgPSAwO1xuXHRcdHRoaXMuc2l6ZSA9IHRoaXMuc3RhcnQgPSAwO1xuXHRcdHRoaXMuZW5kID0gdGhpcy5sZW5ndGggLSAxO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHQvLyBmaWxsIGFsbCBwbGFjZXMgd2l0aCBwYXNzZWQgdmFsdWUgb3IgZnVuY3Rpb25cblx0ZmlsbCA6IGZ1bmN0aW9uIChhcmcpIHtcblx0XHR2YXIgaSA9IDA7XG5cdFx0aWYgKHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHdoaWxlKHRoaXMuZGF0YVtpXSA9IGFyZygpLCArK2kgPCB0aGlzLmxlbmd0aCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdoaWxlKHRoaXMuZGF0YVtpXSA9IGFyZywgKytpIDwgdGhpcy5sZW5ndGgpO1xuXHRcdH1cblx0XHQvLyByZXBvc2l0aW9uIHN0YXJ0L2VuZFxuXHRcdHRoaXMuc3RhcnQgPSAwO1xuXHRcdHRoaXMuZW5kID0gdGhpcy5sZW5ndGggLSAxO1xuXHRcdHRoaXMuc2l6ZSA9IHRoaXMubGVuZ3RoO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXHQvLyByZXR1cm4gZmlyc3QgaXRlbSBpbiBidWZmZXJcblx0Zmlyc3QgOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YVt0aGlzLnN0YXJ0XTtcblx0fSxcblx0Ly8gcmV0dXJuIGxhc3QgaXRlbSBpbiBidWZmZXJcblx0bGFzdCA6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhW3RoaXMuZW5kXTtcblx0fSxcblx0Ly8gcmV0dXJuIHNwZWNpZmljIGluZGV4IGluIGJ1ZmZlclxuXHRnZXQgOiBmdW5jdGlvbiAoYXJnKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YVsodGhpcy5zdGFydCArIGFyZykgJSB0aGlzLmxlbmd0aF07XG5cdH0sXG5cdGlzRnVsbCA6IGZ1bmN0aW9uIChhcmcpIHtcblx0XHRyZXR1cm4gdGhpcy5sZW5ndGggPT09IHRoaXMuc2l6ZTtcblx0fSxcblx0Ly8gc2V0IHZhbHVlIGF0IHNwZWNpZmllZCBpbmRleFxuXHRzZXQgOiBmdW5jdGlvbiAoaWR4LCBhcmcpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhWyh0aGlzLnN0YXJ0ICsgaWR4KSAlIHRoaXMubGVuZ3RoXSA9IGFyZztcblx0fSxcblx0Ly8gcmV0dXJuIGNsZWFuIGFycmF5IG9mIHZhbHVlc1xuXHR0b0FycmF5IDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLnNsaWNlKCk7XG5cdH0sXG5cdC8vIHNsaWNlIHRoZSBidWZmZXIgdG8gYW4gYXJyYWF5XG5cdHNsaWNlIDogZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5zaXplO1xuXG5cdFx0c3RhcnQgPSArc3RhcnQgfHwgMDtcblxuXHRcdGlmIChzdGFydCA8IDApIHtcblx0XHRcdGlmIChzdGFydCA+PSBlbmQpXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdHN0YXJ0ID0gKC1zdGFydCA+IGxlbmd0aCkgPyAwIDogbGVuZ3RoICsgc3RhcnQ7XG5cdFx0fVxuXG5cdFx0aWYgKGVuZCA9PSBudWxsIHx8IGVuZCA+IGxlbmd0aClcblx0XHRcdGVuZCA9IGxlbmd0aDtcblx0XHRlbHNlIGlmIChlbmQgPCAwKVxuXHRcdFx0ZW5kICs9IGxlbmd0aDtcblx0XHRlbHNlXG5cdFx0XHRlbmQgPSArZW5kIHx8IDA7XG5cblx0XHRsZW5ndGggPSBzdGFydCA8IGVuZCA/IGVuZCAtIHN0YXJ0IDogMDtcblxuXHRcdHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXHRcdGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcblx0XHRcdHJlc3VsdFtpbmRleF0gPSB0aGlzLmRhdGFbKHRoaXMuc3RhcnQgKyBzdGFydCArIGluZGV4KSAlIHRoaXMubGVuZ3RoXTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxufTtcblxuLy9pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIG1vZHVsZS5leHBvcnRzID0gQ0J1ZmZlcjtcbi8vZWxzZSBnbG9iYWwuQ0J1ZmZlciA9IENCdWZmZXI7XG5cbmV4cG9ydCBkZWZhdWx0IENCdWZmZXI7IiwiLyogXG4gKiAgRFNQLmpzIC0gYSBjb21wcmVoZW5zaXZlIGRpZ2l0YWwgc2lnbmFsIHByb2Nlc3NpbmcgIGxpYnJhcnkgZm9yIGphdmFzY3JpcHRcbiAqIFxuICogIENyZWF0ZWQgYnkgQ29yYmFuIEJyb29rIDxjb3JiYW5icm9va0BnbWFpbC5jb20+IG9uIDIwMTAtMDEtMDEuXG4gKiAgQ29weXJpZ2h0IDIwMTAgQ29yYmFuIEJyb29rLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqICBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqICBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbiAqICB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiAgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiAgcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG4gKiAgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG4gKiAgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuICogIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuICogIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT05TVEFOVFMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBEU1AgaXMgYW4gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIGdlbmVyYWwgcHVycG9zZSB1dGlsaXR5IGZ1bmN0aW9ucyBhbmQgY29uc3RhbnRzXG4gKi9cbnZhciBEU1AgPSB7XG4gIC8vIENoYW5uZWxzXG4gIExFRlQ6ICAgICAgICAgICAwLFxuICBSSUdIVDogICAgICAgICAgMSxcbiAgTUlYOiAgICAgICAgICAgIDIsXG5cbiAgLy8gV2F2ZWZvcm1zXG4gIFNJTkU6ICAgICAgICAgICAxLFxuICBUUklBTkdMRTogICAgICAgMixcbiAgU0FXOiAgICAgICAgICAgIDMsXG4gIFNRVUFSRTogICAgICAgICA0LFxuXG4gIC8vIEZpbHRlcnNcbiAgTE9XUEFTUzogICAgICAgIDAsXG4gIEhJR0hQQVNTOiAgICAgICAxLFxuICBCQU5EUEFTUzogICAgICAgMixcbiAgTk9UQ0g6ICAgICAgICAgIDMsXG5cbiAgLy8gV2luZG93IGZ1bmN0aW9uc1xuICBCQVJUTEVUVDogICAgICAgMSxcbiAgQkFSVExFVFRIQU5OOiAgIDIsXG4gIEJMQUNLTUFOOiAgICAgICAzLFxuICBDT1NJTkU6ICAgICAgICAgNCxcbiAgR0FVU1M6ICAgICAgICAgIDUsXG4gIEhBTU1JTkc6ICAgICAgICA2LFxuICBIQU5OOiAgICAgICAgICAgNyxcbiAgTEFOQ1pPUzogICAgICAgIDgsXG4gIFJFQ1RBTkdVTEFSOiAgICA5LFxuICBUUklBTkdVTEFSOiAgICAgMTAsXG5cbiAgLy8gTG9vcCBtb2Rlc1xuICBPRkY6ICAgICAgICAgICAgMCxcbiAgRlc6ICAgICAgICAgICAgIDEsXG4gIEJXOiAgICAgICAgICAgICAyLFxuICBGV0JXOiAgICAgICAgICAgMyxcblxuICAvLyBNYXRoXG4gIFRXT19QSTogICAgICAgICAyKk1hdGguUElcbn07XG5cbi8vIFNldHVwIGFycmF5cyBmb3IgcGxhdGZvcm1zIHdoaWNoIGRvIG5vdCBzdXBwb3J0IGJ5dGUgYXJyYXlzXG5mdW5jdGlvbiBzZXR1cFR5cGVkQXJyYXkobmFtZSwgZmFsbGJhY2spIHtcbiAgdmFyIHNlbGYgPSB3aW5kb3c7XG4gIC8vIGNoZWNrIGlmIFR5cGVkQXJyYXkgZXhpc3RzXG4gIC8vIHR5cGVvZiBvbiBNaW5lZmllbGQgYW5kIENocm9tZSByZXR1cm4gZnVuY3Rpb24sIHR5cGVvZiBvbiBXZWJraXQgcmV0dXJucyBvYmplY3QuXG4gIGlmICh0eXBlb2Ygc2VsZltuYW1lXSAhPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzZWxmW25hbWVdICE9PSBcIm9iamVjdFwiKSB7XG4gICAgLy8gbm9wZS4uIGNoZWNrIGlmIFdlYkdMQXJyYXkgZXhpc3RzXG4gICAgaWYgKHR5cGVvZiBzZWxmW2ZhbGxiYWNrXSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBzZWxmW2ZhbGxiYWNrXSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgc2VsZltuYW1lXSA9IHNlbGZbZmFsbGJhY2tdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBub3BlLi4gc2V0IGFzIE5hdGl2ZSBKUyBhcnJheVxuICAgICAgc2VsZltuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEFycmF5KG9iaik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbnNldHVwVHlwZWRBcnJheShcIkZsb2F0MzJBcnJheVwiLCBcIldlYkdMRmxvYXRBcnJheVwiKTtcbnNldHVwVHlwZWRBcnJheShcIkludDMyQXJyYXlcIiwgICBcIldlYkdMSW50QXJyYXlcIik7XG5zZXR1cFR5cGVkQXJyYXkoXCJVaW50MTZBcnJheVwiLCAgXCJXZWJHTFVuc2lnbmVkU2hvcnRBcnJheVwiKTtcbnNldHVwVHlwZWRBcnJheShcIlVpbnQ4QXJyYXlcIiwgICBcIldlYkdMVW5zaWduZWRCeXRlQXJyYXlcIik7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIERTUCBVVElMSVRZIEZVTkNUSU9OUyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEludmVydHMgdGhlIHBoYXNlIG9mIGEgc2lnbmFsXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYnVmZmVyIEEgc2FtcGxlIGJ1ZmZlclxuICpcbiAqIEByZXR1cm5zIFRoZSBpbnZlcnRlZCBzYW1wbGUgYnVmZmVyXG4gKi9cbkRTUC5pbnZlcnQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1ZmZlci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZmZlcltpXSAqPSAtMTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHNwbGl0LXN0ZXJlbyAoZHVhbCBtb25vKSBzYW1wbGUgYnVmZmVycyBpbnRvIGEgc3RlcmVvIGludGVybGVhdmVkIHNhbXBsZSBidWZmZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBsZWZ0ICBBIHNhbXBsZSBidWZmZXJcbiAqIEBwYXJhbSB7QXJyYXl9IHJpZ2h0IEEgc2FtcGxlIGJ1ZmZlclxuICpcbiAqIEByZXR1cm5zIFRoZSBzdGVyZW8gaW50ZXJsZWF2ZWQgYnVmZmVyXG4gKi9cbkRTUC5pbnRlcmxlYXZlID0gZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgaWYgKGxlZnQubGVuZ3RoICE9PSByaWdodC5sZW5ndGgpIHtcbiAgICB0aHJvdyBcIkNhbiBub3QgaW50ZXJsZWF2ZS4gQ2hhbm5lbCBsZW5ndGhzIGRpZmZlci5cIjtcbiAgfVxuIFxuICB2YXIgc3RlcmVvSW50ZXJsZWF2ZWQgPSBuZXcgRmxvYXQzMkFycmF5KGxlZnQubGVuZ3RoICogMik7XG4gXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc3RlcmVvSW50ZXJsZWF2ZWRbMippXSAgID0gbGVmdFtpXTtcbiAgICBzdGVyZW9JbnRlcmxlYXZlZFsyKmkrMV0gPSByaWdodFtpXTtcbiAgfVxuIFxuICByZXR1cm4gc3RlcmVvSW50ZXJsZWF2ZWQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RlcmVvLWludGVybGVhdmVkIHNhbXBsZSBidWZmZXIgaW50byBzcGxpdC1zdGVyZW8gKGR1YWwgbW9ubykgc2FtcGxlIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXIgQSBzdGVyZW8taW50ZXJsZWF2ZWQgc2FtcGxlIGJ1ZmZlclxuICpcbiAqIEByZXR1cm5zIGFuIEFycmF5IGNvbnRhaW5pbmcgbGVmdCBhbmQgcmlnaHQgY2hhbm5lbHNcbiAqL1xuRFNQLmRlaW50ZXJsZWF2ZSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIGxlZnQsIHJpZ2h0LCBtaXgsIGRlaW50ZXJsZWF2ZUNoYW5uZWwgPSBbXTsgXG5cbiAgZGVpbnRlcmxlYXZlQ2hhbm5lbFtEU1AuTUlYXSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWZmZXIubGVuZ3RoLzI7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWl4W2ldID0gKGJ1ZmZlclsyKmldICsgYnVmZmVyWzIqaSsxXSkgLyAyO1xuICAgIH1cbiAgICByZXR1cm4gbWl4O1xuICB9O1xuXG4gIGRlaW50ZXJsZWF2ZUNoYW5uZWxbRFNQLkxFRlRdID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1ZmZlci5sZW5ndGgvMjsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZWZ0W2ldICA9IGJ1ZmZlclsyKmldO1xuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfTtcblxuICBkZWludGVybGVhdmVDaGFubmVsW0RTUC5SSUdIVF0gPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmZmVyLmxlbmd0aC8yOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJpZ2h0W2ldICA9IGJ1ZmZlclsyKmkrMV07XG4gICAgfVxuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24oY2hhbm5lbCwgYnVmZmVyKSB7IFxuICAgIGxlZnQgID0gbGVmdCAgfHwgbmV3IEZsb2F0MzJBcnJheShidWZmZXIubGVuZ3RoLzIpO1xuICAgIHJpZ2h0ID0gcmlnaHQgfHwgbmV3IEZsb2F0MzJBcnJheShidWZmZXIubGVuZ3RoLzIpO1xuICAgIG1peCAgID0gbWl4ICAgfHwgbmV3IEZsb2F0MzJBcnJheShidWZmZXIubGVuZ3RoLzIpO1xuXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGgvMiAhPT0gbGVmdC5sZW5ndGgpIHtcbiAgICAgIGxlZnQgID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIubGVuZ3RoLzIpO1xuICAgICAgcmlnaHQgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlci5sZW5ndGgvMik7XG4gICAgICBtaXggICA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLmxlbmd0aC8yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVpbnRlcmxlYXZlQ2hhbm5lbFtjaGFubmVsXShidWZmZXIpO1xuICB9O1xufSgpKTtcblxuLyoqXG4gKiBTZXBhcmF0ZXMgYSBjaGFubmVsIGZyb20gYSBzdGVyZW8taW50ZXJsZWF2ZWQgc2FtcGxlIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9ICBidWZmZXIgQSBzdGVyZW8taW50ZXJsZWF2ZWQgc2FtcGxlIGJ1ZmZlclxuICogQHBhcmFtIHtOdW1iZXJ9IGNoYW5uZWwgQSBjaGFubmVsIGNvbnN0YW50IChMRUZULCBSSUdIVCwgTUlYKVxuICpcbiAqIEByZXR1cm5zIGFuIEFycmF5IGNvbnRhaW5pbmcgYSBzaWduYWwgbW9ubyBzYW1wbGUgYnVmZmVyXG4gKi9cbkRTUC5nZXRDaGFubmVsID0gRFNQLmRlaW50ZXJsZWF2ZTtcblxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIChmb3IgUmV2ZXJiKSB0byBtaXggdHdvIChpbnRlcmxlYXZlZCkgc2FtcGxlYnVmZmVycy4gSXQncyBwb3NzaWJsZVxuICogdG8gbmVnYXRlIHRoZSBzZWNvbmQgYnVmZmVyIHdoaWxlIG1peGluZyBhbmQgdG8gcGVyZm9ybSBhIHZvbHVtZSBjb3JyZWN0aW9uXG4gKiBvbiB0aGUgZmluYWwgc2lnbmFsLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNhbXBsZUJ1ZmZlcjEgQXJyYXkgY29udGFpbmluZyBGbG9hdCB2YWx1ZXMgb3IgYSBGbG9hdDMyQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IHNhbXBsZUJ1ZmZlcjIgQXJyYXkgY29udGFpbmluZyBGbG9hdCB2YWx1ZXMgb3IgYSBGbG9hdDMyQXJyYXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbmVnYXRlIFdoZW4gdHJ1ZSBpbnZlcnRzL2ZsaXBzIHRoZSBhdWRpbyBzaWduYWxcbiAqIEBwYXJhbSB7TnVtYmVyfSB2b2x1bWVDb3JyZWN0aW9uIFdoZW4geW91IGFkZCBtdWx0aXBsZSBzYW1wbGUgYnVmZmVycywgdXNlIHRoaXMgdG8gdGFtZSB5b3VyIHNpZ25hbCA7KVxuICpcbiAqIEByZXR1cm5zIEEgbmV3IEZsb2F0MzJBcnJheSBpbnRlcmxlYXZlZCBidWZmZXIuXG4gKi9cbkRTUC5taXhTYW1wbGVCdWZmZXJzID0gZnVuY3Rpb24oc2FtcGxlQnVmZmVyMSwgc2FtcGxlQnVmZmVyMiwgbmVnYXRlLCB2b2x1bWVDb3JyZWN0aW9uKXtcbiAgdmFyIG91dHB1dFNhbXBsZXMgPSBuZXcgRmxvYXQzMkFycmF5KHNhbXBsZUJ1ZmZlcjEpO1xuXG4gIGZvcih2YXIgaSA9IDA7IGk8c2FtcGxlQnVmZmVyMS5sZW5ndGg7IGkrKyl7XG4gICAgb3V0cHV0U2FtcGxlc1tpXSArPSAobmVnYXRlID8gLXNhbXBsZUJ1ZmZlcjJbaV0gOiBzYW1wbGVCdWZmZXIyW2ldKSAvIHZvbHVtZUNvcnJlY3Rpb247XG4gIH1cbiBcbiAgcmV0dXJuIG91dHB1dFNhbXBsZXM7XG59OyBcblxuLy8gQmlxdWFkIGZpbHRlciB0eXBlc1xuRFNQLkxQRiA9IDA7ICAgICAgICAgICAgICAgIC8vIEgocykgPSAxIC8gKHNeMiArIHMvUSArIDEpXG5EU1AuSFBGID0gMTsgICAgICAgICAgICAgICAgLy8gSChzKSA9IHNeMiAvIChzXjIgKyBzL1EgKyAxKVxuRFNQLkJQRl9DT05TVEFOVF9TS0lSVCA9IDI7IC8vIEgocykgPSBzIC8gKHNeMiArIHMvUSArIDEpICAoY29uc3RhbnQgc2tpcnQgZ2FpbiwgcGVhayBnYWluID0gUSlcbkRTUC5CUEZfQ09OU1RBTlRfUEVBSyA9IDM7ICAvLyBIKHMpID0gKHMvUSkgLyAoc14yICsgcy9RICsgMSkgICAgICAoY29uc3RhbnQgMCBkQiBwZWFrIGdhaW4pXG5EU1AuTk9UQ0ggPSA0OyAgICAgICAgICAgICAgLy8gSChzKSA9IChzXjIgKyAxKSAvIChzXjIgKyBzL1EgKyAxKVxuRFNQLkFQRiA9IDU7ICAgICAgICAgICAgICAgIC8vIEgocykgPSAoc14yIC0gcy9RICsgMSkgLyAoc14yICsgcy9RICsgMSlcbkRTUC5QRUFLSU5HX0VRID0gNjsgICAgICAgICAvLyBIKHMpID0gKHNeMiArIHMqKEEvUSkgKyAxKSAvIChzXjIgKyBzLyhBKlEpICsgMSlcbkRTUC5MT1dfU0hFTEYgPSA3OyAgICAgICAgICAvLyBIKHMpID0gQSAqIChzXjIgKyAoc3FydChBKS9RKSpzICsgQSkvKEEqc14yICsgKHNxcnQoQSkvUSkqcyArIDEpXG5EU1AuSElHSF9TSEVMRiA9IDg7ICAgICAgICAgLy8gSChzKSA9IEEgKiAoQSpzXjIgKyAoc3FydChBKS9RKSpzICsgMSkvKHNeMiArIChzcXJ0KEEpL1EpKnMgKyBBKVxuXG4vLyBCaXF1YWQgZmlsdGVyIHBhcmFtZXRlciB0eXBlc1xuRFNQLlEgPSAxO1xuRFNQLkJXID0gMjsgLy8gU0hBUkVEIHdpdGggQkFDS1dBUkRTIExPT1AgTU9ERVxuRFNQLlMgPSAzO1xuXG4vLyBGaW5kIFJNUyBvZiBzaWduYWxcbkRTUC5STVMgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHRvdGFsID0gMDtcbiAgXG4gIGZvciAodmFyIGkgPSAwLCBuID0gYnVmZmVyLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgIHRvdGFsICs9IGJ1ZmZlcltpXSAqIGJ1ZmZlcltpXTtcbiAgfVxuICBcbiAgcmV0dXJuIE1hdGguc3FydCh0b3RhbCAvIG4pO1xufTtcblxuLy8gRmluZCBQZWFrIG9mIHNpZ25hbFxuRFNQLlBlYWsgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHBlYWsgPSAwO1xuICBcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBidWZmZXIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgcGVhayA9IChNYXRoLmFicyhidWZmZXJbaV0pID4gcGVhaykgPyBNYXRoLmFicyhidWZmZXJbaV0pIDogcGVhazsgXG4gIH1cbiAgXG4gIHJldHVybiBwZWFrO1xufTtcblxuLy8gRm91cmllciBUcmFuc2Zvcm0gTW9kdWxlIHVzZWQgYnkgREZULCBGRlQsIFJGRlRcbmZ1bmN0aW9uIEZvdXJpZXJUcmFuc2Zvcm0oYnVmZmVyU2l6ZSwgc2FtcGxlUmF0ZSkge1xuICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICB0aGlzLnNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xuICB0aGlzLmJhbmR3aWR0aCAgPSAyIC8gYnVmZmVyU2l6ZSAqIHNhbXBsZVJhdGUgLyAyO1xuXG4gIHRoaXMuc3BlY3RydW0gICA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZS8yKTtcbiAgdGhpcy5yZWFsICAgICAgID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplKTtcbiAgdGhpcy5pbWFnICAgICAgID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplKTtcblxuICB0aGlzLnBlYWtCYW5kICAgPSAwO1xuICB0aGlzLnBlYWsgICAgICAgPSAwO1xuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSAqbWlkZGxlKiBmcmVxdWVuY3kgb2YgYW4gRkZUIGJhbmQuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIEZGVCBiYW5kLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgbWlkZGxlIGZyZXF1ZW5jeSBpbiBIei5cbiAgICovXG4gIHRoaXMuZ2V0QmFuZEZyZXF1ZW5jeSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuYmFuZHdpZHRoICogaW5kZXggKyB0aGlzLmJhbmR3aWR0aCAvIDI7XG4gIH07XG5cbiAgdGhpcy5jYWxjdWxhdGVTcGVjdHJ1bSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzcGVjdHJ1bSAgPSB0aGlzLnNwZWN0cnVtLFxuICAgICAgICByZWFsICAgICAgPSB0aGlzLnJlYWwsXG4gICAgICAgIGltYWcgICAgICA9IHRoaXMuaW1hZyxcbiAgICAgICAgYlNpICAgICAgID0gMiAvIHRoaXMuYnVmZmVyU2l6ZSxcbiAgICAgICAgc3FydCAgICAgID0gTWF0aC5zcXJ0LFxuICAgICAgICBydmFsLCBcbiAgICAgICAgaXZhbCxcbiAgICAgICAgbWFnO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIE4gPSBidWZmZXJTaXplLzI7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ2YWwgPSByZWFsW2ldO1xuICAgICAgaXZhbCA9IGltYWdbaV07XG4gICAgICBtYWcgPSBiU2kgKiBzcXJ0KHJ2YWwgKiBydmFsICsgaXZhbCAqIGl2YWwpO1xuXG4gICAgICBpZiAobWFnID4gdGhpcy5wZWFrKSB7XG4gICAgICAgIHRoaXMucGVha0JhbmQgPSBpO1xuICAgICAgICB0aGlzLnBlYWsgPSBtYWc7XG4gICAgICB9XG5cbiAgICAgIHNwZWN0cnVtW2ldID0gbWFnO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBERlQgaXMgYSBjbGFzcyBmb3IgY2FsY3VsYXRpbmcgdGhlIERpc2NyZXRlIEZvdXJpZXIgVHJhbnNmb3JtIG9mIGEgc2lnbmFsLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBidWZmZXJTaXplIFRoZSBzaXplIG9mIHRoZSBzYW1wbGUgYnVmZmVyIHRvIGJlIGNvbXB1dGVkXG4gKiBAcGFyYW0ge051bWJlcn0gc2FtcGxlUmF0ZSBUaGUgc2FtcGxlUmF0ZSBvZiB0aGUgYnVmZmVyIChlZy4gNDQxMDApXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIERGVChidWZmZXJTaXplLCBzYW1wbGVSYXRlKSB7XG4gIEZvdXJpZXJUcmFuc2Zvcm0uY2FsbCh0aGlzLCBidWZmZXJTaXplLCBzYW1wbGVSYXRlKTtcblxuICB2YXIgTiA9IGJ1ZmZlclNpemUvMiAqIGJ1ZmZlclNpemU7XG4gIHZhciBUV09fUEkgPSAyICogTWF0aC5QSTtcblxuICB0aGlzLnNpblRhYmxlID0gbmV3IEZsb2F0MzJBcnJheShOKTtcbiAgdGhpcy5jb3NUYWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkoTik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICB0aGlzLnNpblRhYmxlW2ldID0gTWF0aC5zaW4oaSAqIFRXT19QSSAvIGJ1ZmZlclNpemUpO1xuICAgIHRoaXMuY29zVGFibGVbaV0gPSBNYXRoLmNvcyhpICogVFdPX1BJIC8gYnVmZmVyU2l6ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGZvcndhcmQgdHJhbnNmb3JtIG9uIHRoZSBzYW1wbGUgYnVmZmVyLlxuICogQ29udmVydHMgYSB0aW1lIGRvbWFpbiBzaWduYWwgdG8gZnJlcXVlbmN5IGRvbWFpbiBzcGVjdHJhLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlciBUaGUgc2FtcGxlIGJ1ZmZlclxuICpcbiAqIEByZXR1cm5zIFRoZSBmcmVxdWVuY3kgc3BlY3RydW0gYXJyYXlcbiAqL1xuREZULnByb3RvdHlwZS5mb3J3YXJkID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZWFsID0gdGhpcy5yZWFsLCBcbiAgICAgIGltYWcgPSB0aGlzLmltYWcsXG4gICAgICBydmFsLFxuICAgICAgaXZhbDtcblxuICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuYnVmZmVyU2l6ZS8yOyBrKyspIHtcbiAgICBydmFsID0gMC4wO1xuICAgIGl2YWwgPSAwLjA7XG5cbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IGJ1ZmZlci5sZW5ndGg7IG4rKykge1xuICAgICAgcnZhbCArPSB0aGlzLmNvc1RhYmxlW2sqbl0gKiBidWZmZXJbbl07XG4gICAgICBpdmFsICs9IHRoaXMuc2luVGFibGVbaypuXSAqIGJ1ZmZlcltuXTtcbiAgICB9XG5cbiAgICByZWFsW2tdID0gcnZhbDtcbiAgICBpbWFnW2tdID0gaXZhbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmNhbGN1bGF0ZVNwZWN0cnVtKCk7XG59O1xuXG5cbi8qKlxuICogRkZUIGlzIGEgY2xhc3MgZm9yIGNhbGN1bGF0aW5nIHRoZSBEaXNjcmV0ZSBGb3VyaWVyIFRyYW5zZm9ybSBvZiBhIHNpZ25hbFxuICogd2l0aCB0aGUgRmFzdCBGb3VyaWVyIFRyYW5zZm9ybSBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGJ1ZmZlclNpemUgVGhlIHNpemUgb2YgdGhlIHNhbXBsZSBidWZmZXIgdG8gYmUgY29tcHV0ZWQuIE11c3QgYmUgcG93ZXIgb2YgMlxuICogQHBhcmFtIHtOdW1iZXJ9IHNhbXBsZVJhdGUgVGhlIHNhbXBsZVJhdGUgb2YgdGhlIGJ1ZmZlciAoZWcuIDQ0MTAwKVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGRlQoYnVmZmVyU2l6ZSwgc2FtcGxlUmF0ZSkge1xuICBGb3VyaWVyVHJhbnNmb3JtLmNhbGwodGhpcywgYnVmZmVyU2l6ZSwgc2FtcGxlUmF0ZSk7XG4gICBcbiAgdGhpcy5yZXZlcnNlVGFibGUgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyU2l6ZSk7XG5cbiAgdmFyIGxpbWl0ID0gMTtcbiAgdmFyIGJpdCA9IGJ1ZmZlclNpemUgPj4gMTtcblxuICB2YXIgaTtcblxuICB3aGlsZSAobGltaXQgPCBidWZmZXJTaXplKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgIHRoaXMucmV2ZXJzZVRhYmxlW2kgKyBsaW1pdF0gPSB0aGlzLnJldmVyc2VUYWJsZVtpXSArIGJpdDtcbiAgICB9XG5cbiAgICBsaW1pdCA9IGxpbWl0IDw8IDE7XG4gICAgYml0ID0gYml0ID4+IDE7XG4gIH1cblxuICB0aGlzLnNpblRhYmxlID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplKTtcbiAgdGhpcy5jb3NUYWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlclNpemU7IGkrKykge1xuICAgIHRoaXMuc2luVGFibGVbaV0gPSBNYXRoLnNpbigtTWF0aC5QSS9pKTtcbiAgICB0aGlzLmNvc1RhYmxlW2ldID0gTWF0aC5jb3MoLU1hdGguUEkvaSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIGZvcndhcmQgdHJhbnNmb3JtIG9uIHRoZSBzYW1wbGUgYnVmZmVyLlxuICogQ29udmVydHMgYSB0aW1lIGRvbWFpbiBzaWduYWwgdG8gZnJlcXVlbmN5IGRvbWFpbiBzcGVjdHJhLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlciBUaGUgc2FtcGxlIGJ1ZmZlci4gQnVmZmVyIExlbmd0aCBtdXN0IGJlIHBvd2VyIG9mIDJcbiAqXG4gKiBAcmV0dXJucyBUaGUgZnJlcXVlbmN5IHNwZWN0cnVtIGFycmF5XG4gKi9cbkZGVC5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBMb2NhbGx5IHNjb3BlIHZhcmlhYmxlcyBmb3Igc3BlZWQgdXBcbiAgdmFyIGJ1ZmZlclNpemUgICAgICA9IHRoaXMuYnVmZmVyU2l6ZSxcbiAgICAgIGNvc1RhYmxlICAgICAgICA9IHRoaXMuY29zVGFibGUsXG4gICAgICBzaW5UYWJsZSAgICAgICAgPSB0aGlzLnNpblRhYmxlLFxuICAgICAgcmV2ZXJzZVRhYmxlICAgID0gdGhpcy5yZXZlcnNlVGFibGUsXG4gICAgICByZWFsICAgICAgICAgICAgPSB0aGlzLnJlYWwsXG4gICAgICBpbWFnICAgICAgICAgICAgPSB0aGlzLmltYWcsXG4gICAgICBzcGVjdHJ1bSAgICAgICAgPSB0aGlzLnNwZWN0cnVtO1xuXG4gIHZhciBrID0gTWF0aC5mbG9vcihNYXRoLmxvZyhidWZmZXJTaXplKSAvIE1hdGguTE4yKTtcblxuICBpZiAoTWF0aC5wb3coMiwgaykgIT09IGJ1ZmZlclNpemUpIHsgdGhyb3cgXCJJbnZhbGlkIGJ1ZmZlciBzaXplLCBtdXN0IGJlIGEgcG93ZXIgb2YgMi5cIjsgfVxuICBpZiAoYnVmZmVyU2l6ZSAhPT0gYnVmZmVyLmxlbmd0aCkgIHsgdGhyb3cgXCJTdXBwbGllZCBidWZmZXIgaXMgbm90IHRoZSBzYW1lIHNpemUgYXMgZGVmaW5lZCBGRlQuIEZGVCBTaXplOiBcIiArIGJ1ZmZlclNpemUgKyBcIiBCdWZmZXIgU2l6ZTogXCIgKyBidWZmZXIubGVuZ3RoOyB9XG5cbiAgdmFyIGhhbGZTaXplID0gMSxcbiAgICAgIHBoYXNlU2hpZnRTdGVwUmVhbCxcbiAgICAgIHBoYXNlU2hpZnRTdGVwSW1hZyxcbiAgICAgIGN1cnJlbnRQaGFzZVNoaWZ0UmVhbCxcbiAgICAgIGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyxcbiAgICAgIG9mZixcbiAgICAgIHRyLFxuICAgICAgdGksXG4gICAgICB0bXBSZWFsLFxuICAgICAgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgYnVmZmVyU2l6ZTsgaSsrKSB7XG4gICAgcmVhbFtpXSA9IGJ1ZmZlcltyZXZlcnNlVGFibGVbaV1dO1xuICAgIGltYWdbaV0gPSAwO1xuICB9XG5cbiAgd2hpbGUgKGhhbGZTaXplIDwgYnVmZmVyU2l6ZSkge1xuICAgIC8vcGhhc2VTaGlmdFN0ZXBSZWFsID0gTWF0aC5jb3MoLU1hdGguUEkvaGFsZlNpemUpO1xuICAgIC8vcGhhc2VTaGlmdFN0ZXBJbWFnID0gTWF0aC5zaW4oLU1hdGguUEkvaGFsZlNpemUpO1xuICAgIHBoYXNlU2hpZnRTdGVwUmVhbCA9IGNvc1RhYmxlW2hhbGZTaXplXTtcbiAgICBwaGFzZVNoaWZ0U3RlcEltYWcgPSBzaW5UYWJsZVtoYWxmU2l6ZV07XG4gICAgXG4gICAgY3VycmVudFBoYXNlU2hpZnRSZWFsID0gMTtcbiAgICBjdXJyZW50UGhhc2VTaGlmdEltYWcgPSAwO1xuXG4gICAgZm9yICh2YXIgZmZ0U3RlcCA9IDA7IGZmdFN0ZXAgPCBoYWxmU2l6ZTsgZmZ0U3RlcCsrKSB7XG4gICAgICBpID0gZmZ0U3RlcDtcblxuICAgICAgd2hpbGUgKGkgPCBidWZmZXJTaXplKSB7XG4gICAgICAgIG9mZiA9IGkgKyBoYWxmU2l6ZTtcbiAgICAgICAgdHIgPSAoY3VycmVudFBoYXNlU2hpZnRSZWFsICogcmVhbFtvZmZdKSAtIChjdXJyZW50UGhhc2VTaGlmdEltYWcgKiBpbWFnW29mZl0pO1xuICAgICAgICB0aSA9IChjdXJyZW50UGhhc2VTaGlmdFJlYWwgKiBpbWFnW29mZl0pICsgKGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyAqIHJlYWxbb2ZmXSk7XG5cbiAgICAgICAgcmVhbFtvZmZdID0gcmVhbFtpXSAtIHRyO1xuICAgICAgICBpbWFnW29mZl0gPSBpbWFnW2ldIC0gdGk7XG4gICAgICAgIHJlYWxbaV0gKz0gdHI7XG4gICAgICAgIGltYWdbaV0gKz0gdGk7XG5cbiAgICAgICAgaSArPSBoYWxmU2l6ZSA8PCAxO1xuICAgICAgfVxuXG4gICAgICB0bXBSZWFsID0gY3VycmVudFBoYXNlU2hpZnRSZWFsO1xuICAgICAgY3VycmVudFBoYXNlU2hpZnRSZWFsID0gKHRtcFJlYWwgKiBwaGFzZVNoaWZ0U3RlcFJlYWwpIC0gKGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyAqIHBoYXNlU2hpZnRTdGVwSW1hZyk7XG4gICAgICBjdXJyZW50UGhhc2VTaGlmdEltYWcgPSAodG1wUmVhbCAqIHBoYXNlU2hpZnRTdGVwSW1hZykgKyAoY3VycmVudFBoYXNlU2hpZnRJbWFnICogcGhhc2VTaGlmdFN0ZXBSZWFsKTtcbiAgICB9XG5cbiAgICBoYWxmU2l6ZSA9IGhhbGZTaXplIDw8IDE7XG4gIH1cblxuICByZXR1cm4gdGhpcy5jYWxjdWxhdGVTcGVjdHJ1bSgpO1xufTtcblxuRkZULnByb3RvdHlwZS5pbnZlcnNlID0gZnVuY3Rpb24ocmVhbCwgaW1hZywgYnVmZmVyKSB7XG4gIC8vIExvY2FsbHkgc2NvcGUgdmFyaWFibGVzIGZvciBzcGVlZCB1cFxuICB2YXIgYnVmZmVyU2l6ZSAgICAgID0gdGhpcy5idWZmZXJTaXplLFxuICAgICAgY29zVGFibGUgICAgICAgID0gdGhpcy5jb3NUYWJsZSxcbiAgICAgIHNpblRhYmxlICAgICAgICA9IHRoaXMuc2luVGFibGUsXG4gICAgICByZXZlcnNlVGFibGUgICAgPSB0aGlzLnJldmVyc2VUYWJsZSxcbiAgICAgIHNwZWN0cnVtICAgICAgICA9IHRoaXMuc3BlY3RydW07XG4gICAgIFxuICAgICAgcmVhbCA9IHJlYWwgfHwgdGhpcy5yZWFsO1xuICAgICAgaW1hZyA9IGltYWcgfHwgdGhpcy5pbWFnO1xuXG4gIHZhciBoYWxmU2l6ZSA9IDEsXG4gICAgICBwaGFzZVNoaWZ0U3RlcFJlYWwsXG4gICAgICBwaGFzZVNoaWZ0U3RlcEltYWcsXG4gICAgICBjdXJyZW50UGhhc2VTaGlmdFJlYWwsXG4gICAgICBjdXJyZW50UGhhc2VTaGlmdEltYWcsXG4gICAgICBvZmYsXG4gICAgICB0cixcbiAgICAgIHRpLFxuICAgICAgdG1wUmVhbCxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IGJ1ZmZlclNpemU7IGkrKykge1xuICAgIGltYWdbaV0gKj0gLTE7XG4gIH1cblxuICB2YXIgcmV2UmVhbCA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSk7XG4gIHZhciByZXZJbWFnID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplKTtcbiBcbiAgZm9yIChpID0gMDsgaSA8IHJlYWwubGVuZ3RoOyBpKyspIHtcbiAgICByZXZSZWFsW2ldID0gcmVhbFtyZXZlcnNlVGFibGVbaV1dO1xuICAgIHJldkltYWdbaV0gPSBpbWFnW3JldmVyc2VUYWJsZVtpXV07XG4gIH1cbiBcbiAgcmVhbCA9IHJldlJlYWw7XG4gIGltYWcgPSByZXZJbWFnO1xuXG4gIHdoaWxlIChoYWxmU2l6ZSA8IGJ1ZmZlclNpemUpIHtcbiAgICBwaGFzZVNoaWZ0U3RlcFJlYWwgPSBjb3NUYWJsZVtoYWxmU2l6ZV07XG4gICAgcGhhc2VTaGlmdFN0ZXBJbWFnID0gc2luVGFibGVbaGFsZlNpemVdO1xuICAgIGN1cnJlbnRQaGFzZVNoaWZ0UmVhbCA9IDE7XG4gICAgY3VycmVudFBoYXNlU2hpZnRJbWFnID0gMDtcblxuICAgIGZvciAodmFyIGZmdFN0ZXAgPSAwOyBmZnRTdGVwIDwgaGFsZlNpemU7IGZmdFN0ZXArKykge1xuICAgICAgaSA9IGZmdFN0ZXA7XG5cbiAgICAgIHdoaWxlIChpIDwgYnVmZmVyU2l6ZSkge1xuICAgICAgICBvZmYgPSBpICsgaGFsZlNpemU7XG4gICAgICAgIHRyID0gKGN1cnJlbnRQaGFzZVNoaWZ0UmVhbCAqIHJlYWxbb2ZmXSkgLSAoY3VycmVudFBoYXNlU2hpZnRJbWFnICogaW1hZ1tvZmZdKTtcbiAgICAgICAgdGkgPSAoY3VycmVudFBoYXNlU2hpZnRSZWFsICogaW1hZ1tvZmZdKSArIChjdXJyZW50UGhhc2VTaGlmdEltYWcgKiByZWFsW29mZl0pO1xuXG4gICAgICAgIHJlYWxbb2ZmXSA9IHJlYWxbaV0gLSB0cjtcbiAgICAgICAgaW1hZ1tvZmZdID0gaW1hZ1tpXSAtIHRpO1xuICAgICAgICByZWFsW2ldICs9IHRyO1xuICAgICAgICBpbWFnW2ldICs9IHRpO1xuXG4gICAgICAgIGkgKz0gaGFsZlNpemUgPDwgMTtcbiAgICAgIH1cblxuICAgICAgdG1wUmVhbCA9IGN1cnJlbnRQaGFzZVNoaWZ0UmVhbDtcbiAgICAgIGN1cnJlbnRQaGFzZVNoaWZ0UmVhbCA9ICh0bXBSZWFsICogcGhhc2VTaGlmdFN0ZXBSZWFsKSAtIChjdXJyZW50UGhhc2VTaGlmdEltYWcgKiBwaGFzZVNoaWZ0U3RlcEltYWcpO1xuICAgICAgY3VycmVudFBoYXNlU2hpZnRJbWFnID0gKHRtcFJlYWwgKiBwaGFzZVNoaWZ0U3RlcEltYWcpICsgKGN1cnJlbnRQaGFzZVNoaWZ0SW1hZyAqIHBoYXNlU2hpZnRTdGVwUmVhbCk7XG4gICAgfVxuXG4gICAgaGFsZlNpemUgPSBoYWxmU2l6ZSA8PCAxO1xuICB9XG5cbiAgLy8gdmFyIGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSk7IC8vIHRoaXMgc2hvdWxkIGJlIHJldXNlZCBpbnN0ZWFkXG4gIGZvciAoaSA9IDA7IGkgPCBidWZmZXJTaXplOyBpKyspIHtcbiAgICBidWZmZXJbaV0gPSByZWFsW2ldIC8gYnVmZmVyU2l6ZTtcbiAgfVxuXG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vKipcbiAqIFJGRlQgaXMgYSBjbGFzcyBmb3IgY2FsY3VsYXRpbmcgdGhlIERpc2NyZXRlIEZvdXJpZXIgVHJhbnNmb3JtIG9mIGEgc2lnbmFsXG4gKiB3aXRoIHRoZSBGYXN0IEZvdXJpZXIgVHJhbnNmb3JtIGFsZ29yaXRobS5cbiAqXG4gKiBUaGlzIG1ldGhvZCBjdXJyZW50bHkgb25seSBjb250YWlucyBhIGZvcndhcmQgdHJhbnNmb3JtIGJ1dCBpcyBoaWdobHkgb3B0aW1pemVkLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBidWZmZXJTaXplIFRoZSBzaXplIG9mIHRoZSBzYW1wbGUgYnVmZmVyIHRvIGJlIGNvbXB1dGVkLiBNdXN0IGJlIHBvd2VyIG9mIDJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzYW1wbGVSYXRlIFRoZSBzYW1wbGVSYXRlIG9mIHRoZSBidWZmZXIgKGVnLiA0NDEwMClcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG4vLyBsb29rdXAgdGFibGVzIGRvbid0IHJlYWxseSBnYWluIHVzIGFueSBzcGVlZCwgYnV0IHRoZXkgZG8gaW5jcmVhc2Vcbi8vIGNhY2hlIGZvb3RwcmludCwgc28gZG9uJ3QgdXNlIHRoZW0gaW4gaGVyZVxuXG4vLyBhbHNvIHdlIGRvbid0IHVzZSBzZXBlYXJhdGUgYXJyYXlzIGZvciByZWFsL2ltYWdpbmFyeSBwYXJ0c1xuXG4vLyB0aGlzIG9uZSBhIGxpdHRsZSBtb3JlIHRoYW4gdHdpY2UgYXMgZmFzdCBhcyB0aGUgb25lIGluIEZGVFxuLy8gaG93ZXZlciBJIG9ubHkgZGlkIHRoZSBmb3J3YXJkIHRyYW5zZm9ybVxuXG4vLyB0aGUgcmVzdCBvZiB0aGlzIHdhcyB0cmFuc2xhdGVkIGZyb20gQywgc2VlIGh0dHA6Ly93d3cuampqLmRlL2Z4dC9cbi8vIHRoaXMgaXMgdGhlIHJlYWwgc3BsaXQgcmFkaXggRkZUXG5cbmZ1bmN0aW9uIFJGRlQoYnVmZmVyU2l6ZSwgc2FtcGxlUmF0ZSkge1xuICBGb3VyaWVyVHJhbnNmb3JtLmNhbGwodGhpcywgYnVmZmVyU2l6ZSwgc2FtcGxlUmF0ZSk7XG5cbiAgdGhpcy50cmFucyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyU2l6ZSk7XG5cbiAgdGhpcy5yZXZlcnNlVGFibGUgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyU2l6ZSk7XG5cbiAgLy8gZG9uJ3QgdXNlIGEgbG9va3VwIHRhYmxlIHRvIGRvIHRoZSBwZXJtdXRlLCB1c2UgdGhpcyBpbnN0ZWFkXG4gIHRoaXMucmV2ZXJzZUJpblBlcm11dGUgPSBmdW5jdGlvbiAoZGVzdCwgc291cmNlKSB7XG4gICAgdmFyIGJ1ZmZlclNpemUgID0gdGhpcy5idWZmZXJTaXplLCBcbiAgICAgICAgaGFsZlNpemUgICAgPSBidWZmZXJTaXplID4+PiAxLCBcbiAgICAgICAgbm0xICAgICAgICAgPSBidWZmZXJTaXplIC0gMSwgXG4gICAgICAgIGkgPSAxLCByID0gMCwgaDtcblxuICAgIGRlc3RbMF0gPSBzb3VyY2VbMF07XG5cbiAgICBkbyB7XG4gICAgICByICs9IGhhbGZTaXplO1xuICAgICAgZGVzdFtpXSA9IHNvdXJjZVtyXTtcbiAgICAgIGRlc3Rbcl0gPSBzb3VyY2VbaV07XG4gICAgICBcbiAgICAgIGkrKztcblxuICAgICAgaCA9IGhhbGZTaXplIDw8IDE7XG4gICAgICB3aGlsZSAoaCA9IGggPj4gMSwgISgociBePSBoKSAmIGgpKTtcblxuICAgICAgaWYgKHIgPj0gaSkgeyBcbiAgICAgICAgZGVzdFtpXSAgICAgPSBzb3VyY2Vbcl07IFxuICAgICAgICBkZXN0W3JdICAgICA9IHNvdXJjZVtpXTtcblxuICAgICAgICBkZXN0W25tMS1pXSA9IHNvdXJjZVtubTEtcl07IFxuICAgICAgICBkZXN0W25tMS1yXSA9IHNvdXJjZVtubTEtaV07XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfSB3aGlsZSAoaSA8IGhhbGZTaXplKTtcbiAgICBkZXN0W25tMV0gPSBzb3VyY2Vbbm0xXTtcbiAgfTtcblxuICB0aGlzLmdlbmVyYXRlUmV2ZXJzZVRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBidWZmZXJTaXplICA9IHRoaXMuYnVmZmVyU2l6ZSwgXG4gICAgICAgIGhhbGZTaXplICAgID0gYnVmZmVyU2l6ZSA+Pj4gMSwgXG4gICAgICAgIG5tMSAgICAgICAgID0gYnVmZmVyU2l6ZSAtIDEsIFxuICAgICAgICBpID0gMSwgciA9IDAsIGg7XG5cbiAgICB0aGlzLnJldmVyc2VUYWJsZVswXSA9IDA7XG5cbiAgICBkbyB7XG4gICAgICByICs9IGhhbGZTaXplO1xuICAgICAgXG4gICAgICB0aGlzLnJldmVyc2VUYWJsZVtpXSA9IHI7XG4gICAgICB0aGlzLnJldmVyc2VUYWJsZVtyXSA9IGk7XG5cbiAgICAgIGkrKztcblxuICAgICAgaCA9IGhhbGZTaXplIDw8IDE7XG4gICAgICB3aGlsZSAoaCA9IGggPj4gMSwgISgociBePSBoKSAmIGgpKTtcblxuICAgICAgaWYgKHIgPj0gaSkgeyBcbiAgICAgICAgdGhpcy5yZXZlcnNlVGFibGVbaV0gPSByO1xuICAgICAgICB0aGlzLnJldmVyc2VUYWJsZVtyXSA9IGk7XG5cbiAgICAgICAgdGhpcy5yZXZlcnNlVGFibGVbbm0xLWldID0gbm0xLXI7XG4gICAgICAgIHRoaXMucmV2ZXJzZVRhYmxlW25tMS1yXSA9IG5tMS1pO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH0gd2hpbGUgKGkgPCBoYWxmU2l6ZSk7XG5cbiAgICB0aGlzLnJldmVyc2VUYWJsZVtubTFdID0gbm0xO1xuICB9O1xuXG4gIHRoaXMuZ2VuZXJhdGVSZXZlcnNlVGFibGUoKTtcbn1cblxuXG4vLyBPcmRlcmluZyBvZiBvdXRwdXQ6XG4vL1xuLy8gdHJhbnNbMF0gICAgID0gcmVbMF0gKD09emVybyBmcmVxdWVuY3ksIHB1cmVseSByZWFsKVxuLy8gdHJhbnNbMV0gICAgID0gcmVbMV1cbi8vICAgICAgICAgICAgIC4uLlxuLy8gdHJhbnNbbi8yLTFdID0gcmVbbi8yLTFdXG4vLyB0cmFuc1tuLzJdICAgPSByZVtuLzJdICAgICg9PW55cXVpc3QgZnJlcXVlbmN5LCBwdXJlbHkgcmVhbClcbi8vXG4vLyB0cmFuc1tuLzIrMV0gPSBpbVtuLzItMV1cbi8vIHRyYW5zW24vMisyXSA9IGltW24vMi0yXVxuLy8gICAgICAgICAgICAgLi4uXG4vLyB0cmFuc1tuLTFdICAgPSBpbVsxXSBcblxuUkZGVC5wcm90b3R5cGUuZm9yd2FyZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgbiAgICAgICAgID0gdGhpcy5idWZmZXJTaXplLCBcbiAgICAgIHNwZWN0cnVtICA9IHRoaXMuc3BlY3RydW0sXG4gICAgICB4ICAgICAgICAgPSB0aGlzLnRyYW5zLCBcbiAgICAgIFRXT19QSSAgICA9IDIqTWF0aC5QSSxcbiAgICAgIHNxcnQgICAgICA9IE1hdGguc3FydCxcbiAgICAgIGkgICAgICAgICA9IG4gPj4+IDEsXG4gICAgICBiU2kgICAgICAgPSAyIC8gbixcbiAgICAgIG4yLCBuNCwgbjgsIG5uLCBcbiAgICAgIHQxLCB0MiwgdDMsIHQ0LCBcbiAgICAgIGkxLCBpMiwgaTMsIGk0LCBpNSwgaTYsIGk3LCBpOCwgXG4gICAgICBzdDEsIGNjMSwgc3MxLCBjYzMsIHNzMyxcbiAgICAgIGUsIFxuICAgICAgYSxcbiAgICAgIHJ2YWwsIGl2YWwsIG1hZzsgXG5cbiAgdGhpcy5yZXZlcnNlQmluUGVybXV0ZSh4LCBidWZmZXIpO1xuXG4gIC8qXG4gIHZhciByZXZlcnNlVGFibGUgPSB0aGlzLnJldmVyc2VUYWJsZTtcblxuICBmb3IgKHZhciBrID0gMCwgbGVuID0gcmV2ZXJzZVRhYmxlLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgeFtrXSA9IGJ1ZmZlcltyZXZlcnNlVGFibGVba11dO1xuICB9XG4gICovXG5cbiAgZm9yICh2YXIgaXggPSAwLCBpZCA9IDQ7IGl4IDwgbjsgaWQgKj0gNCkge1xuICAgIGZvciAodmFyIGkwID0gaXg7IGkwIDwgbjsgaTAgKz0gaWQpIHtcbiAgICAgIC8vc3VtZGlmZih4W2kwXSwgeFtpMCsxXSk7IC8vIHthLCBifSAgPC0tfCB7YStiLCBhLWJ9XG4gICAgICBzdDEgPSB4W2kwXSAtIHhbaTArMV07XG4gICAgICB4W2kwXSArPSB4W2kwKzFdO1xuICAgICAgeFtpMCsxXSA9IHN0MTtcbiAgICB9IFxuICAgIGl4ID0gMiooaWQtMSk7XG4gIH1cblxuICBuMiA9IDI7XG4gIG5uID0gbiA+Pj4gMTtcblxuICB3aGlsZSgobm4gPSBubiA+Pj4gMSkpIHtcbiAgICBpeCA9IDA7XG4gICAgbjIgPSBuMiA8PCAxO1xuICAgIGlkID0gbjIgPDwgMTtcbiAgICBuNCA9IG4yID4+PiAyO1xuICAgIG44ID0gbjIgPj4+IDM7XG4gICAgZG8ge1xuICAgICAgaWYobjQgIT09IDEpIHtcbiAgICAgICAgZm9yKGkwID0gaXg7IGkwIDwgbjsgaTAgKz0gaWQpIHtcbiAgICAgICAgICBpMSA9IGkwO1xuICAgICAgICAgIGkyID0gaTEgKyBuNDtcbiAgICAgICAgICBpMyA9IGkyICsgbjQ7XG4gICAgICAgICAgaTQgPSBpMyArIG40O1xuICAgICBcbiAgICAgICAgICAvL2RpZmZzdW0zX3IoeFtpM10sIHhbaTRdLCB0MSk7IC8vIHthLCBiLCBzfSA8LS18IHthLCBiLWEsIGErYn1cbiAgICAgICAgICB0MSA9IHhbaTNdICsgeFtpNF07XG4gICAgICAgICAgeFtpNF0gLT0geFtpM107XG4gICAgICAgICAgLy9zdW1kaWZmMyh4W2kxXSwgdDEsIHhbaTNdKTsgICAvLyB7YSwgYiwgZH0gPC0tfCB7YStiLCBiLCBhLWJ9XG4gICAgICAgICAgeFtpM10gPSB4W2kxXSAtIHQxOyBcbiAgICAgICAgICB4W2kxXSArPSB0MTtcbiAgICAgXG4gICAgICAgICAgaTEgKz0gbjg7XG4gICAgICAgICAgaTIgKz0gbjg7XG4gICAgICAgICAgaTMgKz0gbjg7XG4gICAgICAgICAgaTQgKz0gbjg7XG4gICAgICAgICBcbiAgICAgICAgICAvL3N1bWRpZmYoeFtpM10sIHhbaTRdLCB0MSwgdDIpOyAvLyB7cywgZH0gIDwtLXwge2ErYiwgYS1ifVxuICAgICAgICAgIHQxID0geFtpM10gKyB4W2k0XTtcbiAgICAgICAgICB0MiA9IHhbaTNdIC0geFtpNF07XG4gICAgICAgICBcbiAgICAgICAgICB0MSA9IC10MSAqIE1hdGguU1FSVDFfMjtcbiAgICAgICAgICB0MiAqPSBNYXRoLlNRUlQxXzI7XG4gICAgIFxuICAgICAgICAgIC8vIHN1bWRpZmYodDEsIHhbaTJdLCB4W2k0XSwgeFtpM10pOyAvLyB7cywgZH0gIDwtLXwge2ErYiwgYS1ifVxuICAgICAgICAgIHN0MSA9IHhbaTJdO1xuICAgICAgICAgIHhbaTRdID0gdDEgKyBzdDE7IFxuICAgICAgICAgIHhbaTNdID0gdDEgLSBzdDE7XG4gICAgICAgICAgXG4gICAgICAgICAgLy9zdW1kaWZmMyh4W2kxXSwgdDIsIHhbaTJdKTsgLy8ge2EsIGIsIGR9IDwtLXwge2ErYiwgYiwgYS1ifVxuICAgICAgICAgIHhbaTJdID0geFtpMV0gLSB0MjtcbiAgICAgICAgICB4W2kxXSArPSB0MjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yKGkwID0gaXg7IGkwIDwgbjsgaTAgKz0gaWQpIHtcbiAgICAgICAgICBpMSA9IGkwO1xuICAgICAgICAgIGkyID0gaTEgKyBuNDtcbiAgICAgICAgICBpMyA9IGkyICsgbjQ7XG4gICAgICAgICAgaTQgPSBpMyArIG40O1xuICAgICBcbiAgICAgICAgICAvL2RpZmZzdW0zX3IoeFtpM10sIHhbaTRdLCB0MSk7IC8vIHthLCBiLCBzfSA8LS18IHthLCBiLWEsIGErYn1cbiAgICAgICAgICB0MSA9IHhbaTNdICsgeFtpNF07IFxuICAgICAgICAgIHhbaTRdIC09IHhbaTNdO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vc3VtZGlmZjMoeFtpMV0sIHQxLCB4W2kzXSk7ICAgLy8ge2EsIGIsIGR9IDwtLXwge2ErYiwgYiwgYS1ifVxuICAgICAgICAgIHhbaTNdID0geFtpMV0gLSB0MTsgXG4gICAgICAgICAgeFtpMV0gKz0gdDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgIFxuICAgICAgaXggPSAoaWQgPDwgMSkgLSBuMjtcbiAgICAgIGlkID0gaWQgPDwgMjtcbiAgICB9IHdoaWxlIChpeCA8IG4pO1xuIFxuICAgIGUgPSBUV09fUEkgLyBuMjtcblxuICAgIGZvciAodmFyIGogPSAxOyBqIDwgbjg7IGorKykge1xuICAgICAgYSA9IGogKiBlO1xuICAgICAgc3MxID0gTWF0aC5zaW4oYSk7XG4gICAgICBjYzEgPSBNYXRoLmNvcyhhKTtcblxuICAgICAgLy9zczMgPSBzaW4oMyphKTsgY2MzID0gY29zKDMqYSk7XG4gICAgICBjYzMgPSA0KmNjMSooY2MxKmNjMS0wLjc1KTtcbiAgICAgIHNzMyA9IDQqc3MxKigwLjc1LXNzMSpzczEpO1xuICAgXG4gICAgICBpeCA9IDA7IGlkID0gbjIgPDwgMTtcbiAgICAgIGRvIHtcbiAgICAgICAgZm9yIChpMCA9IGl4OyBpMCA8IG47IGkwICs9IGlkKSB7XG4gICAgICAgICAgaTEgPSBpMCArIGo7XG4gICAgICAgICAgaTIgPSBpMSArIG40O1xuICAgICAgICAgIGkzID0gaTIgKyBuNDtcbiAgICAgICAgICBpNCA9IGkzICsgbjQ7XG4gICAgICAgXG4gICAgICAgICAgaTUgPSBpMCArIG40IC0gajtcbiAgICAgICAgICBpNiA9IGk1ICsgbjQ7XG4gICAgICAgICAgaTcgPSBpNiArIG40O1xuICAgICAgICAgIGk4ID0gaTcgKyBuNDtcbiAgICAgICBcbiAgICAgICAgICAvL2NtdWx0KGMsIHMsIHgsIHksICZ1LCAmdilcbiAgICAgICAgICAvL2NtdWx0KGNjMSwgc3MxLCB4W2k3XSwgeFtpM10sIHQyLCB0MSk7IC8vIHt1LHZ9IDwtLXwge3gqYy15KnMsIHgqcyt5KmN9XG4gICAgICAgICAgdDIgPSB4W2k3XSpjYzEgLSB4W2kzXSpzczE7IFxuICAgICAgICAgIHQxID0geFtpN10qc3MxICsgeFtpM10qY2MxO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vY211bHQoY2MzLCBzczMsIHhbaThdLCB4W2k0XSwgdDQsIHQzKTtcbiAgICAgICAgICB0NCA9IHhbaThdKmNjMyAtIHhbaTRdKnNzMzsgXG4gICAgICAgICAgdDMgPSB4W2k4XSpzczMgKyB4W2k0XSpjYzM7XG4gICAgICAgXG4gICAgICAgICAgLy9zdW1kaWZmKHQyLCB0NCk7ICAgLy8ge2EsIGJ9IDwtLXwge2ErYiwgYS1ifVxuICAgICAgICAgIHN0MSA9IHQyIC0gdDQ7XG4gICAgICAgICAgdDIgKz0gdDQ7XG4gICAgICAgICAgdDQgPSBzdDE7XG4gICAgICAgICAgXG4gICAgICAgICAgLy9zdW1kaWZmKHQyLCB4W2k2XSwgeFtpOF0sIHhbaTNdKTsgLy8ge3MsIGR9ICA8LS18IHthK2IsIGEtYn1cbiAgICAgICAgICAvL3N0MSA9IHhbaTZdOyB4W2k4XSA9IHQyICsgc3QxOyB4W2kzXSA9IHQyIC0gc3QxO1xuICAgICAgICAgIHhbaThdID0gdDIgKyB4W2k2XTsgXG4gICAgICAgICAgeFtpM10gPSB0MiAtIHhbaTZdO1xuICAgICAgICAgXG4gICAgICAgICAgLy9zdW1kaWZmX3IodDEsIHQzKTsgLy8ge2EsIGJ9IDwtLXwge2ErYiwgYi1hfVxuICAgICAgICAgIHN0MSA9IHQzIC0gdDE7XG4gICAgICAgICAgdDEgKz0gdDM7XG4gICAgICAgICAgdDMgPSBzdDE7XG4gICAgICAgICAgXG4gICAgICAgICAgLy9zdW1kaWZmKHQzLCB4W2kyXSwgeFtpNF0sIHhbaTddKTsgLy8ge3MsIGR9ICA8LS18IHthK2IsIGEtYn1cbiAgICAgICAgICAvL3N0MSA9IHhbaTJdOyB4W2k0XSA9IHQzICsgc3QxOyB4W2k3XSA9IHQzIC0gc3QxO1xuICAgICAgICAgIHhbaTRdID0gdDMgKyB4W2kyXTsgXG4gICAgICAgICAgeFtpN10gPSB0MyAtIHhbaTJdO1xuICAgICAgICAgXG4gICAgICAgICAgLy9zdW1kaWZmMyh4W2kxXSwgdDEsIHhbaTZdKTsgICAvLyB7YSwgYiwgZH0gPC0tfCB7YStiLCBiLCBhLWJ9XG4gICAgICAgICAgeFtpNl0gPSB4W2kxXSAtIHQxOyBcbiAgICAgICAgICB4W2kxXSArPSB0MTtcbiAgICAgICAgICBcbiAgICAgICAgICAvL2RpZmZzdW0zX3IodDQsIHhbaTVdLCB4W2kyXSk7IC8vIHthLCBiLCBzfSA8LS18IHthLCBiLWEsIGErYn1cbiAgICAgICAgICB4W2kyXSA9IHQ0ICsgeFtpNV07IFxuICAgICAgICAgIHhbaTVdIC09IHQ0O1xuICAgICAgICB9XG4gICAgIFxuICAgICAgICBpeCA9IChpZCA8PCAxKSAtIG4yO1xuICAgICAgICBpZCA9IGlkIDw8IDI7XG4gICBcbiAgICAgIH0gd2hpbGUgKGl4IDwgbik7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKC0taSkge1xuICAgIHJ2YWwgPSB4W2ldO1xuICAgIGl2YWwgPSB4W24taS0xXTtcbiAgICBtYWcgPSBiU2kgKiBzcXJ0KHJ2YWwgKiBydmFsICsgaXZhbCAqIGl2YWwpO1xuXG4gICAgaWYgKG1hZyA+IHRoaXMucGVhaykge1xuICAgICAgdGhpcy5wZWFrQmFuZCA9IGk7XG4gICAgICB0aGlzLnBlYWsgPSBtYWc7XG4gICAgfVxuXG4gICAgc3BlY3RydW1baV0gPSBtYWc7XG4gIH1cblxuICBzcGVjdHJ1bVswXSA9IGJTaSAqIHhbMF07XG5cbiAgcmV0dXJuIHNwZWN0cnVtO1xufTtcblxuZnVuY3Rpb24gU2FtcGxlcihmaWxlLCBidWZmZXJTaXplLCBzYW1wbGVSYXRlLCBwbGF5U3RhcnQsIHBsYXlFbmQsIGxvb3BTdGFydCwgbG9vcEVuZCwgbG9vcE1vZGUpIHtcbiAgdGhpcy5maWxlID0gZmlsZTtcbiAgdGhpcy5idWZmZXJTaXplID0gYnVmZmVyU2l6ZTtcbiAgdGhpcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcbiAgdGhpcy5wbGF5U3RhcnQgID0gcGxheVN0YXJ0IHx8IDA7IC8vIDAlXG4gIHRoaXMucGxheUVuZCAgICA9IHBsYXlFbmQgICB8fCAxOyAvLyAxMDAlXG4gIHRoaXMubG9vcFN0YXJ0ICA9IGxvb3BTdGFydCB8fCAwO1xuICB0aGlzLmxvb3BFbmQgICAgPSBsb29wRW5kICAgfHwgMTtcbiAgdGhpcy5sb29wTW9kZSAgID0gbG9vcE1vZGUgIHx8IERTUC5PRkY7XG4gIHRoaXMubG9hZGVkICAgICA9IGZhbHNlO1xuICB0aGlzLnNhbXBsZXMgICAgPSBbXTtcbiAgdGhpcy5zaWduYWwgICAgID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXJTaXplKTtcbiAgdGhpcy5mcmFtZUNvdW50ID0gMDtcbiAgdGhpcy5lbnZlbG9wZSAgID0gbnVsbDtcbiAgdGhpcy5hbXBsaXR1ZGUgID0gMTtcbiAgdGhpcy5yb290RnJlcXVlbmN5ID0gMTEwOyAvLyBBMiAxMTBcbiAgdGhpcy5mcmVxdWVuY3kgID0gNTUwO1xuICB0aGlzLnN0ZXAgICAgICAgPSB0aGlzLmZyZXF1ZW5jeSAvIHRoaXMucm9vdEZyZXF1ZW5jeTtcbiAgdGhpcy5kdXJhdGlvbiAgID0gMDtcbiAgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID0gMDtcbiAgdGhpcy5wbGF5aGVhZCAgID0gMDtcbiBcbiAgdmFyIGF1ZGlvID0gLyogbmV3IEF1ZGlvKCk7Ki8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkFVRElPXCIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gXG4gIHRoaXMubG9hZFNhbXBsZXMgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBidWZmZXIgPSBEU1AuZ2V0Q2hhbm5lbChEU1AuTUlYLCBldmVudC5mcmFtZUJ1ZmZlcik7XG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxmLnNhbXBsZXMucHVzaChidWZmZXJbaV0pO1xuICAgIH1cbiAgfTtcbiBcbiAgdGhpcy5sb2FkQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBjb252ZXJ0IGZsZXhpYmxlIGpzIGFycmF5IGludG8gYSBmYXN0IHR5cGVkIGFycmF5XG4gICAgc2VsZi5zYW1wbGVzID0gbmV3IEZsb2F0MzJBcnJheShzZWxmLnNhbXBsZXMpO1xuICAgIHNlbGYubG9hZGVkID0gdHJ1ZTtcbiAgfTtcbiBcbiAgdGhpcy5sb2FkTWV0YURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLmR1cmF0aW9uID0gYXVkaW8uZHVyYXRpb247XG4gIH07XG4gXG4gIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoXCJNb3pBdWRpb0F2YWlsYWJsZVwiLCB0aGlzLmxvYWRTYW1wbGVzLCBmYWxzZSk7XG4gIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRtZXRhZGF0YVwiLCB0aGlzLmxvYWRNZXRhRGF0YSwgZmFsc2UpO1xuICBhdWRpby5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgdGhpcy5sb2FkQ29tcGxldGUsIGZhbHNlKTtcbiAgYXVkaW8ubXV0ZWQgPSB0cnVlO1xuICBhdWRpby5zcmMgPSBmaWxlO1xuICBhdWRpby5wbGF5KCk7XG59XG5cblNhbXBsZXIucHJvdG90eXBlLmFwcGx5RW52ZWxvcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbnZlbG9wZS5wcm9jZXNzKHRoaXMuc2lnbmFsKTtcbiAgcmV0dXJuIHRoaXMuc2lnbmFsO1xufTtcblxuU2FtcGxlci5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZyYW1lT2Zmc2V0ID0gdGhpcy5mcmFtZUNvdW50ICogdGhpcy5idWZmZXJTaXplO1xuIFxuICB2YXIgbG9vcFdpZHRoID0gdGhpcy5wbGF5RW5kICogdGhpcy5zYW1wbGVzLmxlbmd0aCAtIHRoaXMucGxheVN0YXJ0ICogdGhpcy5zYW1wbGVzLmxlbmd0aDtcbiAgdmFyIHBsYXlTdGFydFNhbXBsZXMgPSB0aGlzLnBsYXlTdGFydCAqIHRoaXMuc2FtcGxlcy5sZW5ndGg7IC8vIGllIDAuNSAtPiA1MCUgb2YgdGhlIGxlbmd0aFxuICB2YXIgcGxheUVuZFNhbXBsZXMgPSB0aGlzLnBsYXlFbmQgKiB0aGlzLnNhbXBsZXMubGVuZ3RoOyAvLyBpZSAwLjUgLT4gNTAlIG9mIHRoZSBsZW5ndGhcbiAgdmFyIG9mZnNldDtcblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlclNpemU7IGkrKyApIHtcbiAgICBzd2l0Y2ggKHRoaXMubG9vcE1vZGUpIHtcbiAgICAgIGNhc2UgRFNQLk9GRjpcbiAgICAgICAgdGhpcy5wbGF5aGVhZCA9IE1hdGgucm91bmQodGhpcy5zYW1wbGVzUHJvY2Vzc2VkICogdGhpcy5zdGVwICsgcGxheVN0YXJ0U2FtcGxlcyk7XG4gICAgICAgIGlmICh0aGlzLnBsYXloZWFkIDwgKHRoaXMucGxheUVuZCAqIHRoaXMuc2FtcGxlcy5sZW5ndGgpICkge1xuICAgICAgICAgIHRoaXMuc2lnbmFsW2ldID0gdGhpcy5zYW1wbGVzW3RoaXMucGxheWhlYWRdICogdGhpcy5hbXBsaXR1ZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaWduYWxbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICBcbiAgICAgIGNhc2UgRFNQLkZXOlxuICAgICAgICB0aGlzLnBsYXloZWFkID0gTWF0aC5yb3VuZCgodGhpcy5zYW1wbGVzUHJvY2Vzc2VkICogdGhpcy5zdGVwKSAlIGxvb3BXaWR0aCArIHBsYXlTdGFydFNhbXBsZXMpO1xuICAgICAgICBpZiAodGhpcy5wbGF5aGVhZCA8ICh0aGlzLnBsYXlFbmQgKiB0aGlzLnNhbXBsZXMubGVuZ3RoKSApIHtcbiAgICAgICAgICB0aGlzLnNpZ25hbFtpXSA9IHRoaXMuc2FtcGxlc1t0aGlzLnBsYXloZWFkXSAqIHRoaXMuYW1wbGl0dWRlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgIFxuICAgICAgY2FzZSBEU1AuQlc6XG4gICAgICAgIHRoaXMucGxheWhlYWQgPSBwbGF5RW5kU2FtcGxlcyAtIE1hdGgucm91bmQoKHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAqIHRoaXMuc3RlcCkgJSBsb29wV2lkdGgpO1xuICAgICAgICBpZiAodGhpcy5wbGF5aGVhZCA8ICh0aGlzLnBsYXlFbmQgKiB0aGlzLnNhbXBsZXMubGVuZ3RoKSApIHtcbiAgICAgICAgICB0aGlzLnNpZ25hbFtpXSA9IHRoaXMuc2FtcGxlc1t0aGlzLnBsYXloZWFkXSAqIHRoaXMuYW1wbGl0dWRlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgIFxuICAgICAgY2FzZSBEU1AuRldCVzpcbiAgICAgICAgaWYgKCBNYXRoLmZsb29yKHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAqIHRoaXMuc3RlcCAvIGxvb3BXaWR0aCkgJSAyID09PSAwICkge1xuICAgICAgICAgIHRoaXMucGxheWhlYWQgPSBNYXRoLnJvdW5kKCh0aGlzLnNhbXBsZXNQcm9jZXNzZWQgKiB0aGlzLnN0ZXApICUgbG9vcFdpZHRoICsgcGxheVN0YXJ0U2FtcGxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wbGF5aGVhZCA9IHBsYXlFbmRTYW1wbGVzIC0gTWF0aC5yb3VuZCgodGhpcy5zYW1wbGVzUHJvY2Vzc2VkICogdGhpcy5zdGVwKSAlIGxvb3BXaWR0aCk7XG4gICAgICAgIH0gIFxuICAgICAgICBpZiAodGhpcy5wbGF5aGVhZCA8ICh0aGlzLnBsYXlFbmQgKiB0aGlzLnNhbXBsZXMubGVuZ3RoKSApIHtcbiAgICAgICAgICB0aGlzLnNpZ25hbFtpXSA9IHRoaXMuc2FtcGxlc1t0aGlzLnBsYXloZWFkXSAqIHRoaXMuYW1wbGl0dWRlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLnNhbXBsZXNQcm9jZXNzZWQrKztcbiAgfVxuXG4gIHRoaXMuZnJhbWVDb3VudCsrO1xuXG4gIHJldHVybiB0aGlzLnNpZ25hbDtcbn07XG5cblNhbXBsZXIucHJvdG90eXBlLnNldEZyZXEgPSBmdW5jdGlvbihmcmVxdWVuY3kpIHtcbiAgICB2YXIgdG90YWxQcm9jZXNzZWQgPSB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgKiB0aGlzLnN0ZXA7XG4gICAgdGhpcy5mcmVxdWVuY3kgPSBmcmVxdWVuY3k7XG4gICAgdGhpcy5zdGVwID0gdGhpcy5mcmVxdWVuY3kgLyB0aGlzLnJvb3RGcmVxdWVuY3k7XG4gICAgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID0gTWF0aC5yb3VuZCh0b3RhbFByb2Nlc3NlZC90aGlzLnN0ZXApO1xufTtcblxuU2FtcGxlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID0gMDtcbiAgdGhpcy5wbGF5aGVhZCA9IDA7XG59O1xuXG4vKipcbiAqIE9zY2lsbGF0b3IgY2xhc3MgZm9yIGdlbmVyYXRpbmcgYW5kIG1vZGlmeWluZyBzaWduYWxzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgICAgICAgQSB3YXZlZm9ybSBjb25zdGFudCAoZWcuIERTUC5TSU5FKVxuICogQHBhcmFtIHtOdW1iZXJ9IGZyZXF1ZW5jeSAgSW5pdGlhbCBmcmVxdWVuY3kgb2YgdGhlIHNpZ25hbFxuICogQHBhcmFtIHtOdW1iZXJ9IGFtcGxpdHVkZSAgSW5pdGlhbCBhbXBsaXR1ZGUgb2YgdGhlIHNpZ25hbFxuICogQHBhcmFtIHtOdW1iZXJ9IGJ1ZmZlclNpemUgU2l6ZSBvZiB0aGUgc2FtcGxlIGJ1ZmZlciB0byBnZW5lcmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHNhbXBsZVJhdGUgVGhlIHNhbXBsZSByYXRlIG9mIHRoZSBzaWduYWxcbiAqXG4gKiBAY29udHJ1Y3RvclxuICovXG5mdW5jdGlvbiBPc2NpbGxhdG9yKHR5cGUsIGZyZXF1ZW5jeSwgYW1wbGl0dWRlLCBidWZmZXJTaXplLCBzYW1wbGVSYXRlKSB7XG4gIHRoaXMuZnJlcXVlbmN5ICA9IGZyZXF1ZW5jeTtcbiAgdGhpcy5hbXBsaXR1ZGUgID0gYW1wbGl0dWRlO1xuICB0aGlzLmJ1ZmZlclNpemUgPSBidWZmZXJTaXplO1xuICB0aGlzLnNhbXBsZVJhdGUgPSBzYW1wbGVSYXRlO1xuICAvL3RoaXMucHVsc2VXaWR0aCA9IHB1bHNlV2lkdGg7XG4gIHRoaXMuZnJhbWVDb3VudCA9IDA7XG4gXG4gIHRoaXMud2F2ZVRhYmxlTGVuZ3RoID0gMjA0ODtcblxuICB0aGlzLmN5Y2xlc1BlclNhbXBsZSA9IGZyZXF1ZW5jeSAvIHNhbXBsZVJhdGU7XG5cbiAgdGhpcy5zaWduYWwgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlclNpemUpO1xuICB0aGlzLmVudmVsb3BlID0gbnVsbDtcblxuICBzd2l0Y2gocGFyc2VJbnQodHlwZSwgMTApKSB7XG4gICAgY2FzZSBEU1AuVFJJQU5HTEU6XG4gICAgICB0aGlzLmZ1bmMgPSBPc2NpbGxhdG9yLlRyaWFuZ2xlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIERTUC5TQVc6XG4gICAgICB0aGlzLmZ1bmMgPSBPc2NpbGxhdG9yLlNhdztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBEU1AuU1FVQVJFOlxuICAgICAgdGhpcy5mdW5jID0gT3NjaWxsYXRvci5TcXVhcmU7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgY2FzZSBEU1AuU0lORTpcbiAgICAgIHRoaXMuZnVuYyA9IE9zY2lsbGF0b3IuU2luZTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdGhpcy5nZW5lcmF0ZVdhdmVUYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIE9zY2lsbGF0b3Iud2F2ZVRhYmxlW3RoaXMuZnVuY10gPSBuZXcgRmxvYXQzMkFycmF5KDIwNDgpO1xuICAgIHZhciB3YXZlVGFibGVUaW1lID0gdGhpcy53YXZlVGFibGVMZW5ndGggLyB0aGlzLnNhbXBsZVJhdGU7XG4gICAgdmFyIHdhdmVUYWJsZUh6ID0gMSAvIHdhdmVUYWJsZVRpbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMud2F2ZVRhYmxlTGVuZ3RoOyBpKyspIHtcbiAgICAgIE9zY2lsbGF0b3Iud2F2ZVRhYmxlW3RoaXMuZnVuY11baV0gPSB0aGlzLmZ1bmMoaSAqIHdhdmVUYWJsZUh6L3RoaXMuc2FtcGxlUmF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIGlmICggdHlwZW9mIE9zY2lsbGF0b3Iud2F2ZVRhYmxlID09PSAndW5kZWZpbmVkJyApIHtcbiAgICBPc2NpbGxhdG9yLndhdmVUYWJsZSA9IHt9O1xuICB9XG5cbiAgaWYgKCB0eXBlb2YgT3NjaWxsYXRvci53YXZlVGFibGVbdGhpcy5mdW5jXSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgdGhpcy5nZW5lcmF0ZVdhdmVUYWJsZSgpO1xuICB9XG4gXG4gIHRoaXMud2F2ZVRhYmxlID0gT3NjaWxsYXRvci53YXZlVGFibGVbdGhpcy5mdW5jXTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGFtcGxpdHVkZSBvZiB0aGUgc2lnbmFsXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGFtcGxpdHVkZSBUaGUgYW1wbGl0dWRlIG9mIHRoZSBzaWduYWwgKGJldHdlZW4gMCBhbmQgMSlcbiAqL1xuT3NjaWxsYXRvci5wcm90b3R5cGUuc2V0QW1wID0gZnVuY3Rpb24oYW1wbGl0dWRlKSB7XG4gIGlmIChhbXBsaXR1ZGUgPj0gMCAmJiBhbXBsaXR1ZGUgPD0gMSkge1xuICAgIHRoaXMuYW1wbGl0dWRlID0gYW1wbGl0dWRlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IFwiQW1wbGl0dWRlIG91dCBvZiByYW5nZSAoMC4uMSkuXCI7XG4gIH1cbn07XG4gIFxuLyoqXG4gKiBTZXQgdGhlIGZyZXF1ZW5jeSBvZiB0aGUgc2lnbmFsXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGZyZXF1ZW5jeSBUaGUgZnJlcXVlbmN5IG9mIHRoZSBzaWduYWxcbiAqLyAgXG5Pc2NpbGxhdG9yLnByb3RvdHlwZS5zZXRGcmVxID0gZnVuY3Rpb24oZnJlcXVlbmN5KSB7XG4gIHRoaXMuZnJlcXVlbmN5ID0gZnJlcXVlbmN5O1xuICB0aGlzLmN5Y2xlc1BlclNhbXBsZSA9IGZyZXF1ZW5jeSAvIHRoaXMuc2FtcGxlUmF0ZTtcbn07XG4gICAgIFxuLy8gQWRkIGFuIG9zY2lsbGF0b3Jcbk9zY2lsbGF0b3IucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG9zY2lsbGF0b3IpIHtcbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5idWZmZXJTaXplOyBpKysgKSB7XG4gICAgLy90aGlzLnNpZ25hbFtpXSArPSBvc2NpbGxhdG9yLnZhbHVlQXQoaSk7XG4gICAgdGhpcy5zaWduYWxbaV0gKz0gb3NjaWxsYXRvci5zaWduYWxbaV07XG4gIH1cbiBcbiAgcmV0dXJuIHRoaXMuc2lnbmFsO1xufTtcbiAgICAgXG4vLyBBZGQgYSBzaWduYWwgdG8gdGhlIGN1cnJlbnQgZ2VuZXJhdGVkIG9zYyBzaWduYWxcbk9zY2lsbGF0b3IucHJvdG90eXBlLmFkZFNpZ25hbCA9IGZ1bmN0aW9uKHNpZ25hbCkge1xuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaWduYWwubGVuZ3RoOyBpKysgKSB7XG4gICAgaWYgKCBpID49IHRoaXMuYnVmZmVyU2l6ZSApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hbFtpXSArPSBzaWduYWxbaV07XG4gICBcbiAgICAvKlxuICAgIC8vIENvbnN0cmFpbiBhbXBsaXR1ZGVcbiAgICBpZiAoIHRoaXMuc2lnbmFsW2ldID4gMSApIHtcbiAgICAgIHRoaXMuc2lnbmFsW2ldID0gMTtcbiAgICB9IGVsc2UgaWYgKCB0aGlzLnNpZ25hbFtpXSA8IC0xICkge1xuICAgICAgdGhpcy5zaWduYWxbaV0gPSAtMTtcbiAgICB9XG4gICAgKi9cbiAgfVxuICByZXR1cm4gdGhpcy5zaWduYWw7XG59O1xuICAgICBcbi8vIEFkZCBhbiBlbnZlbG9wZSB0byB0aGUgb3NjaWxsYXRvclxuT3NjaWxsYXRvci5wcm90b3R5cGUuYWRkRW52ZWxvcGUgPSBmdW5jdGlvbihlbnZlbG9wZSkge1xuICB0aGlzLmVudmVsb3BlID0gZW52ZWxvcGU7XG59O1xuXG5Pc2NpbGxhdG9yLnByb3RvdHlwZS5hcHBseUVudmVsb3BlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW52ZWxvcGUucHJvY2Vzcyh0aGlzLnNpZ25hbCk7XG59O1xuICAgICBcbk9zY2lsbGF0b3IucHJvdG90eXBlLnZhbHVlQXQgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud2F2ZVRhYmxlW29mZnNldCAlIHRoaXMud2F2ZVRhYmxlTGVuZ3RoXTtcbn07XG4gICAgIFxuT3NjaWxsYXRvci5wcm90b3R5cGUuZ2VuZXJhdGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZyYW1lT2Zmc2V0ID0gdGhpcy5mcmFtZUNvdW50ICogdGhpcy5idWZmZXJTaXplO1xuICB2YXIgc3RlcCA9IHRoaXMud2F2ZVRhYmxlTGVuZ3RoICogdGhpcy5mcmVxdWVuY3kgLyB0aGlzLnNhbXBsZVJhdGU7XG4gIHZhciBvZmZzZXQ7XG5cbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5idWZmZXJTaXplOyBpKysgKSB7XG4gICAgLy92YXIgc3RlcCA9IChmcmFtZU9mZnNldCArIGkpICogdGhpcy5jeWNsZXNQZXJTYW1wbGUgJSAxO1xuICAgIC8vdGhpcy5zaWduYWxbaV0gPSB0aGlzLmZ1bmMoc3RlcCkgKiB0aGlzLmFtcGxpdHVkZTtcbiAgICAvL3RoaXMuc2lnbmFsW2ldID0gdGhpcy52YWx1ZUF0KE1hdGgucm91bmQoKGZyYW1lT2Zmc2V0ICsgaSkgKiBzdGVwKSkgKiB0aGlzLmFtcGxpdHVkZTtcbiAgICBvZmZzZXQgPSBNYXRoLnJvdW5kKChmcmFtZU9mZnNldCArIGkpICogc3RlcCk7XG4gICAgdGhpcy5zaWduYWxbaV0gPSB0aGlzLndhdmVUYWJsZVtvZmZzZXQgJSB0aGlzLndhdmVUYWJsZUxlbmd0aF0gKiB0aGlzLmFtcGxpdHVkZTtcbiAgfVxuXG4gIHRoaXMuZnJhbWVDb3VudCsrO1xuXG4gIHJldHVybiB0aGlzLnNpZ25hbDtcbn07XG5cbk9zY2lsbGF0b3IuU2luZSA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgcmV0dXJuIE1hdGguc2luKERTUC5UV09fUEkgKiBzdGVwKTtcbn07XG5cbk9zY2lsbGF0b3IuU3F1YXJlID0gZnVuY3Rpb24oc3RlcCkge1xuICByZXR1cm4gc3RlcCA8IDAuNSA/IDEgOiAtMTtcbn07XG5cbk9zY2lsbGF0b3IuU2F3ID0gZnVuY3Rpb24oc3RlcCkge1xuICByZXR1cm4gMiAqIChzdGVwIC0gTWF0aC5yb3VuZChzdGVwKSk7XG59O1xuXG5Pc2NpbGxhdG9yLlRyaWFuZ2xlID0gZnVuY3Rpb24oc3RlcCkge1xuICByZXR1cm4gMSAtIDQgKiBNYXRoLmFicyhNYXRoLnJvdW5kKHN0ZXApIC0gc3RlcCk7XG59O1xuXG5Pc2NpbGxhdG9yLlB1bHNlID0gZnVuY3Rpb24oc3RlcCkge1xuICAvLyBzdHViXG59O1xuIFxuZnVuY3Rpb24gQURTUihhdHRhY2tMZW5ndGgsIGRlY2F5TGVuZ3RoLCBzdXN0YWluTGV2ZWwsIHN1c3RhaW5MZW5ndGgsIHJlbGVhc2VMZW5ndGgsIHNhbXBsZVJhdGUpIHtcbiAgdGhpcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcbiAgLy8gTGVuZ3RoIGluIHNlY29uZHNcbiAgdGhpcy5hdHRhY2tMZW5ndGggID0gYXR0YWNrTGVuZ3RoO1xuICB0aGlzLmRlY2F5TGVuZ3RoICAgPSBkZWNheUxlbmd0aDtcbiAgdGhpcy5zdXN0YWluTGV2ZWwgID0gc3VzdGFpbkxldmVsO1xuICB0aGlzLnN1c3RhaW5MZW5ndGggPSBzdXN0YWluTGVuZ3RoO1xuICB0aGlzLnJlbGVhc2VMZW5ndGggPSByZWxlYXNlTGVuZ3RoO1xuICB0aGlzLnNhbXBsZVJhdGUgICAgPSBzYW1wbGVSYXRlO1xuIFxuICAvLyBMZW5ndGggaW4gc2FtcGxlc1xuICB0aGlzLmF0dGFja1NhbXBsZXMgID0gYXR0YWNrTGVuZ3RoICAqIHNhbXBsZVJhdGU7XG4gIHRoaXMuZGVjYXlTYW1wbGVzICAgPSBkZWNheUxlbmd0aCAgICogc2FtcGxlUmF0ZTtcbiAgdGhpcy5zdXN0YWluU2FtcGxlcyA9IHN1c3RhaW5MZW5ndGggKiBzYW1wbGVSYXRlO1xuICB0aGlzLnJlbGVhc2VTYW1wbGVzID0gcmVsZWFzZUxlbmd0aCAqIHNhbXBsZVJhdGU7XG4gXG4gIC8vIFVwZGF0ZXMgdGhlIGVudmVsb3BlIHNhbXBsZSBwb3NpdGlvbnNcbiAgdGhpcy51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmF0dGFjayAgICAgICAgID0gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2tTYW1wbGVzO1xuICAgIHRoaXMuZGVjYXkgICAgICAgICAgPSB0aGlzLmF0dGFjayAgKyB0aGlzLmRlY2F5U2FtcGxlcztcbiAgICB0aGlzLnN1c3RhaW4gICAgICAgID0gdGhpcy5kZWNheSAgICsgdGhpcy5zdXN0YWluU2FtcGxlcztcbiAgICB0aGlzLnJlbGVhc2UgICAgICAgID0gdGhpcy5zdXN0YWluICsgdGhpcy5yZWxlYXNlU2FtcGxlcztcbiAgfTtcbiBcbiAgdGhpcy51cGRhdGUoKTtcbiBcbiAgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID0gMDtcbn1cblxuQURTUi5wcm90b3R5cGUubm90ZU9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA9IDA7XG4gIHRoaXMuc3VzdGFpblNhbXBsZXMgPSB0aGlzLnN1c3RhaW5MZW5ndGggKiB0aGlzLnNhbXBsZVJhdGU7XG4gIHRoaXMudXBkYXRlKCk7XG59O1xuXG4vLyBTZW5kIGEgbm90ZSBvZmYgd2hlbiB1c2luZyBhIHN1c3RhaW4gb2YgaW5maW5pdHkgdG8gbGV0IHRoZSBlbnZlbG9wZSBlbnRlciB0aGUgcmVsZWFzZSBwaGFzZVxuQURTUi5wcm90b3R5cGUubm90ZU9mZiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnN1c3RhaW5TYW1wbGVzID0gdGhpcy5zYW1wbGVzUHJvY2Vzc2VkIC0gdGhpcy5kZWNheVNhbXBsZXM7XG4gIHRoaXMudXBkYXRlKCk7XG59O1xuXG5BRFNSLnByb3RvdHlwZS5wcm9jZXNzU2FtcGxlID0gZnVuY3Rpb24oc2FtcGxlKSB7XG4gIHZhciBhbXBsaXR1ZGUgPSAwO1xuXG4gIGlmICggdGhpcy5zYW1wbGVzUHJvY2Vzc2VkIDw9IHRoaXMuYXR0YWNrICkge1xuICAgIGFtcGxpdHVkZSA9IDAgKyAoMSAtIDApICogKCh0aGlzLnNhbXBsZXNQcm9jZXNzZWQgLSAwKSAvICh0aGlzLmF0dGFjayAtIDApKTtcbiAgfSBlbHNlIGlmICggdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID4gdGhpcy5hdHRhY2sgJiYgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkIDw9IHRoaXMuZGVjYXkgKSB7XG4gICAgYW1wbGl0dWRlID0gMSArICh0aGlzLnN1c3RhaW5MZXZlbCAtIDEpICogKCh0aGlzLnNhbXBsZXNQcm9jZXNzZWQgLSB0aGlzLmF0dGFjaykgLyAodGhpcy5kZWNheSAtIHRoaXMuYXR0YWNrKSk7XG4gIH0gZWxzZSBpZiAoIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA+IHRoaXMuZGVjYXkgJiYgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkIDw9IHRoaXMuc3VzdGFpbiApIHtcbiAgICBhbXBsaXR1ZGUgPSB0aGlzLnN1c3RhaW5MZXZlbDtcbiAgfSBlbHNlIGlmICggdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID4gdGhpcy5zdXN0YWluICYmIHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCA8PSB0aGlzLnJlbGVhc2UgKSB7XG4gICAgYW1wbGl0dWRlID0gdGhpcy5zdXN0YWluTGV2ZWwgKyAoMCAtIHRoaXMuc3VzdGFpbkxldmVsKSAqICgodGhpcy5zYW1wbGVzUHJvY2Vzc2VkIC0gdGhpcy5zdXN0YWluKSAvICh0aGlzLnJlbGVhc2UgLSB0aGlzLnN1c3RhaW4pKTtcbiAgfVxuIFxuICByZXR1cm4gc2FtcGxlICogYW1wbGl0dWRlO1xufTtcblxuQURTUi5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGFtcGxpdHVkZSA9IDA7XG5cbiAgaWYgKCB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPD0gdGhpcy5hdHRhY2sgKSB7XG4gICAgYW1wbGl0dWRlID0gMCArICgxIC0gMCkgKiAoKHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAtIDApIC8gKHRoaXMuYXR0YWNrIC0gMCkpO1xuICB9IGVsc2UgaWYgKCB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPiB0aGlzLmF0dGFjayAmJiB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPD0gdGhpcy5kZWNheSApIHtcbiAgICBhbXBsaXR1ZGUgPSAxICsgKHRoaXMuc3VzdGFpbkxldmVsIC0gMSkgKiAoKHRoaXMuc2FtcGxlc1Byb2Nlc3NlZCAtIHRoaXMuYXR0YWNrKSAvICh0aGlzLmRlY2F5IC0gdGhpcy5hdHRhY2spKTtcbiAgfSBlbHNlIGlmICggdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID4gdGhpcy5kZWNheSAmJiB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPD0gdGhpcy5zdXN0YWluICkge1xuICAgIGFtcGxpdHVkZSA9IHRoaXMuc3VzdGFpbkxldmVsO1xuICB9IGVsc2UgaWYgKCB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPiB0aGlzLnN1c3RhaW4gJiYgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkIDw9IHRoaXMucmVsZWFzZSApIHtcbiAgICBhbXBsaXR1ZGUgPSB0aGlzLnN1c3RhaW5MZXZlbCArICgwIC0gdGhpcy5zdXN0YWluTGV2ZWwpICogKCh0aGlzLnNhbXBsZXNQcm9jZXNzZWQgLSB0aGlzLnN1c3RhaW4pIC8gKHRoaXMucmVsZWFzZSAtIHRoaXMuc3VzdGFpbikpO1xuICB9XG4gXG4gIHJldHVybiBhbXBsaXR1ZGU7XG59O1xuICAgICBcbkFEU1IucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrICkge1xuICAgIGJ1ZmZlcltpXSAqPSB0aGlzLnZhbHVlKCk7XG5cbiAgICB0aGlzLnNhbXBsZXNQcm9jZXNzZWQrKztcbiAgfVxuIFxuICByZXR1cm4gYnVmZmVyO1xufTtcbiAgICAgXG4gICAgIFxuQURTUi5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCB0aGlzLnNhbXBsZXNQcm9jZXNzZWQgPiB0aGlzLnJlbGVhc2UgfHwgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID09PSAtMSApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbkFEU1IucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zYW1wbGVzUHJvY2Vzc2VkID0gLTE7XG59O1xuIFxuZnVuY3Rpb24gSUlSRmlsdGVyKHR5cGUsIGN1dG9mZiwgcmVzb25hbmNlLCBzYW1wbGVSYXRlKSB7XG4gIHRoaXMuc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7XG5cbiAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIERTUC5MT1dQQVNTOlxuICAgIGNhc2UgRFNQLkxQMTI6XG4gICAgICB0aGlzLmZ1bmMgPSBuZXcgSUlSRmlsdGVyLkxQMTIoY3V0b2ZmLCByZXNvbmFuY2UsIHNhbXBsZVJhdGUpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuSUlSRmlsdGVyLnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKCdjdXRvZmYnLFxuICBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mdW5jLmN1dG9mZjtcbiAgfVxuKTtcblxuSUlSRmlsdGVyLnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKCdyZXNvbmFuY2UnLFxuICBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mdW5jLnJlc29uYW5jZTtcbiAgfVxuKTtcblxuSUlSRmlsdGVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihjdXRvZmYsIHJlc29uYW5jZSkge1xuICB0aGlzLmZ1bmMuY2FsY0NvZWZmKGN1dG9mZiwgcmVzb25hbmNlKTtcbn07XG5cbklJUkZpbHRlci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB0aGlzLmZ1bmMucHJvY2VzcyhidWZmZXIpO1xufTtcblxuLy8gQWRkIGFuIGVudmVsb3BlIHRvIHRoZSBmaWx0ZXJcbklJUkZpbHRlci5wcm90b3R5cGUuYWRkRW52ZWxvcGUgPSBmdW5jdGlvbihlbnZlbG9wZSkge1xuICBpZiAoIGVudmVsb3BlIGluc3RhbmNlb2YgQURTUiApIHtcbiAgICB0aGlzLmZ1bmMuYWRkRW52ZWxvcGUoZW52ZWxvcGUpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IFwiTm90IGFuIGVudmVsb3BlLlwiO1xuICB9XG59O1xuXG5JSVJGaWx0ZXIuTFAxMiA9IGZ1bmN0aW9uKGN1dG9mZiwgcmVzb25hbmNlLCBzYW1wbGVSYXRlKSB7XG4gIHRoaXMuc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGU7XG4gIHRoaXMudmlicmFQb3MgICA9IDA7XG4gIHRoaXMudmlicmFTcGVlZCA9IDA7XG4gIHRoaXMuZW52ZWxvcGUgPSBmYWxzZTtcbiBcbiAgdGhpcy5jYWxjQ29lZmYgPSBmdW5jdGlvbihjdXRvZmYsIHJlc29uYW5jZSkge1xuICAgIHRoaXMudyA9IDIuMCAqIE1hdGguUEkgKiBjdXRvZmYgLyB0aGlzLnNhbXBsZVJhdGU7XG4gICAgdGhpcy5xID0gMS4wIC0gdGhpcy53IC8gKDIuMCAqIChyZXNvbmFuY2UgKyAwLjUgLyAoMS4wICsgdGhpcy53KSkgKyB0aGlzLncgLSAyLjApO1xuICAgIHRoaXMuciA9IHRoaXMucSAqIHRoaXMucTtcbiAgICB0aGlzLmMgPSB0aGlzLnIgKyAxLjAgLSAyLjAgKiBNYXRoLmNvcyh0aGlzLncpICogdGhpcy5xO1xuICAgXG4gICAgdGhpcy5jdXRvZmYgPSBjdXRvZmY7XG4gICAgdGhpcy5yZXNvbmFuY2UgPSByZXNvbmFuY2U7XG4gIH07XG5cbiAgdGhpcy5jYWxjQ29lZmYoY3V0b2ZmLCByZXNvbmFuY2UpO1xuXG4gIHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKyApIHtcbiAgICAgIHRoaXMudmlicmFTcGVlZCArPSAoYnVmZmVyW2ldIC0gdGhpcy52aWJyYVBvcykgKiB0aGlzLmM7XG4gICAgICB0aGlzLnZpYnJhUG9zICAgKz0gdGhpcy52aWJyYVNwZWVkO1xuICAgICAgdGhpcy52aWJyYVNwZWVkICo9IHRoaXMucjtcbiAgIFxuICAgICAgLypcbiAgICAgIHZhciB0ZW1wID0gdGhpcy52aWJyYVBvcztcbiAgICAgXG4gICAgICBpZiAoIHRlbXAgPiAxLjAgKSB7XG4gICAgICAgIHRlbXAgPSAxLjA7XG4gICAgICB9IGVsc2UgaWYgKCB0ZW1wIDwgLTEuMCApIHtcbiAgICAgICAgdGVtcCA9IC0xLjA7XG4gICAgICB9IGVsc2UgaWYgKCB0ZW1wICE9IHRlbXAgKSB7XG4gICAgICAgIHRlbXAgPSAxO1xuICAgICAgfVxuICAgICBcbiAgICAgIGJ1ZmZlcltpXSA9IHRlbXA7XG4gICAgICAqL1xuXG4gICAgICBpZiAodGhpcy5lbnZlbG9wZSkge1xuICAgICAgICBidWZmZXJbaV0gPSAoYnVmZmVyW2ldICogKDEgLSB0aGlzLmVudmVsb3BlLnZhbHVlKCkpKSArICh0aGlzLnZpYnJhUG9zICogdGhpcy5lbnZlbG9wZS52YWx1ZSgpKTtcbiAgICAgICAgdGhpcy5lbnZlbG9wZS5zYW1wbGVzUHJvY2Vzc2VkKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXJbaV0gPSB0aGlzLnZpYnJhUG9zO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07IFxuXG5JSVJGaWx0ZXIuTFAxMi5wcm90b3R5cGUuYWRkRW52ZWxvcGUgPSBmdW5jdGlvbihlbnZlbG9wZSkge1xuICB0aGlzLmVudmVsb3BlID0gZW52ZWxvcGU7XG59O1xuXG5mdW5jdGlvbiBJSVJGaWx0ZXIyKHR5cGUsIGN1dG9mZiwgcmVzb25hbmNlLCBzYW1wbGVSYXRlKSB7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuY3V0b2ZmID0gY3V0b2ZmO1xuICB0aGlzLnJlc29uYW5jZSA9IHJlc29uYW5jZTtcbiAgdGhpcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTtcblxuICB0aGlzLmYgPSBGbG9hdDMyQXJyYXkoNCk7XG4gIHRoaXMuZlswXSA9IDAuMDsgLy8gbHBcbiAgdGhpcy5mWzFdID0gMC4wOyAvLyBocFxuICB0aGlzLmZbMl0gPSAwLjA7IC8vIGJwXG4gIHRoaXMuZlszXSA9IDAuMDsgLy8gYnIgXG4gXG4gIHRoaXMuY2FsY0NvZWZmID0gZnVuY3Rpb24oY3V0b2ZmLCByZXNvbmFuY2UpIHtcbiAgICB0aGlzLmZyZXEgPSAyICogTWF0aC5zaW4oTWF0aC5QSSAqIE1hdGgubWluKDAuMjUsIGN1dG9mZi8odGhpcy5zYW1wbGVSYXRlKjIpKSk7ICBcbiAgICB0aGlzLmRhbXAgPSBNYXRoLm1pbigyICogKDEgLSBNYXRoLnBvdyhyZXNvbmFuY2UsIDAuMjUpKSwgTWF0aC5taW4oMiwgMi90aGlzLmZyZXEgLSB0aGlzLmZyZXEgKiAwLjUpKTtcbiAgfTtcblxuICB0aGlzLmNhbGNDb2VmZihjdXRvZmYsIHJlc29uYW5jZSk7XG59XG5cbklJUkZpbHRlcjIucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7XG4gIHZhciBmID0gdGhpcy5mO1xuXG4gIGZvciAoIHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKyApIHtcbiAgICBpbnB1dCA9IGJ1ZmZlcltpXTtcblxuICAgIC8vIGZpcnN0IHBhc3NcbiAgICBmWzNdID0gaW5wdXQgLSB0aGlzLmRhbXAgKiBmWzJdO1xuICAgIGZbMF0gPSBmWzBdICsgdGhpcy5mcmVxICogZlsyXTtcbiAgICBmWzFdID0gZlszXSAtIGZbMF07XG4gICAgZlsyXSA9IHRoaXMuZnJlcSAqIGZbMV0gKyBmWzJdO1xuICAgIG91dHB1dCA9IDAuNSAqIGZbdGhpcy50eXBlXTtcblxuICAgIC8vIHNlY29uZCBwYXNzXG4gICAgZlszXSA9IGlucHV0IC0gdGhpcy5kYW1wICogZlsyXTtcbiAgICBmWzBdID0gZlswXSArIHRoaXMuZnJlcSAqIGZbMl07XG4gICAgZlsxXSA9IGZbM10gLSBmWzBdO1xuICAgIGZbMl0gPSB0aGlzLmZyZXEgKiBmWzFdICsgZlsyXTtcbiAgICBvdXRwdXQgKz0gMC41ICogZlt0aGlzLnR5cGVdO1xuXG4gICAgaWYgKHRoaXMuZW52ZWxvcGUpIHtcbiAgICAgIGJ1ZmZlcltpXSA9IChidWZmZXJbaV0gKiAoMSAtIHRoaXMuZW52ZWxvcGUudmFsdWUoKSkpICsgKG91dHB1dCAqIHRoaXMuZW52ZWxvcGUudmFsdWUoKSk7XG4gICAgICB0aGlzLmVudmVsb3BlLnNhbXBsZXNQcm9jZXNzZWQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyW2ldID0gb3V0cHV0O1xuICAgIH1cbiAgfVxufTtcblxuSUlSRmlsdGVyMi5wcm90b3R5cGUuYWRkRW52ZWxvcGUgPSBmdW5jdGlvbihlbnZlbG9wZSkge1xuICBpZiAoIGVudmVsb3BlIGluc3RhbmNlb2YgQURTUiApIHtcbiAgICB0aGlzLmVudmVsb3BlID0gZW52ZWxvcGU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgXCJUaGlzIGlzIG5vdCBhbiBlbnZlbG9wZS5cIjtcbiAgfVxufTtcblxuSUlSRmlsdGVyMi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oY3V0b2ZmLCByZXNvbmFuY2UpIHtcbiAgdGhpcy5jYWxjQ29lZmYoY3V0b2ZmLCByZXNvbmFuY2UpO1xufTtcblxuXG5cbmZ1bmN0aW9uIFdpbmRvd0Z1bmN0aW9uKHR5cGUsIGFscGhhKSB7XG4gIHRoaXMuYWxwaGEgPSBhbHBoYTtcbiBcbiAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIERTUC5CQVJUTEVUVDpcbiAgICAgIHRoaXMuZnVuYyA9IFdpbmRvd0Z1bmN0aW9uLkJhcnRsZXR0O1xuICAgICAgYnJlYWs7XG4gICAgIFxuICAgIGNhc2UgRFNQLkJBUlRMRVRUSEFOTjpcbiAgICAgIHRoaXMuZnVuYyA9IFdpbmRvd0Z1bmN0aW9uLkJhcnRsZXR0SGFubjtcbiAgICAgIGJyZWFrO1xuICAgICBcbiAgICBjYXNlIERTUC5CTEFDS01BTjpcbiAgICAgIHRoaXMuZnVuYyA9IFdpbmRvd0Z1bmN0aW9uLkJsYWNrbWFuO1xuICAgICAgdGhpcy5hbHBoYSA9IHRoaXMuYWxwaGEgfHwgMC4xNjtcbiAgICAgIGJyZWFrO1xuICAgXG4gICAgY2FzZSBEU1AuQ09TSU5FOlxuICAgICAgdGhpcy5mdW5jID0gV2luZG93RnVuY3Rpb24uQ29zaW5lO1xuICAgICAgYnJlYWs7XG4gICAgIFxuICAgIGNhc2UgRFNQLkdBVVNTOlxuICAgICAgdGhpcy5mdW5jID0gV2luZG93RnVuY3Rpb24uR2F1c3M7XG4gICAgICB0aGlzLmFscGhhID0gdGhpcy5hbHBoYSB8fCAwLjI1O1xuICAgICAgYnJlYWs7XG4gICAgIFxuICAgIGNhc2UgRFNQLkhBTU1JTkc6XG4gICAgICB0aGlzLmZ1bmMgPSBXaW5kb3dGdW5jdGlvbi5IYW1taW5nO1xuICAgICAgYnJlYWs7XG4gICAgIFxuICAgIGNhc2UgRFNQLkhBTk46XG4gICAgICB0aGlzLmZ1bmMgPSBXaW5kb3dGdW5jdGlvbi5IYW5uO1xuICAgICAgYnJlYWs7XG4gICBcbiAgICBjYXNlIERTUC5MQU5DWk9TOlxuICAgICAgdGhpcy5mdW5jID0gV2luZG93RnVuY3Rpb24uTGFuY3pvejtcbiAgICAgIGJyZWFrO1xuICAgICBcbiAgICBjYXNlIERTUC5SRUNUQU5HVUxBUjpcbiAgICAgIHRoaXMuZnVuYyA9IFdpbmRvd0Z1bmN0aW9uLlJlY3Rhbmd1bGFyO1xuICAgICAgYnJlYWs7XG4gICAgIFxuICAgIGNhc2UgRFNQLlRSSUFOR1VMQVI6XG4gICAgICB0aGlzLmZ1bmMgPSBXaW5kb3dGdW5jdGlvbi5Ucmlhbmd1bGFyO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuV2luZG93RnVuY3Rpb24ucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrICkge1xuICAgIGJ1ZmZlcltpXSAqPSB0aGlzLmZ1bmMobGVuZ3RoLCBpLCB0aGlzLmFscGhhKTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuV2luZG93RnVuY3Rpb24uQmFydGxldHQgPSBmdW5jdGlvbihsZW5ndGgsIGluZGV4KSB7XG4gIHJldHVybiAyIC8gKGxlbmd0aCAtIDEpICogKChsZW5ndGggLSAxKSAvIDIgLSBNYXRoLmFicyhpbmRleCAtIChsZW5ndGggLSAxKSAvIDIpKTtcbn07XG5cbldpbmRvd0Z1bmN0aW9uLkJhcnRsZXR0SGFubiA9IGZ1bmN0aW9uKGxlbmd0aCwgaW5kZXgpIHtcbiAgcmV0dXJuIDAuNjIgLSAwLjQ4ICogTWF0aC5hYnMoaW5kZXggLyAobGVuZ3RoIC0gMSkgLSAwLjUpIC0gMC4zOCAqIE1hdGguY29zKERTUC5UV09fUEkgKiBpbmRleCAvIChsZW5ndGggLSAxKSk7XG59O1xuXG5XaW5kb3dGdW5jdGlvbi5CbGFja21hbiA9IGZ1bmN0aW9uKGxlbmd0aCwgaW5kZXgsIGFscGhhKSB7XG4gIHZhciBhMCA9ICgxIC0gYWxwaGEpIC8gMjtcbiAgdmFyIGExID0gMC41O1xuICB2YXIgYTIgPSBhbHBoYSAvIDI7XG5cbiAgcmV0dXJuIGEwIC0gYTEgKiBNYXRoLmNvcyhEU1AuVFdPX1BJICogaW5kZXggLyAobGVuZ3RoIC0gMSkpICsgYTIgKiBNYXRoLmNvcyg0ICogTWF0aC5QSSAqIGluZGV4IC8gKGxlbmd0aCAtIDEpKTtcbn07XG5cbldpbmRvd0Z1bmN0aW9uLkNvc2luZSA9IGZ1bmN0aW9uKGxlbmd0aCwgaW5kZXgpIHtcbiAgcmV0dXJuIE1hdGguY29zKE1hdGguUEkgKiBpbmRleCAvIChsZW5ndGggLSAxKSAtIE1hdGguUEkgLyAyKTtcbn07XG5cbldpbmRvd0Z1bmN0aW9uLkdhdXNzID0gZnVuY3Rpb24obGVuZ3RoLCBpbmRleCwgYWxwaGEpIHtcbiAgcmV0dXJuIE1hdGgucG93KE1hdGguRSwgLTAuNSAqIE1hdGgucG93KChpbmRleCAtIChsZW5ndGggLSAxKSAvIDIpIC8gKGFscGhhICogKGxlbmd0aCAtIDEpIC8gMiksIDIpKTtcbn07XG5cbldpbmRvd0Z1bmN0aW9uLkhhbW1pbmcgPSBmdW5jdGlvbihsZW5ndGgsIGluZGV4KSB7XG4gIHJldHVybiAwLjU0IC0gMC40NiAqIE1hdGguY29zKERTUC5UV09fUEkgKiBpbmRleCAvIChsZW5ndGggLSAxKSk7XG59O1xuXG5XaW5kb3dGdW5jdGlvbi5IYW5uID0gZnVuY3Rpb24obGVuZ3RoLCBpbmRleCkge1xuICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhEU1AuVFdPX1BJICogaW5kZXggLyAobGVuZ3RoIC0gMSkpKTtcbn07XG5cbldpbmRvd0Z1bmN0aW9uLkxhbmN6b3MgPSBmdW5jdGlvbihsZW5ndGgsIGluZGV4KSB7XG4gIHZhciB4ID0gMiAqIGluZGV4IC8gKGxlbmd0aCAtIDEpIC0gMTtcbiAgcmV0dXJuIE1hdGguc2luKE1hdGguUEkgKiB4KSAvIChNYXRoLlBJICogeCk7XG59O1xuXG5XaW5kb3dGdW5jdGlvbi5SZWN0YW5ndWxhciA9IGZ1bmN0aW9uKGxlbmd0aCwgaW5kZXgpIHtcbiAgcmV0dXJuIDE7XG59O1xuXG5XaW5kb3dGdW5jdGlvbi5Ucmlhbmd1bGFyID0gZnVuY3Rpb24obGVuZ3RoLCBpbmRleCkge1xuICByZXR1cm4gMiAvIGxlbmd0aCAqIChsZW5ndGggLyAyIC0gTWF0aC5hYnMoaW5kZXggLSAobGVuZ3RoIC0gMSkgLyAyKSk7XG59O1xuXG5mdW5jdGlvbiBzaW5oIChhcmcpIHtcbiAgLy8gUmV0dXJucyB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIHRoZSBudW1iZXIsIGRlZmluZWQgYXMgKGV4cChudW1iZXIpIC0gZXhwKC1udW1iZXIpKS8yIFxuICAvL1xuICAvLyB2ZXJzaW9uOiAxMDA0LjIzMTRcbiAgLy8gZGlzY3VzcyBhdDogaHR0cDovL3BocGpzLm9yZy9mdW5jdGlvbnMvc2luaCAgICAvLyArICAgb3JpZ2luYWwgYnk6IE9ubm8gTWFyc21hblxuICAvLyAqICAgICBleGFtcGxlIDE6IHNpbmgoLTAuOTgzNDMzMDM0ODgyNTkwOSk7XG4gIC8vICogICAgIHJldHVybnMgMTogLTEuMTQ5Nzk3MTQwMjYzNjUwMlxuICByZXR1cm4gKE1hdGguZXhwKGFyZykgLSBNYXRoLmV4cCgtYXJnKSkvMjtcbn1cblxuLyogXG4gKiAgQmlxdWFkIGZpbHRlclxuICogXG4gKiAgQ3JlYXRlZCBieSBSaWNhcmQgTWFyeGVyIDxlbWFpbEByaWNhcmRtYXJ4ZXIuY29tPiBvbiAyMDEwLTA1LTIzLlxuICogIENvcHlyaWdodCAyMDEwIFJpY2FyZCBNYXJ4ZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICovXG4vLyBJbXBsZW1lbnRhdGlvbiBiYXNlZCBvbjpcbi8vIGh0dHA6Ly93d3cubXVzaWNkc3Aub3JnL2ZpbGVzL0F1ZGlvLUVRLUNvb2tib29rLnR4dFxuZnVuY3Rpb24gQmlxdWFkKHR5cGUsIHNhbXBsZVJhdGUpIHtcbiAgdGhpcy5GcyA9IHNhbXBsZVJhdGU7XG4gIHRoaXMudHlwZSA9IHR5cGU7ICAvLyB0eXBlIG9mIHRoZSBmaWx0ZXJcbiAgdGhpcy5wYXJhbWV0ZXJUeXBlID0gRFNQLlE7IC8vIHR5cGUgb2YgdGhlIHBhcmFtZXRlclxuXG4gIHRoaXMueF8xX2wgPSAwO1xuICB0aGlzLnhfMl9sID0gMDtcbiAgdGhpcy55XzFfbCA9IDA7XG4gIHRoaXMueV8yX2wgPSAwO1xuXG4gIHRoaXMueF8xX3IgPSAwO1xuICB0aGlzLnhfMl9yID0gMDtcbiAgdGhpcy55XzFfciA9IDA7XG4gIHRoaXMueV8yX3IgPSAwO1xuXG4gIHRoaXMuYjAgPSAxO1xuICB0aGlzLmEwID0gMTtcblxuICB0aGlzLmIxID0gMDtcbiAgdGhpcy5hMSA9IDA7XG5cbiAgdGhpcy5iMiA9IDA7XG4gIHRoaXMuYTIgPSAwO1xuXG4gIHRoaXMuYjBhMCA9IHRoaXMuYjAgLyB0aGlzLmEwO1xuICB0aGlzLmIxYTAgPSB0aGlzLmIxIC8gdGhpcy5hMDtcbiAgdGhpcy5iMmEwID0gdGhpcy5iMiAvIHRoaXMuYTA7XG4gIHRoaXMuYTFhMCA9IHRoaXMuYTEgLyB0aGlzLmEwO1xuICB0aGlzLmEyYTAgPSB0aGlzLmEyIC8gdGhpcy5hMDtcblxuICB0aGlzLmYwID0gMzAwMDsgICAvLyBcIndoZXJldmVyIGl0J3MgaGFwcGVuaW4nLCBtYW4uXCIgIENlbnRlciBGcmVxdWVuY3kgb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29ybmVyIEZyZXF1ZW5jeSwgb3Igc2hlbGYgbWlkcG9pbnQgZnJlcXVlbmN5LCBkZXBlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gd2hpY2ggZmlsdGVyIHR5cGUuICBUaGUgXCJzaWduaWZpY2FudCBmcmVxdWVuY3lcIi5cblxuICB0aGlzLmRCZ2FpbiA9IDEyOyAvLyB1c2VkIG9ubHkgZm9yIHBlYWtpbmcgYW5kIHNoZWx2aW5nIGZpbHRlcnNcblxuICB0aGlzLlEgPSAxOyAgICAgICAvLyB0aGUgRUUga2luZCBvZiBkZWZpbml0aW9uLCBleGNlcHQgZm9yIHBlYWtpbmdFUSBpbiB3aGljaCBBKlEgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGNsYXNzaWMgRUUgUS4gIFRoYXQgYWRqdXN0bWVudCBpbiBkZWZpbml0aW9uIHdhcyBtYWRlIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBib29zdCBvZiBOIGRCIGZvbGxvd2VkIGJ5IGEgY3V0IG9mIE4gZEIgZm9yIGlkZW50aWNhbCBRIGFuZFxuICAgICAgICAgICAgICAgICAgICAvLyBmMC9GcyByZXN1bHRzIGluIGEgcHJlY2lzZWx5IGZsYXQgdW5pdHkgZ2FpbiBmaWx0ZXIgb3IgXCJ3aXJlXCIuXG5cbiAgdGhpcy5CVyA9IC0zOyAgICAgLy8gdGhlIGJhbmR3aWR0aCBpbiBvY3RhdmVzIChiZXR3ZWVuIC0zIGRCIGZyZXF1ZW5jaWVzIGZvciBCUEZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG5vdGNoIG9yIGJldHdlZW4gbWlkcG9pbnQgKGRCZ2Fpbi8yKSBnYWluIGZyZXF1ZW5jaWVzIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBwZWFraW5nIEVRXG5cbiAgdGhpcy5TID0gMTsgICAgICAgLy8gYSBcInNoZWxmIHNsb3BlXCIgcGFyYW1ldGVyIChmb3Igc2hlbHZpbmcgRVEgb25seSkuICBXaGVuIFMgPSAxLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2hlbGYgc2xvcGUgaXMgYXMgc3RlZXAgYXMgaXQgY2FuIGJlIGFuZCByZW1haW4gbW9ub3RvbmljYWxseVxuICAgICAgICAgICAgICAgICAgICAvLyBpbmNyZWFzaW5nIG9yIGRlY3JlYXNpbmcgZ2FpbiB3aXRoIGZyZXF1ZW5jeS4gIFRoZSBzaGVsZiBzbG9wZSwgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gZEIvb2N0YXZlLCByZW1haW5zIHByb3BvcnRpb25hbCB0byBTIGZvciBhbGwgb3RoZXIgdmFsdWVzIGZvciBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpeGVkIGYwL0ZzIGFuZCBkQmdhaW4uXG5cbiAgdGhpcy5jb2VmZmljaWVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYiA9IFt0aGlzLmIwLCB0aGlzLmIxLCB0aGlzLmIyXTtcbiAgICB2YXIgYSA9IFt0aGlzLmEwLCB0aGlzLmExLCB0aGlzLmEyXTtcbiAgICByZXR1cm4ge2I6IGIsIGE6YX07XG4gIH07XG5cbiAgdGhpcy5zZXRGaWx0ZXJUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUNvZWZmaWNpZW50cygpO1xuICB9O1xuXG4gIHRoaXMuc2V0U2FtcGxlUmF0ZSA9IGZ1bmN0aW9uKHJhdGUpIHtcbiAgICB0aGlzLkZzID0gcmF0ZTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlQ29lZmZpY2llbnRzKCk7XG4gIH07XG5cbiAgdGhpcy5zZXRRID0gZnVuY3Rpb24ocSkge1xuICAgIHRoaXMucGFyYW1ldGVyVHlwZSA9IERTUC5RO1xuICAgIHRoaXMuUSA9IE1hdGgubWF4KE1hdGgubWluKHEsIDExNS4wKSwgMC4wMDEpO1xuICAgIHRoaXMucmVjYWxjdWxhdGVDb2VmZmljaWVudHMoKTtcbiAgfTtcblxuICB0aGlzLnNldEJXID0gZnVuY3Rpb24oYncpIHtcbiAgICB0aGlzLnBhcmFtZXRlclR5cGUgPSBEU1AuQlc7XG4gICAgdGhpcy5CVyA9IGJ3O1xuICAgIHRoaXMucmVjYWxjdWxhdGVDb2VmZmljaWVudHMoKTtcbiAgfTtcblxuICB0aGlzLnNldFMgPSBmdW5jdGlvbihzKSB7XG4gICAgdGhpcy5wYXJhbWV0ZXJUeXBlID0gRFNQLlM7XG4gICAgdGhpcy5TID0gTWF0aC5tYXgoTWF0aC5taW4ocywgNS4wKSwgMC4wMDAxKTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlQ29lZmZpY2llbnRzKCk7XG4gIH07XG5cbiAgdGhpcy5zZXRGMCA9IGZ1bmN0aW9uKGZyZXEpIHtcbiAgICB0aGlzLmYwID0gZnJlcTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlQ29lZmZpY2llbnRzKCk7XG4gIH07IFxuIFxuICB0aGlzLnNldERiR2FpbiA9IGZ1bmN0aW9uKGcpIHtcbiAgICB0aGlzLmRCZ2FpbiA9IGc7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUNvZWZmaWNpZW50cygpO1xuICB9O1xuXG4gIHRoaXMucmVjYWxjdWxhdGVDb2VmZmljaWVudHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQTtcbiAgICBpZiAodHlwZSA9PT0gRFNQLlBFQUtJTkdfRVEgfHwgdHlwZSA9PT0gRFNQLkxPV19TSEVMRiB8fCB0eXBlID09PSBEU1AuSElHSF9TSEVMRiApIHtcbiAgICAgIEEgPSBNYXRoLnBvdygxMCwgKHRoaXMuZEJnYWluLzQwKSk7ICAvLyBmb3IgcGVha2luZyBhbmQgc2hlbHZpbmcgRVEgZmlsdGVycyBvbmx5XG4gICAgfSBlbHNlIHtcbiAgICAgIEEgID0gTWF0aC5zcXJ0KCBNYXRoLnBvdygxMCwgKHRoaXMuZEJnYWluLzIwKSkgKTsgICBcbiAgICB9XG5cbiAgICB2YXIgdzAgPSBEU1AuVFdPX1BJICogdGhpcy5mMCAvIHRoaXMuRnM7XG5cbiAgICB2YXIgY29zdzAgPSBNYXRoLmNvcyh3MCk7XG4gICAgdmFyIHNpbncwID0gTWF0aC5zaW4odzApO1xuXG4gICAgdmFyIGFscGhhID0gMDtcbiAgIFxuICAgIHN3aXRjaCAodGhpcy5wYXJhbWV0ZXJUeXBlKSB7XG4gICAgICBjYXNlIERTUC5ROlxuICAgICAgICBhbHBoYSA9IHNpbncwLygyKnRoaXMuUSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICAgICBcbiAgICAgIGNhc2UgRFNQLkJXOlxuICAgICAgICBhbHBoYSA9IHNpbncwICogc2luaCggTWF0aC5MTjIvMiAqIHRoaXMuQlcgKiB3MC9zaW53MCApO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEU1AuUzpcbiAgICAgICAgYWxwaGEgPSBzaW53MC8yICogTWF0aC5zcXJ0KCAoQSArIDEvQSkqKDEvdGhpcy5TIC0gMSkgKyAyICk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICBGWUk6IFRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiBiYW5kd2lkdGggYW5kIFEgaXNcbiAgICAgICAgICAgICAxL1EgPSAyKnNpbmgobG4oMikvMipCVyp3MC9zaW4odzApKSAgICAgKGRpZ2l0YWwgZmlsdGVyIHcgQkxUKVxuICAgICAgICBvciAgIDEvUSA9IDIqc2luaChsbigyKS8yKkJXKSAgICAgICAgICAgICAoYW5hbG9nIGZpbHRlciBwcm90b3R5cGUpXG5cbiAgICAgICAgVGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHNoZWxmIHNsb3BlIGFuZCBRIGlzXG4gICAgICAgICAgICAgMS9RID0gc3FydCgoQSArIDEvQSkqKDEvUyAtIDEpICsgMilcbiAgICAqL1xuXG4gICAgdmFyIGNvZWZmO1xuXG4gICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgIGNhc2UgRFNQLkxQRjogICAgICAgLy8gSChzKSA9IDEgLyAoc14yICsgcy9RICsgMSlcbiAgICAgICAgdGhpcy5iMCA9ICAoMSAtIGNvc3cwKS8yO1xuICAgICAgICB0aGlzLmIxID0gICAxIC0gY29zdzA7XG4gICAgICAgIHRoaXMuYjIgPSAgKDEgLSBjb3N3MCkvMjtcbiAgICAgICAgdGhpcy5hMCA9ICAgMSArIGFscGhhO1xuICAgICAgICB0aGlzLmExID0gIC0yICogY29zdzA7XG4gICAgICAgIHRoaXMuYTIgPSAgIDEgLSBhbHBoYTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRFNQLkhQRjogICAgICAgLy8gSChzKSA9IHNeMiAvIChzXjIgKyBzL1EgKyAxKVxuICAgICAgICB0aGlzLmIwID0gICgxICsgY29zdzApLzI7XG4gICAgICAgIHRoaXMuYjEgPSAtKDEgKyBjb3N3MCk7XG4gICAgICAgIHRoaXMuYjIgPSAgKDEgKyBjb3N3MCkvMjtcbiAgICAgICAgdGhpcy5hMCA9ICAgMSArIGFscGhhO1xuICAgICAgICB0aGlzLmExID0gIC0yICogY29zdzA7XG4gICAgICAgIHRoaXMuYTIgPSAgIDEgLSBhbHBoYTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRFNQLkJQRl9DT05TVEFOVF9TS0lSVDogICAgICAgLy8gSChzKSA9IHMgLyAoc14yICsgcy9RICsgMSkgIChjb25zdGFudCBza2lydCBnYWluLCBwZWFrIGdhaW4gPSBRKVxuICAgICAgICB0aGlzLmIwID0gICBzaW53MC8yO1xuICAgICAgICB0aGlzLmIxID0gICAwO1xuICAgICAgICB0aGlzLmIyID0gIC1zaW53MC8yO1xuICAgICAgICB0aGlzLmEwID0gICAxICsgYWxwaGE7XG4gICAgICAgIHRoaXMuYTEgPSAgLTIqY29zdzA7XG4gICAgICAgIHRoaXMuYTIgPSAgIDEgLSBhbHBoYTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRFNQLkJQRl9DT05TVEFOVF9QRUFLOiAgICAgICAvLyBIKHMpID0gKHMvUSkgLyAoc14yICsgcy9RICsgMSkgICAgICAoY29uc3RhbnQgMCBkQiBwZWFrIGdhaW4pXG4gICAgICAgIHRoaXMuYjAgPSAgIGFscGhhO1xuICAgICAgICB0aGlzLmIxID0gICAwO1xuICAgICAgICB0aGlzLmIyID0gIC1hbHBoYTtcbiAgICAgICAgdGhpcy5hMCA9ICAgMSArIGFscGhhO1xuICAgICAgICB0aGlzLmExID0gIC0yKmNvc3cwO1xuICAgICAgICB0aGlzLmEyID0gICAxIC0gYWxwaGE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERTUC5OT1RDSDogICAgIC8vIEgocykgPSAoc14yICsgMSkgLyAoc14yICsgcy9RICsgMSlcbiAgICAgICAgdGhpcy5iMCA9ICAgMTtcbiAgICAgICAgdGhpcy5iMSA9ICAtMipjb3N3MDtcbiAgICAgICAgdGhpcy5iMiA9ICAgMTtcbiAgICAgICAgdGhpcy5hMCA9ICAgMSArIGFscGhhO1xuICAgICAgICB0aGlzLmExID0gIC0yKmNvc3cwO1xuICAgICAgICB0aGlzLmEyID0gICAxIC0gYWxwaGE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIERTUC5BUEY6ICAgICAgIC8vIEgocykgPSAoc14yIC0gcy9RICsgMSkgLyAoc14yICsgcy9RICsgMSlcbiAgICAgICAgdGhpcy5iMCA9ICAgMSAtIGFscGhhO1xuICAgICAgICB0aGlzLmIxID0gIC0yKmNvc3cwO1xuICAgICAgICB0aGlzLmIyID0gICAxICsgYWxwaGE7XG4gICAgICAgIHRoaXMuYTAgPSAgIDEgKyBhbHBoYTtcbiAgICAgICAgdGhpcy5hMSA9ICAtMipjb3N3MDtcbiAgICAgICAgdGhpcy5hMiA9ICAgMSAtIGFscGhhO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEU1AuUEVBS0lOR19FUTogIC8vIEgocykgPSAoc14yICsgcyooQS9RKSArIDEpIC8gKHNeMiArIHMvKEEqUSkgKyAxKVxuICAgICAgICB0aGlzLmIwID0gICAxICsgYWxwaGEqQTtcbiAgICAgICAgdGhpcy5iMSA9ICAtMipjb3N3MDtcbiAgICAgICAgdGhpcy5iMiA9ICAgMSAtIGFscGhhKkE7XG4gICAgICAgIHRoaXMuYTAgPSAgIDEgKyBhbHBoYS9BO1xuICAgICAgICB0aGlzLmExID0gIC0yKmNvc3cwO1xuICAgICAgICB0aGlzLmEyID0gICAxIC0gYWxwaGEvQTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRFNQLkxPV19TSEVMRjogICAvLyBIKHMpID0gQSAqIChzXjIgKyAoc3FydChBKS9RKSpzICsgQSkvKEEqc14yICsgKHNxcnQoQSkvUSkqcyArIDEpXG4gICAgICAgIGNvZWZmID0gc2ludzAgKiBNYXRoLnNxcnQoIChBXjIgKyAxKSooMS90aGlzLlMgLSAxKSArIDIqQSApO1xuICAgICAgICB0aGlzLmIwID0gICAgQSooKEErMSkgLSAoQS0xKSpjb3N3MCArIGNvZWZmKTtcbiAgICAgICAgdGhpcy5iMSA9ICAyKkEqKChBLTEpIC0gKEErMSkqY29zdzApO1xuICAgICAgICB0aGlzLmIyID0gICAgQSooKEErMSkgLSAoQS0xKSpjb3N3MCAtIGNvZWZmKTtcbiAgICAgICAgdGhpcy5hMCA9ICAgICAgIChBKzEpICsgKEEtMSkqY29zdzAgKyBjb2VmZjtcbiAgICAgICAgdGhpcy5hMSA9ICAgLTIqKChBLTEpICsgKEErMSkqY29zdzApO1xuICAgICAgICB0aGlzLmEyID0gICAgICAgKEErMSkgKyAoQS0xKSpjb3N3MCAtIGNvZWZmO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEU1AuSElHSF9TSEVMRjogICAvLyBIKHMpID0gQSAqIChBKnNeMiArIChzcXJ0KEEpL1EpKnMgKyAxKS8oc14yICsgKHNxcnQoQSkvUSkqcyArIEEpXG4gICAgICAgIGNvZWZmID0gc2ludzAgKiBNYXRoLnNxcnQoIChBXjIgKyAxKSooMS90aGlzLlMgLSAxKSArIDIqQSApO1xuICAgICAgICB0aGlzLmIwID0gICAgQSooKEErMSkgKyAoQS0xKSpjb3N3MCArIGNvZWZmKTtcbiAgICAgICAgdGhpcy5iMSA9IC0yKkEqKChBLTEpICsgKEErMSkqY29zdzApO1xuICAgICAgICB0aGlzLmIyID0gICAgQSooKEErMSkgKyAoQS0xKSpjb3N3MCAtIGNvZWZmKTtcbiAgICAgICAgdGhpcy5hMCA9ICAgICAgIChBKzEpIC0gKEEtMSkqY29zdzAgKyBjb2VmZjtcbiAgICAgICAgdGhpcy5hMSA9ICAgIDIqKChBLTEpIC0gKEErMSkqY29zdzApO1xuICAgICAgICB0aGlzLmEyID0gICAgICAgKEErMSkgLSAoQS0xKSpjb3N3MCAtIGNvZWZmO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICBcbiAgICB0aGlzLmIwYTAgPSB0aGlzLmIwL3RoaXMuYTA7XG4gICAgdGhpcy5iMWEwID0gdGhpcy5iMS90aGlzLmEwO1xuICAgIHRoaXMuYjJhMCA9IHRoaXMuYjIvdGhpcy5hMDtcbiAgICB0aGlzLmExYTAgPSB0aGlzLmExL3RoaXMuYTA7XG4gICAgdGhpcy5hMmEwID0gdGhpcy5hMi90aGlzLmEwO1xuICB9O1xuXG4gIHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgLy95W25dID0gKGIwL2EwKSp4W25dICsgKGIxL2EwKSp4W24tMV0gKyAoYjIvYTApKnhbbi0yXVxuICAgICAgLy8gICAgICAgLSAoYTEvYTApKnlbbi0xXSAtIChhMi9hMCkqeVtuLTJdXG5cbiAgICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgICAgdmFyIG91dHB1dCA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcblxuICAgICAgZm9yICggdmFyIGk9MDsgaTxidWZmZXIubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIG91dHB1dFtpXSA9IHRoaXMuYjBhMCpidWZmZXJbaV0gKyB0aGlzLmIxYTAqdGhpcy54XzFfbCArIHRoaXMuYjJhMCp0aGlzLnhfMl9sIC0gdGhpcy5hMWEwKnRoaXMueV8xX2wgLSB0aGlzLmEyYTAqdGhpcy55XzJfbDtcbiAgICAgICAgdGhpcy55XzJfbCA9IHRoaXMueV8xX2w7XG4gICAgICAgIHRoaXMueV8xX2wgPSBvdXRwdXRbaV07XG4gICAgICAgIHRoaXMueF8yX2wgPSB0aGlzLnhfMV9sO1xuICAgICAgICB0aGlzLnhfMV9sID0gYnVmZmVyW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIHRoaXMucHJvY2Vzc1N0ZXJlbyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgLy95W25dID0gKGIwL2EwKSp4W25dICsgKGIxL2EwKSp4W24tMV0gKyAoYjIvYTApKnhbbi0yXVxuICAgICAgLy8gICAgICAgLSAoYTEvYTApKnlbbi0xXSAtIChhMi9hMCkqeVtuLTJdXG5cbiAgICAgIHZhciBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgICAgdmFyIG91dHB1dCA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbi8yOyBpKyspIHtcbiAgICAgICAgb3V0cHV0WzIqaV0gPSB0aGlzLmIwYTAqYnVmZmVyWzIqaV0gKyB0aGlzLmIxYTAqdGhpcy54XzFfbCArIHRoaXMuYjJhMCp0aGlzLnhfMl9sIC0gdGhpcy5hMWEwKnRoaXMueV8xX2wgLSB0aGlzLmEyYTAqdGhpcy55XzJfbDtcbiAgICAgICAgdGhpcy55XzJfbCA9IHRoaXMueV8xX2w7XG4gICAgICAgIHRoaXMueV8xX2wgPSBvdXRwdXRbMippXTtcbiAgICAgICAgdGhpcy54XzJfbCA9IHRoaXMueF8xX2w7XG4gICAgICAgIHRoaXMueF8xX2wgPSBidWZmZXJbMippXTtcblxuICAgICAgICBvdXRwdXRbMippKzFdID0gdGhpcy5iMGEwKmJ1ZmZlclsyKmkrMV0gKyB0aGlzLmIxYTAqdGhpcy54XzFfciArIHRoaXMuYjJhMCp0aGlzLnhfMl9yIC0gdGhpcy5hMWEwKnRoaXMueV8xX3IgLSB0aGlzLmEyYTAqdGhpcy55XzJfcjtcbiAgICAgICAgdGhpcy55XzJfciA9IHRoaXMueV8xX3I7XG4gICAgICAgIHRoaXMueV8xX3IgPSBvdXRwdXRbMippKzFdO1xuICAgICAgICB0aGlzLnhfMl9yID0gdGhpcy54XzFfcjtcbiAgICAgICAgdGhpcy54XzFfciA9IGJ1ZmZlclsyKmkrMV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG5cbi8qIFxuICogIE1hZ25pdHVkZSB0byBkZWNpYmVsc1xuICogXG4gKiAgQ3JlYXRlZCBieSBSaWNhcmQgTWFyeGVyIDxlbWFpbEByaWNhcmRtYXJ4ZXIuY29tPiBvbiAyMDEwLTA1LTIzLlxuICogIENvcHlyaWdodCAyMDEwIFJpY2FyZCBNYXJ4ZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIEBidWZmZXIgYXJyYXkgb2YgbWFnbml0dWRlcyB0byBjb252ZXJ0IHRvIGRlY2liZWxzXG4gKlxuICogIEByZXR1cm5zIHRoZSBhcnJheSBpbiBkZWNpYmVsc1xuICpcbiAqL1xuRFNQLm1hZzJkYiA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgbWluRGIgPSAtMTIwO1xuICB2YXIgbWluTWFnID0gTWF0aC5wb3coMTAuMCwgbWluRGIgLyAyMC4wKTtcblxuICB2YXIgbG9nID0gTWF0aC5sb2c7XG4gIHZhciBtYXggPSBNYXRoLm1heDtcbiBcbiAgdmFyIHJlc3VsdCA9IEZsb2F0MzJBcnJheShidWZmZXIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaT0wOyBpPGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IDIwLjAqbG9nKG1heChidWZmZXJbaV0sIG1pbk1hZykpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qIFxuICogIEZyZXF1ZW5jeSByZXNwb25zZVxuICogXG4gKiAgQ3JlYXRlZCBieSBSaWNhcmQgTWFyeGVyIDxlbWFpbEByaWNhcmRtYXJ4ZXIuY29tPiBvbiAyMDEwLTA1LTIzLlxuICogIENvcHlyaWdodCAyMDEwIFJpY2FyZCBNYXJ4ZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogIENhbGN1bGF0ZXMgdGhlIGZyZXF1ZW5jeSByZXNwb25zZSBhdCB0aGUgZ2l2ZW4gcG9pbnRzLlxuICpcbiAqICBAYiBiIGNvZWZmaWNpZW50cyBvZiB0aGUgZmlsdGVyXG4gKiAgQGEgYSBjb2VmZmljaWVudHMgb2YgdGhlIGZpbHRlclxuICogIEB3IHcgcG9pbnRzIChub3JtYWxseSBiZXR3ZWVuIC1QSSBhbmQgUEkpIHdoZXJlIHRvIGNhbGN1bGF0ZSB0aGUgZnJlcXVlbmN5IHJlc3BvbnNlXG4gKlxuICogIEByZXR1cm5zIHRoZSBmcmVxdWVuY3kgcmVzcG9uc2UgaW4gbWFnbml0dWRlXG4gKlxuICovXG5EU1AuZnJlcXogPSBmdW5jdGlvbihiLCBhLCB3KSB7XG4gIHZhciBpLCBqO1xuXG4gIGlmICghdykge1xuICAgIHcgPSBGbG9hdDMyQXJyYXkoMjAwKTtcbiAgICBmb3IgKGk9MDtpPHcubGVuZ3RoOyBpKyspIHtcbiAgICAgIHdbaV0gPSBEU1AuVFdPX1BJL3cubGVuZ3RoICogaSAtIE1hdGguUEk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9IEZsb2F0MzJBcnJheSh3Lmxlbmd0aCk7XG4gXG4gIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICB2YXIgY29zID0gTWF0aC5jb3M7XG4gIHZhciBzaW4gPSBNYXRoLnNpbjtcbiBcbiAgZm9yIChpPTA7IGk8dy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBudW1lcmF0b3IgPSB7cmVhbDowLjAsIGltYWc6MC4wfTtcbiAgICBmb3IgKGo9MDsgajxiLmxlbmd0aDsgaisrKSB7XG4gICAgICBudW1lcmF0b3IucmVhbCArPSBiW2pdICogY29zKC1qKndbaV0pO1xuICAgICAgbnVtZXJhdG9yLmltYWcgKz0gYltqXSAqIHNpbigtaip3W2ldKTtcbiAgICB9XG5cbiAgICB2YXIgZGVub21pbmF0b3IgPSB7cmVhbDowLjAsIGltYWc6MC4wfTtcbiAgICBmb3IgKGo9MDsgajxhLmxlbmd0aDsgaisrKSB7XG4gICAgICBkZW5vbWluYXRvci5yZWFsICs9IGFbal0gKiBjb3MoLWoqd1tpXSk7XG4gICAgICBkZW5vbWluYXRvci5pbWFnICs9IGFbal0gKiBzaW4oLWoqd1tpXSk7XG4gICAgfVxuIFxuICAgIHJlc3VsdFtpXSA9ICBzcXJ0KG51bWVyYXRvci5yZWFsKm51bWVyYXRvci5yZWFsICsgbnVtZXJhdG9yLmltYWcqbnVtZXJhdG9yLmltYWcpIC8gc3FydChkZW5vbWluYXRvci5yZWFsKmRlbm9taW5hdG9yLnJlYWwgKyBkZW5vbWluYXRvci5pbWFnKmRlbm9taW5hdG9yLmltYWcpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qIFxuICogIEdyYXBoaWNhbCBFcXVhbGl6ZXJcbiAqXG4gKiAgSW1wbGVtZW50YXRpb24gb2YgYSBncmFwaGljIGVxdWFsaXplciB3aXRoIGEgY29uZmlndXJhYmxlIGJhbmRzLXBlci1vY3RhdmVcbiAqICBhbmQgbWluaW11bSBhbmQgbWF4aW11bSBmcmVxdWVuY2llc1xuICogXG4gKiAgQ3JlYXRlZCBieSBSaWNhcmQgTWFyeGVyIDxlbWFpbEByaWNhcmRtYXJ4ZXIuY29tPiBvbiAyMDEwLTA1LTIzLlxuICogIENvcHlyaWdodCAyMDEwIFJpY2FyZCBNYXJ4ZXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICovXG5mdW5jdGlvbiBHcmFwaGljYWxFcShzYW1wbGVSYXRlKSB7XG4gIHRoaXMuRlMgPSBzYW1wbGVSYXRlO1xuICB0aGlzLm1pbkZyZXEgPSA0MC4wO1xuICB0aGlzLm1heEZyZXEgPSAxNjAwMC4wO1xuXG4gIHRoaXMuYmFuZHNQZXJPY3RhdmUgPSAxLjA7XG5cbiAgdGhpcy5maWx0ZXJzID0gW107XG4gIHRoaXMuZnJlcXpzID0gW107XG5cbiAgdGhpcy5jYWxjdWxhdGVGcmVxenMgPSB0cnVlO1xuXG4gIHRoaXMucmVjYWxjdWxhdGVGaWx0ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJhbmRDb3VudCA9IE1hdGgucm91bmQoTWF0aC5sb2codGhpcy5tYXhGcmVxL3RoaXMubWluRnJlcSkgKiB0aGlzLmJhbmRzUGVyT2N0YXZlLyBNYXRoLkxOMik7XG5cbiAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpPTA7IGk8YmFuZENvdW50OyBpKyspIHtcbiAgICAgIHZhciBmcmVxID0gdGhpcy5taW5GcmVxKihNYXRoLnBvdygyLCBpL3RoaXMuYmFuZHNQZXJPY3RhdmUpKTtcbiAgICAgIHZhciBuZXdGaWx0ZXIgPSBuZXcgQmlxdWFkKERTUC5QRUFLSU5HX0VRLCB0aGlzLkZTKTtcbiAgICAgIG5ld0ZpbHRlci5zZXREYkdhaW4oMCk7XG4gICAgICBuZXdGaWx0ZXIuc2V0QlcoMS90aGlzLmJhbmRzUGVyT2N0YXZlKTtcbiAgICAgIG5ld0ZpbHRlci5zZXRGMChmcmVxKTtcbiAgICAgIHRoaXMuZmlsdGVyc1tpXSA9IG5ld0ZpbHRlcjtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVGcmVxeihpKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5zZXRNaW5pbXVtRnJlcXVlbmN5ID0gZnVuY3Rpb24oZnJlcSkge1xuICAgIHRoaXMubWluRnJlcSA9IGZyZXE7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUZpbHRlcnMoKTtcbiAgfTtcblxuICB0aGlzLnNldE1heGltdW1GcmVxdWVuY3kgPSBmdW5jdGlvbihmcmVxKSB7XG4gICAgdGhpcy5tYXhGcmVxID0gZnJlcTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlRmlsdGVycygpO1xuICB9O1xuXG4gIHRoaXMuc2V0QmFuZHNQZXJPY3RhdmUgPSBmdW5jdGlvbihiYW5kcykge1xuICAgIHRoaXMuYmFuZHNQZXJPY3RhdmUgPSBiYW5kcztcbiAgICB0aGlzLnJlY2FsY3VsYXRlRmlsdGVycygpO1xuICB9O1xuXG4gIHRoaXMuc2V0QmFuZEdhaW4gPSBmdW5jdGlvbihiYW5kSW5kZXgsIGdhaW4pIHtcbiAgICBpZiAoYmFuZEluZGV4IDwgMCB8fCBiYW5kSW5kZXggPiAodGhpcy5maWx0ZXJzLmxlbmd0aC0xKSkge1xuICAgICAgdGhyb3cgXCJUaGUgYmFuZCBpbmRleCBvZiB0aGUgZ3JhcGhpY2FsIGVxdWFsaXplciBpcyBvdXQgb2YgYm91bmRzLlwiO1xuICAgIH1cblxuICAgIGlmICghZ2Fpbikge1xuICAgICAgdGhyb3cgXCJBIGdhaW4gbXVzdCBiZSBwYXNzZWQuXCI7XG4gICAgfVxuICAgXG4gICAgdGhpcy5maWx0ZXJzW2JhbmRJbmRleF0uc2V0RGJHYWluKGdhaW4pO1xuICAgIHRoaXMucmVjYWxjdWxhdGVGcmVxeihiYW5kSW5kZXgpO1xuICB9O1xuIFxuICB0aGlzLnJlY2FsY3VsYXRlRnJlcXogPSBmdW5jdGlvbihiYW5kSW5kZXgpIHtcbiAgICBpZiAoIXRoaXMuY2FsY3VsYXRlRnJlcXpzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGJhbmRJbmRleCA8IDAgfHwgYmFuZEluZGV4ID4gKHRoaXMuZmlsdGVycy5sZW5ndGgtMSkpIHtcbiAgICAgIHRocm93IFwiVGhlIGJhbmQgaW5kZXggb2YgdGhlIGdyYXBoaWNhbCBlcXVhbGl6ZXIgaXMgb3V0IG9mIGJvdW5kcy4gXCIgKyBiYW5kSW5kZXggKyBcIiBpcyBvdXQgb2YgW1wiICsgMCArIFwiLCBcIiArIHRoaXMuZmlsdGVycy5sZW5ndGgtMSArIFwiXVwiO1xuICAgIH1cbiAgICAgICBcbiAgICBpZiAoIXRoaXMudykge1xuICAgICAgdGhpcy53ID0gRmxvYXQzMkFycmF5KDQwMCk7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy53Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICB0aGlzLndbaV0gPSBNYXRoLlBJL3RoaXMudy5sZW5ndGggKiBpO1xuICAgICAgfVxuICAgIH1cbiAgIFxuICAgIHZhciBiID0gW3RoaXMuZmlsdGVyc1tiYW5kSW5kZXhdLmIwLCB0aGlzLmZpbHRlcnNbYmFuZEluZGV4XS5iMSwgdGhpcy5maWx0ZXJzW2JhbmRJbmRleF0uYjJdO1xuICAgIHZhciBhID0gW3RoaXMuZmlsdGVyc1tiYW5kSW5kZXhdLmEwLCB0aGlzLmZpbHRlcnNbYmFuZEluZGV4XS5hMSwgdGhpcy5maWx0ZXJzW2JhbmRJbmRleF0uYTJdO1xuXG4gICAgdGhpcy5mcmVxenNbYmFuZEluZGV4XSA9IERTUC5tYWcyZGIoRFNQLmZyZXF6KGIsIGEsIHRoaXMudykpO1xuICB9O1xuXG4gIHRoaXMucHJvY2VzcyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIHZhciBvdXRwdXQgPSBidWZmZXI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0ID0gdGhpcy5maWx0ZXJzW2ldLnByb2Nlc3Mob3V0cHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIHRoaXMucHJvY2Vzc1N0ZXJlbyA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgIHZhciBvdXRwdXQgPSBidWZmZXI7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0ID0gdGhpcy5maWx0ZXJzW2ldLnByb2Nlc3NTdGVyZW8ob3V0cHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufVxuXG4vKipcbiAqIE11bHRpRGVsYXkgZWZmZWN0IGJ5IEFsbWVyIFRoaWUgKGh0dHA6Ly9jb2RlLmFsbWVyb3MuY29tKS5cbiAqIENvcHlyaWdodCAyMDEwIEFsbWVyIFRoaWUuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBFeGFtcGxlOiBodHRwOi8vY29kZS5hbG1lcm9zLmNvbS9jb2RlLWV4YW1wbGVzL2RlbGF5LWZpcmVmb3gtYXVkaW8tYXBpL1xuICpcbiAqIFRoaXMgaXMgYSBkZWxheSB0aGF0IGZlZWRzIGl0J3Mgb3duIGRlbGF5ZWQgc2lnbmFsIGJhY2sgaW50byBpdHMgY2lyY3VsYXJcbiAqIGJ1ZmZlci4gQWxzbyBrbm93biBhcyBhIENvbWJGaWx0ZXIuXG4gKlxuICogQ29tcGF0aWJsZSB3aXRoIGludGVybGVhdmVkIHN0ZXJlbyAob3IgbW9yZSBjaGFubmVsKSBidWZmZXJzIGFuZFxuICogbm9uLWludGVybGVhdmVkIG1vbm8gYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RGVsYXlJblNhbXBsZXNTaXplIE1heGltdW0gcG9zc2libGUgZGVsYXkgaW4gc2FtcGxlcyAoc2l6ZSBvZiBjaXJjdWxhciBidWZmZXIpXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlJblNhbXBsZXMgSW5pdGlhbCBkZWxheSBpbiBzYW1wbGVzXG4gKiBAcGFyYW0ge051bWJlcn0gbWFzdGVyVm9sdW1lIEluaXRpYWwgbWFzdGVyIHZvbHVtZS4gRmxvYXQgdmFsdWU6IDAuMCAoc2lsZW5jZSksIDEuMCAobm9ybWFsKSwgPjEuMCAoYW1wbGlmeSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVZvbHVtZSBJbml0aWFsIGZlZWRiYWNrIGRlbGF5IHZvbHVtZS4gRmxvYXQgdmFsdWU6IDAuMCAoc2lsZW5jZSksIDEuMCAobm9ybWFsKSwgPjEuMCAoYW1wbGlmeSlcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gTXVsdGlEZWxheShtYXhEZWxheUluU2FtcGxlc1NpemUsIGRlbGF5SW5TYW1wbGVzLCBtYXN0ZXJWb2x1bWUsIGRlbGF5Vm9sdW1lKSB7XG4gIHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzICAgPSBuZXcgRmxvYXQzMkFycmF5KG1heERlbGF5SW5TYW1wbGVzU2l6ZSk7IC8vIFRoZSBtYXhpbXVtIHNpemUgb2YgZGVsYXlcbiAgdGhpcy5kZWxheUlucHV0UG9pbnRlciAgICAgPSBkZWxheUluU2FtcGxlcztcbiAgdGhpcy5kZWxheU91dHB1dFBvaW50ZXIgICA9IDA7XG4gXG4gIHRoaXMuZGVsYXlJblNhbXBsZXMgICA9IGRlbGF5SW5TYW1wbGVzO1xuICB0aGlzLm1hc3RlclZvbHVtZSAgICAgPSBtYXN0ZXJWb2x1bWU7XG4gIHRoaXMuZGVsYXlWb2x1bWUgICAgID0gZGVsYXlWb2x1bWU7XG59XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBkZWxheSB0aW1lIGluIHNhbXBsZXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5SW5TYW1wbGVzIERlbGF5IGluIHNhbXBsZXNcbiAqL1xuTXVsdGlEZWxheS5wcm90b3R5cGUuc2V0RGVsYXlJblNhbXBsZXMgPSBmdW5jdGlvbiAoZGVsYXlJblNhbXBsZXMpIHtcbiAgdGhpcy5kZWxheUluU2FtcGxlcyA9IGRlbGF5SW5TYW1wbGVzO1xuIFxuICB0aGlzLmRlbGF5SW5wdXRQb2ludGVyID0gdGhpcy5kZWxheU91dHB1dFBvaW50ZXIgKyBkZWxheUluU2FtcGxlcztcblxuICBpZiAodGhpcy5kZWxheUlucHV0UG9pbnRlciA+PSB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlcy5sZW5ndGgtMSkge1xuICAgIHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgPSB0aGlzLmRlbGF5SW5wdXRQb2ludGVyIC0gdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXMubGVuZ3RoOyBcbiAgfVxufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIG1hc3RlciB2b2x1bWUuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1hc3RlclZvbHVtZSBGbG9hdCB2YWx1ZTogMC4wIChzaWxlbmNlKSwgMS4wIChub3JtYWwpLCA+MS4wIChhbXBsaWZ5KVxuICovXG5NdWx0aURlbGF5LnByb3RvdHlwZS5zZXRNYXN0ZXJWb2x1bWUgPSBmdW5jdGlvbihtYXN0ZXJWb2x1bWUpIHtcbiAgdGhpcy5tYXN0ZXJWb2x1bWUgPSBtYXN0ZXJWb2x1bWU7XG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgZGVsYXkgZmVlZGJhY2sgdm9sdW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVZvbHVtZSBGbG9hdCB2YWx1ZTogMC4wIChzaWxlbmNlKSwgMS4wIChub3JtYWwpLCA+MS4wIChhbXBsaWZ5KVxuICovXG5NdWx0aURlbGF5LnByb3RvdHlwZS5zZXREZWxheVZvbHVtZSA9IGZ1bmN0aW9uKGRlbGF5Vm9sdW1lKSB7XG4gIHRoaXMuZGVsYXlWb2x1bWUgPSBkZWxheVZvbHVtZTtcbn07XG5cbi8qKlxuICogUHJvY2VzcyBhIGdpdmVuIGludGVybGVhdmVkIG9yIG1vbm8gbm9uLWludGVybGVhdmVkIGZsb2F0IHZhbHVlIEFycmF5IGFuZCBhZGRzIHRoZSBkZWxheWVkIGF1ZGlvLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNhbXBsZXMgQXJyYXkgY29udGFpbmluZyBGbG9hdCB2YWx1ZXMgb3IgYSBGbG9hdDMyQXJyYXlcbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBGbG9hdDMyQXJyYXkgaW50ZXJsZWF2ZWQgb3IgbW9ubyBub24taW50ZXJsZWF2ZWQgYXMgd2FzIGZlZCB0byB0aGlzIGZ1bmN0aW9uLlxuICovXG5NdWx0aURlbGF5LnByb3RvdHlwZS5wcm9jZXNzID0gZnVuY3Rpb24oc2FtcGxlcykge1xuICAvLyBOQi4gTWFrZSBhIGNvcHkgdG8gcHV0IGluIHRoZSBvdXRwdXQgc2FtcGxlcyB0byByZXR1cm4uXG4gIHZhciBvdXRwdXRTYW1wbGVzID0gbmV3IEZsb2F0MzJBcnJheShzYW1wbGVzLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaT0wOyBpPHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBkZWxheUJ1ZmZlclNhbXBsZXMgY291bGQgY29udGFpbiBpbml0aWFsIE5VTEwncywgcmV0dXJuIHNpbGVuY2UgaW4gdGhhdCBjYXNlXG4gICAgdmFyIGRlbGF5U2FtcGxlID0gKHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzW3RoaXMuZGVsYXlPdXRwdXRQb2ludGVyXSA9PT0gbnVsbCA/IDAuMCA6IHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzW3RoaXMuZGVsYXlPdXRwdXRQb2ludGVyXSk7XG4gICBcbiAgICAvLyBNaXggbm9ybWFsIGF1ZGlvIGRhdGEgd2l0aCBkZWxheWVkIGF1ZGlvXG4gICAgdmFyIHNhbXBsZSA9IChkZWxheVNhbXBsZSAqIHRoaXMuZGVsYXlWb2x1bWUpICsgc2FtcGxlc1tpXTtcbiAgIFxuICAgIC8vIEFkZCBhdWRpbyBkYXRhIHdpdGggdGhlIGRlbGF5IGluIHRoZSBkZWxheSBidWZmZXJcbiAgICB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlc1t0aGlzLmRlbGF5SW5wdXRQb2ludGVyXSA9IHNhbXBsZTtcbiAgIFxuICAgIC8vIFJldHVybiB0aGUgYXVkaW8gd2l0aCBkZWxheSBtaXhcbiAgICBvdXRwdXRTYW1wbGVzW2ldID0gc2FtcGxlICogdGhpcy5tYXN0ZXJWb2x1bWU7XG4gICBcbiAgICAvLyBNYW5hZ2UgY2lyY3VsYWlyIGRlbGF5IGJ1ZmZlciBwb2ludGVyc1xuICAgIHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIrKztcbiAgICBpZiAodGhpcy5kZWxheUlucHV0UG9pbnRlciA+PSB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlcy5sZW5ndGgtMSkge1xuICAgICAgdGhpcy5kZWxheUlucHV0UG9pbnRlciA9IDA7XG4gICAgfVxuICAgICBcbiAgICB0aGlzLmRlbGF5T3V0cHV0UG9pbnRlcisrO1xuICAgIGlmICh0aGlzLmRlbGF5T3V0cHV0UG9pbnRlciA+PSB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlcy5sZW5ndGgtMSkge1xuICAgICAgdGhpcy5kZWxheU91dHB1dFBvaW50ZXIgPSAwOyBcbiAgICB9IFxuICB9XG4gXG4gIHJldHVybiBvdXRwdXRTYW1wbGVzO1xufTtcblxuLyoqXG4gKiBTaW5nbGVEZWxheSBlZmZlY3QgYnkgQWxtZXIgVGhpZSAoaHR0cDovL2NvZGUuYWxtZXJvcy5jb20pLlxuICogQ29weXJpZ2h0IDIwMTAgQWxtZXIgVGhpZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEV4YW1wbGU6IFNlZSB1c2FnZSBpbiBSZXZlcmIgY2xhc3NcbiAqXG4gKiBUaGlzIGlzIGEgZGVsYXkgdGhhdCBkb2VzIE5PVCBmZWVkcyBpdCdzIG93biBkZWxheWVkIHNpZ25hbCBiYWNrIGludG8gaXRzIFxuICogY2lyY3VsYXIgYnVmZmVyLCBuZWl0aGVyIGRvZXMgaXQgcmV0dXJuIHRoZSBvcmlnaW5hbCBzaWduYWwuIEFsc28ga25vd24gYXNcbiAqIGFuIEFsbFBhc3NGaWx0ZXIoPykuXG4gKlxuICogQ29tcGF0aWJsZSB3aXRoIGludGVybGVhdmVkIHN0ZXJlbyAob3IgbW9yZSBjaGFubmVsKSBidWZmZXJzIGFuZFxuICogbm9uLWludGVybGVhdmVkIG1vbm8gYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RGVsYXlJblNhbXBsZXNTaXplIE1heGltdW0gcG9zc2libGUgZGVsYXkgaW4gc2FtcGxlcyAoc2l6ZSBvZiBjaXJjdWxhciBidWZmZXIpXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlJblNhbXBsZXMgSW5pdGlhbCBkZWxheSBpbiBzYW1wbGVzXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlWb2x1bWUgSW5pdGlhbCBmZWVkYmFjayBkZWxheSB2b2x1bWUuIEZsb2F0IHZhbHVlOiAwLjAgKHNpbGVuY2UpLCAxLjAgKG5vcm1hbCksID4xLjAgKGFtcGxpZnkpXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuZnVuY3Rpb24gU2luZ2xlRGVsYXkobWF4RGVsYXlJblNhbXBsZXNTaXplLCBkZWxheUluU2FtcGxlcywgZGVsYXlWb2x1bWUpIHtcbiAgdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXMgPSBuZXcgRmxvYXQzMkFycmF5KG1heERlbGF5SW5TYW1wbGVzU2l6ZSk7IC8vIFRoZSBtYXhpbXVtIHNpemUgb2YgZGVsYXlcbiAgdGhpcy5kZWxheUlucHV0UG9pbnRlciAgPSBkZWxheUluU2FtcGxlcztcbiAgdGhpcy5kZWxheU91dHB1dFBvaW50ZXIgPSAwO1xuIFxuICB0aGlzLmRlbGF5SW5TYW1wbGVzICAgICA9IGRlbGF5SW5TYW1wbGVzO1xuICB0aGlzLmRlbGF5Vm9sdW1lICAgICAgICA9IGRlbGF5Vm9sdW1lO1xufVxuXG4vKipcbiAqIENoYW5nZSB0aGUgZGVsYXkgdGltZSBpbiBzYW1wbGVzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheUluU2FtcGxlcyBEZWxheSBpbiBzYW1wbGVzXG4gKi9cblNpbmdsZURlbGF5LnByb3RvdHlwZS5zZXREZWxheUluU2FtcGxlcyA9IGZ1bmN0aW9uKGRlbGF5SW5TYW1wbGVzKSB7XG4gIHRoaXMuZGVsYXlJblNhbXBsZXMgPSBkZWxheUluU2FtcGxlcztcbiAgdGhpcy5kZWxheUlucHV0UG9pbnRlciA9IHRoaXMuZGVsYXlPdXRwdXRQb2ludGVyICsgZGVsYXlJblNhbXBsZXM7XG5cbiAgaWYgKHRoaXMuZGVsYXlJbnB1dFBvaW50ZXIgPj0gdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXMubGVuZ3RoLTEpIHtcbiAgICB0aGlzLmRlbGF5SW5wdXRQb2ludGVyID0gdGhpcy5kZWxheUlucHV0UG9pbnRlciAtIHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzLmxlbmd0aDsgXG4gIH1cbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSByZXR1cm4gc2lnbmFsIHZvbHVtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlWb2x1bWUgRmxvYXQgdmFsdWU6IDAuMCAoc2lsZW5jZSksIDEuMCAobm9ybWFsKSwgPjEuMCAoYW1wbGlmeSlcbiAqL1xuU2luZ2xlRGVsYXkucHJvdG90eXBlLnNldERlbGF5Vm9sdW1lID0gZnVuY3Rpb24oZGVsYXlWb2x1bWUpIHtcbiAgdGhpcy5kZWxheVZvbHVtZSA9IGRlbGF5Vm9sdW1lO1xufTtcblxuLyoqXG4gKiBQcm9jZXNzIGEgZ2l2ZW4gaW50ZXJsZWF2ZWQgb3IgbW9ubyBub24taW50ZXJsZWF2ZWQgZmxvYXQgdmFsdWUgQXJyYXkgYW5kXG4gKiByZXR1cm5zIHRoZSBkZWxheWVkIGF1ZGlvLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNhbXBsZXMgQXJyYXkgY29udGFpbmluZyBGbG9hdCB2YWx1ZXMgb3IgYSBGbG9hdDMyQXJyYXlcbiAqXG4gKiBAcmV0dXJucyBBIG5ldyBGbG9hdDMyQXJyYXkgaW50ZXJsZWF2ZWQgb3IgbW9ubyBub24taW50ZXJsZWF2ZWQgYXMgd2FzIGZlZCB0byB0aGlzIGZ1bmN0aW9uLlxuICovXG5TaW5nbGVEZWxheS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKHNhbXBsZXMpIHtcbiAgLy8gTkIuIE1ha2UgYSBjb3B5IHRvIHB1dCBpbiB0aGUgb3V0cHV0IHNhbXBsZXMgdG8gcmV0dXJuLlxuICB2YXIgb3V0cHV0U2FtcGxlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2FtcGxlcy5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGk9MDsgaTxzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAvLyBBZGQgYXVkaW8gZGF0YSB3aXRoIHRoZSBkZWxheSBpbiB0aGUgZGVsYXkgYnVmZmVyXG4gICAgdGhpcy5kZWxheUJ1ZmZlclNhbXBsZXNbdGhpcy5kZWxheUlucHV0UG9pbnRlcl0gPSBzYW1wbGVzW2ldO1xuICAgXG4gICAgLy8gZGVsYXlCdWZmZXJTYW1wbGVzIGNvdWxkIGNvbnRhaW4gaW5pdGlhbCBOVUxMJ3MsIHJldHVybiBzaWxlbmNlIGluIHRoYXQgY2FzZVxuICAgIHZhciBkZWxheVNhbXBsZSA9IHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzW3RoaXMuZGVsYXlPdXRwdXRQb2ludGVyXTtcblxuICAgIC8vIFJldHVybiB0aGUgYXVkaW8gd2l0aCBkZWxheSBtaXhcbiAgICBvdXRwdXRTYW1wbGVzW2ldID0gZGVsYXlTYW1wbGUgKiB0aGlzLmRlbGF5Vm9sdW1lO1xuXG4gICAgLy8gTWFuYWdlIGNpcmN1bGFpciBkZWxheSBidWZmZXIgcG9pbnRlcnNcbiAgICB0aGlzLmRlbGF5SW5wdXRQb2ludGVyKys7XG5cbiAgICBpZiAodGhpcy5kZWxheUlucHV0UG9pbnRlciA+PSB0aGlzLmRlbGF5QnVmZmVyU2FtcGxlcy5sZW5ndGgtMSkge1xuICAgICAgdGhpcy5kZWxheUlucHV0UG9pbnRlciA9IDA7XG4gICAgfVxuICAgICBcbiAgICB0aGlzLmRlbGF5T3V0cHV0UG9pbnRlcisrO1xuXG4gICAgaWYgKHRoaXMuZGVsYXlPdXRwdXRQb2ludGVyID49IHRoaXMuZGVsYXlCdWZmZXJTYW1wbGVzLmxlbmd0aC0xKSB7XG4gICAgICB0aGlzLmRlbGF5T3V0cHV0UG9pbnRlciA9IDA7IFxuICAgIH0gXG4gIH1cbiBcbiAgcmV0dXJuIG91dHB1dFNhbXBsZXM7XG59O1xuXG4vKipcbiAqIFJldmVyYiBlZmZlY3QgYnkgQWxtZXIgVGhpZSAoaHR0cDovL2NvZGUuYWxtZXJvcy5jb20pLlxuICogQ29weXJpZ2h0IDIwMTAgQWxtZXIgVGhpZS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEV4YW1wbGU6IGh0dHA6Ly9jb2RlLmFsbWVyb3MuY29tL2NvZGUtZXhhbXBsZXMvcmV2ZXJiLWZpcmVmb3gtYXVkaW8tYXBpL1xuICpcbiAqIFRoaXMgcmV2ZXJiIGNvbnNpc3RzIG9mIDYgU2luZ2xlRGVsYXlzLCA2IE11bHRpRGVsYXlzIGFuZCBhbiBJSVJGaWx0ZXIyXG4gKiBmb3IgZWFjaCBvZiB0aGUgdHdvIHN0ZXJlbyBjaGFubmVscy5cbiAqXG4gKiBDb21wYXRpYmxlIHdpdGggaW50ZXJsZWF2ZWQgc3RlcmVvIGJ1ZmZlcnMgb25seSFcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RGVsYXlJblNhbXBsZXNTaXplIE1heGltdW0gcG9zc2libGUgZGVsYXkgaW4gc2FtcGxlcyAoc2l6ZSBvZiBjaXJjdWxhciBidWZmZXJzKVxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5SW5TYW1wbGVzIEluaXRpYWwgZGVsYXkgaW4gc2FtcGxlcyBmb3IgaW50ZXJuYWwgKFNpbmdsZS9NdWx0aSlkZWxheXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXN0ZXJWb2x1bWUgSW5pdGlhbCBtYXN0ZXIgdm9sdW1lLiBGbG9hdCB2YWx1ZTogMC4wIChzaWxlbmNlKSwgMS4wIChub3JtYWwpLCA+MS4wIChhbXBsaWZ5KVxuICogQHBhcmFtIHtOdW1iZXJ9IG1peFZvbHVtZSBJbml0aWFsIHJldmVyYiBzaWduYWwgbWl4IHZvbHVtZS4gRmxvYXQgdmFsdWU6IDAuMCAoc2lsZW5jZSksIDEuMCAobm9ybWFsKSwgPjEuMCAoYW1wbGlmeSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVZvbHVtZSBJbml0aWFsIGZlZWRiYWNrIGRlbGF5IHZvbHVtZSBmb3IgaW50ZXJuYWwgKFNpbmdsZS9NdWx0aSlkZWxheXMuIEZsb2F0IHZhbHVlOiAwLjAgKHNpbGVuY2UpLCAxLjAgKG5vcm1hbCksID4xLjAgKGFtcGxpZnkpXG4gKiBAcGFyYW0ge051bWJlcn0gZGFtcEZyZXF1ZW5jeSBJbml0aWFsIGxvdyBwYXNzIGZpbHRlciBmcmVxdWVuY3kuIDAgdG8gNDQxMDAgKGRlcGVuZGluZyBvbiB5b3VyIG1heGltdW0gc2FtcGxpbmcgZnJlcXVlbmN5KVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSZXZlcmIobWF4RGVsYXlJblNhbXBsZXNTaXplLCBkZWxheUluU2FtcGxlcywgbWFzdGVyVm9sdW1lLCBtaXhWb2x1bWUsIGRlbGF5Vm9sdW1lLCBkYW1wRnJlcXVlbmN5KSB7XG4gIHRoaXMuZGVsYXlJblNhbXBsZXMgICA9IGRlbGF5SW5TYW1wbGVzO1xuICB0aGlzLm1hc3RlclZvbHVtZSAgICAgPSBtYXN0ZXJWb2x1bWU7XG4gIHRoaXMubWl4Vm9sdW1lICAgICAgID0gbWl4Vm9sdW1lO1xuICB0aGlzLmRlbGF5Vm9sdW1lICAgICA9IGRlbGF5Vm9sdW1lO1xuICB0aGlzLmRhbXBGcmVxdWVuY3kgICAgID0gZGFtcEZyZXF1ZW5jeTtcbiBcbiAgdGhpcy5OUl9PRl9NVUxUSURFTEFZUyA9IDY7XG4gIHRoaXMuTlJfT0ZfU0lOR0xFREVMQVlTID0gNjtcbiBcbiAgdGhpcy5MT1dQQVNTTCA9IG5ldyBJSVJGaWx0ZXIyKERTUC5MT1dQQVNTLCBkYW1wRnJlcXVlbmN5LCAwLCA0NDEwMCk7XG4gIHRoaXMuTE9XUEFTU1IgPSBuZXcgSUlSRmlsdGVyMihEU1AuTE9XUEFTUywgZGFtcEZyZXF1ZW5jeSwgMCwgNDQxMDApO1xuIFxuICB0aGlzLnNpbmdsZURlbGF5cyA9IFtdO1xuICBcbiAgdmFyIGksIGRlbGF5TXVsdGlwbHk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuTlJfT0ZfU0lOR0xFREVMQVlTOyBpKyspIHtcbiAgICBkZWxheU11bHRpcGx5ID0gMS4wICsgKGkvNy4wKTsgLy8gMS4wLCAxLjEsIDEuMi4uLlxuICAgIHRoaXMuc2luZ2xlRGVsYXlzW2ldID0gbmV3IFNpbmdsZURlbGF5KG1heERlbGF5SW5TYW1wbGVzU2l6ZSwgTWF0aC5yb3VuZCh0aGlzLmRlbGF5SW5TYW1wbGVzICogZGVsYXlNdWx0aXBseSksIHRoaXMuZGVsYXlWb2x1bWUpO1xuICB9XG4gXG4gIHRoaXMubXVsdGlEZWxheXMgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5OUl9PRl9NVUxUSURFTEFZUzsgaSsrKSB7XG4gICAgZGVsYXlNdWx0aXBseSA9IDEuMCArIChpLzEwLjApOyAvLyAxLjAsIDEuMSwgMS4yLi4uIFxuICAgIHRoaXMubXVsdGlEZWxheXNbaV0gPSBuZXcgTXVsdGlEZWxheShtYXhEZWxheUluU2FtcGxlc1NpemUsIE1hdGgucm91bmQodGhpcy5kZWxheUluU2FtcGxlcyAqIGRlbGF5TXVsdGlwbHkpLCB0aGlzLm1hc3RlclZvbHVtZSwgdGhpcy5kZWxheVZvbHVtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGFuZ2UgdGhlIGRlbGF5IHRpbWUgaW4gc2FtcGxlcyBhcyBhIGJhc2UgZm9yIGFsbCBkZWxheXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5SW5TYW1wbGVzIERlbGF5IGluIHNhbXBsZXNcbiAqL1xuUmV2ZXJiLnByb3RvdHlwZS5zZXREZWxheUluU2FtcGxlcyA9IGZ1bmN0aW9uIChkZWxheUluU2FtcGxlcyl7XG4gIHRoaXMuZGVsYXlJblNhbXBsZXMgPSBkZWxheUluU2FtcGxlcztcblxuICB2YXIgaSwgZGVsYXlNdWx0aXBseTtcbiBcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuTlJfT0ZfU0lOR0xFREVMQVlTOyBpKyspIHtcbiAgICBkZWxheU11bHRpcGx5ID0gMS4wICsgKGkvNy4wKTsgLy8gMS4wLCAxLjEsIDEuMi4uLlxuICAgIHRoaXMuc2luZ2xlRGVsYXlzW2ldLnNldERlbGF5SW5TYW1wbGVzKCBNYXRoLnJvdW5kKHRoaXMuZGVsYXlJblNhbXBsZXMgKiBkZWxheU11bHRpcGx5KSApO1xuICB9XG4gICBcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuTlJfT0ZfTVVMVElERUxBWVM7IGkrKykge1xuICAgIGRlbGF5TXVsdGlwbHkgPSAxLjAgKyAoaS8xMC4wKTsgLy8gMS4wLCAxLjEsIDEuMi4uLlxuICAgIHRoaXMubXVsdGlEZWxheXNbaV0uc2V0RGVsYXlJblNhbXBsZXMoIE1hdGgucm91bmQodGhpcy5kZWxheUluU2FtcGxlcyAqIGRlbGF5TXVsdGlwbHkpICk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hhbmdlIHRoZSBtYXN0ZXIgdm9sdW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXN0ZXJWb2x1bWUgRmxvYXQgdmFsdWU6IDAuMCAoc2lsZW5jZSksIDEuMCAobm9ybWFsKSwgPjEuMCAoYW1wbGlmeSlcbiAqL1xuUmV2ZXJiLnByb3RvdHlwZS5zZXRNYXN0ZXJWb2x1bWUgPSBmdW5jdGlvbiAobWFzdGVyVm9sdW1lKXtcbiAgdGhpcy5tYXN0ZXJWb2x1bWUgPSBtYXN0ZXJWb2x1bWU7XG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgcmV2ZXJiIHNpZ25hbCBtaXggbGV2ZWwuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1peFZvbHVtZSBGbG9hdCB2YWx1ZTogMC4wIChzaWxlbmNlKSwgMS4wIChub3JtYWwpLCA+MS4wIChhbXBsaWZ5KVxuICovXG5SZXZlcmIucHJvdG90eXBlLnNldE1peFZvbHVtZSA9IGZ1bmN0aW9uIChtaXhWb2x1bWUpe1xuICB0aGlzLm1peFZvbHVtZSA9IG1peFZvbHVtZTtcbn07XG5cbi8qKlxuICogQ2hhbmdlIGFsbCBkZWxheXMgZmVlZGJhY2sgdm9sdW1lLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVZvbHVtZSBGbG9hdCB2YWx1ZTogMC4wIChzaWxlbmNlKSwgMS4wIChub3JtYWwpLCA+MS4wIChhbXBsaWZ5KVxuICovXG5SZXZlcmIucHJvdG90eXBlLnNldERlbGF5Vm9sdW1lID0gZnVuY3Rpb24gKGRlbGF5Vm9sdW1lKXtcbiAgdGhpcy5kZWxheVZvbHVtZSA9IGRlbGF5Vm9sdW1lO1xuIFxuICB2YXIgaTtcblxuICBmb3IgKGkgPSAwOyBpPHRoaXMuTlJfT0ZfU0lOR0xFREVMQVlTOyBpKyspIHtcbiAgICB0aGlzLnNpbmdsZURlbGF5c1tpXS5zZXREZWxheVZvbHVtZSh0aGlzLmRlbGF5Vm9sdW1lKTtcbiAgfSBcbiBcbiAgZm9yIChpID0gMDsgaTx0aGlzLk5SX09GX01VTFRJREVMQVlTOyBpKyspIHtcbiAgICB0aGlzLm11bHRpRGVsYXlzW2ldLnNldERlbGF5Vm9sdW1lKHRoaXMuZGVsYXlWb2x1bWUpO1xuICB9IFxufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIExvdyBQYXNzIGZpbHRlciBmcmVxdWVuY3kuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRhbXBGcmVxdWVuY3kgbG93IHBhc3MgZmlsdGVyIGZyZXF1ZW5jeS4gMCB0byA0NDEwMCAoZGVwZW5kaW5nIG9uIHlvdXIgbWF4aW11bSBzYW1wbGluZyBmcmVxdWVuY3kpXG4gKi9cblJldmVyYi5wcm90b3R5cGUuc2V0RGFtcEZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChkYW1wRnJlcXVlbmN5KXtcbiAgdGhpcy5kYW1wRnJlcXVlbmN5ID0gZGFtcEZyZXF1ZW5jeTtcbiBcbiAgdGhpcy5MT1dQQVNTTC5zZXQoZGFtcEZyZXF1ZW5jeSwgMCk7XG4gIHRoaXMuTE9XUEFTU1Iuc2V0KGRhbXBGcmVxdWVuY3ksIDApOyBcbn07XG5cbi8qKlxuICogUHJvY2VzcyBhIGdpdmVuIGludGVybGVhdmVkIGZsb2F0IHZhbHVlIEFycmF5IGFuZCBjb3BpZXMgYW5kIGFkZHMgdGhlIHJldmVyYiBzaWduYWwuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2FtcGxlcyBBcnJheSBjb250YWluaW5nIEZsb2F0IHZhbHVlcyBvciBhIEZsb2F0MzJBcnJheVxuICpcbiAqIEByZXR1cm5zIEEgbmV3IEZsb2F0MzJBcnJheSBpbnRlcmxlYXZlZCBidWZmZXIuXG4gKi9cblJldmVyYi5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uIChpbnRlcmxlYXZlZFNhbXBsZXMpeyBcbiAgLy8gTkIuIE1ha2UgYSBjb3B5IHRvIHB1dCBpbiB0aGUgb3V0cHV0IHNhbXBsZXMgdG8gcmV0dXJuLlxuICB2YXIgb3V0cHV0U2FtcGxlcyA9IG5ldyBGbG9hdDMyQXJyYXkoaW50ZXJsZWF2ZWRTYW1wbGVzLmxlbmd0aCk7XG4gXG4gIC8vIFBlcmZvcm0gbG93IHBhc3Mgb24gdGhlIGlucHV0IHNhbXBsZXMgdG8gbWltaWNrIGRhbXBcbiAgdmFyIGxlZnRSaWdodE1peCA9IERTUC5kZWludGVybGVhdmUoaW50ZXJsZWF2ZWRTYW1wbGVzKTtcbiAgdGhpcy5MT1dQQVNTTC5wcm9jZXNzKCBsZWZ0UmlnaHRNaXhbRFNQLkxFRlRdICk7XG4gIHRoaXMuTE9XUEFTU1IucHJvY2VzcyggbGVmdFJpZ2h0TWl4W0RTUC5SSUdIVF0gKTsgXG4gIHZhciBmaWx0ZXJlZFNhbXBsZXMgPSBEU1AuaW50ZXJsZWF2ZShsZWZ0UmlnaHRNaXhbRFNQLkxFRlRdLCBsZWZ0UmlnaHRNaXhbRFNQLlJJR0hUXSk7XG5cbiAgdmFyIGk7XG5cbiAgLy8gUHJvY2VzcyBNdWx0aURlbGF5cyBpbiBwYXJhbGxlbFxuICBmb3IgKGkgPSAwOyBpPHRoaXMuTlJfT0ZfTVVMVElERUxBWVM7IGkrKykge1xuICAgIC8vIEludmVydCB0aGUgc2lnbmFsIG9mIGV2ZXJ5IGV2ZW4gbXVsdGlEZWxheVxuICAgIG91dHB1dFNhbXBsZXMgPSBEU1AubWl4U2FtcGxlQnVmZmVycyhvdXRwdXRTYW1wbGVzLCB0aGlzLm11bHRpRGVsYXlzW2ldLnByb2Nlc3MoZmlsdGVyZWRTYW1wbGVzKSwgMiVpID09PSAwLCB0aGlzLk5SX09GX01VTFRJREVMQVlTKTtcbiAgfVxuIFxuICAvLyBQcm9jZXNzIFNpbmdsZURlbGF5cyBpbiBzZXJpZXNcbiAgdmFyIHNpbmdsZURlbGF5U2FtcGxlcyA9IG5ldyBGbG9hdDMyQXJyYXkob3V0cHV0U2FtcGxlcy5sZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBpPHRoaXMuTlJfT0ZfU0lOR0xFREVMQVlTOyBpKyspIHtcbiAgICAvLyBJbnZlcnQgdGhlIHNpZ25hbCBvZiBldmVyeSBldmVuIHNpbmdsZURlbGF5XG4gICAgc2luZ2xlRGVsYXlTYW1wbGVzID0gRFNQLm1peFNhbXBsZUJ1ZmZlcnMoc2luZ2xlRGVsYXlTYW1wbGVzLCB0aGlzLnNpbmdsZURlbGF5c1tpXS5wcm9jZXNzKG91dHB1dFNhbXBsZXMpLCAyJWkgPT09IDAsIDEpO1xuICB9XG5cbiAgLy8gQXBwbHkgdGhlIHZvbHVtZSBvZiB0aGUgcmV2ZXJiIHNpZ25hbFxuICBmb3IgKGkgPSAwOyBpPHNpbmdsZURlbGF5U2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgIHNpbmdsZURlbGF5U2FtcGxlc1tpXSAqPSB0aGlzLm1peFZvbHVtZTtcbiAgfVxuIFxuICAvLyBNaXggdGhlIG9yaWdpbmFsIHNpZ25hbCB3aXRoIHRoZSByZXZlcmIgc2lnbmFsXG4gIG91dHB1dFNhbXBsZXMgPSBEU1AubWl4U2FtcGxlQnVmZmVycyhzaW5nbGVEZWxheVNhbXBsZXMsIGludGVybGVhdmVkU2FtcGxlcywgMCwgMSk7XG5cbiAgLy8gQXBwbHkgdGhlIG1hc3RlciB2b2x1bWUgdG8gdGhlIGNvbXBsZXRlIHNpZ25hbFxuICBmb3IgKGkgPSAwOyBpPG91dHB1dFNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRTYW1wbGVzW2ldICo9IHRoaXMubWFzdGVyVm9sdW1lO1xuICB9XG4gICBcbiAgcmV0dXJuIG91dHB1dFNhbXBsZXM7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEU1A7XG5leHBvcnQgeyBGRlQgYXMgRkZUIH07Iiwid2luZG93Lk1vZHVsZSA9IHt9O1xyXG53aW5kb3cuc2NyaXB0ID0ge307XHJcbndpbmRvdy5kb25lRXZlbnQgPSB7fTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1bHNlRkZUVHJhbnNmb3JtcyB7XHJcblxyXG4gICAgc3RhdGljIGluc3RhbmNlO1xyXG4gICAgc3RhdGljIHB1bHNlO1xyXG4gICAgXHJcbiAgICBjb25zdHJ1Y3Rvcih3aW5TaXplKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgXHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy53aW5TaXplID0gd2luU2l6ZTtcclxuICAgIH1cclxuICAgIGluaXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgZmV0Y2goJ2Fzc2V0cy9wdWxzZS9zcmMvV0FTTWtpc3NGRlQud2FzbScpXHJcbiAgICAgICAgICAgICAgICAudGhlbihjb25zb2xlLmxvZyhcIm1hZGUgaXQgaW50byBsb2FkcHVsc2VcIikpXHJcbiAgICAgICAgICAgICAgICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5hcnJheUJ1ZmZlcigpKVxyXG4gICAgICAgICAgICAgICAgLnRoZW4oY29uc29sZS5sb2coXCJzdGVwIGludG8gbVwiKSlcclxuICAgICAgICAgICAgICAgIC50aGVuKChtKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgTW9kdWxlLndhc21CaW5hcnkgPSBtO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQuc3JjID0gJ2Fzc2V0cy9wdWxzZS9zcmMvd2FzbWtpc3NmZnQuanMnO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb2FkZWQgRW1zY3JpcHRlbi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBkb25lRXZlbnQgPSBuZXcgRXZlbnQoJ2RvbmUnKTtcclxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignZG9uZScsIGJ1aWxkUHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYnVpbGRQdWxzZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHVsc2UgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHB1bHNlWydmZnRDb21wbGV4J10gPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmNmZyA9IF9raXNzX2ZmdF9hbGxvYyhzaXplLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmljZmcgPSBfa2lzc19mZnRfYWxsb2Moc2l6ZSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB0ciA9IF9tYWxsb2Moc2l6ZSAqIDggKyBzaXplICogOCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB0ciA9IHRoaXMuaW5wdHIgKyBzaXplICogODtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNpbiA9IG5ldyBGbG9hdDMyQXJyYXkoSEVBUFU4LmJ1ZmZlciwgdGhpcy5pbnB0ciwgc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3V0ID0gbmV3IEZsb2F0MzJBcnJheShIRUFQVTguYnVmZmVyLCB0aGlzLm91dHB0ciwgc2l6ZSAqIDIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZCA9IGZ1bmN0aW9uIChjaW4pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNpbi5zZXQoY2luKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfa2lzc19mZnQodGhpcy5mY2ZnLCB0aGlzLmlucHRyLCB0aGlzLm91dHB0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoSEVBUFU4LmJ1ZmZlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdHIsIHRoaXMuc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZlcnNlID0gZnVuY3Rpb24gKGNpbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2luLnNldChjaW4pOy8vd2FzIGNweD9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfa2lzc19mZnQodGhpcy5pY2ZnLCB0aGlzLmlucHRyLCB0aGlzLm91dHB0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoSEVBUFU4LmJ1ZmZlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdHIsIHRoaXMuc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mcmVlKHRoaXMuaW5wdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mcmVlKHRoaXMuZmNmZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZyZWUodGhpcy5pY2ZnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHVsc2VbJ2ZmdFJlYWwnXSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mY2ZnID0gX2tpc3NfZmZ0cl9hbGxvYyhzaXplLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmljZmcgPSBfa2lzc19mZnRyX2FsbG9jKHNpemUsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucnB0ciA9IF9tYWxsb2Moc2l6ZSAqIDQgKyAoc2l6ZSArIDIpICogNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNwdHIgPSB0aGlzLnJwdHIgKyBzaXplICogNDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJpID0gbmV3IEZsb2F0MzJBcnJheShIRUFQVTguYnVmZmVyLCB0aGlzLnJwdHIsIHNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaSA9IG5ldyBGbG9hdDMyQXJyYXkoSEVBUFU4LmJ1ZmZlciwgdGhpcy5jcHRyLCBzaXplICsgMik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkID0gZnVuY3Rpb24gKHJlYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJpLnNldChyZWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfa2lzc19mZnRyKHRoaXMuZmNmZywgdGhpcy5ycHRyLCB0aGlzLmNwdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KEhFQVBVOC5idWZmZXIsIHRoaXMuY3B0ciwgdGhpcy5zaXplICsgMik7IC8vY2hhbmdlZCBoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludmVyc2UgPSBmdW5jdGlvbiAoY3B4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaS5zZXQoY3B4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfa2lzc19mZnRyaSh0aGlzLmljZmcsIHRoaXMuY3B0ciwgdGhpcy5ycHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShIRUFQVTguYnVmZmVyLCB0aGlzLnJwdHIsIHRoaXMuc2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZyZWUodGhpcy5ycHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZnJlZSh0aGlzLmZjZmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mcmVlKHRoaXMuaWNmZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHB1bHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICB9KS50aGVuKChwdWxzZSkgPT4geyBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMuX2ZmdFByb2Nlc3NvciA9IG5ldyBwdWxzZS5mZnRSZWFsKHRoaXMud2luU2l6ZSlcclxuICAgICAgICAgICAgdGhpcy5faWZmdFByb2Nlc3NvciA9IG5ldyBwdWxzZS5mZnRDb21wbGV4KHRoaXMud2luU2l6ZSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgdGhpcy5TVEZUID0gIChpbnB1dEZyYW1lLCB3aW5kb3dGcmFtZSwgd2FudGVkU2l6ZSwgb3V0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2luU2l6ZSA9IHdpbmRvd0ZyYW1lLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBfaW5wdXRGcmFtZSA9IG5ldyBBcnJheSh3aW5TaXplKTtcclxuICAgICAgICAgICAgICAgIHZhciBmZnRGcmFtZSA9IG5ldyBBcnJheSgyICogd2luU2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aW5TaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBfaW5wdXRGcmFtZVtpXSA9IGlucHV0RnJhbWVbaV0gKiB3aW5kb3dGcmFtZVtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZmdEZyYW1lID0gdGhpcy5fZmZ0UHJvY2Vzc29yLmZvcndhcmQoX2lucHV0RnJhbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgd2luU2l6ZSAmJiBwIDwgd2FudGVkU2l6ZTsgcCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlYWwgPSBvdXQucmVhbDsgdmFyIGltYWcgPSBvdXQuaW1hZztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGhhc2UgPSBvdXQucGhhc2U7IHZhciBtYWduaXR1ZGUgPSBvdXQubWFnbml0dWRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlYWxbcF0gPSBmZnRGcmFtZVsyICogcF07XHJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ1twXSA9IGZmdEZyYW1lWzIgKiBwICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgbWFnbml0dWRlW3BdID0gTWF0aC5zcXJ0KGltYWdbcF0gKiBpbWFnW3BdICsgcmVhbFtwXSAqIHJlYWxbcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBoYXNlW3BdID0gTWF0aC5hdGFuMihpbWFnW3BdLCByZWFsW3BdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuU1RGVHYyID0gIChpbnB1dEZyYW1lLCB3aW5kb3dGcmFtZSwgd2FudGVkU2l6ZSwgb3V0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgd2luU2l6ZSA9IHdpbmRvd0ZyYW1lLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHZhciBfaW5wdXRGcmFtZSA9IG5ldyBBcnJheSh3aW5TaXplKTtcclxuICAgICAgICAgICAgICAgIHZhciBmZnRGcmFtZSA9IG5ldyBBcnJheSgyICogd2luU2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aW5TaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBfaW5wdXRGcmFtZVtpXSA9IGlucHV0RnJhbWVbaV0gKiB3aW5kb3dGcmFtZVtpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmZnRGcmFtZSA9IHRoaXMuX2ZmdFByb2Nlc3Nvci5mb3J3YXJkKF9pbnB1dEZyYW1lKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IHdpblNpemUgJiYgcCA8IHdhbnRlZFNpemU7IHArKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFsID0gb3V0LnJlYWw7IHZhciBpbWFnID0gb3V0LmltYWc7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhbFtwXSA9IGZmdEZyYW1lWzIgKiBwXTtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnW3BdID0gZmZ0RnJhbWVbMiAqIHAgKyAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuSVNURlQgPSAgKHJlYWwsIGltYWdpbmFyeSwgd2luZG93RnJhbWUsIHJlc3RvcmVFbmVyZ3ksIG91dHB1dDIpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnB1dCA9IG5ldyBBcnJheSgyICogcmVhbC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dDEgPSBuZXcgQXJyYXkoMiAqIHJlYWwubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlYWwubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dFsyICogaV0gPSByZWFsW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0WzIgKiBpICsgMV0gPSBpbWFnaW5hcnlbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgb3V0cHV0MSA9IHRoaXMuX2lmZnRQcm9jZXNzb3IuaW52ZXJzZShpbnB1dCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3RvcmVFbmVyZ3kpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5lcmd5MSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVuZXJneTIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlcHMgPSAyLjIyMDRlLTE2O1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2luZG93RnJhbWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5lcmd5MSArPSBNYXRoLmFicyhvdXRwdXQxWzIgKiBpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDJbaV0gPSBvdXRwdXQxWzIgKiBpXSAvIHdpbmRvd0ZyYW1lLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0MltpXSAqPSB3aW5kb3dGcmFtZVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZW5lcmd5MiArPSBNYXRoLmFicyhvdXRwdXQxWzIgKiBpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDJbaV0gKj0gZW5lcmd5MSAvIChlbmVyZ3kyICsgZXBzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdpbmRvd0ZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aW5kb3dGcmFtZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQyW2ldID0gb3V0cHV0MVsyICogaV0gLyB3aW5kb3dGcmFtZS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDJbaV0gKj0gd2luZG93RnJhbWVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlYWwubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0MltpXSA9IG91dHB1dDFbMiAqIGldIC8gcmVhbC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2NyZWF0ZVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnRpZXNcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eVwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3Byb21pc2VcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc2V0XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07IiwibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbFwiKSwgX19lc01vZHVsZTogdHJ1ZSB9OyIsIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vd2Vhay1tYXBcIiksIF9fZXNNb2R1bGU6IHRydWUgfTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nZXRQcm90b3R5cGVPZik7XG5cbnZhciBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvclwiKTtcblxudmFyIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gIGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbiAgdmFyIGRlc2MgPSAoMCwgX2dldE93blByb3BlcnR5RGVzY3JpcHRvcjIuZGVmYXVsdCkob2JqZWN0LCBwcm9wZXJ0eSk7XG5cbiAgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBwYXJlbnQgPSAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShvYmplY3QpO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7XG4gICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGdldHRlciA9IGRlc2MuZ2V0O1xuXG4gICAgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7XG4gIH1cbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0ID8gKDAsIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdHlwZW9mMiA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL3R5cGVvZlwiKTtcblxudmFyIF90eXBlb2YzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdHlwZW9mMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogKDAsIF90eXBlb2YzLmRlZmF1bHQpKGNhbGwpKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sXCIpO1xuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTsiLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yJyk7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7XG52YXIgJE9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZShQLCBEKSB7XG4gIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTtcbn07XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhULCBEKSB7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVCwgRCk7XG59O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgcmV0dXJuICRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpO1xufTtcbiIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LnNldFByb3RvdHlwZU9mO1xuIiwicmVxdWlyZSgnLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnByb21pc2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LnByb21pc2UuZmluYWxseScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcucHJvbWlzZS50cnknKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9fY29yZScpLlByb21pc2U7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYuc2V0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQudG8tanNvbicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczcuc2V0Lm9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy5zZXQuZnJvbScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL19jb3JlJykuU2V0O1xuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5TeW1ib2w7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lczYud2Vhay1tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM3LndlYWstbWFwLm9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNy53ZWFrLW1hcC5mcm9tJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvX2NvcmUnKS5XZWFrTWFwO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUsIGZvcmJpZGRlbkZpZWxkKSB7XG4gIGlmICghKGl0IGluc3RhbmNlb2YgQ29uc3RydWN0b3IpIHx8IChmb3JiaWRkZW5GaWVsZCAhPT0gdW5kZWZpbmVkICYmIGZvcmJpZGRlbkZpZWxkIGluIGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihuYW1lICsgJzogaW5jb3JyZWN0IGludm9jYXRpb24hJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBmb3JPZiA9IHJlcXVpcmUoJy4vX2Zvci1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyLCBJVEVSQVRPUikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvck9mKGl0ZXIsIGZhbHNlLCByZXN1bHQucHVzaCwgcmVzdWx0LCBJVEVSQVRPUik7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLy8gZmFsc2UgLT4gQXJyYXkjaW5kZXhPZlxuLy8gdHJ1ZSAgLT4gQXJyYXkjaW5jbHVkZXNcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuL190by1sZW5ndGgnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuL190by1hYnNvbHV0ZS1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pIHtcbiAgICAgIGlmIChPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG4iLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgYXNjID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsICRjcmVhdGUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICB2YXIgY3JlYXRlID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgc2VsZiA9IElPYmplY3QoTyk7XG4gICAgdmFyIGYgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkO1xuICAgIHZhciB2YWwsIHJlcztcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykgaWYgKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpIHtcbiAgICAgIHZhbCA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzID0gZih2YWwsIGluZGV4LCBPKTtcbiAgICAgIGlmIChUWVBFKSB7XG4gICAgICAgIGlmIChJU19NQVApIHJlc3VsdFtpbmRleF0gPSByZXM7ICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlcykgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgIC8vIGZpbmRcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBpbmRleDsgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmIChJU19FVkVSWSkgcmV0dXJuIGZhbHNlOyAvLyBldmVyeVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogcmVzdWx0O1xuICB9O1xufTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIFNQRUNJRVMgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgQztcbiAgaWYgKGlzQXJyYXkob3JpZ2luYWwpKSB7XG4gICAgQyA9IG9yaWdpbmFsLmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNPYmplY3QoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYgKEMgPT09IG51bGwpIEMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IHJldHVybiBDID09PSB1bmRlZmluZWQgPyBBcnJheSA6IEM7XG59O1xuIiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWwsIGxlbmd0aCkge1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTtcbiIsIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciAkaXRlckRlZmluZSA9IHJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuL19zZXQtc3BlY2llcycpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi9fbWV0YScpLmZhc3RLZXk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0laRSA9IERFU0NSSVBUT1JTID8gJ19zJyA6ICdzaXplJztcblxudmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAvLyBmYXN0IGNhc2VcbiAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICB2YXIgZW50cnk7XG4gIGlmIChpbmRleCAhPT0gJ0YnKSByZXR1cm4gdGhhdC5faVtpbmRleF07XG4gIC8vIGZyb3plbiBvYmplY3QgY2FzZVxuICBmb3IgKGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgIGlmIChlbnRyeS5rID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBOQU1FLCAnX2knKTtcbiAgICAgIHRoYXQuX3QgPSBOQU1FOyAgICAgICAgIC8vIGNvbGxlY3Rpb24gdHlwZVxuICAgICAgdGhhdC5faSA9IGNyZWF0ZShudWxsKTsgLy8gaW5kZXhcbiAgICAgIHRoYXQuX2YgPSB1bmRlZmluZWQ7ICAgIC8vIGZpcnN0IGVudHJ5XG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAgICAvLyBsYXN0IGVudHJ5XG4gICAgICB0aGF0W1NJWkVdID0gMDsgICAgICAgICAvLyBzaXplXG4gICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBmb3JPZihpdGVyYWJsZSwgSVNfTUFQLCB0aGF0W0FEREVSXSwgdGhhdCk7XG4gICAgfSk7XG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjEuMy4xIE1hcC5wcm90b3R5cGUuY2xlYXIoKVxuICAgICAgLy8gMjMuMi4zLjIgU2V0LnByb3RvdHlwZS5jbGVhcigpXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIGZvciAodmFyIHRoYXQgPSB2YWxpZGF0ZSh0aGlzLCBOQU1FKSwgZGF0YSA9IHRoYXQuX2ksIGVudHJ5ID0gdGhhdC5fZjsgZW50cnk7IGVudHJ5ID0gZW50cnkubikge1xuICAgICAgICAgIGVudHJ5LnIgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wKSBlbnRyeS5wID0gZW50cnkucC5uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmldO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX2YgPSB0aGF0Ll9sID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGF0W1NJWkVdID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gZW50cnkubjtcbiAgICAgICAgICB2YXIgcHJldiA9IGVudHJ5LnA7XG4gICAgICAgICAgZGVsZXRlIHRoYXQuX2lbZW50cnkuaV07XG4gICAgICAgICAgZW50cnkuciA9IHRydWU7XG4gICAgICAgICAgaWYgKHByZXYpIHByZXYubiA9IG5leHQ7XG4gICAgICAgICAgaWYgKG5leHQpIG5leHQucCA9IHByZXY7XG4gICAgICAgICAgaWYgKHRoYXQuX2YgPT0gZW50cnkpIHRoYXQuX2YgPSBuZXh0O1xuICAgICAgICAgIGlmICh0aGF0Ll9sID09IGVudHJ5KSB0aGF0Ll9sID0gcHJldjtcbiAgICAgICAgICB0aGF0W1NJWkVdLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFsaWRhdGUodGhpcywgTkFNRSk7XG4gICAgICAgIHZhciBmID0gY3R4KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGlzLl9mKSB7XG4gICAgICAgICAgZihlbnRyeS52LCBlbnRyeS5rLCB0aGlzKTtcbiAgICAgICAgICAvLyByZXZlcnQgdG8gdGhlIGxhc3QgZXhpc3RpbmcgZW50cnlcbiAgICAgICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucikgZW50cnkgPSBlbnRyeS5wO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjcgTWFwLnByb3RvdHlwZS5oYXMoa2V5KVxuICAgICAgLy8gMjMuMi4zLjcgU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodmFsaWRhdGUodGhpcywgTkFNRSksIGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkUChDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHRoaXMsIE5BTUUpW1NJWkVdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICB2YXIgcHJldiwgaW5kZXg7XG4gICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52ID0gdmFsdWU7XG4gICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGF0Ll9sID0gZW50cnkgPSB7XG4gICAgICAgIGk6IGluZGV4ID0gZmFzdEtleShrZXksIHRydWUpLCAvLyA8LSBpbmRleFxuICAgICAgICBrOiBrZXksICAgICAgICAgICAgICAgICAgICAgICAgLy8gPC0ga2V5XG4gICAgICAgIHY6IHZhbHVlLCAgICAgICAgICAgICAgICAgICAgICAvLyA8LSB2YWx1ZVxuICAgICAgICBwOiBwcmV2ID0gdGhhdC5fbCwgICAgICAgICAgICAgLy8gPC0gcHJldmlvdXMgZW50cnlcbiAgICAgICAgbjogdW5kZWZpbmVkLCAgICAgICAgICAgICAgICAgIC8vIDwtIG5leHQgZW50cnlcbiAgICAgICAgcjogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgIC8vIDwtIHJlbW92ZWRcbiAgICAgIH07XG4gICAgICBpZiAoIXRoYXQuX2YpIHRoYXQuX2YgPSBlbnRyeTtcbiAgICAgIGlmIChwcmV2KSBwcmV2Lm4gPSBlbnRyeTtcbiAgICAgIHRoYXRbU0laRV0rKztcbiAgICAgIC8vIGFkZCB0byBpbmRleFxuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHRoYXQuX2lbaW5kZXhdID0gZW50cnk7XG4gICAgfSByZXR1cm4gdGhhdDtcbiAgfSxcbiAgZ2V0RW50cnk6IGdldEVudHJ5LFxuICBzZXRTdHJvbmc6IGZ1bmN0aW9uIChDLCBOQU1FLCBJU19NQVApIHtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgJGl0ZXJEZWZpbmUoQywgTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICB0aGlzLl90ID0gdmFsaWRhdGUoaXRlcmF0ZWQsIE5BTUUpOyAvLyB0YXJnZXRcbiAgICAgIHRoaXMuX2sgPSBraW5kOyAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgICAgIHRoaXMuX2wgPSB1bmRlZmluZWQ7ICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdmFyIGtpbmQgPSB0aGF0Ll9rO1xuICAgICAgdmFyIGVudHJ5ID0gdGhhdC5fbDtcbiAgICAgIC8vIHJldmVydCB0byB0aGUgbGFzdCBleGlzdGluZyBlbnRyeVxuICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnIpIGVudHJ5ID0gZW50cnkucDtcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXRoYXQuX3QgfHwgISh0aGF0Ll9sID0gZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm4gOiB0aGF0Ll90Ll9mKSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICB0aGF0Ll90ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc3RlcCgxKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkuayk7XG4gICAgICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgZW50cnkudik7XG4gICAgICByZXR1cm4gc3RlcCgwLCBbZW50cnkuaywgZW50cnkudl0pO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhOQU1FKTtcbiAgfVxufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9EYXZpZEJydWFudC9NYXAtU2V0LnByb3RvdHlwZS50b0pTT05cbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIGZyb20gPSByZXF1aXJlKCcuL19hcnJheS1mcm9tLWl0ZXJhYmxlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FKSB7XG4gIHJldHVybiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgaWYgKGNsYXNzb2YodGhpcykgIT0gTkFNRSkgdGhyb3cgVHlwZUVycm9yKE5BTUUgKyBcIiN0b0pTT04gaXNuJ3QgZ2VuZXJpY1wiKTtcbiAgICByZXR1cm4gZnJvbSh0aGlzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuL19yZWRlZmluZS1hbGwnKTtcbnZhciBnZXRXZWFrID0gcmVxdWlyZSgnLi9fbWV0YScpLmdldFdlYWs7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuL19hbi1pbnN0YW5jZScpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgY3JlYXRlQXJyYXlNZXRob2QgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJyk7XG52YXIgJGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHZhbGlkYXRlID0gcmVxdWlyZSgnLi9fdmFsaWRhdGUtY29sbGVjdGlvbicpO1xudmFyIGFycmF5RmluZCA9IGNyZWF0ZUFycmF5TWV0aG9kKDUpO1xudmFyIGFycmF5RmluZEluZGV4ID0gY3JlYXRlQXJyYXlNZXRob2QoNik7XG52YXIgaWQgPSAwO1xuXG4vLyBmYWxsYmFjayBmb3IgdW5jYXVnaHQgZnJvemVuIGtleXNcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKHRoYXQpIHtcbiAgcmV0dXJuIHRoYXQuX2wgfHwgKHRoYXQuX2wgPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcbn07XG52YXIgVW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XG4gIHJldHVybiBhcnJheUZpbmQoc3RvcmUuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGl0WzBdID09PSBrZXk7XG4gIH0pO1xufTtcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIHJldHVybiBlbnRyeVsxXTtcbiAgfSxcbiAgaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuICEhZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgICBpZiAoZW50cnkpIGVudHJ5WzFdID0gdmFsdWU7XG4gICAgZWxzZSB0aGlzLmEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9LFxuICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBpbmRleCA9IGFycmF5RmluZEluZGV4KHRoaXMuYSwgZnVuY3Rpb24gKGl0KSB7XG4gICAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgICB9KTtcbiAgICBpZiAofmluZGV4KSB0aGlzLmEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIE5BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICAgICBhbkluc3RhbmNlKHRoYXQsIEMsIE5BTUUsICdfaScpO1xuICAgICAgdGhhdC5fdCA9IE5BTUU7ICAgICAgLy8gY29sbGVjdGlvbiB0eXBlXG4gICAgICB0aGF0Ll9pID0gaWQrKzsgICAgICAvLyBjb2xsZWN0aW9uIGlkXG4gICAgICB0aGF0Ll9sID0gdW5kZWZpbmVkOyAvLyBsZWFrIHN0b3JlIGZvciB1bmNhdWdodCBmcm96ZW4gb2JqZWN0c1xuICAgICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZCkgZm9yT2YoaXRlcmFibGUsIElTX01BUCwgdGhhdFtBRERFUl0sIHRoYXQpO1xuICAgIH0pO1xuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICAgICAvLyAyMy4zLjMuMiBXZWFrTWFwLnByb3RvdHlwZS5kZWxldGUoa2V5KVxuICAgICAgLy8gMjMuNC4zLjMgV2Vha1NldC5wcm90b3R5cGUuZGVsZXRlKHZhbHVlKVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpICYmIGRlbGV0ZSBkYXRhW3RoaXMuX2ldO1xuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy40IFdlYWtNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy40LjMuNCBXZWFrU2V0LnByb3RvdHlwZS5oYXModmFsdWUpXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2VhayhrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUodmFsaWRhdGUodGhpcywgTkFNRSkpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHRoaXMuX2kpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDO1xuICB9LFxuICBkZWY6IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgdmFyIGRhdGEgPSBnZXRXZWFrKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHRoYXQpLnNldChrZXksIHZhbHVlKTtcbiAgICBlbHNlIGRhdGFbdGhhdC5faV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhhdDtcbiAgfSxcbiAgdWZzdG9yZTogdW5jYXVnaHRGcm96ZW5TdG9yZVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgbWV0YSA9IHJlcXVpcmUoJy4vX21ldGEnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lLWFsbCcpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChOQU1FLCB3cmFwcGVyLCBtZXRob2RzLCBjb21tb24sIElTX01BUCwgSVNfV0VBSykge1xuICB2YXIgQmFzZSA9IGdsb2JhbFtOQU1FXTtcbiAgdmFyIEMgPSBCYXNlO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgcHJvdG8gPSBDICYmIEMucHJvdG90eXBlO1xuICB2YXIgTyA9IHt9O1xuICBpZiAoIURFU0NSSVBUT1JTIHx8IHR5cGVvZiBDICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IHByb3RvLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgQygpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQyA9IGNvbW1vbi5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBOQU1FLCBJU19NQVAsIEFEREVSKTtcbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwgbWV0aG9kcyk7XG4gICAgbWV0YS5ORUVEID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBDID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0YXJnZXQsIEMsIE5BTUUsICdfYycpO1xuICAgICAgdGFyZ2V0Ll9jID0gbmV3IEJhc2UoKTtcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGZvck9mKGl0ZXJhYmxlLCBJU19NQVAsIHRhcmdldFtBRERFUl0sIHRhcmdldCk7XG4gICAgfSk7XG4gICAgZWFjaCgnYWRkLGNsZWFyLGRlbGV0ZSxmb3JFYWNoLGdldCxoYXMsc2V0LGtleXMsdmFsdWVzLGVudHJpZXMsdG9KU09OJy5zcGxpdCgnLCcpLCBmdW5jdGlvbiAoS0VZKSB7XG4gICAgICB2YXIgSVNfQURERVIgPSBLRVkgPT0gJ2FkZCcgfHwgS0VZID09ICdzZXQnO1xuICAgICAgaWYgKEtFWSBpbiBwcm90byAmJiAhKElTX1dFQUsgJiYgS0VZID09ICdjbGVhcicpKSBoaWRlKEMucHJvdG90eXBlLCBLRVksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhpcywgQywgS0VZKTtcbiAgICAgICAgaWYgKCFJU19BRERFUiAmJiBJU19XRUFLICYmICFpc09iamVjdChhKSkgcmV0dXJuIEtFWSA9PSAnZ2V0JyA/IHVuZGVmaW5lZCA6IGZhbHNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5fY1tLRVldKGEgPT09IDAgPyAwIDogYSwgYik7XG4gICAgICAgIHJldHVybiBJU19BRERFUiA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBJU19XRUFLIHx8IGRQKEMucHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYy5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQywgTkFNRSk7XG5cbiAgT1tOQU1FXSA9IEM7XG4gICRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GLCBPKTtcblxuICBpZiAoIUlTX1dFQUspIGNvbW1vbi5zZXRTdHJvbmcoQywgTkFNRSwgSVNfTUFQKTtcblxuICByZXR1cm4gQztcbn07XG4iLCJ2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjQnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIiwiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIGlzID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiIsIi8vIGFsbCBlbnVtZXJhYmxlIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBzeW1ib2xzXG52YXIgZ2V0S2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QUyA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJyk7XG52YXIgcElFID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGdldEtleXMoaXQpO1xuICB2YXIgZ2V0U3ltYm9scyA9IGdPUFMuZjtcbiAgaWYgKGdldFN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IGdldFN5bWJvbHMoaXQpO1xuICAgIHZhciBpc0VudW0gPSBwSUUuZjtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAoc3ltYm9scy5sZW5ndGggPiBpKSBpZiAoaXNFbnVtLmNhbGwoaXQsIGtleSA9IHN5bWJvbHNbaSsrXSkpIHJlc3VsdC5wdXNoKGtleSk7XG4gIH0gcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgSVNfV1JBUCA9IHR5cGUgJiAkZXhwb3J0Llc7XG4gIHZhciBleHBvcnRzID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSk7XG4gIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTtcbiAgdmFyIHRhcmdldCA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSA6IChnbG9iYWxbbmFtZV0gfHwge30pW1BST1RPVFlQRV07XG4gIHZhciBrZXksIG93biwgb3V0O1xuICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lO1xuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChvd24gJiYgaGFzKGV4cG9ydHMsIGtleSkpIGNvbnRpbnVlO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTtcbiAgICAvLyBwcmV2ZW50IGdsb2JhbCBwb2xsdXRpb24gZm9yIG5hbWVzcGFjZXNcbiAgICBleHBvcnRzW2tleV0gPSBJU19HTE9CQUwgJiYgdHlwZW9mIHRhcmdldFtrZXldICE9ICdmdW5jdGlvbicgPyBzb3VyY2Vba2V5XVxuICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0XG4gICAgOiBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbClcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlIHRoZW0gaW4gbGlicmFyeVxuICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHtcbiAgICAgIHZhciBGID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBDKSB7XG4gICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQygpO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IEMoYSk7XG4gICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTtcbiAgICAgICAgICB9IHJldHVybiBuZXcgQyhhLCBiLCBjKTtcbiAgICAgICAgfSByZXR1cm4gQy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICAgIEZbUFJPVE9UWVBFXSA9IENbUFJPVE9UWVBFXTtcbiAgICAgIHJldHVybiBGO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIH0pKG91dCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUubWV0aG9kcy4lTkFNRSVcbiAgICBpZiAoSVNfUFJPVE8pIHtcbiAgICAgIChleHBvcnRzLnZpcnR1YWwgfHwgKGV4cG9ydHMudmlydHVhbCA9IHt9KSlba2V5XSA9IG91dDtcbiAgICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5wcm90b3R5cGUuJU5BTUUlXG4gICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpO1xuICAgIH1cbiAgfVxufTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBjYWxsID0gcmVxdWlyZSgnLi9faXRlci1jYWxsJyk7XG52YXIgaXNBcnJheUl0ZXIgPSByZXF1aXJlKCcuL19pcy1hcnJheS1pdGVyJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJGbiA9IHJlcXVpcmUoJy4vY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgQlJFQUsgPSB7fTtcbnZhciBSRVRVUk4gPSB7fTtcbnZhciBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIGVudHJpZXMsIGZuLCB0aGF0LCBJVEVSQVRPUikge1xuICB2YXIgaXRlckZuID0gSVRFUkFUT1IgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBpdGVyYWJsZTsgfSA6IGdldEl0ZXJGbihpdGVyYWJsZSk7XG4gIHZhciBmID0gY3R4KGZuLCB0aGF0LCBlbnRyaWVzID8gMiA6IDEpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoLCBzdGVwLCBpdGVyYXRvciwgcmVzdWx0O1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXRlcmFibGUgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgLy8gZmFzdCBjYXNlIGZvciBhcnJheXMgd2l0aCBkZWZhdWx0IGl0ZXJhdG9yXG4gIGlmIChpc0FycmF5SXRlcihpdGVyRm4pKSBmb3IgKGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gZW50cmllcyA/IGYoYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pIDogZihpdGVyYWJsZVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2UgZm9yIChpdGVyYXRvciA9IGl0ZXJGbi5jYWxsKGl0ZXJhYmxlKTsgIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lOykge1xuICAgIHJlc3VsdCA9IGNhbGwoaXRlcmF0b3IsIGYsIHN0ZXAudmFsdWUsIGVudHJpZXMpO1xuICAgIGlmIChyZXN1bHQgPT09IEJSRUFLIHx8IHJlc3VsdCA9PT0gUkVUVVJOKSByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuZXhwb3J0cy5CUkVBSyA9IEJSRUFLO1xuZXhwb3J0cy5SRVRVUk4gPSBSRVRVUk47XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgY3JlYXRlRGVzYyA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuIiwidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnZGl2JyksICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG4iLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCBhcmdzLCB0aGF0KSB7XG4gIHZhciB1biA9IHRoYXQgPT09IHVuZGVmaW5lZDtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuIiwiLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICE9PSB1bmRlZmluZWQgJiYgKEl0ZXJhdG9ycy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b1tJVEVSQVRPUl0gPT09IGl0KTtcbn07XG4iLCIvLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwiLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYXRvciwgZm4sIHZhbHVlLCBlbnRyaWVzKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVudHJpZXMgPyBmbihhbk9iamVjdCh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgLy8gNy40LjYgSXRlcmF0b3JDbG9zZShpdGVyYXRvciwgY29tcGxldGlvbilcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciByZXQgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gICAgaWYgKHJldCAhPT0gdW5kZWZpbmVkKSBhbk9iamVjdChyZXQuY2FsbChpdGVyYXRvcikpO1xuICAgIHRocm93IGU7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iLCJ2YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIHJpdGVyID0gWzddW0lURVJBVE9SXSgpO1xuICByaXRlclsncmV0dXJuJ10gPSBmdW5jdGlvbiAoKSB7IFNBRkVfQ0xPU0lORyA9IHRydWU7IH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby10aHJvdy1saXRlcmFsXG4gIEFycmF5LmZyb20ocml0ZXIsIGZ1bmN0aW9uICgpIHsgdGhyb3cgMjsgfSk7XG59IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgc2tpcENsb3NpbmcpIHtcbiAgaWYgKCFza2lwQ2xvc2luZyAmJiAhU0FGRV9DTE9TSU5HKSByZXR1cm4gZmFsc2U7XG4gIHZhciBzYWZlID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IFs3XTtcbiAgICB2YXIgaXRlciA9IGFycltJVEVSQVRPUl0oKTtcbiAgICBpdGVyLm5leHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7IGRvbmU6IHNhZmUgPSB0cnVlIH07IH07XG4gICAgYXJyW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGl0ZXI7IH07XG4gICAgZXhlYyhhcnIpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIHNhZmU7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZG9uZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB0cnVlO1xuIiwidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vX2NvZicpKHByb2Nlc3MpID09ICdwcm9jZXNzJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkLCBsYXN0LCBub3RpZnk7XG5cbiAgdmFyIGZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQsIGZuO1xuICAgIGlmIChpc05vZGUgJiYgKHBhcmVudCA9IHByb2Nlc3MuZG9tYWluKSkgcGFyZW50LmV4aXQoKTtcbiAgICB3aGlsZSAoaGVhZCkge1xuICAgICAgZm4gPSBoZWFkLmZuO1xuICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0gbGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQuZW50ZXIoKTtcbiAgfTtcblxuICAvLyBOb2RlLmpzXG4gIGlmIChpc05vZGUpIHtcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuICAvLyBicm93c2VycyB3aXRoIE11dGF0aW9uT2JzZXJ2ZXIsIGV4Y2VwdCBpT1MgU2FmYXJpIC0gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzMzOVxuICB9IGVsc2UgaWYgKE9ic2VydmVyICYmICEoZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnN0YW5kYWxvbmUpKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRydWU7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgbmV3IE9ic2VydmVyKGZsdXNoKS5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICAgIH07XG4gIC8vIGVudmlyb25tZW50cyB3aXRoIG1heWJlIG5vbi1jb21wbGV0ZWx5IGNvcnJlY3QsIGJ1dCBleGlzdGVudCBQcm9taXNlXG4gIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb21pc2UudGhlbihmbHVzaCk7XG4gICAgfTtcbiAgLy8gZm9yIG90aGVyIGVudmlyb25tZW50cyAtIG1hY3JvdGFzayBiYXNlZCBvbjpcbiAgLy8gLSBzZXRJbW1lZGlhdGVcbiAgLy8gLSBNZXNzYWdlQ2hhbm5lbFxuICAvLyAtIHdpbmRvdy5wb3N0TWVzc2FnXG4gIC8vIC0gb25yZWFkeXN0YXRlY2hhbmdlXG4gIC8vIC0gc2V0VGltZW91dFxuICB9IGVsc2Uge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIHN0cmFuZ2UgSUUgKyB3ZWJwYWNrIGRldiBzZXJ2ZXIgYnVnIC0gdXNlIC5jYWxsKGdsb2JhbClcbiAgICAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgdmFyIHRhc2sgPSB7IGZuOiBmbiwgbmV4dDogdW5kZWZpbmVkIH07XG4gICAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gICAgaWYgKCFoZWFkKSB7XG4gICAgICBoZWFkID0gdGFzaztcbiAgICAgIG5vdGlmeSgpO1xuICAgIH0gbGFzdCA9IHRhc2s7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5cbmZ1bmN0aW9uIFByb21pc2VDYXBhYmlsaXR5KEMpIHtcbiAgdmFyIHJlc29sdmUsIHJlamVjdDtcbiAgdGhpcy5wcm9taXNlID0gbmV3IEMoZnVuY3Rpb24gKCQkcmVzb2x2ZSwgJCRyZWplY3QpIHtcbiAgICBpZiAocmVzb2x2ZSAhPT0gdW5kZWZpbmVkIHx8IHJlamVjdCAhPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgcmVzb2x2ZSA9ICQkcmVzb2x2ZTtcbiAgICByZWplY3QgPSAkJHJlamVjdDtcbiAgfSk7XG4gIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiAgdGhpcy5yZWplY3QgPSBhRnVuY3Rpb24ocmVqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIChDKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG4iLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBkUCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG4iLCIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcbiIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuIiwiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGFycmF5SW5kZXhPZiA9IHJlcXVpcmUoJy4vX2FycmF5LWluY2x1ZGVzJykoZmFsc2UpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG4iLCJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgZXhlYykge1xuICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07XG4gIHZhciBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGU6IGZhbHNlLCB2OiBleGVjKCkgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IGU6IHRydWUsIHY6IGUgfTtcbiAgfVxufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSByZXF1aXJlKCcuL19uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuIiwidmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgc2FmZSkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKHNhZmUgJiYgdGFyZ2V0W2tleV0pIHRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBoaWRlKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS9cbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGZvck9mID0gcmVxdWlyZSgnLi9fZm9yLW9mJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTExFQ1RJT04pIHtcbiAgJGV4cG9ydCgkZXhwb3J0LlMsIENPTExFQ1RJT04sIHsgZnJvbTogZnVuY3Rpb24gZnJvbShzb3VyY2UgLyogLCBtYXBGbiwgdGhpc0FyZyAqLykge1xuICAgIHZhciBtYXBGbiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWFwcGluZywgQSwgbiwgY2I7XG4gICAgYUZ1bmN0aW9uKHRoaXMpO1xuICAgIG1hcHBpbmcgPSBtYXBGbiAhPT0gdW5kZWZpbmVkO1xuICAgIGlmIChtYXBwaW5nKSBhRnVuY3Rpb24obWFwRm4pO1xuICAgIGlmIChzb3VyY2UgPT0gdW5kZWZpbmVkKSByZXR1cm4gbmV3IHRoaXMoKTtcbiAgICBBID0gW107XG4gICAgaWYgKG1hcHBpbmcpIHtcbiAgICAgIG4gPSAwO1xuICAgICAgY2IgPSBjdHgobWFwRm4sIGFyZ3VtZW50c1syXSwgMik7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBmdW5jdGlvbiAobmV4dEl0ZW0pIHtcbiAgICAgICAgQS5wdXNoKGNiKG5leHRJdGVtLCBuKyspKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JPZihzb3VyY2UsIGZhbHNlLCBBLnB1c2gsIEEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHRoaXMoQSk7XG4gIH0gfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tL1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09MTEVDVElPTikge1xuICAkZXhwb3J0KCRleHBvcnQuUywgQ09MTEVDVElPTiwgeyBvZjogZnVuY3Rpb24gb2YoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIEEgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIEFbbGVuZ3RoXSA9IGFyZ3VtZW50c1tsZW5ndGhdO1xuICAgIHJldHVybiBuZXcgdGhpcyhBKTtcbiAgfSB9KTtcbn07XG4iLCIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBkUCA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBDID0gdHlwZW9mIGNvcmVbS0VZXSA9PSAnZnVuY3Rpb24nID8gY29yZVtLRVldIDogZ2xvYmFsW0tFWV07XG4gIGlmIChERVNDUklQVE9SUyAmJiBDICYmICFDW1NQRUNJRVNdKSBkUC5mKEMsIFNQRUNJRVMsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gIH0pO1xufTtcbiIsInZhciBkZWYgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKS5mO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIFRBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgdGFnLCBzdGF0KSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gc3RhdCA/IGl0IDogaXQucHJvdG90eXBlLCBUQUcpKSBkZWYoaXQsIFRBRywgeyBjb25maWd1cmFibGU6IHRydWUsIHZhbHVlOiB0YWcgfSk7XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59O1xuIiwiLy8gNy4zLjIwIFNwZWNpZXNDb25zdHJ1Y3RvcihPLCBkZWZhdWx0Q29uc3RydWN0b3IpXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgU1BFQ0lFUyA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBEKSB7XG4gIHZhciBDID0gYW5PYmplY3QoTykuY29uc3RydWN0b3I7XG4gIHZhciBTO1xuICByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IEQgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xuLy8gdHJ1ZSAgLT4gU3RyaW5nI2F0XG4vLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXRcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIHBvcykge1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpO1xuICAgIHZhciBpID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIGwgPSBzLmxlbmd0aDtcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSBsKSByZXR1cm4gVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgYSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZlxuICAgICAgPyBUT19TVFJJTkcgPyBzLmNoYXJBdChpKSA6IGFcbiAgICAgIDogVE9fU1RSSU5HID8gcy5zbGljZShpLCBpICsgMikgOiAoYSAtIDB4ZDgwMCA8PCAxMCkgKyAoYiAtIDB4ZGMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcbiIsInZhciBjdHggPSByZXF1aXJlKCcuL19jdHgnKTtcbnZhciBpbnZva2UgPSByZXF1aXJlKCcuL19pbnZva2UnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi9faHRtbCcpO1xudmFyIGNlbCA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgc2V0VGFzayA9IGdsb2JhbC5zZXRJbW1lZGlhdGU7XG52YXIgY2xlYXJUYXNrID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIE1lc3NhZ2VDaGFubmVsID0gZ2xvYmFsLk1lc3NhZ2VDaGFubmVsO1xudmFyIERpc3BhdGNoID0gZ2xvYmFsLkRpc3BhdGNoO1xudmFyIGNvdW50ZXIgPSAwO1xudmFyIHF1ZXVlID0ge307XG52YXIgT05SRUFEWVNUQVRFQ0hBTkdFID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG52YXIgZGVmZXIsIGNoYW5uZWwsIHBvcnQ7XG52YXIgcnVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaWQgPSArdGhpcztcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICBpZiAocXVldWUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGZuID0gcXVldWVbaWRdO1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gICAgZm4oKTtcbiAgfVxufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4uY2FsbChldmVudC5kYXRhKTtcbn07XG4vLyBOb2RlLmpzIDAuOSsgJiBJRTEwKyBoYXMgc2V0SW1tZWRpYXRlLCBvdGhlcndpc2U6XG5pZiAoIXNldFRhc2sgfHwgIWNsZWFyVGFzaykge1xuICBzZXRUYXNrID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGZuKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICB2YXIgaSA9IDE7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgIHF1ZXVlWysrY291bnRlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgICAgIGludm9rZSh0eXBlb2YgZm4gPT0gJ2Z1bmN0aW9uJyA/IGZuIDogRnVuY3Rpb24oZm4pLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhclRhc2sgPSBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShpZCkge1xuICAgIGRlbGV0ZSBxdWV1ZVtpZF07XG4gIH07XG4gIC8vIE5vZGUuanMgMC44LVxuICBpZiAocmVxdWlyZSgnLi9fY29mJykocHJvY2VzcykgPT0gJ3Byb2Nlc3MnKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY3R4KHJ1biwgaWQsIDEpKTtcbiAgICB9O1xuICAvLyBTcGhlcmUgKEpTIGdhbWUgZW5naW5lKSBEaXNwYXRjaCBBUElcbiAgfSBlbHNlIGlmIChEaXNwYXRjaCAmJiBEaXNwYXRjaC5ub3cpIHtcbiAgICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgRGlzcGF0Y2gubm93KGN0eChydW4sIGlkLCAxKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBjdHgocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gIC8vIEJyb3dzZXJzIHdpdGggcG9zdE1lc3NhZ2UsIHNraXAgV2ViV29ya2Vyc1xuICAvLyBJRTggaGFzIHBvc3RNZXNzYWdlLCBidXQgaXQncyBzeW5jICYgdHlwZW9mIGl0cyBwb3N0TWVzc2FnZSBpcyAnb2JqZWN0J1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICYmIHR5cGVvZiBwb3N0TWVzc2FnZSA9PSAnZnVuY3Rpb24nICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoaWQgKyAnJywgJyonKTtcbiAgICB9O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjZWwoJ3NjcmlwdCcpKSB7XG4gICAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoY2VsKCdzY3JpcHQnKSlbT05SRUFEWVNUQVRFQ0hBTkdFXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgcnVuLmNhbGwoaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KGN0eChydW4sIGlkLCAxKSwgMCk7XG4gICAgfTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0VGFzayxcbiAgY2xlYXI6IGNsZWFyVGFza1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuIiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iLCIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG4iLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBPYmplY3QoZGVmaW5lZChpdCkpO1xufTtcbiIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcbiIsInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVFlQRSkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSB8fCBpdC5fdCAhPT0gVFlQRSkgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTtcbiAgaWYgKG5hbWUuY2hhckF0KDApICE9ICdfJyAmJiAhKG5hbWUgaW4gJFN5bWJvbCkpIGRlZmluZVByb3BlcnR5KCRTeW1ib2wsIG5hbWUsIHsgdmFsdWU6IHdrc0V4dC5mKG5hbWUpIH0pO1xufTtcbiIsImV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX3drcycpO1xuIiwidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL19jbGFzc29mJyk7XG52YXIgSVRFUkFUT1IgPSByZXF1aXJlKCcuL193a3MnKSgnaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yTWV0aG9kID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXQgPSByZXF1aXJlKCcuL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19jb3JlJykuZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGl0ZXJhYmxlIScpO1xuICByZXR1cm4gYW5PYmplY3QoaXRlckZuLmNhbGwoaXQpKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vX2FkZC10by11bnNjb3BhYmxlcycpO1xudmFyIHN0ZXAgPSByZXF1aXJlKCcuL19pdGVyLXN0ZXAnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHRoaXMuX3QgPSB0b0lPYmplY3QoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmRcbi8vIDIyLjEuNS4yLjEgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgTyA9IHRoaXMuX3Q7XG4gIHZhciBraW5kID0gdGhpcy5faztcbiAgdmFyIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHtcbiAgICB0aGlzLl90ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBzdGVwKDEpO1xuICB9XG4gIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHN0ZXAoMCwgaW5kZXgpO1xuICBpZiAoa2luZCA9PSAndmFsdWVzJykgcmV0dXJuIHN0ZXAoMCwgT1tpbmRleF0pO1xuICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNylcbkl0ZXJhdG9ycy5Bcmd1bWVudHMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpIH0pO1xuIiwidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4zIC8gMTUuMi4zLjcgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7IGRlZmluZVByb3BlcnRpZXM6IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKSB9KTtcbiIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHsgZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmYgfSk7XG4iLCIvLyAxOS4xLjIuNiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmY7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgnZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0lPYmplY3QoaXQpLCBrZXkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjIuOSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyICRnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX29iamVjdC1ncG8nKTtcblxucmVxdWlyZSgnLi9fb2JqZWN0LXNhcCcpKCdnZXRQcm90b3R5cGVPZicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuICRnZXRQcm90b3R5cGVPZih0b09iamVjdChpdCkpO1xuICB9O1xufSk7XG4iLCIvLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbiRleHBvcnQoJGV4cG9ydC5TLCAnT2JqZWN0JywgeyBzZXRQcm90b3R5cGVPZjogcmVxdWlyZSgnLi9fc2V0LXByb3RvJykuc2V0IH0pO1xuIiwiIiwiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgPSByZXF1aXJlKCcuL19saWJyYXJ5Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY3R4ID0gcmVxdWlyZSgnLi9fY3R4Jyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4vX2FuLWluc3RhbmNlJyk7XG52YXIgZm9yT2YgPSByZXF1aXJlKCcuL19mb3Itb2YnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4vX3Rhc2snKS5zZXQ7XG52YXIgbWljcm90YXNrID0gcmVxdWlyZSgnLi9fbWljcm90YXNrJykoKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xudmFyIHByb21pc2VSZXNvbHZlID0gcmVxdWlyZSgnLi9fcHJvbWlzZS1yZXNvbHZlJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFXTtcbnZhciBpc05vZGUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBlbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBJbnRlcm5hbCwgbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5LCBPd25Qcm9taXNlQ2FwYWJpbGl0eSwgV3JhcHBlcjtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlLmY7XG5cbnZhciBVU0VfTkFUSVZFID0gISFmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgLy8gY29ycmVjdCBzdWJjbGFzc2luZyB3aXRoIEBAc3BlY2llcyBzdXBwb3J0XG4gICAgdmFyIHByb21pc2UgPSAkUHJvbWlzZS5yZXNvbHZlKDEpO1xuICAgIHZhciBGYWtlUHJvbWlzZSA9IChwcm9taXNlLmNvbnN0cnVjdG9yID0ge30pW3JlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyldID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgICAgIGV4ZWMoZW1wdHksIGVtcHR5KTtcbiAgICB9O1xuICAgIC8vIHVuaGFuZGxlZCByZWplY3Rpb25zIHRyYWNraW5nIHN1cHBvcnQsIE5vZGVKUyBQcm9taXNlIHdpdGhvdXQgaXQgZmFpbHMgQEBzcGVjaWVzIHRlc3RcbiAgICByZXR1cm4gKGlzTm9kZSB8fCB0eXBlb2YgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID09ICdmdW5jdGlvbicpICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59KCk7XG5cbi8vIGhlbHBlcnNcbnZhciBpc1RoZW5hYmxlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciB0aGVuO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBpc1JlamVjdCkge1xuICBpZiAocHJvbWlzZS5fbikgcmV0dXJuO1xuICBwcm9taXNlLl9uID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gcHJvbWlzZS5fYztcbiAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciBvayA9IHByb21pc2UuX3MgPT0gMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJ1biA9IGZ1bmN0aW9uIChyZWFjdGlvbikge1xuICAgICAgdmFyIGhhbmRsZXIgPSBvayA/IHJlYWN0aW9uLm9rIDogcmVhY3Rpb24uZmFpbDtcbiAgICAgIHZhciByZXNvbHZlID0gcmVhY3Rpb24ucmVzb2x2ZTtcbiAgICAgIHZhciByZWplY3QgPSByZWFjdGlvbi5yZWplY3Q7XG4gICAgICB2YXIgZG9tYWluID0gcmVhY3Rpb24uZG9tYWluO1xuICAgICAgdmFyIHJlc3VsdCwgdGhlbiwgZXhpdGVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICBpZiAocHJvbWlzZS5faCA9PSAyKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlKTtcbiAgICAgICAgICAgIHByb21pc2UuX2ggPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBtYXkgdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChkb21haW4gJiYgIWV4aXRlZCkgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH07XG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGkpIHJ1bihjaGFpbltpKytdKTsgLy8gdmFyaWFibGUgbGVuZ3RoIC0gY2FuJ3QgdXNlIGZvckVhY2hcbiAgICBwcm9taXNlLl9jID0gW107XG4gICAgcHJvbWlzZS5fbiA9IGZhbHNlO1xuICAgIGlmIChpc1JlamVjdCAmJiAhcHJvbWlzZS5faCkgb25VbmhhbmRsZWQocHJvbWlzZSk7XG4gIH0pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBwcm9taXNlLl92O1xuICAgIHZhciB1bmhhbmRsZWQgPSBpc1VuaGFuZGxlZChwcm9taXNlKTtcbiAgICB2YXIgcmVzdWx0LCBoYW5kbGVyLCBjb25zb2xlO1xuICAgIGlmICh1bmhhbmRsZWQpIHtcbiAgICAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNOb2RlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFuZGxlciA9IGdsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbikge1xuICAgICAgICAgIGhhbmRsZXIoeyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHZhbHVlIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKChjb25zb2xlID0gZ2xvYmFsLmNvbnNvbGUpICYmIGNvbnNvbGUuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHByb21pc2UuX2ggPSBpc05vZGUgfHwgaXNVbmhhbmRsZWQocHJvbWlzZSkgPyAyIDogMTtcbiAgICB9IHByb21pc2UuX2EgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVuaGFuZGxlZCAmJiByZXN1bHQuZSkgdGhyb3cgcmVzdWx0LnY7XG4gIH0pO1xufTtcbnZhciBpc1VuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gIHJldHVybiBwcm9taXNlLl9oICE9PSAxICYmIChwcm9taXNlLl9hIHx8IHByb21pc2UuX2MpLmxlbmd0aCA9PT0gMDtcbn07XG52YXIgb25IYW5kbGVVbmhhbmRsZWQgPSBmdW5jdGlvbiAocHJvbWlzZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGhhbmRsZXI7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVyID0gZ2xvYmFsLm9ucmVqZWN0aW9uaGFuZGxlZCkge1xuICAgICAgaGFuZGxlcih7IHByb21pc2U6IHByb21pc2UsIHJlYXNvbjogcHJvbWlzZS5fdiB9KTtcbiAgICB9XG4gIH0pO1xufTtcbnZhciAkcmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHZhciBwcm9taXNlID0gdGhpcztcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICBwcm9taXNlLl92ID0gdmFsdWU7XG4gIHByb21pc2UuX3MgPSAyO1xuICBpZiAoIXByb21pc2UuX2EpIHByb21pc2UuX2EgPSBwcm9taXNlLl9jLnNsaWNlKCk7XG4gIG5vdGlmeShwcm9taXNlLCB0cnVlKTtcbn07XG52YXIgJHJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdmFyIHByb21pc2UgPSB0aGlzO1xuICB2YXIgdGhlbjtcbiAgaWYgKHByb21pc2UuX2QpIHJldHVybjtcbiAgcHJvbWlzZS5fZCA9IHRydWU7XG4gIHByb21pc2UgPSBwcm9taXNlLl93IHx8IHByb21pc2U7IC8vIHVud3JhcFxuICB0cnkge1xuICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkgdGhyb3cgVHlwZUVycm9yKFwiUHJvbWlzZSBjYW4ndCBiZSByZXNvbHZlZCBpdHNlbGZcIik7XG4gICAgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHdyYXBwZXIgPSB7IF93OiBwcm9taXNlLCBfZDogZmFsc2UgfTsgLy8gd3JhcFxuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSwgY3R4KCRyZXNvbHZlLCB3cmFwcGVyLCAxKSwgY3R4KCRyZWplY3QsIHdyYXBwZXIsIDEpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICRyZWplY3QuY2FsbCh3cmFwcGVyLCBlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2UuX3YgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3MgPSAxO1xuICAgICAgbm90aWZ5KHByb21pc2UsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAkcmVqZWN0LmNhbGwoeyBfdzogcHJvbWlzZSwgX2Q6IGZhbHNlIH0sIGUpOyAvLyB3cmFwXG4gIH1cbn07XG5cbi8vIGNvbnN0cnVjdG9yIHBvbHlmaWxsXG5pZiAoIVVTRV9OQVRJVkUpIHtcbiAgLy8gMjUuNC4zLjEgUHJvbWlzZShleGVjdXRvcilcbiAgJFByb21pc2UgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkUHJvbWlzZSwgUFJPTUlTRSwgJ19oJyk7XG4gICAgYUZ1bmN0aW9uKGV4ZWN1dG9yKTtcbiAgICBJbnRlcm5hbC5jYWxsKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihjdHgoJHJlc29sdmUsIHRoaXMsIDEpLCBjdHgoJHJlamVjdCwgdGhpcywgMSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgJHJlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgfVxuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgdGhpcy5fYyA9IFtdOyAgICAgICAgICAgICAvLyA8LSBhd2FpdGluZyByZWFjdGlvbnNcbiAgICB0aGlzLl9hID0gdW5kZWZpbmVkOyAgICAgIC8vIDwtIGNoZWNrZWQgaW4gaXNVbmhhbmRsZWQgcmVhY3Rpb25zXG4gICAgdGhpcy5fcyA9IDA7ICAgICAgICAgICAgICAvLyA8LSBzdGF0ZVxuICAgIHRoaXMuX2QgPSBmYWxzZTsgICAgICAgICAgLy8gPC0gZG9uZVxuICAgIHRoaXMuX3YgPSB1bmRlZmluZWQ7ICAgICAgLy8gPC0gdmFsdWVcbiAgICB0aGlzLl9oID0gMDsgICAgICAgICAgICAgIC8vIDwtIHJlamVjdGlvbiBzdGF0ZSwgMCAtIGRlZmF1bHQsIDEgLSBoYW5kbGVkLCAyIC0gdW5oYW5kbGVkXG4gICAgdGhpcy5fbiA9IGZhbHNlOyAgICAgICAgICAvLyA8LSBub3RpZnlcbiAgfTtcbiAgSW50ZXJuYWwucHJvdG90eXBlID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUtYWxsJykoJFByb21pc2UucHJvdG90eXBlLCB7XG4gICAgLy8gMjUuNC41LjMgUHJvbWlzZS5wcm90b3R5cGUudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZClcbiAgICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgJFByb21pc2UpKTtcbiAgICAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICAgICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgICAgcmVhY3Rpb24uZG9tYWluID0gaXNOb2RlID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLl9jLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHRoaXMuX2EpIHRoaXMuX2EucHVzaChyZWFjdGlvbik7XG4gICAgICBpZiAodGhpcy5fcykgbm90aWZ5KHRoaXMsIGZhbHNlKTtcbiAgICAgIHJldHVybiByZWFjdGlvbi5wcm9taXNlO1xuICAgIH0sXG4gICAgLy8gMjUuNC41LjEgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2gob25SZWplY3RlZClcbiAgICAnY2F0Y2gnOiBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih1bmRlZmluZWQsIG9uUmVqZWN0ZWQpO1xuICAgIH1cbiAgfSk7XG4gIE93blByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IEludGVybmFsKCk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBjdHgoJHJlc29sdmUsIHByb21pc2UsIDEpO1xuICAgIHRoaXMucmVqZWN0ID0gY3R4KCRyZWplY3QsIHByb21pc2UsIDEpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSAkUHJvbWlzZSB8fCBDID09PSBXcmFwcGVyXG4gICAgICA/IG5ldyBPd25Qcm9taXNlQ2FwYWJpbGl0eShDKVxuICAgICAgOiBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gIH07XG59XG5cbiRleHBvcnQoJGV4cG9ydC5HICsgJGV4cG9ydC5XICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsIHsgUHJvbWlzZTogJFByb21pc2UgfSk7XG5yZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpKCRQcm9taXNlLCBQUk9NSVNFKTtcbnJlcXVpcmUoJy4vX3NldC1zcGVjaWVzJykoUFJPTUlTRSk7XG5XcmFwcGVyID0gcmVxdWlyZSgnLi9fY29yZScpW1BST01JU0VdO1xuXG4vLyBzdGF0aWNzXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCBQUk9NSVNFLCB7XG4gIC8vIDI1LjQuNC41IFByb21pc2UucmVqZWN0KHIpXG4gIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHRoaXMpO1xuICAgIHZhciAkJHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgICQkcmVqZWN0KHIpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoTElCUkFSWSB8fCAhVVNFX05BVElWRSksIFBST01JU0UsIHtcbiAgLy8gMjUuNC40LjYgUHJvbWlzZS5yZXNvbHZlKHgpXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShMSUJSQVJZICYmIHRoaXMgPT09IFdyYXBwZXIgPyAkUHJvbWlzZSA6IHRoaXMsIHgpO1xuICB9XG59KTtcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIShVU0VfTkFUSVZFICYmIHJlcXVpcmUoJy4vX2l0ZXItZGV0ZWN0JykoZnVuY3Rpb24gKGl0ZXIpIHtcbiAgJFByb21pc2UuYWxsKGl0ZXIpWydjYXRjaCddKGVtcHR5KTtcbn0pKSwgUFJPTUlTRSwge1xuICAvLyAyNS40LjQuMSBQcm9taXNlLmFsbChpdGVyYWJsZSlcbiAgYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgICB2YXIgQyA9IHRoaXM7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gICAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIHZhciByZW1haW5pbmcgPSAxO1xuICAgICAgZm9yT2YoaXRlcmFibGUsIGZhbHNlLCBmdW5jdGlvbiAocHJvbWlzZSkge1xuICAgICAgICB2YXIgJGluZGV4ID0gaW5kZXgrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgIEMucmVzb2x2ZShwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChhbHJlYWR5Q2FsbGVkKSByZXR1cm47XG4gICAgICAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgdmFsdWVzWyRpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LmUpIHJlamVjdChyZXN1bHQudik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gMjUuNC40LjQgUHJvbWlzZS5yYWNlKGl0ZXJhYmxlKVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvck9mKGl0ZXJhYmxlLCBmYWxzZSwgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgQy5yZXNvbHZlKHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lKSByZWplY3QocmVzdWx0LnYpO1xuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cm9uZyA9IHJlcXVpcmUoJy4vX2NvbGxlY3Rpb24tc3Ryb25nJyk7XG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL192YWxpZGF0ZS1jb2xsZWN0aW9uJyk7XG52YXIgU0VUID0gJ1NldCc7XG5cbi8vIDIzLjIgU2V0IE9iamVjdHNcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFNFVCwgZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gU2V0KCkgeyByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPiAwID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIHtcbiAgLy8gMjMuMi4zLjEgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cm9uZy5kZWYodmFsaWRhdGUodGhpcywgU0VUKSwgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICB9XG59LCBzdHJvbmcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCA9IHJlcXVpcmUoJy4vX3N0cmluZy1hdCcpKHRydWUpO1xuXG4vLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuICB0aGlzLl90ID0gU3RyaW5nKGl0ZXJhdGVkKTsgLy8gdGFyZ2V0XG4gIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4vLyAyMS4xLjUuMi4xICVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGluZGV4ID0gdGhpcy5faTtcbiAgdmFyIHBvaW50O1xuICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMCk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIG1ldGEgPSByZXF1aXJlKCcuL19tZXRhJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9fb2JqZWN0LWFzc2lnbicpO1xudmFyIHdlYWsgPSByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciB2YWxpZGF0ZSA9IHJlcXVpcmUoJy4vX3ZhbGlkYXRlLWNvbGxlY3Rpb24nKTtcbnZhciBXRUFLX01BUCA9ICdXZWFrTWFwJztcbnZhciBnZXRXZWFrID0gbWV0YS5nZXRXZWFrO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IHdlYWsudWZzdG9yZTtcbnZhciB0bXAgPSB7fTtcbnZhciBJbnRlcm5hbE1hcDtcblxudmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA+IDAgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxudmFyIG1ldGhvZHMgPSB7XG4gIC8vIDIzLjMuMy4zIFdlYWtNYXAucHJvdG90eXBlLmdldChrZXkpXG4gIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICB2YXIgZGF0YSA9IGdldFdlYWsoa2V5KTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZSh2YWxpZGF0ZSh0aGlzLCBXRUFLX01BUCkpLmdldChrZXkpO1xuICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3RoaXMuX2ldIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfSxcbiAgLy8gMjMuMy4zLjUgV2Vha01hcC5wcm90b3R5cGUuc2V0KGtleSwgdmFsdWUpXG4gIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gd2Vhay5kZWYodmFsaWRhdGUodGhpcywgV0VBS19NQVApLCBrZXksIHZhbHVlKTtcbiAgfVxufTtcblxuLy8gMjMuMyBXZWFrTWFwIE9iamVjdHNcbnZhciAkV2Vha01hcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29sbGVjdGlvbicpKFdFQUtfTUFQLCB3cmFwcGVyLCBtZXRob2RzLCB3ZWFrLCB0cnVlLCB0cnVlKTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyAkV2Vha01hcCgpLnNldCgoT2JqZWN0LmZyZWV6ZSB8fCBPYmplY3QpKHRtcCksIDcpLmdldCh0bXApICE9IDc7IH0pKSB7XG4gIEludGVybmFsTWFwID0gd2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCBXRUFLX01BUCk7XG4gIGFzc2lnbihJbnRlcm5hbE1hcC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICBtZXRhLk5FRUQgPSB0cnVlO1xuICBlYWNoKFsnZGVsZXRlJywgJ2hhcycsICdnZXQnLCAnc2V0J10sIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcHJvdG8gPSAkV2Vha01hcC5wcm90b3R5cGU7XG4gICAgdmFyIG1ldGhvZCA9IHByb3RvW2tleV07XG4gICAgcmVkZWZpbmUocHJvdG8sIGtleSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIC8vIHN0b3JlIGZyb3plbiBvYmplY3RzIG9uIGludGVybmFsIHdlYWttYXAgc2hpbVxuICAgICAgaWYgKGlzT2JqZWN0KGEpICYmICFpc0V4dGVuc2libGUoYSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mKSB0aGlzLl9mID0gbmV3IEludGVybmFsTWFwKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9mW2tleV0oYSwgYik7XG4gICAgICAgIHJldHVybiBrZXkgPT0gJ3NldCcgPyB0aGlzIDogcmVzdWx0O1xuICAgICAgLy8gc3RvcmUgYWxsIHRoZSByZXN0IG9uIG5hdGl2ZSB3ZWFrbWFwXG4gICAgICB9IHJldHVybiBtZXRob2QuY2FsbCh0aGlzLCBhLCBiKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLWZpbmFsbHlcbid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuL19wcm9taXNlLXJlc29sdmUnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LlIsICdQcm9taXNlJywgeyAnZmluYWxseSc6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgY29yZS5Qcm9taXNlIHx8IGdsb2JhbC5Qcm9taXNlKTtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2Ygb25GaW5hbGx5ID09ICdmdW5jdGlvbic7XG4gIHJldHVybiB0aGlzLnRoZW4oXG4gICAgaXNGdW5jdGlvbiA/IGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4geDsgfSk7XG4gICAgfSA6IG9uRmluYWxseSxcbiAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7IHRocm93IGU7IH0pO1xuICAgIH0gOiBvbkZpbmFsbHlcbiAgKTtcbn0gfSk7XG4iLCIndXNlIHN0cmljdCc7XG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wcm9taXNlLXRyeVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4vX25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi9fcGVyZm9ybScpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ1Byb21pc2UnLCB7ICd0cnknOiBmdW5jdGlvbiAoY2FsbGJhY2tmbikge1xuICB2YXIgcHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eS5mKHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gcGVyZm9ybShjYWxsYmFja2ZuKTtcbiAgKHJlc3VsdC5lID8gcHJvbWlzZUNhcGFiaWxpdHkucmVqZWN0IDogcHJvbWlzZUNhcGFiaWxpdHkucmVzb2x2ZSkocmVzdWx0LnYpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn0gfSk7XG4iLCIvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLXNldG1hcC1vZmZyb20vI3NlYy1zZXQuZnJvbVxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tZnJvbScpKCdTZXQnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXNldC5vZlxucmVxdWlyZSgnLi9fc2V0LWNvbGxlY3Rpb24tb2YnKSgnU2V0Jyk7XG4iLCIvLyBodHRwczovL2dpdGh1Yi5jb20vRGF2aWRCcnVhbnQvTWFwLVNldC5wcm90b3R5cGUudG9KU09OXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuUiwgJ1NldCcsIHsgdG9KU09OOiByZXF1aXJlKCcuL19jb2xsZWN0aW9uLXRvLWpzb24nKSgnU2V0JykgfSk7XG4iLCJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcbiIsInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuIiwiLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9wcm9wb3NhbC1zZXRtYXAtb2Zmcm9tLyNzZWMtd2Vha21hcC5mcm9tXG5yZXF1aXJlKCcuL19zZXQtY29sbGVjdGlvbi1mcm9tJykoJ1dlYWtNYXAnKTtcbiIsIi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vcHJvcG9zYWwtc2V0bWFwLW9mZnJvbS8jc2VjLXdlYWttYXAub2ZcbnJlcXVpcmUoJy4vX3NldC1jb2xsZWN0aW9uLW9mJykoJ1dlYWtNYXAnKTtcbiIsInJlcXVpcmUoJy4vZXM2LmFycmF5Lml0ZXJhdG9yJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciBUT19TVFJJTkdfVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbnZhciBET01JdGVyYWJsZXMgPSAoJ0NTU1J1bGVMaXN0LENTU1N0eWxlRGVjbGFyYXRpb24sQ1NTVmFsdWVMaXN0LENsaWVudFJlY3RMaXN0LERPTVJlY3RMaXN0LERPTVN0cmluZ0xpc3QsJyArXG4gICdET01Ub2tlbkxpc3QsRGF0YVRyYW5zZmVySXRlbUxpc3QsRmlsZUxpc3QsSFRNTEFsbENvbGxlY3Rpb24sSFRNTENvbGxlY3Rpb24sSFRNTEZvcm1FbGVtZW50LEhUTUxTZWxlY3RFbGVtZW50LCcgK1xuICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICtcbiAgJ1NWR1BhdGhTZWdMaXN0LFNWR1BvaW50TGlzdCxTVkdTdHJpbmdMaXN0LFNWR1RyYW5zZm9ybUxpc3QsU291cmNlQnVmZmVyTGlzdCxTdHlsZVNoZWV0TGlzdCxUZXh0VHJhY2tDdWVMaXN0LCcgK1xuICAnVGV4dFRyYWNrTGlzdCxUb3VjaExpc3QnKS5zcGxpdCgnLCcpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IERPTUl0ZXJhYmxlcy5sZW5ndGg7IGkrKykge1xuICB2YXIgTkFNRSA9IERPTUl0ZXJhYmxlc1tpXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIGlmIChwcm90byAmJiAhcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7XG59XG4iLCIvKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuICAgIC8vIGRvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgICAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnIubWVzc2FnZTtcbiAgfVxufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm47XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKVxuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cblxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Z1snZGVmYXVsdCddID0gY3JlYXRlRGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICB2YXIgaGFzaCA9IDAsIGk7XG5cbiAgZm9yIChpIGluIG5hbWVzcGFjZSkge1xuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW01hdGguYWJzKGhhc2gpICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cbiAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgLy8gZGlzYWJsZWQ/XG4gICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSByZXR1cm47XG5cbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyB0dXJuIHRoZSBgYXJndW1lbnRzYCBpbnRvIGEgcHJvcGVyIEFycmF5XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIC8vIGFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cbiAgICB2YXIgbG9nRm4gPSBkZWJ1Zy5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgZGVidWcuZW5hYmxlZCA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpO1xuICBkZWJ1Zy51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cbiAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcbiAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmluaXQpIHtcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xuICB9XG5cbiAgcmV0dXJuIGRlYnVnO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIGV4cG9ydHMubmFtZXMgPSBbXTtcbiAgZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtcyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxuICAgIHBsdXJhbChtcywgaCwgJ2hvdXInKSB8fFxuICAgIHBsdXJhbChtcywgbSwgJ21pbnV0ZScpIHx8XG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcbiAgICBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgfVxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdfQ==
